//********************************************************************
// Copyright (c) 2006 by Prem Nallasivampillai. All rights reserved.
//********************************************************************

//********************************************************************
// include files
//********************************************************************
#include "axAvlTreeLockingCapable.hpp"

//********************************************************************
// definitions/macros
//********************************************************************

//********************************************************************
// constants
//********************************************************************

//********************************************************************
// static member initialization
//********************************************************************

//********************************************************************
// forward declerations
//********************************************************************


//********************************************************************
// default constructor:
//********************************************************************
axAvlTreeLockingCapable::axAvlTreeLockingCapable()
{
}


//********************************************************************
// destructor:
//********************************************************************
axAvlTreeLockingCapable::~axAvlTreeLockingCapable()
{
}


#if 0
//********************************************************************
// data constructor:
//********************************************************************
axAvlTreeLockingCapable::axAvlTreeLockingCapable(avl_comparison_func * cmpFunc) :
  axAvlTree(cmpFunc)
{
}
#endif


//********************************************************************
// method:
//********************************************************************
bool 
axAvlTreeLockingCapable::isEmpty(void)
{
  bool ret;

  lock();

  ret = axAvlTree::isEmpty();

  unlock();

  return (ret);
}


//********************************************************************
// method:
//********************************************************************
// void
axObject *
axAvlTreeLockingCapable::add(axObject * o)
{
  axObject * ret;

  lock();

  ret = axAvlTree::add(o);

  unlock();

  return (ret);
}


//********************************************************************
// method:
//********************************************************************
axObject *
axAvlTreeLockingCapable::find(axObject * o)
{
  axObject * ret;

  lock();

  ret = axAvlTree::find(o);

  unlock();

  return (ret);
}


//********************************************************************
// method:
//********************************************************************
axObject *
axAvlTreeLockingCapable::remove(axObject * o)
{
  axObject * ret;

  lock();

  ret = axAvlTree::remove(o);

  unlock();

  return (ret);
}


//********************************************************************
// method:
//********************************************************************
size_t
axAvlTreeLockingCapable::size(void)
{
  size_t ret;

  lock();

  ret = axAvlTree::size();

  unlock();

  return (ret);
}


//********************************************************************
// method:
//********************************************************************
void
axAvlTreeLockingCapable::clear(void)
{
  lock();

  axAvlTree::clear();

  unlock();
}


//********************************************************************
// method:
//********************************************************************
void
axAvlTreeLockingCapable::clearAndFreeEntries(void)
{
  lock();

  axAvlTree::clearAndFreeEntries();

  unlock();
}


