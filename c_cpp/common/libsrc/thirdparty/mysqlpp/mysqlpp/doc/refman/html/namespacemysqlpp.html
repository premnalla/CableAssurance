<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="refman.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>mysqlpp Namespace Reference</h1>
<p>
<table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Compounds</h2></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1BadConversion.html">BadConversion</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when a bad type conversion is attempted.</em> <a href="classmysqlpp_1_1BadConversion.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1BadFieldName.html">BadFieldName</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when a requested named field doesn't exist.</em> <a href="classmysqlpp_1_1BadFieldName.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1BadNullConversion.html">BadNullConversion</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when you attempt to convert a SQL null to an incompatible type.</em> <a href="classmysqlpp_1_1BadNullConversion.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1BadOption.html">BadOption</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when you pass an unrecognized option to <a class="el" href="classmysqlpp_1_1Connection.html#a28">Connection::set_option()</a>.</em> <a href="classmysqlpp_1_1BadOption.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1BadParamCount.html">BadParamCount</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when not enough query parameters are provided.</em> <a href="classmysqlpp_1_1BadParamCount.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1BadQuery.html">BadQuery</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when MySQL encounters a problem while processing your query.</em> <a href="classmysqlpp_1_1BadQuery.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1BasicLock.html">BasicLock</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Trivial <a class="el" href="classmysqlpp_1_1Lock.html">Lock</a> subclass, using a boolean variable as the lock flag.</em> <a href="classmysqlpp_1_1BasicLock.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Template for string data that can convert itself to any standard C data type.</em> <a href="classmysqlpp_1_1ColData__Tmpl.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Manages the connection to the MySQL database.</em> <a href="classmysqlpp_1_1Connection.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><b>OptionInfo</b></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1ConnectionFailed.html">ConnectionFailed</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when there is a problem establishing the database server connection. It's also thrown if <a class="el" href="classmysqlpp_1_1Connection.html#a26">Connection::shutdown()</a> fails.</em> <a href="classmysqlpp_1_1ConnectionFailed.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1const__string.html">const_string</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Wrapper for <code>const char*</code> to make it behave in a way more useful to MySQL++.</em> <a href="classmysqlpp_1_1const__string.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1const__subscript__container.html">const_subscript_container</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A base class that one derives from to become a random access container, which can be accessed with subscript notation.</em> <a href="classmysqlpp_1_1const__subscript__container.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1Date.html">Date</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>C++ form of MySQL's DATE type.</em> <a href="structmysqlpp_1_1Date.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1DateTime.html">DateTime</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>C++ form of MySQL's DATETIME type.</em> <a href="structmysqlpp_1_1DateTime.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1DBSelectionFailed.html">DBSelectionFailed</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when the program tries to select a new database and the server refuses for some reason.</em> <a href="classmysqlpp_1_1DBSelectionFailed.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1DTbase.html">DTbase</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Base class template for MySQL++ date and time classes.</em> <a href="structmysqlpp_1_1DTbase.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1EndOfResults.html">EndOfResults</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when <a class="el" href="classmysqlpp_1_1ResUse.html#a6">ResUse::fetch_row()</a> walks off the end of a use-query's result set.</em> <a href="classmysqlpp_1_1EndOfResults.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1EndOfResultSets.html">EndOfResultSets</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when <a class="el" href="classmysqlpp_1_1Query.html#a20">Query::store_next()</a> walks off the end of a use-query's multi result sets.</em> <a href="classmysqlpp_1_1EndOfResultSets.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Same as <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>, plus the option to have some elements of the equals clause suppressed.</em> <a href="structmysqlpp_1_1equal__list__b.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Holds two lists of items, typically used to construct a SQL "equals clause".</em> <a href="structmysqlpp_1_1equal__list__ba.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Base class for all MySQL++ custom exceptions.</em> <a href="classmysqlpp_1_1Exception.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1FieldNames.html">FieldNames</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Holds a list of SQL field names.</em> <a href="classmysqlpp_1_1FieldNames.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Fields.html">Fields</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A container similar to <code>std::vector</code> for holding <a class="el" href="namespacemysqlpp.html#a4">mysqlpp::Field</a> records.</em> <a href="classmysqlpp_1_1Fields.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1FieldTypes.html">FieldTypes</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A vector of SQL field types.</em> <a href="classmysqlpp_1_1FieldTypes.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Lock.html">Lock</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Abstract base class for lock implementation, used by <a class="el" href="classmysqlpp_1_1Lockable.html">Lockable</a>.</em> <a href="classmysqlpp_1_1Lock.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Lockable.html">Lockable</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Interface allowing a class to declare itself as "lockable".</em> <a href="classmysqlpp_1_1Lockable.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1LockFailed.html">LockFailed</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when a <a class="el" href="classmysqlpp_1_1Lockable.html">Lockable</a> object fails.</em> <a href="classmysqlpp_1_1LockFailed.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Holds basic type information for ColData.</em> <a href="classmysqlpp_1_1mysql__type__info.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1NoExceptions.html">NoExceptions</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Disable exceptions in an object derived from <a class="el" href="classmysqlpp_1_1OptionalExceptions.html">OptionalExceptions</a>.</em> <a href="classmysqlpp_1_1NoExceptions.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Null.html">Null</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Class for holding data from a SQL column with the NULL attribute.</em> <a href="classmysqlpp_1_1Null.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1null__type.html">null_type</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The type of the global <a class="el" href="namespacemysqlpp.html#a15">mysqlpp::null</a> object.</em> <a href="classmysqlpp_1_1null__type.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1NullisBlank.html">NullisBlank</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Class for objects that define SQL null as a blank C string.</em> <a href="structmysqlpp_1_1NullisBlank.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1NullisNull.html">NullisNull</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Class for objects that define SQL null in terms of MySQL++'s <a class="el" href="classmysqlpp_1_1null__type.html">null_type</a>.</em> <a href="structmysqlpp_1_1NullisNull.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1NullisZero.html">NullisZero</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Class for objects that define SQL null as 0.</em> <a href="structmysqlpp_1_1NullisZero.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1ObjectNotInitialized.html">ObjectNotInitialized</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Exception.html">Exception</a> thrown when you try to use an object that isn't completely initialized.</em> <a href="classmysqlpp_1_1ObjectNotInitialized.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1OptionalExceptions.html">OptionalExceptions</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Interface allowing a class to have optional exceptions.</em> <a href="classmysqlpp_1_1OptionalExceptions.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html">Query</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A class for building and executing SQL queries.</em> <a href="classmysqlpp_1_1Query.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1ResNSel.html">ResNSel</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Holds the information on the success of queries that don't return any results.</em> <a href="classmysqlpp_1_1ResNSel.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Result.html">Result</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This class manages SQL result sets.</em> <a href="classmysqlpp_1_1Result.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A basic result set class, for use with "use" queries.</em> <a href="classmysqlpp_1_1ResUse.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Row.html">Row</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Manages rows from a result set.</em> <a href="classmysqlpp_1_1Row.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1scoped__var__set.html">scoped_var_set</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Sets a variable to a given value temporarily.</em> <a href="classmysqlpp_1_1scoped__var__set.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Set.html">Set</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A special std::set derivative for holding MySQL data sets.</em> <a href="classmysqlpp_1_1Set.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1SQLParseElement.html">SQLParseElement</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Used within <a class="el" href="classmysqlpp_1_1Query.html">Query</a> to hold elements for parameterized queries.</em> <a href="structmysqlpp_1_1SQLParseElement.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>This class holds the parameter values for filling template queries.</em> <a href="classmysqlpp_1_1SQLQueryParms.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>A specialized <code>std::string</code> that will convert from any valid MySQL type.</em> <a href="classmysqlpp_1_1SQLString.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1subscript__iterator.html">subscript_iterator</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Iterator that can be subscripted.</em> <a href="classmysqlpp_1_1subscript__iterator.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1Time.html">Time</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>C++ form of MySQL's TIME type.</em> <a href="structmysqlpp_1_1Time.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1tiny__int.html">tiny_int</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Class for holding an SQL <code>tiny_int</code> object.</em> <a href="classmysqlpp_1_1tiny__int.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>class &nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Transaction.html">Transaction</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Helper object for creating exception-safe SQL transactions.</em> <a href="classmysqlpp_1_1Transaction.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Same as <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>, plus the option to have some elements of the list suppressed.</em> <a href="structmysqlpp_1_1value__list__b.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>struct &nbsp;</td><td valign=bottom><a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Holds a list of items, typically used to construct a SQL "value list".</em> <a href="structmysqlpp_1_1value__list__ba.html#_details">More...</a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Typedefs</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a1" doxytag="mysqlpp::ColData"></a>
typedef <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a1">ColData</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The type that is returned by constant rows.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a2" doxytag="mysqlpp::MutableColData"></a>
typedef <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; std::string &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a2">MutableColData</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The type that is returned by mutable rows.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a4" doxytag="mysqlpp::Field"></a>
typedef MYSQL_FIELD&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a4">Field</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Alias for MYSQL_FIELD.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a5" doxytag="mysqlpp::cchar"></a>
typedef const char&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a5">cchar</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Contraction for 'const char*'.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a6" doxytag="mysqlpp::uint"></a>
typedef unsigned int&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a6">uint</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Contraction for 'unsigned int'.</em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Enumerations</h2></td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a91">sql_cmp_type</a> </td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Used to disambiguate overloads of equal_list() in SSQLSes.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a92">quote_type0</a> { <a class="el" href="namespacemysqlpp.html#a92a9">quote</a>
 }</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a93">quote_only_type0</a> { <a class="el" href="namespacemysqlpp.html#a93a10">quote_only</a>
 }</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a94">quote_double_only_type0</a> { <a class="el" href="namespacemysqlpp.html#a94a11">quote_double_only</a>
 }</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a95">escape_type0</a> </td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> { <a class="el" href="namespacemysqlpp.html#a96a13">do_nothing</a>
 }</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a97">ignore_type0</a> { <a class="el" href="namespacemysqlpp.html#a97a14">ignore</a>
 }</td></tr>
<tr><td nowrap align=right valign=top>enum &nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a98">query_reset</a> </td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Used for indicating whether a query object should auto-reset.</em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Functions</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a18" doxytag="mysqlpp::operator<<"></a>
std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a18">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> into a C++ stream.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a19" doxytag="mysqlpp::compare"></a>
int&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a19">compare</a> (const <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;lhs, const <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Calls lhs.compare(), passing rhs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a20" doxytag="mysqlpp::operator=="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a20">operator==</a> (<a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;lhs, <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if lhs is the same as rhs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a21" doxytag="mysqlpp::operator!="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a21">operator!=</a> (<a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;lhs, <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if lhs is not the same as rhs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a22" doxytag="mysqlpp::operator<"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a22">operator&lt;</a> (<a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;lhs, <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if lhs is lexically less than rhs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a23" doxytag="mysqlpp::operator<="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a23">operator&lt;=</a> (<a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;lhs, <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if lhs is lexically less or equal to rhs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a24" doxytag="mysqlpp::operator>"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a24">operator&gt;</a> (<a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;lhs, <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if lhs is lexically greater than rhs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a25" doxytag="mysqlpp::operator>="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a25">operator&gt;=</a> (<a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;lhs, <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if lhs is lexically greater than or equal to rhs.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a26">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structmysqlpp_1_1Date.html">Date</a> &amp;d)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="structmysqlpp_1_1Date.html">Date</a> object into a C++ stream.</em> <a href="#a26"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a27">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structmysqlpp_1_1Time.html">Time</a> &amp;t)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="structmysqlpp_1_1Time.html">Time</a> object into a C++ stream in a MySQL-compatible format.</em> <a href="#a27"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a28">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="structmysqlpp_1_1DateTime.html">DateTime</a> &amp;dt)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="structmysqlpp_1_1DateTime.html">DateTime</a> object into a C++ stream in a MySQL-compatible format.</em> <a href="#a28"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a29">operator&lt;&lt;</a> (quote_type2 p, <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, quoted and escaped.</em> <a href="#a29"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a30">operator&lt;&lt;</a> (quote_type1 o, const string &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a C++ string into a stream, quoted and escaped.</em> <a href="#a30"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a31">operator&lt;&lt;</a> (quote_type1 o, const char *const &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a C string into a stream, quoted and escaped.</em> <a href="#a31"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a32" doxytag="mysqlpp::_manip"></a>
template&lt;class Str&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a32">_manip</a> (quote_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; Str &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Utility function used by operator&lt;&lt;(quote_type1, ColData).</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a33">operator&lt;&lt;</a> (quote_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData into a stream, quoted and escaped.</em> <a href="#a33"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a34">operator&lt;&lt;</a> (quote_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData with const string into a stream, quoted and escaped.</em> <a href="#a34"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a35">operator&lt;&lt;</a> (ostream &amp;o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData into a stream.</em> <a href="#a35"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a36">operator&lt;&lt;</a> (ostream &amp;o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData with const string into a stream.</em> <a href="#a36"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a37">operator&lt;&lt;</a> (<a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Insert a ColData into a SQLQuery.</em> <a href="#a37"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a38">operator&lt;&lt;</a> (<a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Insert a ColData with const string into a SQLQuery.</em> <a href="#a38"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a39">operator&lt;&lt;</a> (quote_only_type2 p, <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, quoting it unless it's data that needs no quoting.</em> <a href="#a39"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a40">operator&lt;&lt;</a> (quote_only_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData into a stream, quoted.</em> <a href="#a40"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a41">operator&lt;&lt;</a> (quote_only_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData with const string into a stream, quoted.</em> <a href="#a41"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a42">operator&lt;&lt;</a> (quote_double_only_type2 p, <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, double-quoting it (") unless it's data that needs no quoting.</em> <a href="#a42"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a43">operator&lt;&lt;</a> (quote_double_only_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData into a stream, double-quoted (").</em> <a href="#a43"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a44">operator&lt;&lt;</a> (quote_double_only_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData with const string into a stream, double-quoted (").</em> <a href="#a44"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a45">operator&lt;&lt;</a> (escape_type2 p, <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, escaping special SQL characters.</em> <a href="#a45"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a46">operator&lt;&lt;</a> (escape_type1 o, const std::string &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a C++ string into a stream, escaping special SQL characters.</em> <a href="#a46"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a47">operator&lt;&lt;</a> (escape_type1 o, const char *const &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a C string into a stream, escaping special SQL characters.</em> <a href="#a47"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a48" doxytag="mysqlpp::_manip"></a>
template&lt;class Str&gt; ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a48">_manip</a> (escape_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; Str &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Utility function used by operator&lt;&lt;(escape_type1, ColData).</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a49">operator&lt;&lt;</a> (escape_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; std::string &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData into a stream, escaping special SQL characters.</em> <a href="#a49"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a50">operator&lt;&lt;</a> (escape_type1 o, const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a ColData with const string into a stream, escaping special SQL characters.</em> <a href="#a50"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a51" doxytag="mysqlpp::operator<<"></a>
<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a51">operator&lt;&lt;</a> (do_nothing_type2 p, <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, with no escaping or quoting.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a52" doxytag="mysqlpp::operator<<"></a>
<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a52">operator&lt;&lt;</a> (ignore_type2 p, <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, with no escaping or quoting, and without marking the string as having been "processed".</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class T&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a53">operator&lt;&lt;</a> (escape_type1 o, const T &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts any type T into a stream that has an operator&lt;&lt; defined for it.</em> <a href="#a53"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;&gt; MYSQLPP_EXPORT std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a54">operator&lt;&lt;</a> (escape_type1 o, char *const &amp;in)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a C string into a stream, escaping special SQL characters.</em> <a href="#a54"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a55" doxytag="mysqlpp::operator<<"></a>
template&lt;class Container&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a55">operator&lt;&lt;</a> (std::ostream &amp;s, const <a class="el" href="classmysqlpp_1_1Set.html">Set</a>&lt; Container &gt; &amp;d)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="classmysqlpp_1_1Set.html">Set</a> object into a C++ stream.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a56" doxytag="mysqlpp::operator<<"></a>
template&lt;class Type, class Behavior&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a56">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="classmysqlpp_1_1Null.html">Null</a>&lt; Type, Behavior &gt; &amp;n)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts null-able data into a C++ stream if it is not actually null. Otherwise, insert something appropriate for null data.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a57" doxytag="mysqlpp::swap"></a>
void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a57">swap</a> (<a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a> &amp;x, <a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a> &amp;y)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Swaps two <a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a> objects.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a58" doxytag="mysqlpp::swap"></a>
void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a58">swap</a> (<a class="el" href="classmysqlpp_1_1Result.html">Result</a> &amp;x, <a class="el" href="classmysqlpp_1_1Result.html">Result</a> &amp;y)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Swaps two <a class="el" href="classmysqlpp_1_1Result.html">Result</a> objects.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Strng, class T&gt; Strng&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a59">stream2string</a> (const T &amp;object)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Converts a stream-able object to any type that can be initialized from an <code>std::string</code>.</em> <a href="#a59"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a60" doxytag="mysqlpp::strip"></a>
void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a60">strip</a> (std::string &amp;s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Strips blanks at left and right ends.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a61" doxytag="mysqlpp::escape_string"></a>
void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a61">escape_string</a> (std::string &amp;s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>C++ equivalent of mysql_escape_string().</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a62" doxytag="mysqlpp::str_to_upr"></a>
MYSQLPP_EXPORT void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a62">str_to_upr</a> (std::string &amp;s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Changes case of string to upper.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a63" doxytag="mysqlpp::str_to_lwr"></a>
MYSQLPP_EXPORT void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a63">str_to_lwr</a> (std::string &amp;s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Changes case of string to lower.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a64" doxytag="mysqlpp::strip_all_blanks"></a>
MYSQLPP_EXPORT void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a64">strip_all_blanks</a> (std::string &amp;s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Removes all blanks.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a65" doxytag="mysqlpp::strip_all_non_num"></a>
MYSQLPP_EXPORT void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a65">strip_all_non_num</a> (std::string &amp;s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Removes all non-numerics.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a66" doxytag="mysqlpp::operator=="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a66">operator==</a> (const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;a, const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if two <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> objects are equal.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a67" doxytag="mysqlpp::operator!="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a67">operator!=</a> (const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;a, const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if two <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> objects are not equal.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a68" doxytag="mysqlpp::operator=="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a68">operator==</a> (const std::type_info &amp;a, const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if a given <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> object is equal to a given C++ type_info object.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a69" doxytag="mysqlpp::operator!="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a69">operator!=</a> (const std::type_info &amp;a, const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if a given <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> object is not equal to a given C++ type_info object.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a70" doxytag="mysqlpp::operator=="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a70">operator==</a> (const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;a, const std::type_info &amp;b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if a given <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> object is equal to a given C++ type_info object.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a71" doxytag="mysqlpp::operator!="></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a71">operator!=</a> (const <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> &amp;a, const std::type_info &amp;b)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if a given <a class="el" href="classmysqlpp_1_1mysql__type__info.html">mysql_type_info</a> object is not equal to a given C++ type_info object.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a72">create_vector</a> (size_t size, std::vector&lt; bool &gt; &amp;v, bool t0, bool t1, bool t2, bool t3, bool t4, bool t5, bool t6, bool t7, bool t8, bool t9, bool ta, bool tb, bool tc)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a vector of bool with the given arguments as values.</em> <a href="#a72"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Container&gt; void&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a73">create_vector</a> (const Container &amp;c, std::vector&lt; bool &gt; &amp;v, std::string s0, std::string s1, std::string s2, std::string s3, std::string s4, std::string s5, std::string s6, std::string s7, std::string s8, std::string s9, std::string sa, std::string sb, std::string sc)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a vector of bool using a list of named fields.</em> <a href="#a73"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2, class Manip&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a74">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>&lt; Seq1, Seq2, Manip &gt; &amp;el)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts an <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a> into an std::ostream.</em> <a href="#a74"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2, class Manip&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a75">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2, Manip &gt; &amp;el)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Same as operator&lt;&lt; for <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>, plus the option to suppress insertion of some list items in the stream.</em> <a href="#a75"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq, class Manip&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a76">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>&lt; Seq, Manip &gt; &amp;cl)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Inserts a <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a> into an std::ostream.</em> <a href="#a76"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq, class Manip&gt; std::ostream &amp;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a77">operator&lt;&lt;</a> (std::ostream &amp;o, const <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt; Seq, Manip &gt; &amp;cl)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Same as operator&lt;&lt; for <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>, plus the option to suppress insertion of some list items in the stream.</em> <a href="#a77"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq&gt; <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>&lt; Seq, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a78">value_list</a> (const Seq &amp;s, const char *d=",")</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>.</em> <a href="#a78"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq, class Manip&gt; <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>&lt; Seq, Manip &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a79">value_list</a> (const Seq &amp;s, const char *d, Manip m)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>.</em> <a href="#a79"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq, class Manip&gt; <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt; Seq, Manip &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a80">value_list</a> (const Seq &amp;s, const char *d, Manip m, const std::vector&lt; bool &gt; &amp;vb)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a> (sparse value list).</em> <a href="#a80"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq, class Manip&gt; <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt; Seq, Manip &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a81">value_list</a> (const Seq &amp;s, const char *d, Manip m, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a> (sparse value list).</em> <a href="#a81"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq&gt; <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt; Seq, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a82">value_list</a> (const Seq &amp;s, const char *d, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a sparse value list.</em> <a href="#a82"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq&gt; <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt; Seq, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a83">value_list</a> (const Seq &amp;s, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a sparse value list.</em> <a href="#a83"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2&gt; <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>&lt; Seq1, Seq2,<br>
 <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a84">equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d=",", const char *e="=")</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs an <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>.</em> <a href="#a84"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2, class Manip&gt; <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>&lt; Seq1, Seq2,<br>
 Manip &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a85">equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, Manip m)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs an <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>.</em> <a href="#a85"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2, class Manip&gt; <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2,<br>
 Manip &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a86">equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, Manip m, const std::vector&lt; bool &gt; &amp;vb)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).</em> <a href="#a86"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2, class Manip&gt; <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2,<br>
 Manip &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a87">equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, Manip m, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).</em> <a href="#a87"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2&gt; <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2,<br>
 <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a88">equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, const char *e, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).</em> <a href="#a88"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2&gt; <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2,<br>
 <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a89">equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, const char *d, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).</em> <a href="#a89"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Seq1, class Seq2&gt; <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2,<br>
 <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a> &gt;&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a90">equal_list</a> (const Seq1 &amp;s1, const Seq2 &amp;s2, bool t0, bool t1=false, bool t2=false, bool t3=false, bool t4=false, bool t5=false, bool t6=false, bool t7=false, bool t8=false, bool t9=false, bool ta=false, bool tb=false, bool tc=false)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).</em> <a href="#a90"></a><em></em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Variables</h2></td></tr>
<tr><td nowrap align=right valign=top><a name="a3" doxytag="mysqlpp::use_exceptions"></a>
const bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a3">use_exceptions</a> = true</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Alias for 'true', to make code requesting exceptions more readable.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>bool&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a8">dont_quote_auto</a> = false</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em><a class="el" href="classmysqlpp_1_1Set.html">Set</a> to true if you want to suppress automatic quoting.</em> <a href="#a8"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a15" doxytag="mysqlpp::null"></a>
const <a class="el" href="classmysqlpp_1_1null__type.html">null_type</a>&nbsp;</td><td valign=bottom><a class="el" href="namespacemysqlpp.html#a15">null</a> = <a class="el" href="classmysqlpp_1_1null__type.html">null_type</a>()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Global 'null' instance. Use wherever you need a SQL null. (As opposed to a C++ language null pointer or null character.).</em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
All global symbols in MySQL++ are in namespace mysqlpp. This is needed because many symbols are rather generic (e.g. <a class="el" href="classmysqlpp_1_1Row.html">Row</a>, <a class="el" href="classmysqlpp_1_1Query.html">Query</a>...), so there is a serious danger of conflicts. 
<p>
<hr><h2>Enumeration Type Documentation</h2>
<a name="a96" doxytag="mysqlpp::do_nothing_type0"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum mysqlpp::do_nothing_type0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a name="do_nothing_manip"></a>
<p>
The 'do_nothing' manipulator.
<p>
Does exactly what it says: nothing. Used as a dummy manipulator when you are required to use some manipulator but don't want anything to be done to the following item. When used with <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> it will make sure that it does not get formatted in any way, overriding any setting set by the template query. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a96a13" doxytag="do_nothing"></a><em>do_nothing</em></em>&nbsp;</td><td>
insert into a std::ostream to override manipulation of next item</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="a95" doxytag="mysqlpp::escape_type0"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum mysqlpp::escape_type0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The 'escape' manipulator.
<p>
Calls mysql_escape_string() in the MySQL C API on the following argument to prevent any special SQL characters from being interpreted.     </td>
  </tr>
</table>
<a name="a97" doxytag="mysqlpp::ignore_type0"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum mysqlpp::ignore_type0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a name="ignore_manip"></a>
<p>
The 'ignore' manipulator.
<p>
Only valid when used with <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>. It's a dummy manipulator like the <a href="#do_nothing_manip">do_nothing manipulator</a>, except that it will not override formatting set by the template query. It is simply ignored. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a97a14" doxytag="ignore"></a><em>ignore</em></em>&nbsp;</td><td>
insert into a std::ostream as a dummy manipulator</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="a94" doxytag="mysqlpp::quote_double_only_type0"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum mysqlpp::quote_double_only_type0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a name="quote_double_manip"></a>
<p>
The 'double_quote_only' manipulator.
<p>
Similar to <a href="#quote_only_manip">quote_only manipulator</a>, except that it uses double quotes instead of single quotes. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a94a11" doxytag="quote_double_only"></a><em>quote_double_only</em></em>&nbsp;</td><td>
insert into a std::ostream to double-quote next item</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="a93" doxytag="mysqlpp::quote_only_type0"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum mysqlpp::quote_only_type0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a name="quote_only_manip"></a>
<p>
The 'quote_only' manipulator.
<p>
Similar to <a href="#quote_manip">quote manipulator</a>, except that it doesn't escape special SQL characters. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a93a10" doxytag="quote_only"></a><em>quote_only</em></em>&nbsp;</td><td>
insert into a std::ostream to single-quote next item</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<a name="a92" doxytag="mysqlpp::quote_type0"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> enum mysqlpp::quote_type0
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a name="quote_manip"></a>
<p>
The standard 'quote' manipulator.
<p>
Insert this into a stream to put single quotes around the next item in the stream, and escape characters within it that are 'special' in SQL. This is the most generally useful of the manipulators. <dl compact><dt><b>Enumeration values: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em><a name="a92a9" doxytag="quote"></a><em>quote</em></em>&nbsp;</td><td>
insert into a std::ostream to single-quote and escape next item</td></tr>
</table>
</dl>
    </td>
  </tr>
</table>
<hr><h2>Function Documentation</h2>
<a name="a73" doxytag="mysqlpp::create_vector"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Container&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void mysqlpp::create_vector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Container &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>c</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::vector&lt; bool &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>v</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s3</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s4</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s5</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s6</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s7</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s8</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s9</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sa</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sb</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::string&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>sc</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a vector of bool using a list of named fields.
<p>
This function is used with the <a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a> and <a class="el" href="classmysqlpp_1_1Result.html">Result</a> containers, which have a field_num() member function that maps a field name to its position number. So for each named field, we set the bool in the vector at the corresponding position to true.
<p>
This function is used within the library to build the vector used in calling the vector form of <a class="el" href="classmysqlpp_1_1Row.html#a27">Row::equal_list()</a>, <a class="el" href="classmysqlpp_1_1Row.html#a10">Row::value_list()</a>, and <a class="el" href="classmysqlpp_1_1Row.html#a19">Row::field_list()</a>. See the "Harnessing SSQLS Internals" section of the user manual to see that feature at work.     </td>
  </tr>
</table>
<a name="a72" doxytag="mysqlpp::create_vector"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mysqlpp::create_vector </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">size_t&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>size</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>std::vector&lt; bool &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>v</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a vector of bool with the given arguments as values.
<p>
This function takes up to 13 bools, with the size parameter controlling the actual number of parameters we pay attention to.
<p>
This function is used within the library to build the vector used in calling the vector form of <a class="el" href="classmysqlpp_1_1Row.html#a27">Row::equal_list()</a>, <a class="el" href="classmysqlpp_1_1Row.html#a10">Row::value_list()</a>, and <a class="el" href="classmysqlpp_1_1Row.html#a19">Row::field_list()</a>. See the "Harnessing SSQLS Internals" section of the user manual to see that feature at work.     </td>
  </tr>
</table>
<a name="a90" doxytag="mysqlpp::equal_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt;Seq1, Seq2, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a>&gt; equal_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq1 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Seq2 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).
<p>
Same as equal_list(Seq&amp;, Seq&amp;, const char*, bool, bool...) except that it doesn't take the const char* argument. It uses a comma for the delimiter. This form is useful for building simple equals lists, where no manipulators are necessary, and the default delimiter and equals symbol are suitable.     </td>
  </tr>
</table>
<a name="a89" doxytag="mysqlpp::equal_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt;Seq1, Seq2, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a>&gt; equal_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq1 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Seq2 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).
<p>
Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, bool, bool...) except that it doesn't take the second const char* argument. It uses " = " for the equals symbol.     </td>
  </tr>
</table>
<a name="a88" doxytag="mysqlpp::equal_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt;Seq1, Seq2, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a>&gt; equal_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq1 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Seq2 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>e</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).
<p>
Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, Manip, bool, bool...) except that it doesn't take the Manip argument. It uses the do_nothing manipulator instead, meaning that none of the elements are escaped when being inserted into a stream.     </td>
  </tr>
</table>
<a name="a87" doxytag="mysqlpp::equal_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt;Seq1, Seq2, Manip&gt; equal_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq1 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Seq2 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>e</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Manip&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).
<p>
Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, Manip, vector&lt;bool&gt;&amp;) except that it takes boolean parameters instead of a list of bools.     </td>
  </tr>
</table>
<a name="a86" doxytag="mysqlpp::equal_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt;Seq1, Seq2, Manip&gt; equal_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq1 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Seq2 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>e</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Manip&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::vector&lt; bool &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>vb</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a> (sparse equal list).
<p>
Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*, Manip) except that you can pass a vector of bools. For each true item in that list, operator&lt;&lt; adds the corresponding item is put in the equal list. This lets you pass in sequences when you don't want all of the elements to be inserted into a stream.     </td>
  </tr>
</table>
<a name="a85" doxytag="mysqlpp::equal_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>&lt;Seq1, Seq2, Manip&gt; equal_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq1 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Seq2 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>e</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Manip&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs an <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>.
<p>
Same as equal_list(Seq&amp;, Seq&amp;, const char*, const char*) except that it also lets you specify the manipulator. Use this version if the data must be escaped or quoted when being inserted into a stream.     </td>
  </tr>
</table>
<a name="a84" doxytag="mysqlpp::equal_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>&lt;Seq1, Seq2, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a>&gt; equal_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq1 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s1</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const Seq2 &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s2</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em> = ",", </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>e</em> = " = "</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs an <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>.
<p>
This function returns an equal list that uses the 'do_nothing' manipulator. That is, the items are not quoted or escaped in any way when inserted into a stream. See equal_list(Seq, Seq, const char*, const char*, Manip) if you need a different manipulator.
<p>
The idea is for both lists to be of equal length because corresponding elements from each list are handled as pairs, but if one list is shorter than the other, the generated list will have that many elements.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>s1</em>&nbsp;</td><td>
items on the left side of the equals sign when the equal list is inserted into a stream </td></tr>
<tr><td valign=top><em>s2</em>&nbsp;</td><td>
items on the right side of the equals sign </td></tr>
<tr><td valign=top><em>d</em>&nbsp;</td><td>
delimiter operator&lt;&lt; should place between pairs </td></tr>
<tr><td valign=top><em>e</em>&nbsp;</td><td>
what operator&lt;&lt; should place between items in each pair; by default, an equals sign, as that is the primary use for this mechanism. </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a77" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt; Seq, Manip &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cl</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as operator&lt;&lt; for <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>, plus the option to suppress insertion of some list items in the stream.
<p>
See <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>'s documentation for examples of how this works.     </td>
  </tr>
</table>
<a name="a76" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>&lt; Seq, Manip &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>cl</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a> into an std::ostream.
<p>
Given a list (a, b) and a delimiter D, this operator will insert "aDb" into the stream.
<p>
See <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>'s documentation for concrete examples.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="namespacemysqlpp.html#a78">value_list()</a> </dl>    </td>
  </tr>
</table>
<a name="a75" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>&lt; Seq1, Seq2, Manip &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>el</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Same as operator&lt;&lt; for <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>, plus the option to suppress insertion of some list items in the stream.
<p>
See <a class="el" href="structmysqlpp_1_1equal__list__b.html">equal_list_b</a>'s documentation for examples of how this works.     </td>
  </tr>
</table>
<a name="a74" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq1, class Seq2, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>&lt; Seq1, Seq2, Manip &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>el</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts an <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a> into an std::ostream.
<p>
Given two lists (a, b) and (c, d), a delimiter D, and an equals symbol E, this operator will insert "aEcDbEd" into the stream.
<p>
See <a class="el" href="structmysqlpp_1_1equal__list__ba.html">equal_list_ba</a>'s documentation for concrete examples.
<p>
<dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="namespacemysqlpp.html#a84">equal_list()</a> </dl>    </td>
  </tr>
</table>
<a name="a54" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">escape_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>char *const &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a C string into a stream, escaping special SQL characters.
<p>
This version exists solely to handle constness problems. We force everything to the completely-const version: operator&lt;&lt;(escape_type1, const char* const&amp;).     </td>
  </tr>
</table>
<a name="a53" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> std::ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">escape_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts any type T into a stream that has an operator&lt;&lt; defined for it.
<p>
Does not actually escape that data! Use one of the other forms of operator&lt;&lt; for the escape manipulator if you need escaping. This template exists to catch cases like inserting an <code>int</code> after the escape manipulator: you don't actually want escaping in this instance.     </td>
  </tr>
</table>
<a name="a50" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">escape_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData with const string into a stream, escaping special SQL characters.
<p>
Because ColData was designed to contain MySQL type data, we may choose not to escape the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a49" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">escape_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; std::string &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData into a stream, escaping special SQL characters.
<p>
Because ColData was designed to contain MySQL type data, we may choose not to escape the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a47" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">escape_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *const &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a C string into a stream, escaping special SQL characters.
<p>
Because C's type system lacks the information we need to second- guess this manipulator, we always run the escaping algorithm on the data, even if it's not needed.     </td>
  </tr>
</table>
<a name="a46" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">escape_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a C++ string into a stream, escaping special SQL characters.
<p>
Because std::string lacks the type information we need, the string is always escaped, even if it doesn't need it.     </td>
  </tr>
</table>
<a name="a45" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">escape_type2&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, escaping special SQL characters.
<p>
We actually only do the escaping if in.is_string is set but in.dont_escape is not. If that is not the case, we insert the string data directly.     </td>
  </tr>
</table>
<a name="a44" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_double_only_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData with const string into a stream, double-quoted (").
<p>
Because ColData was designed to contain MySQL type data, we may choose not to actually quote the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a43" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_double_only_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData into a stream, double-quoted (").
<p>
Because ColData was designed to contain MySQL type data, we may choose not to actually quote the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a42" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_double_only_type2&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, double-quoting it (") unless it's data that needs no quoting.
<p>
We make the decision to quote the data based on the in.is_string flag. You can set it yourself, but <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a>'s ctors should set it correctly for you.     </td>
  </tr>
</table>
<a name="a41" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_only_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData with const string into a stream, quoted.
<p>
Because ColData was designed to contain MySQL type data, we may choose not to actually quote the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a40" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_only_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData into a stream, quoted.
<p>
Because ColData was designed to contain MySQL type data, we may choose not to actually quote the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a39" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_only_type2&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, quoting it unless it's data that needs no quoting.
<p>
We make the decision to quote the data based on the in.is_string flag. You can set it yourself, but <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a>'s ctors should set it correctly for you.     </td>
  </tr>
</table>
<a name="a38" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a ColData with const string into a SQLQuery.
<p>
This operator appears to be a workaround for a weakness in one compiler's implementation of the C++ type system. See Wishlist for current plan on what to do about this.     </td>
  </tr>
</table>
<a name="a37" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1Query.html">Query</a>&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classmysqlpp_1_1Query.html">Query</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a ColData into a SQLQuery.
<p>
This operator appears to be a workaround for a weakness in one compiler's implementation of the C++ type system. See Wishlist for current plan on what to do about this.     </td>
  </tr>
</table>
<a name="a36" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData with const string into a stream.
<p>
Because ColData was designed to contain MySQL type data, this operator has the information needed to choose to quote and/or escape the data as it is inserted into the stream, even if you don't use any of the quoting or escaping manipulators.     </td>
  </tr>
</table>
<a name="a35" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData into a stream.
<p>
Because ColData was designed to contain MySQL type data, this operator has the information needed to choose to quote and/or escape the data as it is inserted into the stream, even if you don't use any of the quoting or escaping manipulators.     </td>
  </tr>
</table>
<a name="a34" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; <a class="el" href="classmysqlpp_1_1const__string.html">const_string</a> &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData with const string into a stream, quoted and escaped.
<p>
Because ColData was designed to contain MySQL type data, we may choose not to actually quote or escape the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a33" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="classmysqlpp_1_1ColData__Tmpl.html">ColData_Tmpl</a>&lt; string &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a ColData into a stream, quoted and escaped.
<p>
Because ColData was designed to contain MySQL type data, we may choose not to actually quote or escape the data, if it is not needed.     </td>
  </tr>
</table>
<a name="a31" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *const &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a C string into a stream, quoted and escaped.
<p>
Because C strings lack the type information we need, the string is both quoted and escaped, always.     </td>
  </tr>
</table>
<a name="a30" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> ostream&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_type1&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const string &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a C++ string into a stream, quoted and escaped.
<p>
Because std::string lacks the type information we need, the string is both quoted and escaped, always.     </td>
  </tr>
</table>
<a name="a29" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&amp; operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">quote_type2&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>in</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> into a stream, quoted and escaped.
<p>
If in.is_string is set and in.dont_escape is <em>not</em> set, the string is quoted and escaped.
<p>
If both in.is_string and in.dont_escape are set, the string is quoted but not escaped.
<p>
If in.is_string is not set, the data is inserted as-is. This is the case when you initialize <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a> with one of the constructors taking an integral type, for instance.     </td>
  </tr>
</table>
<a name="a28" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="structmysqlpp_1_1DateTime.html">DateTime</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>dt</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="structmysqlpp_1_1DateTime.html">DateTime</a> object into a C++ stream in a MySQL-compatible format.
<p>
The date and time are inserted into the stream, in that order, with a space between them.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>os</em>&nbsp;</td><td>
stream to insert date and time into </td></tr>
<tr><td valign=top><em>dt</em>&nbsp;</td><td>
date/time object to insert into stream </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a27" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="structmysqlpp_1_1Time.html">Time</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="structmysqlpp_1_1Time.html">Time</a> object into a C++ stream in a MySQL-compatible format.
<p>
The format is HH:MM:SS, zero-padded.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>os</em>&nbsp;</td><td>
stream to insert time into </td></tr>
<tr><td valign=top><em>t</em>&nbsp;</td><td>
time to insert into stream </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a26" doxytag="mysqlpp::operator<<"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> MYSQLPP_EXPORT std::ostream &amp; mysqlpp::operator&lt;&lt; </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">std::ostream &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>os</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const <a class="el" href="structmysqlpp_1_1Date.html">Date</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Inserts a <a class="el" href="structmysqlpp_1_1Date.html">Date</a> object into a C++ stream.
<p>
The format is YYYY-MM-DD, zero-padded.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>os</em>&nbsp;</td><td>
stream to insert date into </td></tr>
<tr><td valign=top><em>d</em>&nbsp;</td><td>
date to insert into stream </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a59" doxytag="mysqlpp::stream2string"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Strng, class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Strng stream2string </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>object</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Converts a stream-able object to any type that can be initialized from an <code>std::string</code>.
<p>
This adapter takes any object that has an <code>out_stream()</code> member function and converts it to a string type. An example of such a type within the library is <a class="el" href="structmysqlpp_1_1Date.html">mysqlpp::Date</a>.     </td>
  </tr>
</table>
<a name="a83" doxytag="mysqlpp::value_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt;Seq, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a>&gt; value_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a sparse value list.
<p>
Same as value_list(Seq&amp;, const char*, Manip, bool, bool...) but without the Manip or delimiter parameters. We use the do_nothing manipulator, meaning that the value list items are neither escaped nor quoted when being inserted into a stream. The delimiter is a comma. This form is suitable for lists of simple data, such as integers.     </td>
  </tr>
</table>
<a name="a82" doxytag="mysqlpp::value_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt;Seq, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a>&gt; value_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a sparse value list.
<p>
Same as value_list(Seq&amp;, const char*, Manip, bool, bool...) but without the Manip parameter. We use the do_nothing manipulator, meaning that the value list items are neither escaped nor quoted when being inserted into a stream.     </td>
  </tr>
</table>
<a name="a81" doxytag="mysqlpp::value_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt;Seq, Manip&gt; value_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Manip&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t0</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t1</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t2</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t3</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t4</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t5</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t6</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t7</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t8</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>t9</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>ta</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tb</em> = false, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>tc</em> = false</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a> (sparse value list).
<p>
Same as value_list(Seq&amp;, const char*, Manip, const vector&lt;bool&gt;&amp;), except that it takes the bools as arguments instead of wrapped up in a vector object.     </td>
  </tr>
</table>
<a name="a80" doxytag="mysqlpp::value_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a>&lt;Seq, Manip&gt; value_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Manip&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const std::vector&lt; bool &gt; &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>vb</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1value__list__b.html">value_list_b</a> (sparse value list).
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>s</em>&nbsp;</td><td>
an STL sequence of items in the value list </td></tr>
<tr><td valign=top><em>d</em>&nbsp;</td><td>
delimiter operator&lt;&lt; should place between items </td></tr>
<tr><td valign=top><em>m</em>&nbsp;</td><td>
manipulator to use when inserting items into a stream </td></tr>
<tr><td valign=top><em>vb</em>&nbsp;</td><td>
for each item in this vector that is true, the corresponding item in the value list is inserted into a stream; the others are suppressed </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a79" doxytag="mysqlpp::value_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq, class Manip&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>&lt;Seq, Manip&gt; value_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Manip&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>m</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>s</em>&nbsp;</td><td>
an STL sequence of items in the value list </td></tr>
<tr><td valign=top><em>d</em>&nbsp;</td><td>
delimiter operator&lt;&lt; should place between items </td></tr>
<tr><td valign=top><em>m</em>&nbsp;</td><td>
manipulator to use when inserting items into a stream </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a78" doxytag="mysqlpp::value_list"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Seq&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>&lt;Seq, <a class="el" href="namespacemysqlpp.html#a96">do_nothing_type0</a>&gt; value_list </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Seq &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>s</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const char *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>d</em> = ","</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Constructs a <a class="el" href="structmysqlpp_1_1value__list__ba.html">value_list_ba</a>.
<p>
This function returns a value list that uses the 'do_nothing' manipulator. That is, the items are not quoted or escaped in any way. See value_list(Seq, const char*, Manip) if you need to specify a manipulator.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>s</em>&nbsp;</td><td>
an STL sequence of items in the value list </td></tr>
<tr><td valign=top><em>d</em>&nbsp;</td><td>
delimiter operator&lt;&lt; should place between items </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<hr><h2>Variable Documentation</h2>
<a name="a8" doxytag="mysqlpp::dont_quote_auto"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool mysqlpp::dont_quote_auto = false
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
<a class="el" href="classmysqlpp_1_1Set.html">Set</a> to true if you want to suppress automatic quoting.
<p>
Works only for ColData inserted into C++ streams.     </td>
  </tr>
</table>
<hr><address style="align: right;"><small>Generated on Fri Mar 24 14:04:55 2006 for MySQL++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
