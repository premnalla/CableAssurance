<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
	<title>MySQL++ Reference Manual</title>
	<meta http-equiv="Content-type" content="text/html;charset=iso-8859-1">
	<link href="doxygen.css" rel="stylesheet" type="text/css">
	<link href="refman.css" rel="stylesheet" type="text/css">
</head>
<body>
<!-- Generated by Doxygen 1.2.18 -->
<center>
<a class="qindex" href="index.html">Main Page</a> &nbsp; <a class="qindex" href="namespaces.html">Namespace List</a> &nbsp; <a class="qindex" href="hierarchy.html">Class Hierarchy</a> &nbsp; <a class="qindex" href="annotated.html">Compound List</a> &nbsp; <a class="qindex" href="files.html">File List</a> &nbsp; <a class="qindex" href="namespacemembers.html">Namespace Members</a> &nbsp; <a class="qindex" href="functions.html">Compound Members</a> &nbsp; </center>
<hr><h1>mysqlpp::Query Class Reference</h1>A class for building and executing SQL queries. 
<a href="#_details">More...</a>
<p>
<code>#include &lt;<a class="el" href="query_8h-source.html">query.h</a>&gt;</code>
<p>
Inheritance diagram for mysqlpp::Query:<p><center><img src="classmysqlpp_1_1Query__inherit__graph.png" border="0" usemap="#mysqlpp_1_1Query__inherit__map" alt="Inheritance graph"></center>
<map name="mysqlpp_1_1Query__inherit__map">
<area href="classmysqlpp_1_1OptionalExceptions.html" shape="rect" coords="7,9,199,33" alt="">
<area href="classmysqlpp_1_1Lockable.html" shape="rect" coords="223,9,354,33" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center>Collaboration diagram for mysqlpp::Query:<p><center><img src="classmysqlpp_1_1Query__coll__graph.png" border="0" usemap="#mysqlpp_1_1Query__coll__map" alt="Collaboration graph"></center>
<map name="mysqlpp_1_1Query__coll__map">
<area href="classmysqlpp_1_1SQLQueryParms.html" shape="rect" coords="106,358,288,382" alt="">
<area href="classmysqlpp_1_1OptionalExceptions.html" shape="rect" coords="8,100,200,124" alt="">
<area href="classmysqlpp_1_1Connection.html" shape="rect" coords="124,177,270,201" alt="">
<area href="classmysqlpp_1_1Lockable.html" shape="rect" coords="233,100,364,124" alt="">
<area href="classmysqlpp_1_1Lock.html" shape="rect" coords="245,9,352,33" alt="">
</map>
<center><font size="2">[<a href="graph_legend.html">legend</a>]</font></center><a href="classmysqlpp_1_1Query-members.html">List of all members.</a><table border=0 cellpadding=0 cellspacing=0>
<tr><td></td></tr>
<tr><td colspan=2><br><h2>Public Methods</h2></td></tr>
<tr><td nowrap align=right valign=top>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a0">Query</a> (<a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *c, bool te=true)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new query object attached to a connection.</em> <a href="#a0"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a1">Query</a> (const Query &amp;q)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Create a new query object as a copy of another.</em> <a href="#a1"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT Query &amp;&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a2">operator=</a> (const Query &amp;rhs)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Assign another query's state to this object.</em> <a href="#a2"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT std::string&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a3">error</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get the last error message that was set.</em> <a href="#a3"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT bool&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a4">success</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Returns true if the last operation succeeded.</em> <a href="#a4"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a5">parse</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Treat the contents of the query string as a template query.</em> <a href="#a5"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a6">reset</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Reset the query object so that it can be reused.</em> <a href="#a6"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a7" doxytag="mysqlpp::Query::preview"></a>
std::string&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a7">preview</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the query string currently in the buffer.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a8" doxytag="mysqlpp::Query::preview"></a>
std::string&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a8">preview</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return the query string currently in the buffer.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a9" doxytag="mysqlpp::Query::str"></a>
std::string&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a9">str</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get built query as a null-terminated C++ string.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>std::string&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a10">str</a> (<a class="el" href="namespacemysqlpp.html#a98">query_reset</a> r)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get built query as a null-terminated C++ string.</em> <a href="#a10"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT std::string&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a11">str</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get built query as a null-terminated C++ string.</em> <a href="#a11"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT std::string&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a12">str</a> (<a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;p, <a class="el" href="namespacemysqlpp.html#a98">query_reset</a> r)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Get built query as a null-terminated C++ string.</em> <a href="#a12"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT bool&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a13">exec</a> (const std::string &amp;str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute a query.</em> <a href="#a13"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1ResNSel.html">ResNSel</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a14">execute</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute built-up query.</em> <a href="#a14"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT <a class="el" href="classmysqlpp_1_1ResNSel.html">ResNSel</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a15">execute</a> (const char *str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute query in a C++ string.</em> <a href="#a15"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a16">use</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute a query that can return a result set.</em> <a href="#a16"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT <a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a17">use</a> (const char *str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute query in a C++ string.</em> <a href="#a17"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1Result.html">Result</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a18">store</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute a query that can return a result set.</em> <a href="#a18"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT <a class="el" href="classmysqlpp_1_1Result.html">Result</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a19">store</a> (const char *str)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute query in a C++ string.</em> <a href="#a19"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT <a class="el" href="classmysqlpp_1_1Result.html">Result</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a20">store_next</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return next result set, when processing a multi-query.</em> <a href="#a20"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>MYSQLPP_EXPORT bool&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a21">more_results</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return whether more results are waiting for a multi-query or stored procedure response.</em> <a href="#a21"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Sequence&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a22">storein_sequence</a> (Sequence &amp;con, <a class="el" href="namespacemysqlpp.html#a98">query_reset</a> r=RESET_QUERY)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute a query, storing the result set in an STL sequence container.</em> <a href="#a22"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Set&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a23">storein_set</a> (<a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;con, <a class="el" href="namespacemysqlpp.html#a98">query_reset</a> r=RESET_QUERY)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute a query, storing the result set in an STL associative container.</em> <a href="#a23"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Container&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a24">storein</a> (Container &amp;con, <a class="el" href="namespacemysqlpp.html#a98">query_reset</a> r=RESET_QUERY)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Execute a query, and store the entire result set in an STL container.</em> <a href="#a24"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a25" doxytag="mysqlpp::Query::storein"></a>
template&lt;class T&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a25">storein</a> (std::vector&lt; T &gt; &amp;con, const char *s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a22">storein_sequence()</a> for <code>std::vector</code>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a26" doxytag="mysqlpp::Query::storein"></a>
template&lt;class T&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a26">storein</a> (std::deque&lt; T &gt; &amp;con, const char *s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a22">storein_sequence()</a> for <code>std::deque</code>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a27" doxytag="mysqlpp::Query::storein"></a>
template&lt;class T&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a27">storein</a> (std::list&lt; T &gt; &amp;con, const char *s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a22">storein_sequence()</a> for <code>std::list</code>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a28" doxytag="mysqlpp::Query::storein"></a>
template&lt;class T&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a28">storein</a> (std::set&lt; T &gt; &amp;con, const char *s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a23">storein_set()</a> for <code>std::set</code>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a29" doxytag="mysqlpp::Query::storein"></a>
template&lt;class T&gt; void&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a29">storein</a> (std::multiset&lt; T &gt; &amp;con, const char *s)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Specialization of <a class="el" href="classmysqlpp_1_1Query.html#a23">storein_set()</a> for <code>std::multiset</code>.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class T&gt; Query &amp;&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a30">update</a> (const T &amp;o, const T &amp;n)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Replace an existing row's data with new data.</em> <a href="#a30"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class T&gt; Query &amp;&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a31">insert</a> (const T &amp;v)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Insert a new row.</em> <a href="#a31"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class Iter&gt; Query &amp;&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a32">insert</a> (Iter first, Iter last)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Insert multiple new rows.</em> <a href="#a32"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top>template&lt;class T&gt; Query &amp;&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a33">replace</a> (const T &amp;v)</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Insert new row unless there is an existing row that matches on a unique index, in which case we replace it.</em> <a href="#a33"></a><em></em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a34" doxytag="mysqlpp::Query::operator bool"></a>
&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a34">operator bool</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return true if the last query was successful.</em></font><br><br></td></tr>
<tr><td nowrap align=right valign=top><a name="a35" doxytag="mysqlpp::Query::operator!"></a>
bool&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#a35">operator!</a> ()</td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>Return true if the last query failed.</em></font><br><br></td></tr>
<tr><td colspan=2><br><h2>Public Attributes</h2></td></tr>
<tr><td nowrap align=right valign=top><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a>&nbsp;</td><td valign=bottom><a class="el" href="classmysqlpp_1_1Query.html#m0">def</a></td></tr>
<tr><td>&nbsp;</td><td><font size=-1><em>The default template parameters.</em> <a href="#m0"></a><em></em></font><br><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
A class for building and executing SQL queries.
<p>
This class is derived from SQLQuery. It adds to that a tie between the query object and a MySQL++ <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object, so that the query can be sent to the MySQL server we're connected to.
<p>
One does not generally create <a class="el" href="classmysqlpp_1_1Query.html">Query</a> objects directly. Instead, call <a class="el" href="classmysqlpp_1_1Connection.html#a9">mysqlpp::Connection::query()</a> to get one tied to that connection.
<p>
There are several ways to build and execute SQL queries with this class.
<p>
The way most like other database libraries is to pass a SQL statement to one of the <a class="el" href="classmysqlpp_1_1Query.html#a14">exec*(),</a> <a class="el" href="classmysqlpp_1_1Query.html#a18">store*(),</a> or <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> methods taking a C or C++ string. The query is executed immediately, and any results returned.
<p>
For more complicated queries, you can use <a class="el" href="classmysqlpp_1_1Query.html">Query</a>'s stream interface. You simply build up a query using the <a class="el" href="classmysqlpp_1_1Query.html">Query</a> instance as you would any other C++ stream object. When the query string is complete, you call the overloaded version of <code>exec*()</code>, <code>store*()</code> or <code><a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a></code> that takes no parameters, which executes the built query and returns any results.
<p>
If you are using the library's Specialized SQL Structures feature, <a class="el" href="classmysqlpp_1_1Query.html">Query</a> has several special functions for generating common SQL queries from those structures. For instance, it offers the <a class="el" href="classmysqlpp_1_1Query.html#a31">insert()</a> method, which builds an INSERT query to add the contents of the SSQLS to the database. As with the stream interface, these methods only build the query string; call one of the parameterless methods mentioned previously to actually execute the query.
<p>
Finally, you can build "template queries". This is something like C's <code>printf()</code> function, in that you insert a specially-formatted query string into the object which contains placeholders for data. You call the <a class="el" href="classmysqlpp_1_1Query.html#a5">parse()</a> method to tell the <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object that the query string contains placeholders. Once that's done, you can call any of the many overloaded methods that take a number of SQLStrings (up to 25 by default) or any type that can be converted to <a class="el" href="classmysqlpp_1_1SQLString.html">SQLString</a>, and those parameters will be inserted into the placeholders. When you call one of the parameterless functions the execute the query, the final query string is assembled and sent to the server.
<p>
See the user manual for more details about these options. 
<p>
<hr><h2>Constructor &amp; Destructor Documentation</h2>
<a name="a0" doxytag="mysqlpp::Query::Query"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> mysqlpp::Query::Query </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> *&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>c</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>bool&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>te</em> = true</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new query object attached to a connection.
<p>
This is the constructor used by <a class="el" href="classmysqlpp_1_1Connection.html#a9">mysqlpp::Connection::query()</a>.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>c</em>&nbsp;</td><td>
connection the finished query should be sent out on </td></tr>
<tr><td valign=top><em>te</em>&nbsp;</td><td>
if true, throw exceptions on errors </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a1" doxytag="mysqlpp::Query::Query"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> mysqlpp::Query::Query </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Query &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>q</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Create a new query object as a copy of another.
<p>
This is <b>not</b> a traditional copy ctor! Its only purpose is to make it possible to assign the return of <a class="el" href="classmysqlpp_1_1Connection.html#a9">Connection::query()</a> to an empty <a class="el" href="classmysqlpp_1_1Query.html">Query</a> object. In particular, the stream buffer and template query stuff will be empty in the copy, regardless of what values they have in the original.     </td>
  </tr>
</table>
<hr><h2>Member Function Documentation</h2>
<a name="a3" doxytag="mysqlpp::Query::error"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string mysqlpp::Query::error </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get the last error message that was set.
<p>
This class has an internal error message string, but if it isn't set, we return the last error message that happened on the connection we're bound to instead.     </td>
  </tr>
</table>
<a name="a13" doxytag="mysqlpp::Query::exec"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool mysqlpp::Query::exec </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const std::string &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>str</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute a query.
<p>
Same as <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>, except that it only returns a flag indicating whether the query succeeded or not. It is basically a thin wrapper around the C API function <code>mysql_real_query()</code>.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>str</em>&nbsp;</td><td>
the query to execute</td></tr>
</table>
</dl><dl compact><dt><b>Returns: </b></dt><dd>
true if query was executed successfully</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> </dl>    </td>
  </tr>
</table>
<a name="a15" doxytag="mysqlpp::Query::execute"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1ResNSel.html">ResNSel</a> mysqlpp::Query::execute </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>str</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute query in a C++ string.
<p>
Executes the query immediately, and returns the results.     </td>
  </tr>
</table>
<a name="a14" doxytag="mysqlpp::Query::execute"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1ResNSel.html">ResNSel</a> mysqlpp::Query::execute </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute built-up query.
<p>
Use one of the <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a> overloads if you don't expect the server to return a result set. For instance, a DELETE query. The returned <a class="el" href="classmysqlpp_1_1ResNSel.html">ResNSel</a> object contains status information from the server, such as whether the query succeeded, and if so how many rows were affected.
<p>
This overloaded version of <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a> simply executes the query that you have built up in the object in some way. (For instance, via the <a class="el" href="classmysqlpp_1_1Query.html#a31">insert()</a> method, or by using the object's stream interface.)
<p>
<dl compact><dt><b>Returns: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1ResNSel.html">ResNSel</a> status information about the query</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a13">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> </dl>    </td>
  </tr>
</table>
<a name="a32" doxytag="mysqlpp::Query::insert"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Iter&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Query&amp; mysqlpp::Query::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Iter&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>first</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>Iter&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>last</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert multiple new rows.
<p>
Builds an INSERT SQL query using items from a range within an STL container. Insert the entire contents of the container by using the begin() and end() iterators of the container as parameters to this function.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>first</em>&nbsp;</td><td>
iterator pointing to first element in range to insert </td></tr>
<tr><td valign=top><em>last</em>&nbsp;</td><td>
iterator pointing to one past the last element to insert</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a33">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a30">update()</a> </dl>    </td>
  </tr>
</table>
<a name="a31" doxytag="mysqlpp::Query::insert"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Query&amp; mysqlpp::Query::insert </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>v</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert a new row.
<p>
This function builds an INSERT SQL query. One uses it with MySQL++'s Specialized SQL Structures mechanism.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>v</em>&nbsp;</td><td>
new row</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a33">replace()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a30">update()</a> </dl>    </td>
  </tr>
</table>
<a name="a21" doxytag="mysqlpp::Query::more_results"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool mysqlpp::Query::more_results </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return whether more results are waiting for a multi-query or stored procedure response.
<p>
If this function returns true, you must call <a class="el" href="classmysqlpp_1_1Query.html#a20">store_next()</a> to fetch the next result set before you can execute more queries.
<p>
Wraps mysql_more_results() in the MySQL C API. That function only exists in MySQL v4.1 and higher. Therefore, this function always returns false when built against older API libraries.
<p>
<dl compact><dt><b>Returns: </b></dt><dd>
true if another result set exists </dl>    </td>
  </tr>
</table>
<a name="a2" doxytag="mysqlpp::Query::operator="></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> Query &amp; mysqlpp::Query::operator= </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const Query &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>rhs</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Assign another query's state to this object.
<p>
The same caveats apply to this operator as apply to the copy ctor.     </td>
  </tr>
</table>
<a name="a5" doxytag="mysqlpp::Query::parse"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mysqlpp::Query::parse </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Treat the contents of the query string as a template query.
<p>
This method sets up the internal structures used by all of the other members that accept template query parameters. See the "Template Queries" chapter in the user manual for more information.     </td>
  </tr>
</table>
<a name="a33" doxytag="mysqlpp::Query::replace"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Query&amp; mysqlpp::Query::replace </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>v</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Insert new row unless there is an existing row that matches on a unique index, in which case we replace it.
<p>
This function builds a REPLACE SQL query. One uses it with MySQL++'s Specialized SQL Structures mechanism.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>v</em>&nbsp;</td><td>
new row</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a31">insert()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a30">update()</a> </dl>    </td>
  </tr>
</table>
<a name="a6" doxytag="mysqlpp::Query::reset"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> void mysqlpp::Query::reset </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Reset the query object so that it can be reused.
<p>
This erases the query string and the contents of the parameterized query element list.     </td>
  </tr>
</table>
<a name="a19" doxytag="mysqlpp::Query::store"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1Result.html">Result</a> mysqlpp::Query::store </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>str</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute query in a C++ string.
<p>
Executes the query immediately, and returns an object that contains the entire result set. This is less memory-efficient than <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a>, but it lets you have random access to the results.     </td>
  </tr>
</table>
<a name="a18" doxytag="mysqlpp::Query::store"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1Result.html">Result</a> mysqlpp::Query::store </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute a query that can return a result set.
<p>
Use one of the <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a> overloads to execute a query and retrieve the entire result set into memory. This is useful if you actually need all of the records at once, but if not, consider using one of the <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> methods instead, which returns the results one at a time, so they don't allocate as much memory as <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a>.
<p>
You must use <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24">storein()</a> or <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> for <code>SELECT</code>, <code>SHOW</code>, <code>DESCRIBE</code> and <code>EXPLAIN</code> queries. You can use these functions with other query types, but since they don't return a result set, <a class="el" href="classmysqlpp_1_1Query.html#a13">exec()</a> and <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a> are more efficient.
<p>
The name of this method comes from the MySQL C API function it is implemented in terms of, <code>mysql_store_result()</code>.
<p>
This function has the same set of overloads as <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>.
<p>
<dl compact><dt><b>Returns: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Result.html">Result</a> object containing entire result set</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a13">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a24">storein()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> </dl>    </td>
  </tr>
</table>
<a name="a20" doxytag="mysqlpp::Query::store_next"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1Result.html">Result</a> mysqlpp::Query::store_next </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Return next result set, when processing a multi-query.
<p>
There are two cases where you'd use this function instead of the regular <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a> functions.
<p>
First, when handling the result of executing multiple queries at once. (See <a href="http://dev.mysql.com/doc/mysql/en/c-api-multiple-queries.html">this page</a> in the MySQL documentation for details.)
<p>
Second, when calling a stored procedure, MySQL can return the result as a set of results.
<p>
In either case, you must consume all results before making another MySQL query, even if you don't care about the remaining results or result sets.
<p>
As the MySQL documentation points out, you must set the MYSQL_OPTION_MULTI_STATEMENTS_ON flag on the connection in order to use this feature. See <a class="el" href="classmysqlpp_1_1Connection.html#a28">Connection::set_option()</a>.
<p>
Multi-queries only exist in MySQL v4.1 and higher. Therefore, this function just wraps <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a> when built against older API libraries.
<p>
<dl compact><dt><b>Returns: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Result.html">Result</a> object containing the next result set. </dl>    </td>
  </tr>
</table>
<a name="a24" doxytag="mysqlpp::Query::storein"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Container&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void mysqlpp::Query::storein </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Container &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>con</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespacemysqlpp.html#a98">query_reset</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em> = RESET_QUERY</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute a query, and store the entire result set in an STL container.
<p>
This is a set of specialized template functions that call either <a class="el" href="classmysqlpp_1_1Query.html#a22">storein_sequence()</a> or <a class="el" href="classmysqlpp_1_1Query.html#a23">storein_set()</a>, depending on the type of container you pass it. It understands <code>std::vector</code>, <code>deque</code>, <code>list</code>, <code>slist</code> (a common C++ library extension), <code>set</code>, and <code>multiset</code>.
<p>
Like the functions it wraps, this is actually an overloaded set of functions. See the other functions' documentation for details.
<p>
Use this function if you think you might someday switch your program from using a set-associative container to a sequence container for storing result sets, or vice versa.
<p>
See <a class="el" href="classmysqlpp_1_1Query.html#a13">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> for alternative query execution mechanisms.     </td>
  </tr>
</table>
<a name="a22" doxytag="mysqlpp::Query::storein_sequence"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Sequence&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void mysqlpp::Query::storein_sequence </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">Sequence &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>con</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespacemysqlpp.html#a98">query_reset</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em> = RESET_QUERY</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute a query, storing the result set in an STL sequence container.
<p>
This function works much like <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a> from the caller's perspective, because it returns the entire result set at once. It's actually implemented in terms of <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a>, however, so that memory for the result set doesn't need to be allocated twice.
<p>
There are many overloads for this function, pretty much the same as for <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>, except that there is a Container parameter at the front of the list. So, you can pass a container and a query string, or a container and template query parameters.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>con</em>&nbsp;</td><td>
any STL sequence container, such as <code>std::vector</code> </td></tr>
<tr><td valign=top><em>r</em>&nbsp;</td><td>
whether the query automatically resets after being used</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a13">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a>, and <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> </dl>    </td>
  </tr>
</table>
<a name="a23" doxytag="mysqlpp::Query::storein_set"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class Set&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> void mysqlpp::Query::storein_set </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classmysqlpp_1_1Set.html">Set</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>con</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespacemysqlpp.html#a98">query_reset</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em> = RESET_QUERY</td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute a query, storing the result set in an STL associative container.
<p>
The same thing as <a class="el" href="classmysqlpp_1_1Query.html#a22">storein_sequence()</a>, except that it's used with associative STL containers, such as <code>std::set</code>. Other than that detail, that method's comments apply equally well to this one.     </td>
  </tr>
</table>
<a name="a12" doxytag="mysqlpp::Query::str"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string mysqlpp::Query::str </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>p</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap><a class="el" href="namespacemysqlpp.html#a98">query_reset</a>&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>r</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get built query as a null-terminated C++ string.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p</em>&nbsp;</td><td>
template query parameters to use, overriding the ones this object holds, if any </td></tr>
<tr><td valign=top><em>r</em>&nbsp;</td><td>
if equal to <code>RESET_QUERY</code>, query object is cleared after this call </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a11" doxytag="mysqlpp::Query::str"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string mysqlpp::Query::str </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> &amp;&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>p</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get built query as a null-terminated C++ string.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>p</em>&nbsp;</td><td>
template query parameters to use, overriding the ones this object holds, if any </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a10" doxytag="mysqlpp::Query::str"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> std::string mysqlpp::Query::str </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top"><a class="el" href="namespacemysqlpp.html#a98">query_reset</a>&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>r</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Get built query as a null-terminated C++ string.
<p>
<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>r</em>&nbsp;</td><td>
if equal to <code>RESET_QUERY</code>, query object is cleared after this call </td></tr>
</table>
</dl>    </td>
  </tr>
</table>
<a name="a4" doxytag="mysqlpp::Query::success"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> bool mysqlpp::Query::success </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Returns true if the last operation succeeded.
<p>
Returns true if the last query succeeded, and the associated <a class="el" href="classmysqlpp_1_1Connection.html">Connection</a> object's <a class="el" href="classmysqlpp_1_1Query.html#a4">success()</a> method also returns true. If either object is unhappy, this method returns false.     </td>
  </tr>
</table>
<a name="a30" doxytag="mysqlpp::Query::update"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" colspan="4">
template&lt;class T&gt; </td>
        </tr>
        <tr>
          <td class="md" nowrap valign="top"> Query&amp; mysqlpp::Query::update </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const T &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>o</em>, </td>
        </tr>
        <tr>
          <td></td>
          <td></td>
          <td class="md" nowrap>const T &amp;&nbsp;</td>
          <td class="mdname" nowrap>&nbsp; <em>n</em></td>
        </tr>
        <tr>
          <td></td>
          <td class="md">)&nbsp;</td>
          <td class="md" colspan="2"><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Replace an existing row's data with new data.
<p>
This function builds an UPDATE SQL query using the new row data for the SET clause, and the old row data for the WHERE clause. One uses it with MySQL++'s Specialized SQL Structures mechanism.<dl compact><dt><b>Parameters: </b></dt><dd>
<table border=0 cellspacing=2 cellpadding=0>
<tr><td valign=top><em>o</em>&nbsp;</td><td>
old row </td></tr>
<tr><td valign=top><em>n</em>&nbsp;</td><td>
new row</td></tr>
</table>
</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a31">insert()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a33">replace()</a> </dl>    </td>
  </tr>
</table>
<a name="a17" doxytag="mysqlpp::Query::use"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a> mysqlpp::Query::use </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="md" nowrap valign="top">const char *&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp; <em>str</em>          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute query in a C++ string.
<p>
Executes the query immediately, and returns an object that lets you walk through the result set one row at a time, in sequence. This is more memory-efficient than <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a>.     </td>
  </tr>
</table>
<a name="a16" doxytag="mysqlpp::Query::use"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a> mysqlpp::Query::use </td>
          <td class="md" valign="top">(&nbsp;</td>
          <td class="mdname1" valign="top" nowrap>&nbsp;          </td>
          <td class="md" valign="top">)&nbsp;</td>
          <td class="md" nowrap><code> [inline]</code></td>
        </tr>

      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
Execute a query that can return a result set.
<p>
Use one of the <a class="el" href="classmysqlpp_1_1Query.html#a16">use()</a> overloads if memory efficiency is important. They return an object that can walk through the result records one by one, without fetching the entire result set from the server. This is superior to <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a> when there are a large number of results; <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a> would have to allocate a large block of memory to hold all those records, which could cause problems.
<p>
A potential downside of this method is that MySQL database resources are tied up until the result set is completely consumed. Do your best to walk through the result set as expeditiously as possible.
<p>
The name of this method comes from the MySQL C API function that initiates the retrieval process, <code>mysql_use_result()</code>. This method is implemented in terms of that function.
<p>
This function has the same set of overloads as <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>.
<p>
<dl compact><dt><b>Returns: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1ResUse.html">ResUse</a> object that can walk through result set serially</dl><dl compact><dt><b>See also: </b></dt><dd>
<a class="el" href="classmysqlpp_1_1Query.html#a13">exec()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a14">execute()</a>, <a class="el" href="classmysqlpp_1_1Query.html#a18">store()</a> and <a class="el" href="classmysqlpp_1_1Query.html#a24">storein()</a> </dl>    </td>
  </tr>
</table>
<hr><h2>Member Data Documentation</h2>
<a name="m0" doxytag="mysqlpp::Query::def"></a><p>
<table width="100%" cellpadding="2" cellspacing="0" border="0">
  <tr>
    <td class="md">
      <table cellpadding="0" cellspacing="0" border="0">
        <tr>
          <td class="md" nowrap valign="top"> <a class="el" href="classmysqlpp_1_1SQLQueryParms.html">SQLQueryParms</a> mysqlpp::Query::def
      </table>
    </td>
  </tr>
</table>
<table cellspacing=5 cellpadding=0 border=0>
  <tr>
    <td>
      &nbsp;
    </td>
    <td>

<p>
The default template parameters.
<p>
Used for filling in parameterized queries.     </td>
  </tr>
</table>
<hr>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="query_8h-source.html">query.h</a><li>query.cpp</ul>
<hr><address style="align: right;"><small>Generated on Fri Mar 24 14:05:08 2006 for MySQL++ by
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border=0 
width=110 height=53></a>1.2.18 </small></address>
</body>
</html>
