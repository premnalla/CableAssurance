/* CteServC.cpp
   Generated by gSOAP 2.7.9c from include/CteServices.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "CteServH.h"

SOAP_SOURCE_STAMP("@(#) CteServC.cpp ver 2.7.9c 2007-06-22 15:56:53 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__ApplicationDomainTypeT:
		return soap_in_ns1__ApplicationDomainTypeT(soap, NULL, NULL, "ns1:ApplicationDomainTypeT");
	case SOAP_TYPE_ns1__UserAccessTypeT:
		return soap_in_ns1__UserAccessTypeT(soap, NULL, NULL, "ns1:UserAccessTypeT");
	case SOAP_TYPE_ns1__EndUserDeviceTypeT:
		return soap_in_ns1__EndUserDeviceTypeT(soap, NULL, NULL, "ns1:EndUserDeviceTypeT");
	case SOAP_TYPE_ns1__ChannelTypeT:
		return soap_in_ns1__ChannelTypeT(soap, NULL, NULL, "ns1:ChannelTypeT");
	case SOAP_TYPE_ns1__SnmpVersionT:
		return soap_in_ns1__SnmpVersionT(soap, NULL, NULL, "ns1:SnmpVersionT");
	case SOAP_TYPE_ns1__StatusColorT:
		return soap_in_ns1__StatusColorT(soap, NULL, NULL, "ns1:StatusColorT");
	case SOAP_TYPE_ns1__ResourceTypeT:
		return soap_in_ns1__ResourceTypeT(soap, NULL, NULL, "ns1:ResourceTypeT");
	case SOAP_TYPE_ns1__SystemTypeT:
		return soap_in_ns1__SystemTypeT(soap, NULL, NULL, "ns1:SystemTypeT");
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		return soap_in_ns1__HistoricalAlarmsRespT(soap, NULL, NULL, "ns1:HistoricalAlarmsRespT");
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		return soap_in_ns1__CurrentAlarmsRespT(soap, NULL, NULL, "ns1:CurrentAlarmsRespT");
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		return soap_in_ns1__CmStatusSummaryRespT(soap, NULL, NULL, "ns1:CmStatusSummaryRespT");
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		return soap_in_ns1__HfcStatusSummaryRespT(soap, NULL, NULL, "ns1:HfcStatusSummaryRespT");
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		return soap_in_ns1__MtaStatusSummaryRespT(soap, NULL, NULL, "ns1:MtaStatusSummaryRespT");
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		return soap_in_ArrayOfCmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		return soap_in_ns1__CmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		return soap_in_ArrayOfMtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		return soap_in_ns1__MtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		return soap_in_ArrayOfHfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		return soap_in_ns1__HfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__StatusSummaryT:
		return soap_in_ns1__StatusSummaryT(soap, NULL, NULL, "ns1:StatusSummaryT");
	case SOAP_TYPE_ns1__MtaDataT:
		return soap_in_ns1__MtaDataT(soap, NULL, NULL, "ns1:MtaDataT");
	case SOAP_TYPE_ns1__CmDataT:
		return soap_in_ns1__CmDataT(soap, NULL, NULL, "ns1:CmDataT");
	case SOAP_TYPE_ns1__CmtsCmDataT:
		return soap_in_ns1__CmtsCmDataT(soap, NULL, NULL, "ns1:CmtsCmDataT");
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		return soap_in_ns1__CmPerformanceConfigT(soap, NULL, NULL, "ns1:CmPerformanceConfigT");
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		return soap_in_ns1__CmsAlarmConfigT(soap, NULL, NULL, "ns1:CmsAlarmConfigT");
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		return soap_in_ns1__CmtsAlarmConfigT(soap, NULL, NULL, "ns1:CmtsAlarmConfigT");
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		return soap_in_ns1__MtaAlarmConfigT(soap, NULL, NULL, "ns1:MtaAlarmConfigT");
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		return soap_in_ArrayOfAlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		return soap_in_ns1__AlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		return soap_in_ns1__HfcAlarmConfigT(soap, NULL, NULL, "ns1:HfcAlarmConfigT");
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		return soap_in_ns1__HfcPowerTresholdT(soap, NULL, NULL, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		return soap_in_ns1__AggregateMtaTresholdT(soap, NULL, NULL, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		return soap_in_ns1__AggregateCmOfflineTresholdT(soap, NULL, NULL, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_ns1__SoakWindowT:
		return soap_in_ns1__SoakWindowT(soap, NULL, NULL, "ns1:SoakWindowT");
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		return soap_in_ns1__CmsStatusThresholdT(soap, NULL, NULL, "ns1:CmsStatusThresholdT");
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		return soap_in_ns1__CmtsStatusThresholdT(soap, NULL, NULL, "ns1:CmtsStatusThresholdT");
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		return soap_in_ns1__ChannelStatusThresholdT(soap, NULL, NULL, "ns1:ChannelStatusThresholdT");
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		return soap_in_ns1__HfcStatusThresholdT(soap, NULL, NULL, "ns1:HfcStatusThresholdT");
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		return soap_in_ns1__MtaStatusThresholdT(soap, NULL, NULL, "ns1:MtaStatusThresholdT");
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		return soap_in_ArrayOfAggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		return soap_in_ns1__AggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		return soap_in_ArrayOfAlarmStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		return soap_in_ns1__AlarmBasedStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__PollingIntervalsT:
		return soap_in_ns1__PollingIntervalsT(soap, NULL, NULL, "ns1:PollingIntervalsT");
	case SOAP_TYPE_ns1__UserAccessPrivilegesT:
		return soap_in_ns1__UserAccessPrivilegesT(soap, NULL, NULL, "ns1:UserAccessPrivilegesT");
	case SOAP_TYPE_ArrayOfUserT:
		return soap_in_ArrayOfUserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_ns1__UserT:
		return soap_in_ns1__UserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_ArrayOfUserRoleT:
		return soap_in_ArrayOfUserRoleT(soap, NULL, NULL, "ns1:UserRoleT");
	case SOAP_TYPE_ns1__RoleOAPairT:
		return soap_in_ns1__RoleOAPairT(soap, NULL, NULL, "ns1:RoleOAPairT");
	case SOAP_TYPE_ns1__UserRoleT:
		return soap_in_ns1__UserRoleT(soap, NULL, NULL, "ns1:UserRoleT");
	case SOAP_TYPE_ArrayOfOAPairT:
		return soap_in_ArrayOfOAPairT(soap, NULL, NULL, "ns1:OAPairT");
	case SOAP_TYPE_ns1__OAPairT:
		return soap_in_ns1__OAPairT(soap, NULL, NULL, "ns1:OAPairT");
	case SOAP_TYPE_ns1__CMSResultT:
		return soap_in_ns1__CMSResultT(soap, NULL, NULL, "ns1:CMSResultT");
	case SOAP_TYPE_ArrayOfCMSLineT:
		return soap_in_ArrayOfCMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_ns1__CMSLineT:
		return soap_in_ns1__CMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		return soap_in_ArrayOfCTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ns1__CTEQueryInputT:
		return soap_in_ns1__CTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ArrayOfCTEDataT:
		return soap_in_ArrayOfCTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEDataT:
		return soap_in_ns1__CTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		return soap_in_ns1__CTEAbstractNameT(soap, NULL, NULL, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		return soap_in_ns1__CTEAbstractMacT(soap, NULL, NULL, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_ArrayOfCTECustomerT:
		return soap_in_ArrayOfCTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_ns1__CTECustomerT:
		return soap_in_ns1__CTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		return soap_in_ArrayOfCmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		return soap_in_ns1__CmCurrentPerformanceT(soap, NULL, NULL, "ns1:CmCurrentPerformanceT");
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		return soap_in_ns1__CmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmPerformanceT:
		return soap_in_ns1__CmPerformanceT(soap, NULL, NULL, "ns1:CmPerformanceT");
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		return soap_in_ArrayOfMtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		return soap_in_ns1__MtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusT:
		return soap_in_ns1__MtaPingStatusT(soap, NULL, NULL, "ns1:MtaPingStatusT");
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		return soap_in_ArrayOfMtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		return soap_in_ns1__MtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusT:
		return soap_in_ns1__MtaProvStatusT(soap, NULL, NULL, "ns1:MtaProvStatusT");
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		return soap_in_ArrayOfMtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		return soap_in_ns1__MtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		return soap_in_ns1__MtaAvailabilityT(soap, NULL, NULL, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		return soap_in_ArrayOfCmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		return soap_in_ns1__CmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusT:
		return soap_in_ns1__CmStatusT(soap, NULL, NULL, "ns1:CmStatusT");
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		return soap_in_ArrayOfGenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		return soap_in_ns1__GenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ArrayOfQueryStateT:
		return soap_in_ArrayOfQueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_ns1__QueryStateT:
		return soap_in_ns1__QueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_ArrayOfScrollPageT:
		return soap_in_ArrayOfScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__ScrollPageT:
		return soap_in_ns1__ScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		return soap_in_ns1__MappedEuDevicesT(soap, NULL, NULL, "ns1:MappedEuDevicesT");
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		return soap_in_ArrayOfAlarmHistoriesT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		return soap_in_ArrayOfHistoricalAlarmsT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		return soap_in_ArrayOfCurrentAlarmsT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ArrayOfEmtasT:
		return soap_in_ArrayOfEmtasT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_ArrayOfCableModemsT:
		return soap_in_ArrayOfCableModemsT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_ArrayOfHfcsT:
		return soap_in_ArrayOfHfcsT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_ArrayOfChannelsT:
		return soap_in_ArrayOfChannelsT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		return soap_in_ArrayOfSnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_ArrayOfCmtsesT:
		return soap_in_ArrayOfCmtsesT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_ArrayOfCmsesT:
		return soap_in_ArrayOfCmsesT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_ArrayOfBladesT:
		return soap_in_ArrayOfBladesT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_ArrayOfMarketsT:
		return soap_in_ArrayOfMarketsT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_ArrayOfRegionsT:
		return soap_in_ArrayOfRegionsT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_ns1__AlarmHistoryT:
		return soap_in_ns1__AlarmHistoryT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		return soap_in_ns1__HistoricalAlarmDetailsT(soap, NULL, NULL, "ns1:HistoricalAlarmDetailsT");
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		return soap_in_ns1__HistoricalAlarmT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		return soap_in_ns1__CurrentAlarmDetailsT(soap, NULL, NULL, "ns1:CurrentAlarmDetailsT");
	case SOAP_TYPE_ns1__CurrentAlarmT:
		return soap_in_ns1__CurrentAlarmT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ns1__AbstractAlarmT:
		return soap_in_ns1__AbstractAlarmT(soap, NULL, NULL, "ns1:AbstractAlarmT");
	case SOAP_TYPE_ns1__EmtaT:
		return soap_in_ns1__EmtaT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_ns1__CableModemT:
		return soap_in_ns1__CableModemT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_ns1__HfcT:
		return soap_in_ns1__HfcT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_ns1__ChannelT:
		return soap_in_ns1__ChannelT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_ns1__CmtsT:
		return soap_in_ns1__CmtsT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_ns1__CmsT:
		return soap_in_ns1__CmsT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_ns1__BladeT:
		return soap_in_ns1__BladeT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_ns1__MarketT:
		return soap_in_ns1__MarketT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_ns1__RegionT:
		return soap_in_ns1__RegionT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_ns1__LocalSystemT:
		return soap_in_ns1__LocalSystemT(soap, NULL, NULL, "ns1:LocalSystemT");
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		return soap_in_ns1__TopoHierarchyKeyT(soap, NULL, NULL, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_ns1__ResultBatchT:
		return soap_in_ns1__ResultBatchT(soap, NULL, NULL, "ns1:ResultBatchT");
	case SOAP_TYPE_ns1__InputTimeT:
		return soap_in_ns1__InputTimeT(soap, NULL, NULL, "ns1:InputTimeT");
	case SOAP_TYPE_ns1__GenericCountsT:
		return soap_in_ns1__GenericCountsT(soap, NULL, NULL, "ns1:GenericCountsT");
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		return soap_in_ns1__SnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_cte__getCteData:
		return soap_in_cte__getCteData(soap, NULL, NULL, "cte:getCteData");
	case SOAP_TYPE_cte__getCteDataResponse:
		return soap_in_cte__getCteDataResponse(soap, NULL, NULL, "cte:getCteDataResponse");
	case SOAP_TYPE_PointerToArrayOfCTEQueryInputT:
		return soap_in_PointerToArrayOfCTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerToArrayOfCTEDataT:
		return soap_in_PointerToArrayOfCTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT:
		return soap_in_PointerToPointerTons1__CmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerTons1__CmStatusSummaryT:
		return soap_in_PointerTons1__CmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT:
		return soap_in_PointerToPointerTons1__MtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__MtaStatusSummaryT:
		return soap_in_PointerTons1__MtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT:
		return soap_in_PointerToPointerTons1__HfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerTons1__HfcStatusSummaryT:
		return soap_in_PointerTons1__HfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT:
		return soap_in_PointerToPointerTons1__AlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT:
		return soap_in_PointerToPointerTons1__AggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AggregateStatusThresholdT:
		return soap_in_PointerTons1__AggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT:
		return soap_in_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT:
		return soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__UserT:
		return soap_in_PointerToPointerTons1__UserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_PointerTons1__UserT:
		return soap_in_PointerTons1__UserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_PointerToPointerTons1__UserRoleT:
		return soap_in_PointerToPointerTons1__UserRoleT(soap, NULL, NULL, "ns1:UserRoleT");
	case SOAP_TYPE_PointerToPointerTons1__OAPairT:
		return soap_in_PointerToPointerTons1__OAPairT(soap, NULL, NULL, "ns1:OAPairT");
	case SOAP_TYPE_PointerTons1__OAPairT:
		return soap_in_PointerTons1__OAPairT(soap, NULL, NULL, "ns1:OAPairT");
	case SOAP_TYPE_PointerToPointerTons1__CMSLineT:
		return soap_in_PointerToPointerTons1__CMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT:
		return soap_in_PointerToPointerTons1__CTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerTons1__CTEQueryInputT:
		return soap_in_PointerTons1__CTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerToPointerTons1__CTEDataT:
		return soap_in_PointerToPointerTons1__CTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_PointerTons1__CTEDataT:
		return soap_in_PointerTons1__CTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_PointerToPointerTons1__CTECustomerT:
		return soap_in_PointerToPointerTons1__CTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT:
		return soap_in_PointerToPointerTons1__CmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerTons1__CmPerformanceHistoryT:
		return soap_in_PointerTons1__CmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT:
		return soap_in_PointerToPointerTons1__MtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT:
		return soap_in_PointerTons1__MtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT:
		return soap_in_PointerToPointerTons1__MtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT:
		return soap_in_PointerTons1__MtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT:
		return soap_in_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT:
		return soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT:
		return soap_in_PointerToPointerTons1__CmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerTons1__CmStatusHistoryT:
		return soap_in_PointerTons1__CmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT:
		return soap_in_PointerToPointerTons1__GenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerTons1__GenericCountsHistoryT:
		return soap_in_PointerTons1__GenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__QueryStateT:
		return soap_in_PointerToPointerTons1__QueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_PointerTons1__QueryStateT:
		return soap_in_PointerTons1__QueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToPointerTons1__ScrollPageT:
		return soap_in_PointerToPointerTons1__ScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ScrollPageT:
		return soap_in_PointerTons1__ScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT:
		return soap_in_PointerToPointerTons1__AlarmHistoryT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerTons1__AlarmHistoryT:
		return soap_in_PointerTons1__AlarmHistoryT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT:
		return soap_in_PointerToPointerTons1__HistoricalAlarmT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT:
		return soap_in_PointerToPointerTons1__CurrentAlarmT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__EmtaT:
		return soap_in_PointerToPointerTons1__EmtaT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_PointerToPointerTons1__CableModemT:
		return soap_in_PointerToPointerTons1__CableModemT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_PointerToPointerTons1__HfcT:
		return soap_in_PointerToPointerTons1__HfcT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_PointerTons1__HfcT:
		return soap_in_PointerTons1__HfcT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_PointerToPointerTons1__ChannelT:
		return soap_in_PointerToPointerTons1__ChannelT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_PointerTons1__ChannelT:
		return soap_in_PointerTons1__ChannelT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT:
		return soap_in_PointerToPointerTons1__SnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerTons1__SnmpV2CAttributesT:
		return soap_in_PointerTons1__SnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerToPointerTons1__CmtsT:
		return soap_in_PointerToPointerTons1__CmtsT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_PointerTons1__CmtsT:
		return soap_in_PointerTons1__CmtsT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_PointerToPointerTons1__CmsT:
		return soap_in_PointerToPointerTons1__CmsT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_PointerTons1__CmsT:
		return soap_in_PointerTons1__CmsT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_PointerToPointerTons1__BladeT:
		return soap_in_PointerToPointerTons1__BladeT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_PointerTons1__BladeT:
		return soap_in_PointerTons1__BladeT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_PointerToPointerTons1__MarketT:
		return soap_in_PointerToPointerTons1__MarketT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_PointerTons1__MarketT:
		return soap_in_PointerTons1__MarketT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_PointerToPointerTons1__RegionT:
		return soap_in_PointerToPointerTons1__RegionT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_PointerTons1__RegionT:
		return soap_in_PointerTons1__RegionT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT:
		return soap_in_PointerToArrayOfHistoricalAlarmsT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToArrayOfCurrentAlarmsT:
		return soap_in_PointerToArrayOfCurrentAlarmsT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToArrayOfCmStatusSummaryT:
		return soap_in_PointerToArrayOfCmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT:
		return soap_in_PointerToArrayOfHfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfQueryStateT:
		return soap_in_PointerToArrayOfQueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT:
		return soap_in_PointerToArrayOfMtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__StatusSummaryT:
		return soap_in_PointerTons1__StatusSummaryT(soap, NULL, NULL, "ns1:StatusSummaryT");
	case SOAP_TYPE_PointerTons1__AlarmTypeConfigT:
		return soap_in_PointerTons1__AlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT:
		return soap_in_PointerToArrayOfAlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerTons1__HfcPowerTresholdT:
		return soap_in_PointerTons1__HfcPowerTresholdT(soap, NULL, NULL, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_PointerTons1__AggregateMtaTresholdT:
		return soap_in_PointerTons1__AggregateMtaTresholdT(soap, NULL, NULL, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_PointerTons1__SoakWindowT:
		return soap_in_PointerTons1__SoakWindowT(soap, NULL, NULL, "ns1:SoakWindowT");
	case SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT:
		return soap_in_PointerTons1__AggregateCmOfflineTresholdT(soap, NULL, NULL, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT:
		return soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT:
		return soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerTons1__UserRoleT:
		return soap_in_PointerTons1__UserRoleT(soap, NULL, NULL, "ns1:UserRoleT");
	case SOAP_TYPE_PointerToArrayOfOAPairT:
		return soap_in_PointerToArrayOfOAPairT(soap, NULL, NULL, "ns1:OAPairT");
	case SOAP_TYPE_PointerTons1__CMSLineT:
		return soap_in_PointerTons1__CMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_PointerTons1__CTEAbstractNameT:
		return soap_in_PointerTons1__CTEAbstractNameT(soap, NULL, NULL, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_PointerTons1__CTEAbstractMacT:
		return soap_in_PointerTons1__CTEAbstractMacT(soap, NULL, NULL, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_PointerTons1__CTECustomerT:
		return soap_in_PointerTons1__CTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToshort:
		return soap_in_PointerToshort(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_PointerTons1__CmPerformanceT:
		return soap_in_PointerTons1__CmPerformanceT(soap, NULL, NULL, "ns1:CmPerformanceT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusT:
		return soap_in_PointerTons1__MtaPingStatusT(soap, NULL, NULL, "ns1:MtaPingStatusT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusT:
		return soap_in_PointerTons1__MtaProvStatusT(soap, NULL, NULL, "ns1:MtaProvStatusT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityT:
		return soap_in_PointerTons1__MtaAvailabilityT(soap, NULL, NULL, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_PointerTons1__CmStatusT:
		return soap_in_PointerTons1__CmStatusT(soap, NULL, NULL, "ns1:CmStatusT");
	case SOAP_TYPE_PointerToArrayOfScrollPageT:
		return soap_in_PointerToArrayOfScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ResultBatchT:
		return soap_in_PointerTons1__ResultBatchT(soap, NULL, NULL, "ns1:ResultBatchT");
	case SOAP_TYPE_PointerTons1__EmtaT:
		return soap_in_PointerTons1__EmtaT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_PointerTons1__CableModemT:
		return soap_in_PointerTons1__CableModemT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_PointerTons1__HistoricalAlarmT:
		return soap_in_PointerTons1__HistoricalAlarmT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerTons1__CurrentAlarmT:
		return soap_in_PointerTons1__CurrentAlarmT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerTons1__AbstractAlarmT:
		return soap_in_PointerTons1__AbstractAlarmT(soap, NULL, NULL, "ns1:AbstractAlarmT");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTons1__GenericCountsT:
		return soap_in_PointerTons1__GenericCountsT(soap, NULL, NULL, "ns1:GenericCountsT");
	case SOAP_TYPE_PointerTons1__TopoHierarchyKeyT:
		return soap_in_PointerTons1__TopoHierarchyKeyT(soap, NULL, NULL, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApplicationDomainTypeT"))
		{	*type = SOAP_TYPE_ns1__ApplicationDomainTypeT;
			return soap_in_ns1__ApplicationDomainTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserAccessTypeT"))
		{	*type = SOAP_TYPE_ns1__UserAccessTypeT;
			return soap_in_ns1__UserAccessTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndUserDeviceTypeT"))
		{	*type = SOAP_TYPE_ns1__EndUserDeviceTypeT;
			return soap_in_ns1__EndUserDeviceTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChannelTypeT"))
		{	*type = SOAP_TYPE_ns1__ChannelTypeT;
			return soap_in_ns1__ChannelTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnmpVersionT"))
		{	*type = SOAP_TYPE_ns1__SnmpVersionT;
			return soap_in_ns1__SnmpVersionT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatusColorT"))
		{	*type = SOAP_TYPE_ns1__StatusColorT;
			return soap_in_ns1__StatusColorT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResourceTypeT"))
		{	*type = SOAP_TYPE_ns1__ResourceTypeT;
			return soap_in_ns1__ResourceTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SystemTypeT"))
		{	*type = SOAP_TYPE_ns1__SystemTypeT;
			return soap_in_ns1__SystemTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistoricalAlarmsRespT"))
		{	*type = SOAP_TYPE_ns1__HistoricalAlarmsRespT;
			return soap_in_ns1__HistoricalAlarmsRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CurrentAlarmsRespT"))
		{	*type = SOAP_TYPE_ns1__CurrentAlarmsRespT;
			return soap_in_ns1__CurrentAlarmsRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusSummaryRespT"))
		{	*type = SOAP_TYPE_ns1__CmStatusSummaryRespT;
			return soap_in_ns1__CmStatusSummaryRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcStatusSummaryRespT"))
		{	*type = SOAP_TYPE_ns1__HfcStatusSummaryRespT;
			return soap_in_ns1__HfcStatusSummaryRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaStatusSummaryRespT"))
		{	*type = SOAP_TYPE_ns1__MtaStatusSummaryRespT;
			return soap_in_ns1__MtaStatusSummaryRespT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmStatusSummaryT"))
		{	*type = SOAP_TYPE_ArrayOfCmStatusSummaryT;
			return soap_in_ArrayOfCmStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__CmStatusSummaryT;
			return soap_in_ns1__CmStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaStatusSummaryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaStatusSummaryT;
			return soap_in_ArrayOfMtaStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaStatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__MtaStatusSummaryT;
			return soap_in_ns1__MtaStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:HfcStatusSummaryT"))
		{	*type = SOAP_TYPE_ArrayOfHfcStatusSummaryT;
			return soap_in_ArrayOfHfcStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcStatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__HfcStatusSummaryT;
			return soap_in_ns1__HfcStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__StatusSummaryT;
			return soap_in_ns1__StatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaDataT"))
		{	*type = SOAP_TYPE_ns1__MtaDataT;
			return soap_in_ns1__MtaDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmDataT"))
		{	*type = SOAP_TYPE_ns1__CmDataT;
			return soap_in_ns1__CmDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsCmDataT"))
		{	*type = SOAP_TYPE_ns1__CmtsCmDataT;
			return soap_in_ns1__CmtsCmDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmPerformanceConfigT"))
		{	*type = SOAP_TYPE_ns1__CmPerformanceConfigT;
			return soap_in_ns1__CmPerformanceConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmsAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__CmsAlarmConfigT;
			return soap_in_ns1__CmsAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__CmtsAlarmConfigT;
			return soap_in_ns1__CmtsAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__MtaAlarmConfigT;
			return soap_in_ns1__MtaAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AlarmTypeConfigT"))
		{	*type = SOAP_TYPE_ArrayOfAlarmTypeConfigT;
			return soap_in_ArrayOfAlarmTypeConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmTypeConfigT"))
		{	*type = SOAP_TYPE_ns1__AlarmTypeConfigT;
			return soap_in_ns1__AlarmTypeConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__HfcAlarmConfigT;
			return soap_in_ns1__HfcAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcPowerTresholdT"))
		{	*type = SOAP_TYPE_ns1__HfcPowerTresholdT;
			return soap_in_ns1__HfcPowerTresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AggregateMtaTresholdT"))
		{	*type = SOAP_TYPE_ns1__AggregateMtaTresholdT;
			return soap_in_ns1__AggregateMtaTresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AggregateCmOfflineTresholdT"))
		{	*type = SOAP_TYPE_ns1__AggregateCmOfflineTresholdT;
			return soap_in_ns1__AggregateCmOfflineTresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoakWindowT"))
		{	*type = SOAP_TYPE_ns1__SoakWindowT;
			return soap_in_ns1__SoakWindowT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmsStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__CmsStatusThresholdT;
			return soap_in_ns1__CmsStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__CmtsStatusThresholdT;
			return soap_in_ns1__CmtsStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChannelStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__ChannelStatusThresholdT;
			return soap_in_ns1__ChannelStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__HfcStatusThresholdT;
			return soap_in_ns1__HfcStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__MtaStatusThresholdT;
			return soap_in_ns1__MtaStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AggregateStatusThresholdT"))
		{	*type = SOAP_TYPE_ArrayOfAggregateStatusThresholdT;
			return soap_in_ArrayOfAggregateStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AggregateStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__AggregateStatusThresholdT;
			return soap_in_ns1__AggregateStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AlarmBasedStatusThresholdT"))
		{	*type = SOAP_TYPE_ArrayOfAlarmStatusThresholdT;
			return soap_in_ArrayOfAlarmStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmBasedStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__AlarmBasedStatusThresholdT;
			return soap_in_ns1__AlarmBasedStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PollingIntervalsT"))
		{	*type = SOAP_TYPE_ns1__PollingIntervalsT;
			return soap_in_ns1__PollingIntervalsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserAccessPrivilegesT"))
		{	*type = SOAP_TYPE_ns1__UserAccessPrivilegesT;
			return soap_in_ns1__UserAccessPrivilegesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:UserT"))
		{	*type = SOAP_TYPE_ArrayOfUserT;
			return soap_in_ArrayOfUserT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserT"))
		{	*type = SOAP_TYPE_ns1__UserT;
			return soap_in_ns1__UserT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:UserRoleT"))
		{	*type = SOAP_TYPE_ArrayOfUserRoleT;
			return soap_in_ArrayOfUserRoleT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoleOAPairT"))
		{	*type = SOAP_TYPE_ns1__RoleOAPairT;
			return soap_in_ns1__RoleOAPairT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserRoleT"))
		{	*type = SOAP_TYPE_ns1__UserRoleT;
			return soap_in_ns1__UserRoleT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:OAPairT"))
		{	*type = SOAP_TYPE_ArrayOfOAPairT;
			return soap_in_ArrayOfOAPairT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:OAPairT"))
		{	*type = SOAP_TYPE_ns1__OAPairT;
			return soap_in_ns1__OAPairT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CMSResultT"))
		{	*type = SOAP_TYPE_ns1__CMSResultT;
			return soap_in_ns1__CMSResultT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CMSLineT"))
		{	*type = SOAP_TYPE_ArrayOfCMSLineT;
			return soap_in_ArrayOfCMSLineT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CMSLineT"))
		{	*type = SOAP_TYPE_ns1__CMSLineT;
			return soap_in_ns1__CMSLineT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTEQueryInputT"))
		{	*type = SOAP_TYPE_ArrayOfCTEQueryInputT;
			return soap_in_ArrayOfCTEQueryInputT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEQueryInputT"))
		{	*type = SOAP_TYPE_ns1__CTEQueryInputT;
			return soap_in_ns1__CTEQueryInputT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTEDataT"))
		{	*type = SOAP_TYPE_ArrayOfCTEDataT;
			return soap_in_ArrayOfCTEDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEDataT"))
		{	*type = SOAP_TYPE_ns1__CTEDataT;
			return soap_in_ns1__CTEDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEAbstractNameT"))
		{	*type = SOAP_TYPE_ns1__CTEAbstractNameT;
			return soap_in_ns1__CTEAbstractNameT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEAbstractMacT"))
		{	*type = SOAP_TYPE_ns1__CTEAbstractMacT;
			return soap_in_ns1__CTEAbstractMacT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTECustomerT"))
		{	*type = SOAP_TYPE_ArrayOfCTECustomerT;
			return soap_in_ArrayOfCTECustomerT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTECustomerT"))
		{	*type = SOAP_TYPE_ns1__CTECustomerT;
			return soap_in_ns1__CTECustomerT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmPerformanceHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfCmPerformanceHistoryT;
			return soap_in_ArrayOfCmPerformanceHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmCurrentPerformanceT"))
		{	*type = SOAP_TYPE_ns1__CmCurrentPerformanceT;
			return soap_in_ns1__CmCurrentPerformanceT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmPerformanceHistoryT"))
		{	*type = SOAP_TYPE_ns1__CmPerformanceHistoryT;
			return soap_in_ns1__CmPerformanceHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmPerformanceT"))
		{	*type = SOAP_TYPE_ns1__CmPerformanceT;
			return soap_in_ns1__CmPerformanceT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaPingStatusHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaPingStatusHistoryT;
			return soap_in_ArrayOfMtaPingStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaPingStatusHistoryT"))
		{	*type = SOAP_TYPE_ns1__MtaPingStatusHistoryT;
			return soap_in_ns1__MtaPingStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaPingStatusT"))
		{	*type = SOAP_TYPE_ns1__MtaPingStatusT;
			return soap_in_ns1__MtaPingStatusT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaProvStatusHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaProvStatusHistoryT;
			return soap_in_ArrayOfMtaProvStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaProvStatusHistoryT"))
		{	*type = SOAP_TYPE_ns1__MtaProvStatusHistoryT;
			return soap_in_ns1__MtaProvStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaProvStatusT"))
		{	*type = SOAP_TYPE_ns1__MtaProvStatusT;
			return soap_in_ns1__MtaProvStatusT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaAvailabilityHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT;
			return soap_in_ArrayOfMtaAvailabilityHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaAvailabilityHistoryT"))
		{	*type = SOAP_TYPE_ns1__MtaAvailabilityHistoryT;
			return soap_in_ns1__MtaAvailabilityHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaAvailabilityT"))
		{	*type = SOAP_TYPE_ns1__MtaAvailabilityT;
			return soap_in_ns1__MtaAvailabilityT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmStatusHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfCmStatusHistoryT;
			return soap_in_ArrayOfCmStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusHistoryT"))
		{	*type = SOAP_TYPE_ns1__CmStatusHistoryT;
			return soap_in_ns1__CmStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusT"))
		{	*type = SOAP_TYPE_ns1__CmStatusT;
			return soap_in_ns1__CmStatusT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:GenericCountsHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfGenericCountsHistoryT;
			return soap_in_ArrayOfGenericCountsHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericCountsHistoryT"))
		{	*type = SOAP_TYPE_ns1__GenericCountsHistoryT;
			return soap_in_ns1__GenericCountsHistoryT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:QueryStateT"))
		{	*type = SOAP_TYPE_ArrayOfQueryStateT;
			return soap_in_ArrayOfQueryStateT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryStateT"))
		{	*type = SOAP_TYPE_ns1__QueryStateT;
			return soap_in_ns1__QueryStateT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ScrollPageT"))
		{	*type = SOAP_TYPE_ArrayOfScrollPageT;
			return soap_in_ArrayOfScrollPageT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScrollPageT"))
		{	*type = SOAP_TYPE_ns1__ScrollPageT;
			return soap_in_ns1__ScrollPageT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MappedEuDevicesT"))
		{	*type = SOAP_TYPE_ns1__MappedEuDevicesT;
			return soap_in_ns1__MappedEuDevicesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AlarmHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfAlarmHistoriesT;
			return soap_in_ArrayOfAlarmHistoriesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:HistoricalAlarmT"))
		{	*type = SOAP_TYPE_ArrayOfHistoricalAlarmsT;
			return soap_in_ArrayOfHistoricalAlarmsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CurrentAlarmT"))
		{	*type = SOAP_TYPE_ArrayOfCurrentAlarmsT;
			return soap_in_ArrayOfCurrentAlarmsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:EmtaT"))
		{	*type = SOAP_TYPE_ArrayOfEmtasT;
			return soap_in_ArrayOfEmtasT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CableModemT"))
		{	*type = SOAP_TYPE_ArrayOfCableModemsT;
			return soap_in_ArrayOfCableModemsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:HfcT"))
		{	*type = SOAP_TYPE_ArrayOfHfcsT;
			return soap_in_ArrayOfHfcsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ChannelT"))
		{	*type = SOAP_TYPE_ArrayOfChannelsT;
			return soap_in_ArrayOfChannelsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:SnmpV2CAttributesT"))
		{	*type = SOAP_TYPE_ArrayOfSnmpV2CAttributesT;
			return soap_in_ArrayOfSnmpV2CAttributesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmtsT"))
		{	*type = SOAP_TYPE_ArrayOfCmtsesT;
			return soap_in_ArrayOfCmtsesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmsT"))
		{	*type = SOAP_TYPE_ArrayOfCmsesT;
			return soap_in_ArrayOfCmsesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:BladeT"))
		{	*type = SOAP_TYPE_ArrayOfBladesT;
			return soap_in_ArrayOfBladesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MarketT"))
		{	*type = SOAP_TYPE_ArrayOfMarketsT;
			return soap_in_ArrayOfMarketsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:RegionT"))
		{	*type = SOAP_TYPE_ArrayOfRegionsT;
			return soap_in_ArrayOfRegionsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmHistoryT"))
		{	*type = SOAP_TYPE_ns1__AlarmHistoryT;
			return soap_in_ns1__AlarmHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistoricalAlarmDetailsT"))
		{	*type = SOAP_TYPE_ns1__HistoricalAlarmDetailsT;
			return soap_in_ns1__HistoricalAlarmDetailsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistoricalAlarmT"))
		{	*type = SOAP_TYPE_ns1__HistoricalAlarmT;
			return soap_in_ns1__HistoricalAlarmT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CurrentAlarmDetailsT"))
		{	*type = SOAP_TYPE_ns1__CurrentAlarmDetailsT;
			return soap_in_ns1__CurrentAlarmDetailsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CurrentAlarmT"))
		{	*type = SOAP_TYPE_ns1__CurrentAlarmT;
			return soap_in_ns1__CurrentAlarmT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AbstractAlarmT"))
		{	*type = SOAP_TYPE_ns1__AbstractAlarmT;
			return soap_in_ns1__AbstractAlarmT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EmtaT"))
		{	*type = SOAP_TYPE_ns1__EmtaT;
			return soap_in_ns1__EmtaT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CableModemT"))
		{	*type = SOAP_TYPE_ns1__CableModemT;
			return soap_in_ns1__CableModemT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcT"))
		{	*type = SOAP_TYPE_ns1__HfcT;
			return soap_in_ns1__HfcT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChannelT"))
		{	*type = SOAP_TYPE_ns1__ChannelT;
			return soap_in_ns1__ChannelT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsT"))
		{	*type = SOAP_TYPE_ns1__CmtsT;
			return soap_in_ns1__CmtsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmsT"))
		{	*type = SOAP_TYPE_ns1__CmsT;
			return soap_in_ns1__CmsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BladeT"))
		{	*type = SOAP_TYPE_ns1__BladeT;
			return soap_in_ns1__BladeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketT"))
		{	*type = SOAP_TYPE_ns1__MarketT;
			return soap_in_ns1__MarketT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegionT"))
		{	*type = SOAP_TYPE_ns1__RegionT;
			return soap_in_ns1__RegionT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LocalSystemT"))
		{	*type = SOAP_TYPE_ns1__LocalSystemT;
			return soap_in_ns1__LocalSystemT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TopoHierarchyKeyT"))
		{	*type = SOAP_TYPE_ns1__TopoHierarchyKeyT;
			return soap_in_ns1__TopoHierarchyKeyT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResultBatchT"))
		{	*type = SOAP_TYPE_ns1__ResultBatchT;
			return soap_in_ns1__ResultBatchT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InputTimeT"))
		{	*type = SOAP_TYPE_ns1__InputTimeT;
			return soap_in_ns1__InputTimeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericCountsT"))
		{	*type = SOAP_TYPE_ns1__GenericCountsT;
			return soap_in_ns1__GenericCountsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnmpV2CAttributesT"))
		{	*type = SOAP_TYPE_ns1__SnmpV2CAttributesT;
			return soap_in_ns1__SnmpV2CAttributesT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cte:getCteData"))
		{	*type = SOAP_TYPE_cte__getCteData;
			return soap_in_cte__getCteData(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "cte:getCteDataResponse"))
		{	*type = SOAP_TYPE_cte__getCteDataResponse;
			return soap_in_cte__getCteDataResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "SOAP-ENC:arrayType"))
		{	*type = SOAP_TYPE__SOAP_ENC__arrayType;
			return soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns1__ApplicationDomainTypeT:
		return soap_out_ns1__ApplicationDomainTypeT(soap, tag, id, (const enum ns1__ApplicationDomainTypeT *)ptr, "ns1:ApplicationDomainTypeT");
	case SOAP_TYPE_ns1__UserAccessTypeT:
		return soap_out_ns1__UserAccessTypeT(soap, tag, id, (const enum ns1__UserAccessTypeT *)ptr, "ns1:UserAccessTypeT");
	case SOAP_TYPE_ns1__EndUserDeviceTypeT:
		return soap_out_ns1__EndUserDeviceTypeT(soap, tag, id, (const enum ns1__EndUserDeviceTypeT *)ptr, "ns1:EndUserDeviceTypeT");
	case SOAP_TYPE_ns1__ChannelTypeT:
		return soap_out_ns1__ChannelTypeT(soap, tag, id, (const enum ns1__ChannelTypeT *)ptr, "ns1:ChannelTypeT");
	case SOAP_TYPE_ns1__SnmpVersionT:
		return soap_out_ns1__SnmpVersionT(soap, tag, id, (const enum ns1__SnmpVersionT *)ptr, "ns1:SnmpVersionT");
	case SOAP_TYPE_ns1__StatusColorT:
		return soap_out_ns1__StatusColorT(soap, tag, id, (const enum ns1__StatusColorT *)ptr, "ns1:StatusColorT");
	case SOAP_TYPE_ns1__ResourceTypeT:
		return soap_out_ns1__ResourceTypeT(soap, tag, id, (const enum ns1__ResourceTypeT *)ptr, "ns1:ResourceTypeT");
	case SOAP_TYPE_ns1__SystemTypeT:
		return soap_out_ns1__SystemTypeT(soap, tag, id, (const enum ns1__SystemTypeT *)ptr, "ns1:SystemTypeT");
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		return ((ns1__HistoricalAlarmsRespT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmsRespT");
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		return ((ns1__CurrentAlarmsRespT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmsRespT");
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		return ((ns1__CmStatusSummaryRespT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusSummaryRespT");
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		return ((ns1__HfcStatusSummaryRespT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusSummaryRespT");
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		return ((ns1__MtaStatusSummaryRespT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusSummaryRespT");
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		return ((ArrayOfCmStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		return ((ns1__CmStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		return ((ArrayOfMtaStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		return ((ns1__MtaStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		return ((ArrayOfHfcStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		return ((ns1__HfcStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__StatusSummaryT:
		return ((ns1__StatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:StatusSummaryT");
	case SOAP_TYPE_ns1__MtaDataT:
		return ((ns1__MtaDataT *)ptr)->soap_out(soap, tag, id, "ns1:MtaDataT");
	case SOAP_TYPE_ns1__CmDataT:
		return ((ns1__CmDataT *)ptr)->soap_out(soap, tag, id, "ns1:CmDataT");
	case SOAP_TYPE_ns1__CmtsCmDataT:
		return ((ns1__CmtsCmDataT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsCmDataT");
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		return ((ns1__CmPerformanceConfigT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceConfigT");
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		return ((ns1__CmsAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:CmsAlarmConfigT");
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		return ((ns1__CmtsAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsAlarmConfigT");
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		return ((ns1__MtaAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAlarmConfigT");
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		return ((ArrayOfAlarmTypeConfigT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		return ((ns1__AlarmTypeConfigT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		return ((ns1__HfcAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:HfcAlarmConfigT");
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		return ((ns1__HfcPowerTresholdT *)ptr)->soap_out(soap, tag, id, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		return ((ns1__AggregateMtaTresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		return ((ns1__AggregateCmOfflineTresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_ns1__SoakWindowT:
		return ((ns1__SoakWindowT *)ptr)->soap_out(soap, tag, id, "ns1:SoakWindowT");
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		return ((ns1__CmsStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:CmsStatusThresholdT");
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		return ((ns1__CmtsStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsStatusThresholdT");
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		return ((ns1__ChannelStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:ChannelStatusThresholdT");
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		return ((ns1__HfcStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusThresholdT");
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		return ((ns1__MtaStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusThresholdT");
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		return ((ArrayOfAggregateStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		return ((ns1__AggregateStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		return ((ArrayOfAlarmStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		return ((ns1__AlarmBasedStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__PollingIntervalsT:
		return ((ns1__PollingIntervalsT *)ptr)->soap_out(soap, tag, id, "ns1:PollingIntervalsT");
	case SOAP_TYPE_ns1__UserAccessPrivilegesT:
		return ((ns1__UserAccessPrivilegesT *)ptr)->soap_out(soap, tag, id, "ns1:UserAccessPrivilegesT");
	case SOAP_TYPE_ArrayOfUserT:
		return ((ArrayOfUserT *)ptr)->soap_out(soap, tag, id, "ns1:UserT");
	case SOAP_TYPE_ns1__UserT:
		return ((ns1__UserT *)ptr)->soap_out(soap, tag, id, "ns1:UserT");
	case SOAP_TYPE_ArrayOfUserRoleT:
		return ((ArrayOfUserRoleT *)ptr)->soap_out(soap, tag, id, "ns1:UserRoleT");
	case SOAP_TYPE_ns1__RoleOAPairT:
		return ((ns1__RoleOAPairT *)ptr)->soap_out(soap, tag, id, "ns1:RoleOAPairT");
	case SOAP_TYPE_ns1__UserRoleT:
		return ((ns1__UserRoleT *)ptr)->soap_out(soap, tag, id, "ns1:UserRoleT");
	case SOAP_TYPE_ArrayOfOAPairT:
		return ((ArrayOfOAPairT *)ptr)->soap_out(soap, tag, id, "ns1:OAPairT");
	case SOAP_TYPE_ns1__OAPairT:
		return ((ns1__OAPairT *)ptr)->soap_out(soap, tag, id, "ns1:OAPairT");
	case SOAP_TYPE_ns1__CMSResultT:
		return ((ns1__CMSResultT *)ptr)->soap_out(soap, tag, id, "ns1:CMSResultT");
	case SOAP_TYPE_ArrayOfCMSLineT:
		return ((ArrayOfCMSLineT *)ptr)->soap_out(soap, tag, id, "ns1:CMSLineT");
	case SOAP_TYPE_ns1__CMSLineT:
		return ((ns1__CMSLineT *)ptr)->soap_out(soap, tag, id, "ns1:CMSLineT");
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		return ((ArrayOfCTEQueryInputT *)ptr)->soap_out(soap, tag, id, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ns1__CTEQueryInputT:
		return ((ns1__CTEQueryInputT *)ptr)->soap_out(soap, tag, id, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ArrayOfCTEDataT:
		return ((ArrayOfCTEDataT *)ptr)->soap_out(soap, tag, id, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEDataT:
		return ((ns1__CTEDataT *)ptr)->soap_out(soap, tag, id, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		return ((ns1__CTEAbstractNameT *)ptr)->soap_out(soap, tag, id, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		return ((ns1__CTEAbstractMacT *)ptr)->soap_out(soap, tag, id, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_ArrayOfCTECustomerT:
		return ((ArrayOfCTECustomerT *)ptr)->soap_out(soap, tag, id, "ns1:CTECustomerT");
	case SOAP_TYPE_ns1__CTECustomerT:
		return ((ns1__CTECustomerT *)ptr)->soap_out(soap, tag, id, "ns1:CTECustomerT");
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		return ((ArrayOfCmPerformanceHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		return ((ns1__CmCurrentPerformanceT *)ptr)->soap_out(soap, tag, id, "ns1:CmCurrentPerformanceT");
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		return ((ns1__CmPerformanceHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmPerformanceT:
		return ((ns1__CmPerformanceT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceT");
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		return ((ArrayOfMtaPingStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		return ((ns1__MtaPingStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusT:
		return ((ns1__MtaPingStatusT *)ptr)->soap_out(soap, tag, id, "ns1:MtaPingStatusT");
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		return ((ArrayOfMtaProvStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		return ((ns1__MtaProvStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusT:
		return ((ns1__MtaProvStatusT *)ptr)->soap_out(soap, tag, id, "ns1:MtaProvStatusT");
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		return ((ArrayOfMtaAvailabilityHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		return ((ns1__MtaAvailabilityHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		return ((ns1__MtaAvailabilityT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		return ((ArrayOfCmStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		return ((ns1__CmStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusT:
		return ((ns1__CmStatusT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusT");
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		return ((ArrayOfGenericCountsHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		return ((ns1__GenericCountsHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ArrayOfQueryStateT:
		return ((ArrayOfQueryStateT *)ptr)->soap_out(soap, tag, id, "ns1:QueryStateT");
	case SOAP_TYPE_ns1__QueryStateT:
		return ((ns1__QueryStateT *)ptr)->soap_out(soap, tag, id, "ns1:QueryStateT");
	case SOAP_TYPE_ArrayOfScrollPageT:
		return ((ArrayOfScrollPageT *)ptr)->soap_out(soap, tag, id, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__ScrollPageT:
		return ((ns1__ScrollPageT *)ptr)->soap_out(soap, tag, id, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		return ((ns1__MappedEuDevicesT *)ptr)->soap_out(soap, tag, id, "ns1:MappedEuDevicesT");
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		return ((ArrayOfAlarmHistoriesT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		return ((ArrayOfHistoricalAlarmsT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		return ((ArrayOfCurrentAlarmsT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ArrayOfEmtasT:
		return ((ArrayOfEmtasT *)ptr)->soap_out(soap, tag, id, "ns1:EmtaT");
	case SOAP_TYPE_ArrayOfCableModemsT:
		return ((ArrayOfCableModemsT *)ptr)->soap_out(soap, tag, id, "ns1:CableModemT");
	case SOAP_TYPE_ArrayOfHfcsT:
		return ((ArrayOfHfcsT *)ptr)->soap_out(soap, tag, id, "ns1:HfcT");
	case SOAP_TYPE_ArrayOfChannelsT:
		return ((ArrayOfChannelsT *)ptr)->soap_out(soap, tag, id, "ns1:ChannelT");
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		return ((ArrayOfSnmpV2CAttributesT *)ptr)->soap_out(soap, tag, id, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_ArrayOfCmtsesT:
		return ((ArrayOfCmtsesT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsT");
	case SOAP_TYPE_ArrayOfCmsesT:
		return ((ArrayOfCmsesT *)ptr)->soap_out(soap, tag, id, "ns1:CmsT");
	case SOAP_TYPE_ArrayOfBladesT:
		return ((ArrayOfBladesT *)ptr)->soap_out(soap, tag, id, "ns1:BladeT");
	case SOAP_TYPE_ArrayOfMarketsT:
		return ((ArrayOfMarketsT *)ptr)->soap_out(soap, tag, id, "ns1:MarketT");
	case SOAP_TYPE_ArrayOfRegionsT:
		return ((ArrayOfRegionsT *)ptr)->soap_out(soap, tag, id, "ns1:RegionT");
	case SOAP_TYPE_ns1__AlarmHistoryT:
		return ((ns1__AlarmHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		return ((ns1__HistoricalAlarmDetailsT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmDetailsT");
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		return ((ns1__HistoricalAlarmT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		return ((ns1__CurrentAlarmDetailsT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmDetailsT");
	case SOAP_TYPE_ns1__CurrentAlarmT:
		return ((ns1__CurrentAlarmT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ns1__AbstractAlarmT:
		return ((ns1__AbstractAlarmT *)ptr)->soap_out(soap, tag, id, "ns1:AbstractAlarmT");
	case SOAP_TYPE_ns1__EmtaT:
		return ((ns1__EmtaT *)ptr)->soap_out(soap, tag, id, "ns1:EmtaT");
	case SOAP_TYPE_ns1__CableModemT:
		return ((ns1__CableModemT *)ptr)->soap_out(soap, tag, id, "ns1:CableModemT");
	case SOAP_TYPE_ns1__HfcT:
		return ((ns1__HfcT *)ptr)->soap_out(soap, tag, id, "ns1:HfcT");
	case SOAP_TYPE_ns1__ChannelT:
		return ((ns1__ChannelT *)ptr)->soap_out(soap, tag, id, "ns1:ChannelT");
	case SOAP_TYPE_ns1__CmtsT:
		return ((ns1__CmtsT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsT");
	case SOAP_TYPE_ns1__CmsT:
		return ((ns1__CmsT *)ptr)->soap_out(soap, tag, id, "ns1:CmsT");
	case SOAP_TYPE_ns1__BladeT:
		return ((ns1__BladeT *)ptr)->soap_out(soap, tag, id, "ns1:BladeT");
	case SOAP_TYPE_ns1__MarketT:
		return ((ns1__MarketT *)ptr)->soap_out(soap, tag, id, "ns1:MarketT");
	case SOAP_TYPE_ns1__RegionT:
		return ((ns1__RegionT *)ptr)->soap_out(soap, tag, id, "ns1:RegionT");
	case SOAP_TYPE_ns1__LocalSystemT:
		return ((ns1__LocalSystemT *)ptr)->soap_out(soap, tag, id, "ns1:LocalSystemT");
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		return ((ns1__TopoHierarchyKeyT *)ptr)->soap_out(soap, tag, id, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_ns1__ResultBatchT:
		return ((ns1__ResultBatchT *)ptr)->soap_out(soap, tag, id, "ns1:ResultBatchT");
	case SOAP_TYPE_ns1__InputTimeT:
		return ((ns1__InputTimeT *)ptr)->soap_out(soap, tag, id, "ns1:InputTimeT");
	case SOAP_TYPE_ns1__GenericCountsT:
		return ((ns1__GenericCountsT *)ptr)->soap_out(soap, tag, id, "ns1:GenericCountsT");
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		return ((ns1__SnmpV2CAttributesT *)ptr)->soap_out(soap, tag, id, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE__SOAP_ENC__arrayType:
		return soap_out__SOAP_ENC__arrayType(soap, "SOAP-ENC:arrayType", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_cte__getCteData:
		return soap_out_cte__getCteData(soap, tag, id, (const struct cte__getCteData *)ptr, "cte:getCteData");
	case SOAP_TYPE_cte__getCteDataResponse:
		return soap_out_cte__getCteDataResponse(soap, tag, id, (const struct cte__getCteDataResponse *)ptr, "cte:getCteDataResponse");
	case SOAP_TYPE_PointerToArrayOfCTEQueryInputT:
		return soap_out_PointerToArrayOfCTEQueryInputT(soap, tag, id, (ArrayOfCTEQueryInputT *const*)ptr, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerToArrayOfCTEDataT:
		return soap_out_PointerToArrayOfCTEDataT(soap, tag, id, (ArrayOfCTEDataT *const*)ptr, "ns1:CTEDataT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT:
		return soap_out_PointerToPointerTons1__CmStatusSummaryT(soap, tag, id, (ns1__CmStatusSummaryT **const*)ptr, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerTons1__CmStatusSummaryT:
		return soap_out_PointerTons1__CmStatusSummaryT(soap, tag, id, (ns1__CmStatusSummaryT *const*)ptr, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT:
		return soap_out_PointerToPointerTons1__MtaStatusSummaryT(soap, tag, id, (ns1__MtaStatusSummaryT **const*)ptr, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__MtaStatusSummaryT:
		return soap_out_PointerTons1__MtaStatusSummaryT(soap, tag, id, (ns1__MtaStatusSummaryT *const*)ptr, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT:
		return soap_out_PointerToPointerTons1__HfcStatusSummaryT(soap, tag, id, (ns1__HfcStatusSummaryT **const*)ptr, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerTons1__HfcStatusSummaryT:
		return soap_out_PointerTons1__HfcStatusSummaryT(soap, tag, id, (ns1__HfcStatusSummaryT *const*)ptr, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT:
		return soap_out_PointerToPointerTons1__AlarmTypeConfigT(soap, tag, id, (ns1__AlarmTypeConfigT **const*)ptr, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT:
		return soap_out_PointerToPointerTons1__AggregateStatusThresholdT(soap, tag, id, (ns1__AggregateStatusThresholdT **const*)ptr, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AggregateStatusThresholdT:
		return soap_out_PointerTons1__AggregateStatusThresholdT(soap, tag, id, (ns1__AggregateStatusThresholdT *const*)ptr, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT:
		return soap_out_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, (ns1__AlarmBasedStatusThresholdT **const*)ptr, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT:
		return soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, (ns1__AlarmBasedStatusThresholdT *const*)ptr, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__UserT:
		return soap_out_PointerToPointerTons1__UserT(soap, tag, id, (ns1__UserT **const*)ptr, "ns1:UserT");
	case SOAP_TYPE_PointerTons1__UserT:
		return soap_out_PointerTons1__UserT(soap, tag, id, (ns1__UserT *const*)ptr, "ns1:UserT");
	case SOAP_TYPE_PointerToPointerTons1__UserRoleT:
		return soap_out_PointerToPointerTons1__UserRoleT(soap, tag, id, (ns1__UserRoleT **const*)ptr, "ns1:UserRoleT");
	case SOAP_TYPE_PointerToPointerTons1__OAPairT:
		return soap_out_PointerToPointerTons1__OAPairT(soap, tag, id, (ns1__OAPairT **const*)ptr, "ns1:OAPairT");
	case SOAP_TYPE_PointerTons1__OAPairT:
		return soap_out_PointerTons1__OAPairT(soap, tag, id, (ns1__OAPairT *const*)ptr, "ns1:OAPairT");
	case SOAP_TYPE_PointerToPointerTons1__CMSLineT:
		return soap_out_PointerToPointerTons1__CMSLineT(soap, tag, id, (ns1__CMSLineT **const*)ptr, "ns1:CMSLineT");
	case SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT:
		return soap_out_PointerToPointerTons1__CTEQueryInputT(soap, tag, id, (ns1__CTEQueryInputT **const*)ptr, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerTons1__CTEQueryInputT:
		return soap_out_PointerTons1__CTEQueryInputT(soap, tag, id, (ns1__CTEQueryInputT *const*)ptr, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerToPointerTons1__CTEDataT:
		return soap_out_PointerToPointerTons1__CTEDataT(soap, tag, id, (ns1__CTEDataT **const*)ptr, "ns1:CTEDataT");
	case SOAP_TYPE_PointerTons1__CTEDataT:
		return soap_out_PointerTons1__CTEDataT(soap, tag, id, (ns1__CTEDataT *const*)ptr, "ns1:CTEDataT");
	case SOAP_TYPE_PointerToPointerTons1__CTECustomerT:
		return soap_out_PointerToPointerTons1__CTECustomerT(soap, tag, id, (ns1__CTECustomerT **const*)ptr, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT:
		return soap_out_PointerToPointerTons1__CmPerformanceHistoryT(soap, tag, id, (ns1__CmPerformanceHistoryT **const*)ptr, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerTons1__CmPerformanceHistoryT:
		return soap_out_PointerTons1__CmPerformanceHistoryT(soap, tag, id, (ns1__CmPerformanceHistoryT *const*)ptr, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT:
		return soap_out_PointerToPointerTons1__MtaPingStatusHistoryT(soap, tag, id, (ns1__MtaPingStatusHistoryT **const*)ptr, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT:
		return soap_out_PointerTons1__MtaPingStatusHistoryT(soap, tag, id, (ns1__MtaPingStatusHistoryT *const*)ptr, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT:
		return soap_out_PointerToPointerTons1__MtaProvStatusHistoryT(soap, tag, id, (ns1__MtaProvStatusHistoryT **const*)ptr, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT:
		return soap_out_PointerTons1__MtaProvStatusHistoryT(soap, tag, id, (ns1__MtaProvStatusHistoryT *const*)ptr, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT:
		return soap_out_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, tag, id, (ns1__MtaAvailabilityHistoryT **const*)ptr, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT:
		return soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, tag, id, (ns1__MtaAvailabilityHistoryT *const*)ptr, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT:
		return soap_out_PointerToPointerTons1__CmStatusHistoryT(soap, tag, id, (ns1__CmStatusHistoryT **const*)ptr, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerTons1__CmStatusHistoryT:
		return soap_out_PointerTons1__CmStatusHistoryT(soap, tag, id, (ns1__CmStatusHistoryT *const*)ptr, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT:
		return soap_out_PointerToPointerTons1__GenericCountsHistoryT(soap, tag, id, (ns1__GenericCountsHistoryT **const*)ptr, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerTons1__GenericCountsHistoryT:
		return soap_out_PointerTons1__GenericCountsHistoryT(soap, tag, id, (ns1__GenericCountsHistoryT *const*)ptr, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__QueryStateT:
		return soap_out_PointerToPointerTons1__QueryStateT(soap, tag, id, (ns1__QueryStateT **const*)ptr, "ns1:QueryStateT");
	case SOAP_TYPE_PointerTons1__QueryStateT:
		return soap_out_PointerTons1__QueryStateT(soap, tag, id, (ns1__QueryStateT *const*)ptr, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToPointerTons1__ScrollPageT:
		return soap_out_PointerToPointerTons1__ScrollPageT(soap, tag, id, (ns1__ScrollPageT **const*)ptr, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ScrollPageT:
		return soap_out_PointerTons1__ScrollPageT(soap, tag, id, (ns1__ScrollPageT *const*)ptr, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT:
		return soap_out_PointerToPointerTons1__AlarmHistoryT(soap, tag, id, (ns1__AlarmHistoryT **const*)ptr, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerTons1__AlarmHistoryT:
		return soap_out_PointerTons1__AlarmHistoryT(soap, tag, id, (ns1__AlarmHistoryT *const*)ptr, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT:
		return soap_out_PointerToPointerTons1__HistoricalAlarmT(soap, tag, id, (ns1__HistoricalAlarmT **const*)ptr, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT:
		return soap_out_PointerToPointerTons1__CurrentAlarmT(soap, tag, id, (ns1__CurrentAlarmT **const*)ptr, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__EmtaT:
		return soap_out_PointerToPointerTons1__EmtaT(soap, tag, id, (ns1__EmtaT **const*)ptr, "ns1:EmtaT");
	case SOAP_TYPE_PointerToPointerTons1__CableModemT:
		return soap_out_PointerToPointerTons1__CableModemT(soap, tag, id, (ns1__CableModemT **const*)ptr, "ns1:CableModemT");
	case SOAP_TYPE_PointerToPointerTons1__HfcT:
		return soap_out_PointerToPointerTons1__HfcT(soap, tag, id, (ns1__HfcT **const*)ptr, "ns1:HfcT");
	case SOAP_TYPE_PointerTons1__HfcT:
		return soap_out_PointerTons1__HfcT(soap, tag, id, (ns1__HfcT *const*)ptr, "ns1:HfcT");
	case SOAP_TYPE_PointerToPointerTons1__ChannelT:
		return soap_out_PointerToPointerTons1__ChannelT(soap, tag, id, (ns1__ChannelT **const*)ptr, "ns1:ChannelT");
	case SOAP_TYPE_PointerTons1__ChannelT:
		return soap_out_PointerTons1__ChannelT(soap, tag, id, (ns1__ChannelT *const*)ptr, "ns1:ChannelT");
	case SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT:
		return soap_out_PointerToPointerTons1__SnmpV2CAttributesT(soap, tag, id, (ns1__SnmpV2CAttributesT **const*)ptr, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerTons1__SnmpV2CAttributesT:
		return soap_out_PointerTons1__SnmpV2CAttributesT(soap, tag, id, (ns1__SnmpV2CAttributesT *const*)ptr, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerToPointerTons1__CmtsT:
		return soap_out_PointerToPointerTons1__CmtsT(soap, tag, id, (ns1__CmtsT **const*)ptr, "ns1:CmtsT");
	case SOAP_TYPE_PointerTons1__CmtsT:
		return soap_out_PointerTons1__CmtsT(soap, tag, id, (ns1__CmtsT *const*)ptr, "ns1:CmtsT");
	case SOAP_TYPE_PointerToPointerTons1__CmsT:
		return soap_out_PointerToPointerTons1__CmsT(soap, tag, id, (ns1__CmsT **const*)ptr, "ns1:CmsT");
	case SOAP_TYPE_PointerTons1__CmsT:
		return soap_out_PointerTons1__CmsT(soap, tag, id, (ns1__CmsT *const*)ptr, "ns1:CmsT");
	case SOAP_TYPE_PointerToPointerTons1__BladeT:
		return soap_out_PointerToPointerTons1__BladeT(soap, tag, id, (ns1__BladeT **const*)ptr, "ns1:BladeT");
	case SOAP_TYPE_PointerTons1__BladeT:
		return soap_out_PointerTons1__BladeT(soap, tag, id, (ns1__BladeT *const*)ptr, "ns1:BladeT");
	case SOAP_TYPE_PointerToPointerTons1__MarketT:
		return soap_out_PointerToPointerTons1__MarketT(soap, tag, id, (ns1__MarketT **const*)ptr, "ns1:MarketT");
	case SOAP_TYPE_PointerTons1__MarketT:
		return soap_out_PointerTons1__MarketT(soap, tag, id, (ns1__MarketT *const*)ptr, "ns1:MarketT");
	case SOAP_TYPE_PointerToPointerTons1__RegionT:
		return soap_out_PointerToPointerTons1__RegionT(soap, tag, id, (ns1__RegionT **const*)ptr, "ns1:RegionT");
	case SOAP_TYPE_PointerTons1__RegionT:
		return soap_out_PointerTons1__RegionT(soap, tag, id, (ns1__RegionT *const*)ptr, "ns1:RegionT");
	case SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT:
		return soap_out_PointerToArrayOfHistoricalAlarmsT(soap, tag, id, (ArrayOfHistoricalAlarmsT *const*)ptr, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToArrayOfCurrentAlarmsT:
		return soap_out_PointerToArrayOfCurrentAlarmsT(soap, tag, id, (ArrayOfCurrentAlarmsT *const*)ptr, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToArrayOfCmStatusSummaryT:
		return soap_out_PointerToArrayOfCmStatusSummaryT(soap, tag, id, (ArrayOfCmStatusSummaryT *const*)ptr, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT:
		return soap_out_PointerToArrayOfHfcStatusSummaryT(soap, tag, id, (ArrayOfHfcStatusSummaryT *const*)ptr, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfQueryStateT:
		return soap_out_PointerToArrayOfQueryStateT(soap, tag, id, (ArrayOfQueryStateT *const*)ptr, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT:
		return soap_out_PointerToArrayOfMtaStatusSummaryT(soap, tag, id, (ArrayOfMtaStatusSummaryT *const*)ptr, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__StatusSummaryT:
		return soap_out_PointerTons1__StatusSummaryT(soap, tag, id, (ns1__StatusSummaryT *const*)ptr, "ns1:StatusSummaryT");
	case SOAP_TYPE_PointerTons1__AlarmTypeConfigT:
		return soap_out_PointerTons1__AlarmTypeConfigT(soap, tag, id, (ns1__AlarmTypeConfigT *const*)ptr, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT:
		return soap_out_PointerToArrayOfAlarmTypeConfigT(soap, tag, id, (ArrayOfAlarmTypeConfigT *const*)ptr, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerTons1__HfcPowerTresholdT:
		return soap_out_PointerTons1__HfcPowerTresholdT(soap, tag, id, (ns1__HfcPowerTresholdT *const*)ptr, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_PointerTons1__AggregateMtaTresholdT:
		return soap_out_PointerTons1__AggregateMtaTresholdT(soap, tag, id, (ns1__AggregateMtaTresholdT *const*)ptr, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_PointerTons1__SoakWindowT:
		return soap_out_PointerTons1__SoakWindowT(soap, tag, id, (ns1__SoakWindowT *const*)ptr, "ns1:SoakWindowT");
	case SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT:
		return soap_out_PointerTons1__AggregateCmOfflineTresholdT(soap, tag, id, (ns1__AggregateCmOfflineTresholdT *const*)ptr, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT:
		return soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, tag, id, (ArrayOfAggregateStatusThresholdT *const*)ptr, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT:
		return soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, tag, id, (ArrayOfAlarmStatusThresholdT *const*)ptr, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerTons1__UserRoleT:
		return soap_out_PointerTons1__UserRoleT(soap, tag, id, (ns1__UserRoleT *const*)ptr, "ns1:UserRoleT");
	case SOAP_TYPE_PointerToArrayOfOAPairT:
		return soap_out_PointerToArrayOfOAPairT(soap, tag, id, (ArrayOfOAPairT *const*)ptr, "ns1:OAPairT");
	case SOAP_TYPE_PointerTons1__CMSLineT:
		return soap_out_PointerTons1__CMSLineT(soap, tag, id, (ns1__CMSLineT *const*)ptr, "ns1:CMSLineT");
	case SOAP_TYPE_PointerTons1__CTEAbstractNameT:
		return soap_out_PointerTons1__CTEAbstractNameT(soap, tag, id, (ns1__CTEAbstractNameT *const*)ptr, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_PointerTons1__CTEAbstractMacT:
		return soap_out_PointerTons1__CTEAbstractMacT(soap, tag, id, (ns1__CTEAbstractMacT *const*)ptr, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_PointerTons1__CTECustomerT:
		return soap_out_PointerTons1__CTECustomerT(soap, tag, id, (ns1__CTECustomerT *const*)ptr, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToshort:
		return soap_out_PointerToshort(soap, tag, id, (short *const*)ptr, "xsd:short");
	case SOAP_TYPE_PointerTons1__CmPerformanceT:
		return soap_out_PointerTons1__CmPerformanceT(soap, tag, id, (ns1__CmPerformanceT *const*)ptr, "ns1:CmPerformanceT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusT:
		return soap_out_PointerTons1__MtaPingStatusT(soap, tag, id, (ns1__MtaPingStatusT *const*)ptr, "ns1:MtaPingStatusT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusT:
		return soap_out_PointerTons1__MtaProvStatusT(soap, tag, id, (ns1__MtaProvStatusT *const*)ptr, "ns1:MtaProvStatusT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityT:
		return soap_out_PointerTons1__MtaAvailabilityT(soap, tag, id, (ns1__MtaAvailabilityT *const*)ptr, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_PointerTons1__CmStatusT:
		return soap_out_PointerTons1__CmStatusT(soap, tag, id, (ns1__CmStatusT *const*)ptr, "ns1:CmStatusT");
	case SOAP_TYPE_PointerToArrayOfScrollPageT:
		return soap_out_PointerToArrayOfScrollPageT(soap, tag, id, (ArrayOfScrollPageT *const*)ptr, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ResultBatchT:
		return soap_out_PointerTons1__ResultBatchT(soap, tag, id, (ns1__ResultBatchT *const*)ptr, "ns1:ResultBatchT");
	case SOAP_TYPE_PointerTons1__EmtaT:
		return soap_out_PointerTons1__EmtaT(soap, tag, id, (ns1__EmtaT *const*)ptr, "ns1:EmtaT");
	case SOAP_TYPE_PointerTons1__CableModemT:
		return soap_out_PointerTons1__CableModemT(soap, tag, id, (ns1__CableModemT *const*)ptr, "ns1:CableModemT");
	case SOAP_TYPE_PointerTons1__HistoricalAlarmT:
		return soap_out_PointerTons1__HistoricalAlarmT(soap, tag, id, (ns1__HistoricalAlarmT *const*)ptr, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerTons1__CurrentAlarmT:
		return soap_out_PointerTons1__CurrentAlarmT(soap, tag, id, (ns1__CurrentAlarmT *const*)ptr, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerTons1__AbstractAlarmT:
		return soap_out_PointerTons1__AbstractAlarmT(soap, tag, id, (ns1__AbstractAlarmT *const*)ptr, "ns1:AbstractAlarmT");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::string *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTons1__GenericCountsT:
		return soap_out_PointerTons1__GenericCountsT(soap, tag, id, (ns1__GenericCountsT *const*)ptr, "ns1:GenericCountsT");
	case SOAP_TYPE_PointerTons1__TopoHierarchyKeyT:
		return soap_out_PointerTons1__TopoHierarchyKeyT(soap, tag, id, (ns1__TopoHierarchyKeyT *const*)ptr, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		((ns1__HistoricalAlarmsRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		((ns1__CurrentAlarmsRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		((ns1__CmStatusSummaryRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		((ns1__HfcStatusSummaryRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		((ns1__MtaStatusSummaryRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		((ArrayOfCmStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		((ns1__CmStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		((ArrayOfMtaStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		((ns1__MtaStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		((ArrayOfHfcStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		((ns1__HfcStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StatusSummaryT:
		((ns1__StatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaDataT:
		((ns1__MtaDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmDataT:
		((ns1__CmDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsCmDataT:
		((ns1__CmtsCmDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		((ns1__CmPerformanceConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		((ns1__CmsAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		((ns1__CmtsAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		((ns1__MtaAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		((ArrayOfAlarmTypeConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		((ns1__AlarmTypeConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		((ns1__HfcAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		((ns1__HfcPowerTresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		((ns1__AggregateMtaTresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		((ns1__AggregateCmOfflineTresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoakWindowT:
		((ns1__SoakWindowT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		((ns1__CmsStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		((ns1__CmtsStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		((ns1__ChannelStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		((ns1__HfcStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		((ns1__MtaStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		((ArrayOfAggregateStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		((ns1__AggregateStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		((ArrayOfAlarmStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		((ns1__AlarmBasedStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PollingIntervalsT:
		((ns1__PollingIntervalsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserAccessPrivilegesT:
		((ns1__UserAccessPrivilegesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfUserT:
		((ArrayOfUserT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserT:
		((ns1__UserT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfUserRoleT:
		((ArrayOfUserRoleT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RoleOAPairT:
		((ns1__RoleOAPairT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserRoleT:
		((ns1__UserRoleT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfOAPairT:
		((ArrayOfOAPairT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__OAPairT:
		((ns1__OAPairT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CMSResultT:
		((ns1__CMSResultT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCMSLineT:
		((ArrayOfCMSLineT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CMSLineT:
		((ns1__CMSLineT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		((ArrayOfCTEQueryInputT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEQueryInputT:
		((ns1__CTEQueryInputT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTEDataT:
		((ArrayOfCTEDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEDataT:
		((ns1__CTEDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		((ns1__CTEAbstractNameT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		((ns1__CTEAbstractMacT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTECustomerT:
		((ArrayOfCTECustomerT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTECustomerT:
		((ns1__CTECustomerT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		((ArrayOfCmPerformanceHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		((ns1__CmCurrentPerformanceT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		((ns1__CmPerformanceHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmPerformanceT:
		((ns1__CmPerformanceT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		((ArrayOfMtaPingStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		((ns1__MtaPingStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaPingStatusT:
		((ns1__MtaPingStatusT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		((ArrayOfMtaProvStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		((ns1__MtaProvStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaProvStatusT:
		((ns1__MtaProvStatusT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		((ArrayOfMtaAvailabilityHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		((ns1__MtaAvailabilityHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		((ns1__MtaAvailabilityT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		((ArrayOfCmStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		((ns1__CmStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusT:
		((ns1__CmStatusT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		((ArrayOfGenericCountsHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		((ns1__GenericCountsHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfQueryStateT:
		((ArrayOfQueryStateT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QueryStateT:
		((ns1__QueryStateT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfScrollPageT:
		((ArrayOfScrollPageT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScrollPageT:
		((ns1__ScrollPageT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		((ns1__MappedEuDevicesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		((ArrayOfAlarmHistoriesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		((ArrayOfHistoricalAlarmsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		((ArrayOfCurrentAlarmsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfEmtasT:
		((ArrayOfEmtasT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCableModemsT:
		((ArrayOfCableModemsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfHfcsT:
		((ArrayOfHfcsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfChannelsT:
		((ArrayOfChannelsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		((ArrayOfSnmpV2CAttributesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmtsesT:
		((ArrayOfCmtsesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmsesT:
		((ArrayOfCmsesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfBladesT:
		((ArrayOfBladesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMarketsT:
		((ArrayOfMarketsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfRegionsT:
		((ArrayOfRegionsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AlarmHistoryT:
		((ns1__AlarmHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		((ns1__HistoricalAlarmDetailsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		((ns1__HistoricalAlarmT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		((ns1__CurrentAlarmDetailsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CurrentAlarmT:
		((ns1__CurrentAlarmT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AbstractAlarmT:
		((ns1__AbstractAlarmT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EmtaT:
		((ns1__EmtaT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CableModemT:
		((ns1__CableModemT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcT:
		((ns1__HfcT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChannelT:
		((ns1__ChannelT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsT:
		((ns1__CmtsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmsT:
		((ns1__CmsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BladeT:
		((ns1__BladeT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MarketT:
		((ns1__MarketT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RegionT:
		((ns1__RegionT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LocalSystemT:
		((ns1__LocalSystemT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		((ns1__TopoHierarchyKeyT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ResultBatchT:
		((ns1__ResultBatchT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InputTimeT:
		((ns1__InputTimeT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericCountsT:
		((ns1__GenericCountsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		((ns1__SnmpV2CAttributesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__SOAP_ENC__arrayType:
		soap_serialize__SOAP_ENC__arrayType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_cte__getCteData:
		soap_serialize_cte__getCteData(soap, (const struct cte__getCteData *)ptr);
		break;
	case SOAP_TYPE_cte__getCteDataResponse:
		soap_serialize_cte__getCteDataResponse(soap, (const struct cte__getCteDataResponse *)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCTEQueryInputT:
		soap_serialize_PointerToArrayOfCTEQueryInputT(soap, (ArrayOfCTEQueryInputT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCTEDataT:
		soap_serialize_PointerToArrayOfCTEDataT(soap, (ArrayOfCTEDataT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT:
		soap_serialize_PointerToPointerTons1__CmStatusSummaryT(soap, (ns1__CmStatusSummaryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmStatusSummaryT:
		soap_serialize_PointerTons1__CmStatusSummaryT(soap, (ns1__CmStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT:
		soap_serialize_PointerToPointerTons1__MtaStatusSummaryT(soap, (ns1__MtaStatusSummaryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaStatusSummaryT:
		soap_serialize_PointerTons1__MtaStatusSummaryT(soap, (ns1__MtaStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT:
		soap_serialize_PointerToPointerTons1__HfcStatusSummaryT(soap, (ns1__HfcStatusSummaryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcStatusSummaryT:
		soap_serialize_PointerTons1__HfcStatusSummaryT(soap, (ns1__HfcStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT:
		soap_serialize_PointerToPointerTons1__AlarmTypeConfigT(soap, (ns1__AlarmTypeConfigT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT:
		soap_serialize_PointerToPointerTons1__AggregateStatusThresholdT(soap, (ns1__AggregateStatusThresholdT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AggregateStatusThresholdT:
		soap_serialize_PointerTons1__AggregateStatusThresholdT(soap, (ns1__AggregateStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT:
		soap_serialize_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, (ns1__AlarmBasedStatusThresholdT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT:
		soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(soap, (ns1__AlarmBasedStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UserT:
		soap_serialize_PointerToPointerTons1__UserT(soap, (ns1__UserT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserT:
		soap_serialize_PointerTons1__UserT(soap, (ns1__UserT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UserRoleT:
		soap_serialize_PointerToPointerTons1__UserRoleT(soap, (ns1__UserRoleT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__OAPairT:
		soap_serialize_PointerToPointerTons1__OAPairT(soap, (ns1__OAPairT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__OAPairT:
		soap_serialize_PointerTons1__OAPairT(soap, (ns1__OAPairT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CMSLineT:
		soap_serialize_PointerToPointerTons1__CMSLineT(soap, (ns1__CMSLineT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT:
		soap_serialize_PointerToPointerTons1__CTEQueryInputT(soap, (ns1__CTEQueryInputT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEQueryInputT:
		soap_serialize_PointerTons1__CTEQueryInputT(soap, (ns1__CTEQueryInputT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTEDataT:
		soap_serialize_PointerToPointerTons1__CTEDataT(soap, (ns1__CTEDataT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEDataT:
		soap_serialize_PointerTons1__CTEDataT(soap, (ns1__CTEDataT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTECustomerT:
		soap_serialize_PointerToPointerTons1__CTECustomerT(soap, (ns1__CTECustomerT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT:
		soap_serialize_PointerToPointerTons1__CmPerformanceHistoryT(soap, (ns1__CmPerformanceHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmPerformanceHistoryT:
		soap_serialize_PointerTons1__CmPerformanceHistoryT(soap, (ns1__CmPerformanceHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT:
		soap_serialize_PointerToPointerTons1__MtaPingStatusHistoryT(soap, (ns1__MtaPingStatusHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT:
		soap_serialize_PointerTons1__MtaPingStatusHistoryT(soap, (ns1__MtaPingStatusHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT:
		soap_serialize_PointerToPointerTons1__MtaProvStatusHistoryT(soap, (ns1__MtaProvStatusHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT:
		soap_serialize_PointerTons1__MtaProvStatusHistoryT(soap, (ns1__MtaProvStatusHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT:
		soap_serialize_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, (ns1__MtaAvailabilityHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT:
		soap_serialize_PointerTons1__MtaAvailabilityHistoryT(soap, (ns1__MtaAvailabilityHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT:
		soap_serialize_PointerToPointerTons1__CmStatusHistoryT(soap, (ns1__CmStatusHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmStatusHistoryT:
		soap_serialize_PointerTons1__CmStatusHistoryT(soap, (ns1__CmStatusHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT:
		soap_serialize_PointerToPointerTons1__GenericCountsHistoryT(soap, (ns1__GenericCountsHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericCountsHistoryT:
		soap_serialize_PointerTons1__GenericCountsHistoryT(soap, (ns1__GenericCountsHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__QueryStateT:
		soap_serialize_PointerToPointerTons1__QueryStateT(soap, (ns1__QueryStateT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QueryStateT:
		soap_serialize_PointerTons1__QueryStateT(soap, (ns1__QueryStateT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ScrollPageT:
		soap_serialize_PointerToPointerTons1__ScrollPageT(soap, (ns1__ScrollPageT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScrollPageT:
		soap_serialize_PointerTons1__ScrollPageT(soap, (ns1__ScrollPageT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT:
		soap_serialize_PointerToPointerTons1__AlarmHistoryT(soap, (ns1__AlarmHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AlarmHistoryT:
		soap_serialize_PointerTons1__AlarmHistoryT(soap, (ns1__AlarmHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT:
		soap_serialize_PointerToPointerTons1__HistoricalAlarmT(soap, (ns1__HistoricalAlarmT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT:
		soap_serialize_PointerToPointerTons1__CurrentAlarmT(soap, (ns1__CurrentAlarmT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__EmtaT:
		soap_serialize_PointerToPointerTons1__EmtaT(soap, (ns1__EmtaT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CableModemT:
		soap_serialize_PointerToPointerTons1__CableModemT(soap, (ns1__CableModemT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__HfcT:
		soap_serialize_PointerToPointerTons1__HfcT(soap, (ns1__HfcT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcT:
		soap_serialize_PointerTons1__HfcT(soap, (ns1__HfcT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ChannelT:
		soap_serialize_PointerToPointerTons1__ChannelT(soap, (ns1__ChannelT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChannelT:
		soap_serialize_PointerTons1__ChannelT(soap, (ns1__ChannelT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT:
		soap_serialize_PointerToPointerTons1__SnmpV2CAttributesT(soap, (ns1__SnmpV2CAttributesT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnmpV2CAttributesT:
		soap_serialize_PointerTons1__SnmpV2CAttributesT(soap, (ns1__SnmpV2CAttributesT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmtsT:
		soap_serialize_PointerToPointerTons1__CmtsT(soap, (ns1__CmtsT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmtsT:
		soap_serialize_PointerTons1__CmtsT(soap, (ns1__CmtsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmsT:
		soap_serialize_PointerToPointerTons1__CmsT(soap, (ns1__CmsT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmsT:
		soap_serialize_PointerTons1__CmsT(soap, (ns1__CmsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__BladeT:
		soap_serialize_PointerToPointerTons1__BladeT(soap, (ns1__BladeT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BladeT:
		soap_serialize_PointerTons1__BladeT(soap, (ns1__BladeT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MarketT:
		soap_serialize_PointerToPointerTons1__MarketT(soap, (ns1__MarketT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MarketT:
		soap_serialize_PointerTons1__MarketT(soap, (ns1__MarketT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__RegionT:
		soap_serialize_PointerToPointerTons1__RegionT(soap, (ns1__RegionT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RegionT:
		soap_serialize_PointerTons1__RegionT(soap, (ns1__RegionT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT:
		soap_serialize_PointerToArrayOfHistoricalAlarmsT(soap, (ArrayOfHistoricalAlarmsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCurrentAlarmsT:
		soap_serialize_PointerToArrayOfCurrentAlarmsT(soap, (ArrayOfCurrentAlarmsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCmStatusSummaryT:
		soap_serialize_PointerToArrayOfCmStatusSummaryT(soap, (ArrayOfCmStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT:
		soap_serialize_PointerToArrayOfHfcStatusSummaryT(soap, (ArrayOfHfcStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfQueryStateT:
		soap_serialize_PointerToArrayOfQueryStateT(soap, (ArrayOfQueryStateT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT:
		soap_serialize_PointerToArrayOfMtaStatusSummaryT(soap, (ArrayOfMtaStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StatusSummaryT:
		soap_serialize_PointerTons1__StatusSummaryT(soap, (ns1__StatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AlarmTypeConfigT:
		soap_serialize_PointerTons1__AlarmTypeConfigT(soap, (ns1__AlarmTypeConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT:
		soap_serialize_PointerToArrayOfAlarmTypeConfigT(soap, (ArrayOfAlarmTypeConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcPowerTresholdT:
		soap_serialize_PointerTons1__HfcPowerTresholdT(soap, (ns1__HfcPowerTresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AggregateMtaTresholdT:
		soap_serialize_PointerTons1__AggregateMtaTresholdT(soap, (ns1__AggregateMtaTresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoakWindowT:
		soap_serialize_PointerTons1__SoakWindowT(soap, (ns1__SoakWindowT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT:
		soap_serialize_PointerTons1__AggregateCmOfflineTresholdT(soap, (ns1__AggregateCmOfflineTresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT:
		soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, (ArrayOfAggregateStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT:
		soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, (ArrayOfAlarmStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserRoleT:
		soap_serialize_PointerTons1__UserRoleT(soap, (ns1__UserRoleT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfOAPairT:
		soap_serialize_PointerToArrayOfOAPairT(soap, (ArrayOfOAPairT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CMSLineT:
		soap_serialize_PointerTons1__CMSLineT(soap, (ns1__CMSLineT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEAbstractNameT:
		soap_serialize_PointerTons1__CTEAbstractNameT(soap, (ns1__CTEAbstractNameT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEAbstractMacT:
		soap_serialize_PointerTons1__CTEAbstractMacT(soap, (ns1__CTEAbstractMacT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTECustomerT:
		soap_serialize_PointerTons1__CTECustomerT(soap, (ns1__CTECustomerT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToshort:
		soap_serialize_PointerToshort(soap, (short *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmPerformanceT:
		soap_serialize_PointerTons1__CmPerformanceT(soap, (ns1__CmPerformanceT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaPingStatusT:
		soap_serialize_PointerTons1__MtaPingStatusT(soap, (ns1__MtaPingStatusT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaProvStatusT:
		soap_serialize_PointerTons1__MtaProvStatusT(soap, (ns1__MtaProvStatusT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaAvailabilityT:
		soap_serialize_PointerTons1__MtaAvailabilityT(soap, (ns1__MtaAvailabilityT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmStatusT:
		soap_serialize_PointerTons1__CmStatusT(soap, (ns1__CmStatusT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfScrollPageT:
		soap_serialize_PointerToArrayOfScrollPageT(soap, (ArrayOfScrollPageT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ResultBatchT:
		soap_serialize_PointerTons1__ResultBatchT(soap, (ns1__ResultBatchT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EmtaT:
		soap_serialize_PointerTons1__EmtaT(soap, (ns1__EmtaT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CableModemT:
		soap_serialize_PointerTons1__CableModemT(soap, (ns1__CableModemT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HistoricalAlarmT:
		soap_serialize_PointerTons1__HistoricalAlarmT(soap, (ns1__HistoricalAlarmT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CurrentAlarmT:
		soap_serialize_PointerTons1__CurrentAlarmT(soap, (ns1__CurrentAlarmT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AbstractAlarmT:
		soap_serialize_PointerTons1__AbstractAlarmT(soap, (ns1__AbstractAlarmT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericCountsT:
		soap_serialize_PointerTons1__GenericCountsT(soap, (ns1__GenericCountsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TopoHierarchyKeyT:
		soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, (ns1__TopoHierarchyKeyT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		return (void*)soap_instantiate_ns1__SnmpV2CAttributesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericCountsT:
		return (void*)soap_instantiate_ns1__GenericCountsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InputTimeT:
		return (void*)soap_instantiate_ns1__InputTimeT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ResultBatchT:
		return (void*)soap_instantiate_ns1__ResultBatchT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		return (void*)soap_instantiate_ns1__TopoHierarchyKeyT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LocalSystemT:
		return (void*)soap_instantiate_ns1__LocalSystemT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RegionT:
		return (void*)soap_instantiate_ns1__RegionT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MarketT:
		return (void*)soap_instantiate_ns1__MarketT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BladeT:
		return (void*)soap_instantiate_ns1__BladeT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmsT:
		return (void*)soap_instantiate_ns1__CmsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsT:
		return (void*)soap_instantiate_ns1__CmtsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ChannelT:
		return (void*)soap_instantiate_ns1__ChannelT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcT:
		return (void*)soap_instantiate_ns1__HfcT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CableModemT:
		return (void*)soap_instantiate_ns1__CableModemT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EmtaT:
		return (void*)soap_instantiate_ns1__EmtaT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AbstractAlarmT:
		return (void*)soap_instantiate_ns1__AbstractAlarmT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CurrentAlarmT:
		return (void*)soap_instantiate_ns1__CurrentAlarmT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		return (void*)soap_instantiate_ns1__CurrentAlarmDetailsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		return (void*)soap_instantiate_ns1__HistoricalAlarmT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		return (void*)soap_instantiate_ns1__HistoricalAlarmDetailsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AlarmHistoryT:
		return (void*)soap_instantiate_ns1__AlarmHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		return (void*)soap_instantiate_ns1__MappedEuDevicesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScrollPageT:
		return (void*)soap_instantiate_ns1__ScrollPageT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QueryStateT:
		return (void*)soap_instantiate_ns1__QueryStateT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		return (void*)soap_instantiate_ns1__GenericCountsHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusT:
		return (void*)soap_instantiate_ns1__CmStatusT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		return (void*)soap_instantiate_ns1__CmStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		return (void*)soap_instantiate_ns1__MtaAvailabilityT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		return (void*)soap_instantiate_ns1__MtaAvailabilityHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaProvStatusT:
		return (void*)soap_instantiate_ns1__MtaProvStatusT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		return (void*)soap_instantiate_ns1__MtaProvStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaPingStatusT:
		return (void*)soap_instantiate_ns1__MtaPingStatusT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		return (void*)soap_instantiate_ns1__MtaPingStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmPerformanceT:
		return (void*)soap_instantiate_ns1__CmPerformanceT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		return (void*)soap_instantiate_ns1__CmPerformanceHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		return (void*)soap_instantiate_ns1__CmCurrentPerformanceT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTECustomerT:
		return (void*)soap_instantiate_ns1__CTECustomerT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		return (void*)soap_instantiate_ns1__CTEAbstractMacT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		return (void*)soap_instantiate_ns1__CTEAbstractNameT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEDataT:
		return (void*)soap_instantiate_ns1__CTEDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEQueryInputT:
		return (void*)soap_instantiate_ns1__CTEQueryInputT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CMSLineT:
		return (void*)soap_instantiate_ns1__CMSLineT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CMSResultT:
		return (void*)soap_instantiate_ns1__CMSResultT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__OAPairT:
		return (void*)soap_instantiate_ns1__OAPairT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserRoleT:
		return (void*)soap_instantiate_ns1__UserRoleT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RoleOAPairT:
		return (void*)soap_instantiate_ns1__RoleOAPairT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserT:
		return (void*)soap_instantiate_ns1__UserT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserAccessPrivilegesT:
		return (void*)soap_instantiate_ns1__UserAccessPrivilegesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PollingIntervalsT:
		return (void*)soap_instantiate_ns1__PollingIntervalsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		return (void*)soap_instantiate_ns1__AlarmBasedStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		return (void*)soap_instantiate_ns1__AggregateStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		return (void*)soap_instantiate_ns1__MtaStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		return (void*)soap_instantiate_ns1__HfcStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		return (void*)soap_instantiate_ns1__ChannelStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		return (void*)soap_instantiate_ns1__CmtsStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		return (void*)soap_instantiate_ns1__CmsStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoakWindowT:
		return (void*)soap_instantiate_ns1__SoakWindowT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		return (void*)soap_instantiate_ns1__AggregateCmOfflineTresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		return (void*)soap_instantiate_ns1__AggregateMtaTresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		return (void*)soap_instantiate_ns1__HfcPowerTresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		return (void*)soap_instantiate_ns1__HfcAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		return (void*)soap_instantiate_ns1__AlarmTypeConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		return (void*)soap_instantiate_ns1__MtaAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		return (void*)soap_instantiate_ns1__CmtsAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		return (void*)soap_instantiate_ns1__CmsAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		return (void*)soap_instantiate_ns1__CmPerformanceConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsCmDataT:
		return (void*)soap_instantiate_ns1__CmtsCmDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmDataT:
		return (void*)soap_instantiate_ns1__CmDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaDataT:
		return (void*)soap_instantiate_ns1__MtaDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StatusSummaryT:
		return (void*)soap_instantiate_ns1__StatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		return (void*)soap_instantiate_ns1__HfcStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		return (void*)soap_instantiate_ns1__MtaStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		return (void*)soap_instantiate_ns1__CmStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		return (void*)soap_instantiate_ns1__MtaStatusSummaryRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		return (void*)soap_instantiate_ns1__HfcStatusSummaryRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		return (void*)soap_instantiate_ns1__CmStatusSummaryRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		return (void*)soap_instantiate_ns1__CurrentAlarmsRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		return (void*)soap_instantiate_ns1__HistoricalAlarmsRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfRegionsT:
		return (void*)soap_instantiate_ArrayOfRegionsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMarketsT:
		return (void*)soap_instantiate_ArrayOfMarketsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfBladesT:
		return (void*)soap_instantiate_ArrayOfBladesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmsesT:
		return (void*)soap_instantiate_ArrayOfCmsesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmtsesT:
		return (void*)soap_instantiate_ArrayOfCmtsesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		return (void*)soap_instantiate_ArrayOfSnmpV2CAttributesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfChannelsT:
		return (void*)soap_instantiate_ArrayOfChannelsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfHfcsT:
		return (void*)soap_instantiate_ArrayOfHfcsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCableModemsT:
		return (void*)soap_instantiate_ArrayOfCableModemsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfEmtasT:
		return (void*)soap_instantiate_ArrayOfEmtasT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		return (void*)soap_instantiate_ArrayOfCurrentAlarmsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		return (void*)soap_instantiate_ArrayOfHistoricalAlarmsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		return (void*)soap_instantiate_ArrayOfAlarmHistoriesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfScrollPageT:
		return (void*)soap_instantiate_ArrayOfScrollPageT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfQueryStateT:
		return (void*)soap_instantiate_ArrayOfQueryStateT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		return (void*)soap_instantiate_ArrayOfGenericCountsHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		return (void*)soap_instantiate_ArrayOfCmStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		return (void*)soap_instantiate_ArrayOfMtaAvailabilityHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		return (void*)soap_instantiate_ArrayOfMtaProvStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		return (void*)soap_instantiate_ArrayOfMtaPingStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		return (void*)soap_instantiate_ArrayOfCmPerformanceHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTECustomerT:
		return (void*)soap_instantiate_ArrayOfCTECustomerT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTEDataT:
		return (void*)soap_instantiate_ArrayOfCTEDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		return (void*)soap_instantiate_ArrayOfCTEQueryInputT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCMSLineT:
		return (void*)soap_instantiate_ArrayOfCMSLineT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfOAPairT:
		return (void*)soap_instantiate_ArrayOfOAPairT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfUserRoleT:
		return (void*)soap_instantiate_ArrayOfUserRoleT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfUserT:
		return (void*)soap_instantiate_ArrayOfUserT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		return (void*)soap_instantiate_ArrayOfAlarmStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		return (void*)soap_instantiate_ArrayOfAggregateStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		return (void*)soap_instantiate_ArrayOfAlarmTypeConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		return (void*)soap_instantiate_ArrayOfHfcStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		return (void*)soap_instantiate_ArrayOfMtaStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		return (void*)soap_instantiate_ArrayOfCmStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cte__getCteDataResponse:
		return (void*)soap_instantiate_cte__getCteDataResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_cte__getCteData:
		return (void*)soap_instantiate_cte__getCteData(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__SOAP_ENC__arrayType:
		return (void*)soap_instantiate__SOAP_ENC__arrayType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		if (p->size < 0)
			delete (ns1__SnmpV2CAttributesT*)p->ptr;
		else
			delete[] (ns1__SnmpV2CAttributesT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GenericCountsT:
		if (p->size < 0)
			delete (ns1__GenericCountsT*)p->ptr;
		else
			delete[] (ns1__GenericCountsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__InputTimeT:
		if (p->size < 0)
			delete (ns1__InputTimeT*)p->ptr;
		else
			delete[] (ns1__InputTimeT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ResultBatchT:
		if (p->size < 0)
			delete (ns1__ResultBatchT*)p->ptr;
		else
			delete[] (ns1__ResultBatchT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		if (p->size < 0)
			delete (ns1__TopoHierarchyKeyT*)p->ptr;
		else
			delete[] (ns1__TopoHierarchyKeyT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__LocalSystemT:
		if (p->size < 0)
			delete (ns1__LocalSystemT*)p->ptr;
		else
			delete[] (ns1__LocalSystemT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RegionT:
		if (p->size < 0)
			delete (ns1__RegionT*)p->ptr;
		else
			delete[] (ns1__RegionT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MarketT:
		if (p->size < 0)
			delete (ns1__MarketT*)p->ptr;
		else
			delete[] (ns1__MarketT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BladeT:
		if (p->size < 0)
			delete (ns1__BladeT*)p->ptr;
		else
			delete[] (ns1__BladeT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmsT:
		if (p->size < 0)
			delete (ns1__CmsT*)p->ptr;
		else
			delete[] (ns1__CmsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsT:
		if (p->size < 0)
			delete (ns1__CmtsT*)p->ptr;
		else
			delete[] (ns1__CmtsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ChannelT:
		if (p->size < 0)
			delete (ns1__ChannelT*)p->ptr;
		else
			delete[] (ns1__ChannelT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcT:
		if (p->size < 0)
			delete (ns1__HfcT*)p->ptr;
		else
			delete[] (ns1__HfcT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CableModemT:
		if (p->size < 0)
			delete (ns1__CableModemT*)p->ptr;
		else
			delete[] (ns1__CableModemT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__EmtaT:
		if (p->size < 0)
			delete (ns1__EmtaT*)p->ptr;
		else
			delete[] (ns1__EmtaT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AbstractAlarmT:
		if (p->size < 0)
			delete (ns1__AbstractAlarmT*)p->ptr;
		else
			delete[] (ns1__AbstractAlarmT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CurrentAlarmT:
		if (p->size < 0)
			delete (ns1__CurrentAlarmT*)p->ptr;
		else
			delete[] (ns1__CurrentAlarmT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		if (p->size < 0)
			delete (ns1__CurrentAlarmDetailsT*)p->ptr;
		else
			delete[] (ns1__CurrentAlarmDetailsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		if (p->size < 0)
			delete (ns1__HistoricalAlarmT*)p->ptr;
		else
			delete[] (ns1__HistoricalAlarmT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		if (p->size < 0)
			delete (ns1__HistoricalAlarmDetailsT*)p->ptr;
		else
			delete[] (ns1__HistoricalAlarmDetailsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AlarmHistoryT:
		if (p->size < 0)
			delete (ns1__AlarmHistoryT*)p->ptr;
		else
			delete[] (ns1__AlarmHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		if (p->size < 0)
			delete (ns1__MappedEuDevicesT*)p->ptr;
		else
			delete[] (ns1__MappedEuDevicesT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ScrollPageT:
		if (p->size < 0)
			delete (ns1__ScrollPageT*)p->ptr;
		else
			delete[] (ns1__ScrollPageT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__QueryStateT:
		if (p->size < 0)
			delete (ns1__QueryStateT*)p->ptr;
		else
			delete[] (ns1__QueryStateT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		if (p->size < 0)
			delete (ns1__GenericCountsHistoryT*)p->ptr;
		else
			delete[] (ns1__GenericCountsHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusT:
		if (p->size < 0)
			delete (ns1__CmStatusT*)p->ptr;
		else
			delete[] (ns1__CmStatusT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		if (p->size < 0)
			delete (ns1__CmStatusHistoryT*)p->ptr;
		else
			delete[] (ns1__CmStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		if (p->size < 0)
			delete (ns1__MtaAvailabilityT*)p->ptr;
		else
			delete[] (ns1__MtaAvailabilityT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		if (p->size < 0)
			delete (ns1__MtaAvailabilityHistoryT*)p->ptr;
		else
			delete[] (ns1__MtaAvailabilityHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaProvStatusT:
		if (p->size < 0)
			delete (ns1__MtaProvStatusT*)p->ptr;
		else
			delete[] (ns1__MtaProvStatusT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		if (p->size < 0)
			delete (ns1__MtaProvStatusHistoryT*)p->ptr;
		else
			delete[] (ns1__MtaProvStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaPingStatusT:
		if (p->size < 0)
			delete (ns1__MtaPingStatusT*)p->ptr;
		else
			delete[] (ns1__MtaPingStatusT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		if (p->size < 0)
			delete (ns1__MtaPingStatusHistoryT*)p->ptr;
		else
			delete[] (ns1__MtaPingStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmPerformanceT:
		if (p->size < 0)
			delete (ns1__CmPerformanceT*)p->ptr;
		else
			delete[] (ns1__CmPerformanceT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		if (p->size < 0)
			delete (ns1__CmPerformanceHistoryT*)p->ptr;
		else
			delete[] (ns1__CmPerformanceHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		if (p->size < 0)
			delete (ns1__CmCurrentPerformanceT*)p->ptr;
		else
			delete[] (ns1__CmCurrentPerformanceT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTECustomerT:
		if (p->size < 0)
			delete (ns1__CTECustomerT*)p->ptr;
		else
			delete[] (ns1__CTECustomerT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		if (p->size < 0)
			delete (ns1__CTEAbstractMacT*)p->ptr;
		else
			delete[] (ns1__CTEAbstractMacT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		if (p->size < 0)
			delete (ns1__CTEAbstractNameT*)p->ptr;
		else
			delete[] (ns1__CTEAbstractNameT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEDataT:
		if (p->size < 0)
			delete (ns1__CTEDataT*)p->ptr;
		else
			delete[] (ns1__CTEDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEQueryInputT:
		if (p->size < 0)
			delete (ns1__CTEQueryInputT*)p->ptr;
		else
			delete[] (ns1__CTEQueryInputT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CMSLineT:
		if (p->size < 0)
			delete (ns1__CMSLineT*)p->ptr;
		else
			delete[] (ns1__CMSLineT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CMSResultT:
		if (p->size < 0)
			delete (ns1__CMSResultT*)p->ptr;
		else
			delete[] (ns1__CMSResultT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__OAPairT:
		if (p->size < 0)
			delete (ns1__OAPairT*)p->ptr;
		else
			delete[] (ns1__OAPairT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UserRoleT:
		if (p->size < 0)
			delete (ns1__UserRoleT*)p->ptr;
		else
			delete[] (ns1__UserRoleT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RoleOAPairT:
		if (p->size < 0)
			delete (ns1__RoleOAPairT*)p->ptr;
		else
			delete[] (ns1__RoleOAPairT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UserT:
		if (p->size < 0)
			delete (ns1__UserT*)p->ptr;
		else
			delete[] (ns1__UserT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UserAccessPrivilegesT:
		if (p->size < 0)
			delete (ns1__UserAccessPrivilegesT*)p->ptr;
		else
			delete[] (ns1__UserAccessPrivilegesT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PollingIntervalsT:
		if (p->size < 0)
			delete (ns1__PollingIntervalsT*)p->ptr;
		else
			delete[] (ns1__PollingIntervalsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		if (p->size < 0)
			delete (ns1__AlarmBasedStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__AlarmBasedStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		if (p->size < 0)
			delete (ns1__AggregateStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__AggregateStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		if (p->size < 0)
			delete (ns1__MtaStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__MtaStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		if (p->size < 0)
			delete (ns1__HfcStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__HfcStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		if (p->size < 0)
			delete (ns1__ChannelStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__ChannelStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		if (p->size < 0)
			delete (ns1__CmtsStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__CmtsStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		if (p->size < 0)
			delete (ns1__CmsStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__CmsStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SoakWindowT:
		if (p->size < 0)
			delete (ns1__SoakWindowT*)p->ptr;
		else
			delete[] (ns1__SoakWindowT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		if (p->size < 0)
			delete (ns1__AggregateCmOfflineTresholdT*)p->ptr;
		else
			delete[] (ns1__AggregateCmOfflineTresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		if (p->size < 0)
			delete (ns1__AggregateMtaTresholdT*)p->ptr;
		else
			delete[] (ns1__AggregateMtaTresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		if (p->size < 0)
			delete (ns1__HfcPowerTresholdT*)p->ptr;
		else
			delete[] (ns1__HfcPowerTresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		if (p->size < 0)
			delete (ns1__HfcAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__HfcAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		if (p->size < 0)
			delete (ns1__AlarmTypeConfigT*)p->ptr;
		else
			delete[] (ns1__AlarmTypeConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		if (p->size < 0)
			delete (ns1__MtaAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__MtaAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		if (p->size < 0)
			delete (ns1__CmtsAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__CmtsAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		if (p->size < 0)
			delete (ns1__CmsAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__CmsAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		if (p->size < 0)
			delete (ns1__CmPerformanceConfigT*)p->ptr;
		else
			delete[] (ns1__CmPerformanceConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsCmDataT:
		if (p->size < 0)
			delete (ns1__CmtsCmDataT*)p->ptr;
		else
			delete[] (ns1__CmtsCmDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmDataT:
		if (p->size < 0)
			delete (ns1__CmDataT*)p->ptr;
		else
			delete[] (ns1__CmDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaDataT:
		if (p->size < 0)
			delete (ns1__MtaDataT*)p->ptr;
		else
			delete[] (ns1__MtaDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__StatusSummaryT:
		if (p->size < 0)
			delete (ns1__StatusSummaryT*)p->ptr;
		else
			delete[] (ns1__StatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		if (p->size < 0)
			delete (ns1__HfcStatusSummaryT*)p->ptr;
		else
			delete[] (ns1__HfcStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		if (p->size < 0)
			delete (ns1__MtaStatusSummaryT*)p->ptr;
		else
			delete[] (ns1__MtaStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		if (p->size < 0)
			delete (ns1__CmStatusSummaryT*)p->ptr;
		else
			delete[] (ns1__CmStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		if (p->size < 0)
			delete (ns1__MtaStatusSummaryRespT*)p->ptr;
		else
			delete[] (ns1__MtaStatusSummaryRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		if (p->size < 0)
			delete (ns1__HfcStatusSummaryRespT*)p->ptr;
		else
			delete[] (ns1__HfcStatusSummaryRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		if (p->size < 0)
			delete (ns1__CmStatusSummaryRespT*)p->ptr;
		else
			delete[] (ns1__CmStatusSummaryRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		if (p->size < 0)
			delete (ns1__CurrentAlarmsRespT*)p->ptr;
		else
			delete[] (ns1__CurrentAlarmsRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		if (p->size < 0)
			delete (ns1__HistoricalAlarmsRespT*)p->ptr;
		else
			delete[] (ns1__HistoricalAlarmsRespT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfRegionsT:
		if (p->size < 0)
			delete (ArrayOfRegionsT*)p->ptr;
		else
			delete[] (ArrayOfRegionsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMarketsT:
		if (p->size < 0)
			delete (ArrayOfMarketsT*)p->ptr;
		else
			delete[] (ArrayOfMarketsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfBladesT:
		if (p->size < 0)
			delete (ArrayOfBladesT*)p->ptr;
		else
			delete[] (ArrayOfBladesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmsesT:
		if (p->size < 0)
			delete (ArrayOfCmsesT*)p->ptr;
		else
			delete[] (ArrayOfCmsesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmtsesT:
		if (p->size < 0)
			delete (ArrayOfCmtsesT*)p->ptr;
		else
			delete[] (ArrayOfCmtsesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		if (p->size < 0)
			delete (ArrayOfSnmpV2CAttributesT*)p->ptr;
		else
			delete[] (ArrayOfSnmpV2CAttributesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfChannelsT:
		if (p->size < 0)
			delete (ArrayOfChannelsT*)p->ptr;
		else
			delete[] (ArrayOfChannelsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfHfcsT:
		if (p->size < 0)
			delete (ArrayOfHfcsT*)p->ptr;
		else
			delete[] (ArrayOfHfcsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCableModemsT:
		if (p->size < 0)
			delete (ArrayOfCableModemsT*)p->ptr;
		else
			delete[] (ArrayOfCableModemsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfEmtasT:
		if (p->size < 0)
			delete (ArrayOfEmtasT*)p->ptr;
		else
			delete[] (ArrayOfEmtasT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		if (p->size < 0)
			delete (ArrayOfCurrentAlarmsT*)p->ptr;
		else
			delete[] (ArrayOfCurrentAlarmsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		if (p->size < 0)
			delete (ArrayOfHistoricalAlarmsT*)p->ptr;
		else
			delete[] (ArrayOfHistoricalAlarmsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		if (p->size < 0)
			delete (ArrayOfAlarmHistoriesT*)p->ptr;
		else
			delete[] (ArrayOfAlarmHistoriesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfScrollPageT:
		if (p->size < 0)
			delete (ArrayOfScrollPageT*)p->ptr;
		else
			delete[] (ArrayOfScrollPageT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfQueryStateT:
		if (p->size < 0)
			delete (ArrayOfQueryStateT*)p->ptr;
		else
			delete[] (ArrayOfQueryStateT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		if (p->size < 0)
			delete (ArrayOfGenericCountsHistoryT*)p->ptr;
		else
			delete[] (ArrayOfGenericCountsHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		if (p->size < 0)
			delete (ArrayOfCmStatusHistoryT*)p->ptr;
		else
			delete[] (ArrayOfCmStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		if (p->size < 0)
			delete (ArrayOfMtaAvailabilityHistoryT*)p->ptr;
		else
			delete[] (ArrayOfMtaAvailabilityHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		if (p->size < 0)
			delete (ArrayOfMtaProvStatusHistoryT*)p->ptr;
		else
			delete[] (ArrayOfMtaProvStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		if (p->size < 0)
			delete (ArrayOfMtaPingStatusHistoryT*)p->ptr;
		else
			delete[] (ArrayOfMtaPingStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		if (p->size < 0)
			delete (ArrayOfCmPerformanceHistoryT*)p->ptr;
		else
			delete[] (ArrayOfCmPerformanceHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCTECustomerT:
		if (p->size < 0)
			delete (ArrayOfCTECustomerT*)p->ptr;
		else
			delete[] (ArrayOfCTECustomerT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCTEDataT:
		if (p->size < 0)
			delete (ArrayOfCTEDataT*)p->ptr;
		else
			delete[] (ArrayOfCTEDataT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		if (p->size < 0)
			delete (ArrayOfCTEQueryInputT*)p->ptr;
		else
			delete[] (ArrayOfCTEQueryInputT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCMSLineT:
		if (p->size < 0)
			delete (ArrayOfCMSLineT*)p->ptr;
		else
			delete[] (ArrayOfCMSLineT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfOAPairT:
		if (p->size < 0)
			delete (ArrayOfOAPairT*)p->ptr;
		else
			delete[] (ArrayOfOAPairT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfUserRoleT:
		if (p->size < 0)
			delete (ArrayOfUserRoleT*)p->ptr;
		else
			delete[] (ArrayOfUserRoleT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfUserT:
		if (p->size < 0)
			delete (ArrayOfUserT*)p->ptr;
		else
			delete[] (ArrayOfUserT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		if (p->size < 0)
			delete (ArrayOfAlarmStatusThresholdT*)p->ptr;
		else
			delete[] (ArrayOfAlarmStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		if (p->size < 0)
			delete (ArrayOfAggregateStatusThresholdT*)p->ptr;
		else
			delete[] (ArrayOfAggregateStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		if (p->size < 0)
			delete (ArrayOfAlarmTypeConfigT*)p->ptr;
		else
			delete[] (ArrayOfAlarmTypeConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		if (p->size < 0)
			delete (ArrayOfHfcStatusSummaryT*)p->ptr;
		else
			delete[] (ArrayOfHfcStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		if (p->size < 0)
			delete (ArrayOfMtaStatusSummaryT*)p->ptr;
		else
			delete[] (ArrayOfMtaStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		if (p->size < 0)
			delete (ArrayOfCmStatusSummaryT*)p->ptr;
		else
			delete[] (ArrayOfCmStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_cte__getCteDataResponse:
		if (p->size < 0)
			delete (struct cte__getCteDataResponse*)p->ptr;
		else
			delete[] (struct cte__getCteDataResponse*)p->ptr;
		break;
	case SOAP_TYPE_cte__getCteData:
		if (p->size < 0)
			delete (struct cte__getCteData*)p->ptr;
		else
			delete[] (struct cte__getCteData*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE__SOAP_ENC__arrayType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ApplicationDomainTypeT(struct soap *soap, enum ns1__ApplicationDomainTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ApplicationDomainTypeT
	*a = SOAP_DEFAULT_ns1__ApplicationDomainTypeT;
#else
	*a = (enum ns1__ApplicationDomainTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ApplicationDomainTypeT(struct soap *soap, const enum ns1__ApplicationDomainTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ApplicationDomainTypeT);
	if (soap_out_ns1__ApplicationDomainTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ApplicationDomainTypeT[] =
{	{ (long)ns1__ApplicationDomainTypeT__Administration, "Administration" },
	{ (long)ns1__ApplicationDomainTypeT__Alarm, "Alarm" },
	{ (long)ns1__ApplicationDomainTypeT__CsrPortal, "CsrPortal" },
	{ (long)ns1__ApplicationDomainTypeT__Reports, "Reports" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ApplicationDomainTypeT2s(struct soap *soap, enum ns1__ApplicationDomainTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__ApplicationDomainTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApplicationDomainTypeT(struct soap *soap, const char *tag, int id, const enum ns1__ApplicationDomainTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApplicationDomainTypeT), type);
	soap_send(soap, soap_ns1__ApplicationDomainTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ApplicationDomainTypeT * SOAP_FMAC4 soap_get_ns1__ApplicationDomainTypeT(struct soap *soap, enum ns1__ApplicationDomainTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApplicationDomainTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ApplicationDomainTypeT(struct soap *soap, const char *s, enum ns1__ApplicationDomainTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ApplicationDomainTypeT, s);
	if (map)
		*a = (enum ns1__ApplicationDomainTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ApplicationDomainTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ApplicationDomainTypeT * SOAP_FMAC4 soap_in_ns1__ApplicationDomainTypeT(struct soap *soap, const char *tag, enum ns1__ApplicationDomainTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ApplicationDomainTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApplicationDomainTypeT, sizeof(enum ns1__ApplicationDomainTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ApplicationDomainTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ApplicationDomainTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApplicationDomainTypeT, 0, sizeof(enum ns1__ApplicationDomainTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UserAccessTypeT(struct soap *soap, enum ns1__UserAccessTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__UserAccessTypeT
	*a = SOAP_DEFAULT_ns1__UserAccessTypeT;
#else
	*a = (enum ns1__UserAccessTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UserAccessTypeT(struct soap *soap, const enum ns1__UserAccessTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__UserAccessTypeT);
	if (soap_out_ns1__UserAccessTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__UserAccessTypeT[] =
{	{ (long)ns1__UserAccessTypeT__Read, "Read" },
	{ (long)ns1__UserAccessTypeT__Write, "Write" },
	{ (long)ns1__UserAccessTypeT__None, "None" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__UserAccessTypeT2s(struct soap *soap, enum ns1__UserAccessTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__UserAccessTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserAccessTypeT(struct soap *soap, const char *tag, int id, const enum ns1__UserAccessTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserAccessTypeT), type);
	soap_send(soap, soap_ns1__UserAccessTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__UserAccessTypeT * SOAP_FMAC4 soap_get_ns1__UserAccessTypeT(struct soap *soap, enum ns1__UserAccessTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserAccessTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__UserAccessTypeT(struct soap *soap, const char *s, enum ns1__UserAccessTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__UserAccessTypeT, s);
	if (map)
		*a = (enum ns1__UserAccessTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__UserAccessTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__UserAccessTypeT * SOAP_FMAC4 soap_in_ns1__UserAccessTypeT(struct soap *soap, const char *tag, enum ns1__UserAccessTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__UserAccessTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserAccessTypeT, sizeof(enum ns1__UserAccessTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__UserAccessTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__UserAccessTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserAccessTypeT, 0, sizeof(enum ns1__UserAccessTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EndUserDeviceTypeT(struct soap *soap, enum ns1__EndUserDeviceTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EndUserDeviceTypeT
	*a = SOAP_DEFAULT_ns1__EndUserDeviceTypeT;
#else
	*a = (enum ns1__EndUserDeviceTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EndUserDeviceTypeT(struct soap *soap, const enum ns1__EndUserDeviceTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__EndUserDeviceTypeT);
	if (soap_out_ns1__EndUserDeviceTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__EndUserDeviceTypeT[] =
{	{ (long)ns1__EndUserDeviceTypeT__CM, "CM" },
	{ (long)ns1__EndUserDeviceTypeT__eMTA, "eMTA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__EndUserDeviceTypeT2s(struct soap *soap, enum ns1__EndUserDeviceTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__EndUserDeviceTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EndUserDeviceTypeT(struct soap *soap, const char *tag, int id, const enum ns1__EndUserDeviceTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EndUserDeviceTypeT), type);
	soap_send(soap, soap_ns1__EndUserDeviceTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__EndUserDeviceTypeT * SOAP_FMAC4 soap_get_ns1__EndUserDeviceTypeT(struct soap *soap, enum ns1__EndUserDeviceTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EndUserDeviceTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__EndUserDeviceTypeT(struct soap *soap, const char *s, enum ns1__EndUserDeviceTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__EndUserDeviceTypeT, s);
	if (map)
		*a = (enum ns1__EndUserDeviceTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__EndUserDeviceTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__EndUserDeviceTypeT * SOAP_FMAC4 soap_in_ns1__EndUserDeviceTypeT(struct soap *soap, const char *tag, enum ns1__EndUserDeviceTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__EndUserDeviceTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EndUserDeviceTypeT, sizeof(enum ns1__EndUserDeviceTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__EndUserDeviceTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__EndUserDeviceTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EndUserDeviceTypeT, 0, sizeof(enum ns1__EndUserDeviceTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChannelTypeT(struct soap *soap, enum ns1__ChannelTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ChannelTypeT
	*a = SOAP_DEFAULT_ns1__ChannelTypeT;
#else
	*a = (enum ns1__ChannelTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChannelTypeT(struct soap *soap, const enum ns1__ChannelTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ChannelTypeT);
	if (soap_out_ns1__ChannelTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ChannelTypeT[] =
{	{ (long)ns1__ChannelTypeT__Upstream, "Upstream" },
	{ (long)ns1__ChannelTypeT__Downstream, "Downstream" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ChannelTypeT2s(struct soap *soap, enum ns1__ChannelTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__ChannelTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChannelTypeT(struct soap *soap, const char *tag, int id, const enum ns1__ChannelTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChannelTypeT), type);
	soap_send(soap, soap_ns1__ChannelTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ChannelTypeT * SOAP_FMAC4 soap_get_ns1__ChannelTypeT(struct soap *soap, enum ns1__ChannelTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChannelTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ChannelTypeT(struct soap *soap, const char *s, enum ns1__ChannelTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ChannelTypeT, s);
	if (map)
		*a = (enum ns1__ChannelTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ChannelTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ChannelTypeT * SOAP_FMAC4 soap_in_ns1__ChannelTypeT(struct soap *soap, const char *tag, enum ns1__ChannelTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ChannelTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChannelTypeT, sizeof(enum ns1__ChannelTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ChannelTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ChannelTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChannelTypeT, 0, sizeof(enum ns1__ChannelTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SnmpVersionT(struct soap *soap, enum ns1__SnmpVersionT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__SnmpVersionT
	*a = SOAP_DEFAULT_ns1__SnmpVersionT;
#else
	*a = (enum ns1__SnmpVersionT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SnmpVersionT(struct soap *soap, const enum ns1__SnmpVersionT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SnmpVersionT);
	if (soap_out_ns1__SnmpVersionT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__SnmpVersionT[] =
{	{ (long)ns1__SnmpVersionT__v1, "v1" },
	{ (long)ns1__SnmpVersionT__v2c, "v2c" },
	{ (long)ns1__SnmpVersionT__v3, "v3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SnmpVersionT2s(struct soap *soap, enum ns1__SnmpVersionT n)
{	const char *s = soap_code_str(soap_codes_ns1__SnmpVersionT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnmpVersionT(struct soap *soap, const char *tag, int id, const enum ns1__SnmpVersionT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnmpVersionT), type);
	soap_send(soap, soap_ns1__SnmpVersionT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__SnmpVersionT * SOAP_FMAC4 soap_get_ns1__SnmpVersionT(struct soap *soap, enum ns1__SnmpVersionT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnmpVersionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SnmpVersionT(struct soap *soap, const char *s, enum ns1__SnmpVersionT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__SnmpVersionT, s);
	if (map)
		*a = (enum ns1__SnmpVersionT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__SnmpVersionT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SnmpVersionT * SOAP_FMAC4 soap_in_ns1__SnmpVersionT(struct soap *soap, const char *tag, enum ns1__SnmpVersionT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__SnmpVersionT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnmpVersionT, sizeof(enum ns1__SnmpVersionT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__SnmpVersionT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__SnmpVersionT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnmpVersionT, 0, sizeof(enum ns1__SnmpVersionT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StatusColorT(struct soap *soap, enum ns1__StatusColorT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__StatusColorT
	*a = SOAP_DEFAULT_ns1__StatusColorT;
#else
	*a = (enum ns1__StatusColorT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StatusColorT(struct soap *soap, const enum ns1__StatusColorT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StatusColorT);
	if (soap_out_ns1__StatusColorT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__StatusColorT[] =
{	{ (long)ns1__StatusColorT__Gray, "Gray" },
	{ (long)ns1__StatusColorT__Green, "Green" },
	{ (long)ns1__StatusColorT__Yellow, "Yellow" },
	{ (long)ns1__StatusColorT__Orange, "Orange" },
	{ (long)ns1__StatusColorT__Red, "Red" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__StatusColorT2s(struct soap *soap, enum ns1__StatusColorT n)
{	const char *s = soap_code_str(soap_codes_ns1__StatusColorT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatusColorT(struct soap *soap, const char *tag, int id, const enum ns1__StatusColorT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatusColorT), type);
	soap_send(soap, soap_ns1__StatusColorT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__StatusColorT * SOAP_FMAC4 soap_get_ns1__StatusColorT(struct soap *soap, enum ns1__StatusColorT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatusColorT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__StatusColorT(struct soap *soap, const char *s, enum ns1__StatusColorT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__StatusColorT, s);
	if (map)
		*a = (enum ns1__StatusColorT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__StatusColorT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StatusColorT * SOAP_FMAC4 soap_in_ns1__StatusColorT(struct soap *soap, const char *tag, enum ns1__StatusColorT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__StatusColorT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatusColorT, sizeof(enum ns1__StatusColorT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__StatusColorT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__StatusColorT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StatusColorT, 0, sizeof(enum ns1__StatusColorT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ResourceTypeT(struct soap *soap, enum ns1__ResourceTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ResourceTypeT
	*a = SOAP_DEFAULT_ns1__ResourceTypeT;
#else
	*a = (enum ns1__ResourceTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ResourceTypeT(struct soap *soap, const enum ns1__ResourceTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ResourceTypeT);
	if (soap_out_ns1__ResourceTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ResourceTypeT[] =
{	{ (long)ns1__ResourceTypeT__CMTS, "CMTS" },
	{ (long)ns1__ResourceTypeT__CMS, "CMS" },
	{ (long)ns1__ResourceTypeT__Channel, "Channel" },
	{ (long)ns1__ResourceTypeT__HFC, "HFC" },
	{ (long)ns1__ResourceTypeT__CM, "CM" },
	{ (long)ns1__ResourceTypeT__MTA, "MTA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ResourceTypeT2s(struct soap *soap, enum ns1__ResourceTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__ResourceTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResourceTypeT(struct soap *soap, const char *tag, int id, const enum ns1__ResourceTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResourceTypeT), type);
	soap_send(soap, soap_ns1__ResourceTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ResourceTypeT * SOAP_FMAC4 soap_get_ns1__ResourceTypeT(struct soap *soap, enum ns1__ResourceTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResourceTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ResourceTypeT(struct soap *soap, const char *s, enum ns1__ResourceTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ResourceTypeT, s);
	if (map)
		*a = (enum ns1__ResourceTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ResourceTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ResourceTypeT * SOAP_FMAC4 soap_in_ns1__ResourceTypeT(struct soap *soap, const char *tag, enum ns1__ResourceTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ResourceTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResourceTypeT, sizeof(enum ns1__ResourceTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ResourceTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ResourceTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResourceTypeT, 0, sizeof(enum ns1__ResourceTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SystemTypeT(struct soap *soap, enum ns1__SystemTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__SystemTypeT
	*a = SOAP_DEFAULT_ns1__SystemTypeT;
#else
	*a = (enum ns1__SystemTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SystemTypeT(struct soap *soap, const enum ns1__SystemTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SystemTypeT);
	if (soap_out_ns1__SystemTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__SystemTypeT[] =
{	{ (long)ns1__SystemTypeT__EnterpriseServer, "EnterpriseServer" },
	{ (long)ns1__SystemTypeT__RegionServer, "RegionServer" },
	{ (long)ns1__SystemTypeT__MarketServer, "MarketServer" },
	{ (long)ns1__SystemTypeT__BladeServer, "BladeServer" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SystemTypeT2s(struct soap *soap, enum ns1__SystemTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__SystemTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SystemTypeT(struct soap *soap, const char *tag, int id, const enum ns1__SystemTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SystemTypeT), type);
	soap_send(soap, soap_ns1__SystemTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__SystemTypeT * SOAP_FMAC4 soap_get_ns1__SystemTypeT(struct soap *soap, enum ns1__SystemTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SystemTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SystemTypeT(struct soap *soap, const char *s, enum ns1__SystemTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__SystemTypeT, s);
	if (map)
		*a = (enum ns1__SystemTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__SystemTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SystemTypeT * SOAP_FMAC4 soap_in_ns1__SystemTypeT(struct soap *soap, const char *tag, enum ns1__SystemTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__SystemTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SystemTypeT, sizeof(enum ns1__SystemTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__SystemTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__SystemTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SystemTypeT, 0, sizeof(enum ns1__SystemTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void ns1__HistoricalAlarmsRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HistoricalAlarmsRespT*)this)->alarms = NULL;
	((ns1__HistoricalAlarmsRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__HistoricalAlarmsRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfHistoricalAlarmsT(soap, &((ns1__HistoricalAlarmsRespT*)this)->alarms);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__HistoricalAlarmsRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__HistoricalAlarmsRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HistoricalAlarmsRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HistoricalAlarmsRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistoricalAlarmsRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistoricalAlarmsRespT(struct soap *soap, const char *tag, int id, const ns1__HistoricalAlarmsRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistoricalAlarmsRespT), type);
	soap_out_PointerToArrayOfHistoricalAlarmsT(soap, "alarms", -1, &(((ns1__HistoricalAlarmsRespT*)a)->alarms), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__HistoricalAlarmsRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HistoricalAlarmsRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistoricalAlarmsRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmsRespT * SOAP_FMAC4 soap_get_ns1__HistoricalAlarmsRespT(struct soap *soap, ns1__HistoricalAlarmsRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistoricalAlarmsRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HistoricalAlarmsRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HistoricalAlarmsRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmsRespT * SOAP_FMAC4 soap_in_ns1__HistoricalAlarmsRespT(struct soap *soap, const char *tag, ns1__HistoricalAlarmsRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistoricalAlarmsRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistoricalAlarmsRespT, sizeof(ns1__HistoricalAlarmsRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HistoricalAlarmsRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HistoricalAlarmsRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarms1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfHistoricalAlarmsT(soap, "alarms", &(((ns1__HistoricalAlarmsRespT*)a)->alarms), "ns1:HistoricalAlarmT"))
				{	soap_flag_alarms1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__HistoricalAlarmsRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarms1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmsRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistoricalAlarmsRespT, 0, sizeof(ns1__HistoricalAlarmsRespT), 0, soap_copy_ns1__HistoricalAlarmsRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HistoricalAlarmsRespT * SOAP_FMAC6 soap_new_ns1__HistoricalAlarmsRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HistoricalAlarmsRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HistoricalAlarmsRespT(struct soap *soap, ns1__HistoricalAlarmsRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HistoricalAlarmsRespT * SOAP_FMAC4 soap_instantiate_ns1__HistoricalAlarmsRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistoricalAlarmsRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HistoricalAlarmsRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HistoricalAlarmsRespT;
		if (size)
			*size = sizeof(ns1__HistoricalAlarmsRespT);
		((ns1__HistoricalAlarmsRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HistoricalAlarmsRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HistoricalAlarmsRespT);
		for (int i = 0; i < n; i++)
			((ns1__HistoricalAlarmsRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HistoricalAlarmsRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HistoricalAlarmsRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HistoricalAlarmsRespT %p -> %p\n", q, p));
	*(ns1__HistoricalAlarmsRespT*)p = *(ns1__HistoricalAlarmsRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CurrentAlarmsRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CurrentAlarmsRespT*)this)->alarms = NULL;
	((ns1__CurrentAlarmsRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__CurrentAlarmsRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCurrentAlarmsT(soap, &((ns1__CurrentAlarmsRespT*)this)->alarms);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__CurrentAlarmsRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__CurrentAlarmsRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CurrentAlarmsRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CurrentAlarmsRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CurrentAlarmsRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CurrentAlarmsRespT(struct soap *soap, const char *tag, int id, const ns1__CurrentAlarmsRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CurrentAlarmsRespT), type);
	soap_out_PointerToArrayOfCurrentAlarmsT(soap, "alarms", -1, &(((ns1__CurrentAlarmsRespT*)a)->alarms), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__CurrentAlarmsRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CurrentAlarmsRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CurrentAlarmsRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CurrentAlarmsRespT * SOAP_FMAC4 soap_get_ns1__CurrentAlarmsRespT(struct soap *soap, ns1__CurrentAlarmsRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CurrentAlarmsRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CurrentAlarmsRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CurrentAlarmsRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CurrentAlarmsRespT * SOAP_FMAC4 soap_in_ns1__CurrentAlarmsRespT(struct soap *soap, const char *tag, ns1__CurrentAlarmsRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CurrentAlarmsRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CurrentAlarmsRespT, sizeof(ns1__CurrentAlarmsRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CurrentAlarmsRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CurrentAlarmsRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarms1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCurrentAlarmsT(soap, "alarms", &(((ns1__CurrentAlarmsRespT*)a)->alarms), "ns1:CurrentAlarmT"))
				{	soap_flag_alarms1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__CurrentAlarmsRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarms1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmsRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CurrentAlarmsRespT, 0, sizeof(ns1__CurrentAlarmsRespT), 0, soap_copy_ns1__CurrentAlarmsRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CurrentAlarmsRespT * SOAP_FMAC6 soap_new_ns1__CurrentAlarmsRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CurrentAlarmsRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CurrentAlarmsRespT(struct soap *soap, ns1__CurrentAlarmsRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CurrentAlarmsRespT * SOAP_FMAC4 soap_instantiate_ns1__CurrentAlarmsRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CurrentAlarmsRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CurrentAlarmsRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CurrentAlarmsRespT;
		if (size)
			*size = sizeof(ns1__CurrentAlarmsRespT);
		((ns1__CurrentAlarmsRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CurrentAlarmsRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CurrentAlarmsRespT);
		for (int i = 0; i < n; i++)
			((ns1__CurrentAlarmsRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CurrentAlarmsRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CurrentAlarmsRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CurrentAlarmsRespT %p -> %p\n", q, p));
	*(ns1__CurrentAlarmsRespT*)p = *(ns1__CurrentAlarmsRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusSummaryRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmStatusSummaryRespT*)this)->cmData = NULL;
	((ns1__CmStatusSummaryRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__CmStatusSummaryRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCmStatusSummaryT(soap, &((ns1__CmStatusSummaryRespT*)this)->cmData);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__CmStatusSummaryRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__CmStatusSummaryRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusSummaryRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusSummaryRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusSummaryRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusSummaryRespT(struct soap *soap, const char *tag, int id, const ns1__CmStatusSummaryRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusSummaryRespT), type);
	soap_out_PointerToArrayOfCmStatusSummaryT(soap, "cmData", -1, &(((ns1__CmStatusSummaryRespT*)a)->cmData), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__CmStatusSummaryRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusSummaryRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusSummaryRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryRespT * SOAP_FMAC4 soap_get_ns1__CmStatusSummaryRespT(struct soap *soap, ns1__CmStatusSummaryRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusSummaryRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusSummaryRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusSummaryRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryRespT * SOAP_FMAC4 soap_in_ns1__CmStatusSummaryRespT(struct soap *soap, const char *tag, ns1__CmStatusSummaryRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusSummaryRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusSummaryRespT, sizeof(ns1__CmStatusSummaryRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusSummaryRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusSummaryRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmData1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCmStatusSummaryT(soap, "cmData", &(((ns1__CmStatusSummaryRespT*)a)->cmData), "ns1:CmStatusSummaryT"))
				{	soap_flag_cmData1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__CmStatusSummaryRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmData1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusSummaryRespT, 0, sizeof(ns1__CmStatusSummaryRespT), 0, soap_copy_ns1__CmStatusSummaryRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusSummaryRespT * SOAP_FMAC6 soap_new_ns1__CmStatusSummaryRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusSummaryRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusSummaryRespT(struct soap *soap, ns1__CmStatusSummaryRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusSummaryRespT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusSummaryRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusSummaryRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusSummaryRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusSummaryRespT;
		if (size)
			*size = sizeof(ns1__CmStatusSummaryRespT);
		((ns1__CmStatusSummaryRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusSummaryRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusSummaryRespT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusSummaryRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusSummaryRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusSummaryRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusSummaryRespT %p -> %p\n", q, p));
	*(ns1__CmStatusSummaryRespT*)p = *(ns1__CmStatusSummaryRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcStatusSummaryRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcStatusSummaryRespT*)this)->hfcData = NULL;
	((ns1__HfcStatusSummaryRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__HfcStatusSummaryRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfHfcStatusSummaryT(soap, &((ns1__HfcStatusSummaryRespT*)this)->hfcData);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__HfcStatusSummaryRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__HfcStatusSummaryRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcStatusSummaryRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcStatusSummaryRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcStatusSummaryRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcStatusSummaryRespT(struct soap *soap, const char *tag, int id, const ns1__HfcStatusSummaryRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcStatusSummaryRespT), type);
	soap_out_PointerToArrayOfHfcStatusSummaryT(soap, "hfcData", -1, &(((ns1__HfcStatusSummaryRespT*)a)->hfcData), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__HfcStatusSummaryRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcStatusSummaryRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcStatusSummaryRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryRespT * SOAP_FMAC4 soap_get_ns1__HfcStatusSummaryRespT(struct soap *soap, ns1__HfcStatusSummaryRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcStatusSummaryRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcStatusSummaryRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcStatusSummaryRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryRespT * SOAP_FMAC4 soap_in_ns1__HfcStatusSummaryRespT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcStatusSummaryRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcStatusSummaryRespT, sizeof(ns1__HfcStatusSummaryRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcStatusSummaryRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcStatusSummaryRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_hfcData1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hfcData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfHfcStatusSummaryT(soap, "hfcData", &(((ns1__HfcStatusSummaryRespT*)a)->hfcData), "ns1:HfcStatusSummaryT"))
				{	soap_flag_hfcData1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__HfcStatusSummaryRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hfcData1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcStatusSummaryRespT, 0, sizeof(ns1__HfcStatusSummaryRespT), 0, soap_copy_ns1__HfcStatusSummaryRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcStatusSummaryRespT * SOAP_FMAC6 soap_new_ns1__HfcStatusSummaryRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcStatusSummaryRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcStatusSummaryRespT(struct soap *soap, ns1__HfcStatusSummaryRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcStatusSummaryRespT * SOAP_FMAC4 soap_instantiate_ns1__HfcStatusSummaryRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcStatusSummaryRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcStatusSummaryRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryRespT;
		if (size)
			*size = sizeof(ns1__HfcStatusSummaryRespT);
		((ns1__HfcStatusSummaryRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcStatusSummaryRespT);
		for (int i = 0; i < n; i++)
			((ns1__HfcStatusSummaryRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcStatusSummaryRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcStatusSummaryRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcStatusSummaryRespT %p -> %p\n", q, p));
	*(ns1__HfcStatusSummaryRespT*)p = *(ns1__HfcStatusSummaryRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaStatusSummaryRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaStatusSummaryRespT*)this)->mtaData = NULL;
	((ns1__MtaStatusSummaryRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__MtaStatusSummaryRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfMtaStatusSummaryT(soap, &((ns1__MtaStatusSummaryRespT*)this)->mtaData);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__MtaStatusSummaryRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__MtaStatusSummaryRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaStatusSummaryRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaStatusSummaryRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaStatusSummaryRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaStatusSummaryRespT(struct soap *soap, const char *tag, int id, const ns1__MtaStatusSummaryRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaStatusSummaryRespT), type);
	soap_out_PointerToArrayOfMtaStatusSummaryT(soap, "mtaData", -1, &(((ns1__MtaStatusSummaryRespT*)a)->mtaData), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__MtaStatusSummaryRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaStatusSummaryRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaStatusSummaryRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryRespT * SOAP_FMAC4 soap_get_ns1__MtaStatusSummaryRespT(struct soap *soap, ns1__MtaStatusSummaryRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaStatusSummaryRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaStatusSummaryRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaStatusSummaryRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryRespT * SOAP_FMAC4 soap_in_ns1__MtaStatusSummaryRespT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaStatusSummaryRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaStatusSummaryRespT, sizeof(ns1__MtaStatusSummaryRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaStatusSummaryRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaStatusSummaryRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mtaData1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtaData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfMtaStatusSummaryT(soap, "mtaData", &(((ns1__MtaStatusSummaryRespT*)a)->mtaData), "ns1:MtaStatusSummaryT"))
				{	soap_flag_mtaData1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__MtaStatusSummaryRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mtaData1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaStatusSummaryRespT, 0, sizeof(ns1__MtaStatusSummaryRespT), 0, soap_copy_ns1__MtaStatusSummaryRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaStatusSummaryRespT * SOAP_FMAC6 soap_new_ns1__MtaStatusSummaryRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaStatusSummaryRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaStatusSummaryRespT(struct soap *soap, ns1__MtaStatusSummaryRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaStatusSummaryRespT * SOAP_FMAC4 soap_instantiate_ns1__MtaStatusSummaryRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaStatusSummaryRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaStatusSummaryRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryRespT;
		if (size)
			*size = sizeof(ns1__MtaStatusSummaryRespT);
		((ns1__MtaStatusSummaryRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaStatusSummaryRespT);
		for (int i = 0; i < n; i++)
			((ns1__MtaStatusSummaryRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaStatusSummaryRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaStatusSummaryRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaStatusSummaryRespT %p -> %p\n", q, p));
	*(ns1__MtaStatusSummaryRespT*)p = *(ns1__MtaStatusSummaryRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmStatusSummaryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmStatusSummaryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmStatusSummaryT(soap, this->__ptr + i);
		}
}

int ArrayOfCmStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, int id, const ArrayOfCmStatusSummaryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmStatusSummaryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmStatusSummaryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmStatusSummaryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT * SOAP_FMAC4 soap_get_ArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT * SOAP_FMAC4 soap_in_ArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, ArrayOfCmStatusSummaryT *a, const char *type)
{	int i, j;
	ns1__CmStatusSummaryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmStatusSummaryT, sizeof(ArrayOfCmStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmStatusSummaryT **)soap_malloc(soap, sizeof(ns1__CmStatusSummaryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmStatusSummaryT(soap, NULL, a->__ptr + i, "ns1:CmStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmStatusSummaryT **)soap_push_block(soap, sizeof(ns1__CmStatusSummaryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmStatusSummaryT(soap, NULL, p, "ns1:CmStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmStatusSummaryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmStatusSummaryT, 0, sizeof(ArrayOfCmStatusSummaryT), 0, soap_copy_ArrayOfCmStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmStatusSummaryT * SOAP_FMAC6 soap_new_ArrayOfCmStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT * SOAP_FMAC4 soap_instantiate_ArrayOfCmStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmStatusSummaryT;
		if (size)
			*size = sizeof(ArrayOfCmStatusSummaryT);
		((ArrayOfCmStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmStatusSummaryT %p -> %p\n", q, p));
	*(ArrayOfCmStatusSummaryT*)p = *(ArrayOfCmStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmStatusSummaryT*)this)->statusSummary = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__CmStatusSummaryT*)this)->cmtsName);
	soap_default_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->hfcResId);
	soap_default_std__string(soap, &((ns1__CmStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

void ns1__CmStatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StatusSummaryT(soap, &((ns1__CmStatusSummaryT*)this)->statusSummary);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmStatusSummaryT*)this)->cmtsName);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->hfcName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

int ns1__CmStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__CmStatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusSummaryT), type);
	soap_out_PointerTons1__StatusSummaryT(soap, "statusSummary", -1, &(((ns1__CmStatusSummaryT*)a)->statusSummary), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__CmStatusSummaryT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__CmStatusSummaryT*)a)->cmtsName), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__CmStatusSummaryT*)a)->hfcResId), "");
	soap_out_std__string(soap, "hfcName", -1, &(((ns1__CmStatusSummaryT*)a)->hfcName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT * SOAP_FMAC4 soap_get_ns1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT * SOAP_FMAC4 soap_in_ns1__CmStatusSummaryT(struct soap *soap, const char *tag, ns1__CmStatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusSummaryT, sizeof(ns1__CmStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_statusSummary1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1, soap_flag_hfcResId1 = 1, soap_flag_hfcName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusSummary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StatusSummaryT(soap, "statusSummary", &(((ns1__CmStatusSummaryT*)a)->statusSummary), "ns1:StatusSummaryT"))
				{	soap_flag_statusSummary1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__CmStatusSummaryT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__CmStatusSummaryT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__CmStatusSummaryT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "hfcName", &(((ns1__CmStatusSummaryT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusSummary1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_hfcName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusSummaryT, 0, sizeof(ns1__CmStatusSummaryT), 0, soap_copy_ns1__CmStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusSummaryT * SOAP_FMAC6 soap_new_ns1__CmStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusSummaryT;
		if (size)
			*size = sizeof(ns1__CmStatusSummaryT);
		((ns1__CmStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusSummaryT %p -> %p\n", q, p));
	*(ns1__CmStatusSummaryT*)p = *(ns1__CmStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaStatusSummaryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaStatusSummaryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaStatusSummaryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaStatusSummaryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaStatusSummaryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaStatusSummaryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT * SOAP_FMAC4 soap_get_ArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT * SOAP_FMAC4 soap_in_ArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, ArrayOfMtaStatusSummaryT *a, const char *type)
{	int i, j;
	ns1__MtaStatusSummaryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaStatusSummaryT, sizeof(ArrayOfMtaStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaStatusSummaryT **)soap_malloc(soap, sizeof(ns1__MtaStatusSummaryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaStatusSummaryT(soap, NULL, a->__ptr + i, "ns1:MtaStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaStatusSummaryT **)soap_push_block(soap, sizeof(ns1__MtaStatusSummaryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaStatusSummaryT(soap, NULL, p, "ns1:MtaStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaStatusSummaryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaStatusSummaryT, 0, sizeof(ArrayOfMtaStatusSummaryT), 0, soap_copy_ArrayOfMtaStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaStatusSummaryT * SOAP_FMAC6 soap_new_ArrayOfMtaStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaStatusSummaryT;
		if (size)
			*size = sizeof(ArrayOfMtaStatusSummaryT);
		((ArrayOfMtaStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaStatusSummaryT %p -> %p\n", q, p));
	*(ArrayOfMtaStatusSummaryT*)p = *(ArrayOfMtaStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaStatusSummaryT*)this)->statusSummary = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsName);
	soap_default_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->hfcResId);
	soap_default_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

void ns1__MtaStatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StatusSummaryT(soap, &((ns1__MtaStatusSummaryT*)this)->statusSummary);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsName);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->hfcName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

int ns1__MtaStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaStatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__MtaStatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaStatusSummaryT), type);
	soap_out_PointerTons1__StatusSummaryT(soap, "statusSummary", -1, &(((ns1__MtaStatusSummaryT*)a)->statusSummary), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__MtaStatusSummaryT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__MtaStatusSummaryT*)a)->cmtsName), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__MtaStatusSummaryT*)a)->hfcResId), "");
	soap_out_std__string(soap, "hfcName", -1, &(((ns1__MtaStatusSummaryT*)a)->hfcName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT * SOAP_FMAC4 soap_get_ns1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT * SOAP_FMAC4 soap_in_ns1__MtaStatusSummaryT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaStatusSummaryT, sizeof(ns1__MtaStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaStatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaStatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_statusSummary1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1, soap_flag_hfcResId1 = 1, soap_flag_hfcName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusSummary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StatusSummaryT(soap, "statusSummary", &(((ns1__MtaStatusSummaryT*)a)->statusSummary), "ns1:StatusSummaryT"))
				{	soap_flag_statusSummary1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__MtaStatusSummaryT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__MtaStatusSummaryT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__MtaStatusSummaryT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "hfcName", &(((ns1__MtaStatusSummaryT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusSummary1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_hfcName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaStatusSummaryT, 0, sizeof(ns1__MtaStatusSummaryT), 0, soap_copy_ns1__MtaStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaStatusSummaryT * SOAP_FMAC6 soap_new_ns1__MtaStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__MtaStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryT;
		if (size)
			*size = sizeof(ns1__MtaStatusSummaryT);
		((ns1__MtaStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaStatusSummaryT %p -> %p\n", q, p));
	*(ns1__MtaStatusSummaryT*)p = *(ns1__MtaStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfHfcStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfHfcStatusSummaryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfHfcStatusSummaryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__HfcStatusSummaryT(soap, this->__ptr + i);
		}
}

int ArrayOfHfcStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfHfcStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfHfcStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfHfcStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, int id, const ArrayOfHfcStatusSummaryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:HfcStatusSummaryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfHfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__HfcStatusSummaryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfHfcStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfHfcStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT * SOAP_FMAC4 soap_get_ArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfHfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfHfcStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfHfcStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT * SOAP_FMAC4 soap_in_ArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, ArrayOfHfcStatusSummaryT *a, const char *type)
{	int i, j;
	ns1__HfcStatusSummaryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfHfcStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfHfcStatusSummaryT, sizeof(ArrayOfHfcStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__HfcStatusSummaryT **)soap_malloc(soap, sizeof(ns1__HfcStatusSummaryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__HfcStatusSummaryT(soap, NULL, a->__ptr + i, "ns1:HfcStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__HfcStatusSummaryT **)soap_push_block(soap, sizeof(ns1__HfcStatusSummaryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__HfcStatusSummaryT(soap, NULL, p, "ns1:HfcStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__HfcStatusSummaryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfHfcStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfHfcStatusSummaryT, 0, sizeof(ArrayOfHfcStatusSummaryT), 0, soap_copy_ArrayOfHfcStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfHfcStatusSummaryT * SOAP_FMAC6 soap_new_ArrayOfHfcStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfHfcStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT * SOAP_FMAC4 soap_instantiate_ArrayOfHfcStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfHfcStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfHfcStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfHfcStatusSummaryT;
		if (size)
			*size = sizeof(ArrayOfHfcStatusSummaryT);
		((ArrayOfHfcStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfHfcStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfHfcStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ArrayOfHfcStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfHfcStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfHfcStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfHfcStatusSummaryT %p -> %p\n", q, p));
	*(ArrayOfHfcStatusSummaryT*)p = *(ArrayOfHfcStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcStatusSummaryT*)this)->statusSummary = NULL;
	soap_default_xsd__integer(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsName);
	/* transient soap skipped */
}

void ns1__HfcStatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StatusSummaryT(soap, &((ns1__HfcStatusSummaryT*)this)->statusSummary);
	soap_embedded(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsName);
	/* transient soap skipped */
}

int ns1__HfcStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcStatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__HfcStatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcStatusSummaryT), type);
	soap_out_PointerTons1__StatusSummaryT(soap, "statusSummary", -1, &(((ns1__HfcStatusSummaryT*)a)->statusSummary), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__HfcStatusSummaryT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__HfcStatusSummaryT*)a)->cmtsName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT * SOAP_FMAC4 soap_get_ns1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT * SOAP_FMAC4 soap_in_ns1__HfcStatusSummaryT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcStatusSummaryT, sizeof(ns1__HfcStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcStatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcStatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_statusSummary1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusSummary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StatusSummaryT(soap, "statusSummary", &(((ns1__HfcStatusSummaryT*)a)->statusSummary), "ns1:StatusSummaryT"))
				{	soap_flag_statusSummary1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__HfcStatusSummaryT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__HfcStatusSummaryT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusSummary1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcStatusSummaryT, 0, sizeof(ns1__HfcStatusSummaryT), 0, soap_copy_ns1__HfcStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcStatusSummaryT * SOAP_FMAC6 soap_new_ns1__HfcStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__HfcStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryT;
		if (size)
			*size = sizeof(ns1__HfcStatusSummaryT);
		((ns1__HfcStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__HfcStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcStatusSummaryT %p -> %p\n", q, p));
	*(ns1__HfcStatusSummaryT*)p = *(ns1__HfcStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__StatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__StatusSummaryT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->resId);
	soap_default_std__string(soap, &((ns1__StatusSummaryT*)this)->name);
	soap_default_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumRedStatusTime);
	soap_default_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumGreenStatusTime);
	soap_default_short(soap, &((ns1__StatusSummaryT*)this)->sumStateChanges);
	/* transient soap skipped */
}

void ns1__StatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__StatusSummaryT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->resId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->resId);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__StatusSummaryT*)this)->name);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->sumRedStatusTime, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumRedStatusTime);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->sumGreenStatusTime, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumGreenStatusTime);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->sumStateChanges, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__StatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__StatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__StatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatusSummaryT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__StatusSummaryT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "resId", -1, &(((ns1__StatusSummaryT*)a)->resId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__StatusSummaryT*)a)->name), "");
	soap_out_xsd__integer(soap, "sumRedStatusTime", -1, &(((ns1__StatusSummaryT*)a)->sumRedStatusTime), "");
	soap_out_xsd__integer(soap, "sumGreenStatusTime", -1, &(((ns1__StatusSummaryT*)a)->sumGreenStatusTime), "");
	soap_out_short(soap, "sumStateChanges", -1, &(((ns1__StatusSummaryT*)a)->sumStateChanges), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__StatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StatusSummaryT * SOAP_FMAC4 soap_get_ns1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__StatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StatusSummaryT * SOAP_FMAC4 soap_in_ns1__StatusSummaryT(struct soap *soap, const char *tag, ns1__StatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatusSummaryT, sizeof(ns1__StatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_resId1 = 1, soap_flag_name1 = 1, soap_flag_sumRedStatusTime1 = 1, soap_flag_sumGreenStatusTime1 = 1, soap_flag_sumStateChanges1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__StatusSummaryT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_resId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "resId", &(((ns1__StatusSummaryT*)a)->resId), "xsd:integer"))
				{	soap_flag_resId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__StatusSummaryT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_sumRedStatusTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "sumRedStatusTime", &(((ns1__StatusSummaryT*)a)->sumRedStatusTime), "xsd:integer"))
				{	soap_flag_sumRedStatusTime1--;
					continue;
				}
			if (soap_flag_sumGreenStatusTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "sumGreenStatusTime", &(((ns1__StatusSummaryT*)a)->sumGreenStatusTime), "xsd:integer"))
				{	soap_flag_sumGreenStatusTime1--;
					continue;
				}
			if (soap_flag_sumStateChanges1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "sumStateChanges", &(((ns1__StatusSummaryT*)a)->sumStateChanges), "xsd:short"))
				{	soap_flag_sumStateChanges1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resId1 > 0 || soap_flag_name1 > 0 || soap_flag_sumRedStatusTime1 > 0 || soap_flag_sumGreenStatusTime1 > 0 || soap_flag_sumStateChanges1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StatusSummaryT, 0, sizeof(ns1__StatusSummaryT), 0, soap_copy_ns1__StatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__StatusSummaryT * SOAP_FMAC6 soap_new_ns1__StatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__StatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__StatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__StatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__StatusSummaryT;
		if (size)
			*size = sizeof(ns1__StatusSummaryT);
		((ns1__StatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__StatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__StatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StatusSummaryT %p -> %p\n", q, p));
	*(ns1__StatusSummaryT*)p = *(ns1__StatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__MtaDataT*)this)->provStatus);
	soap_default_std__string(soap, &((ns1__MtaDataT*)this)->provCounter);
	((ns1__MtaDataT*)this)->batteryStatus1 = NULL;
	((ns1__MtaDataT*)this)->batteryStatus2 = NULL;
	((ns1__MtaDataT*)this)->field1 = NULL;
	((ns1__MtaDataT*)this)->field2 = NULL;
	/* transient soap skipped */
}

void ns1__MtaDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaDataT*)this)->provStatus, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__MtaDataT*)this)->provCounter, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MtaDataT*)this)->provCounter);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->batteryStatus1);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->batteryStatus2);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->field1);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->field2);
	/* transient soap skipped */
}

int ns1__MtaDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaDataT(struct soap *soap, const char *tag, int id, const ns1__MtaDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaDataT), type);
	soap_out_short(soap, "provStatus", -1, &(((ns1__MtaDataT*)a)->provStatus), "");
	soap_out_std__string(soap, "provCounter", -1, &(((ns1__MtaDataT*)a)->provCounter), "");
	soap_out_PointerTostd__string(soap, "batteryStatus1", -1, &(((ns1__MtaDataT*)a)->batteryStatus1), "");
	soap_out_PointerTostd__string(soap, "batteryStatus2", -1, &(((ns1__MtaDataT*)a)->batteryStatus2), "");
	soap_out_PointerTostd__string(soap, "field1", -1, &(((ns1__MtaDataT*)a)->field1), "");
	soap_out_PointerTostd__string(soap, "field2", -1, &(((ns1__MtaDataT*)a)->field2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaDataT * SOAP_FMAC4 soap_get_ns1__MtaDataT(struct soap *soap, ns1__MtaDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaDataT * SOAP_FMAC4 soap_in_ns1__MtaDataT(struct soap *soap, const char *tag, ns1__MtaDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaDataT, sizeof(ns1__MtaDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_provStatus1 = 1, soap_flag_provCounter1 = 1, soap_flag_batteryStatus11 = 1, soap_flag_batteryStatus21 = 1, soap_flag_field11 = 1, soap_flag_field21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_provStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "provStatus", &(((ns1__MtaDataT*)a)->provStatus), "xsd:short"))
				{	soap_flag_provStatus1--;
					continue;
				}
			if (soap_flag_provCounter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "provCounter", &(((ns1__MtaDataT*)a)->provCounter), "xsd:string"))
				{	soap_flag_provCounter1--;
					continue;
				}
			if (soap_flag_batteryStatus11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "batteryStatus1", &(((ns1__MtaDataT*)a)->batteryStatus1), "xsd:string"))
				{	soap_flag_batteryStatus11--;
					continue;
				}
			if (soap_flag_batteryStatus21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "batteryStatus2", &(((ns1__MtaDataT*)a)->batteryStatus2), "xsd:string"))
				{	soap_flag_batteryStatus21--;
					continue;
				}
			if (soap_flag_field11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field1", &(((ns1__MtaDataT*)a)->field1), "xsd:string"))
				{	soap_flag_field11--;
					continue;
				}
			if (soap_flag_field21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field2", &(((ns1__MtaDataT*)a)->field2), "xsd:string"))
				{	soap_flag_field21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_provStatus1 > 0 || soap_flag_provCounter1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaDataT, 0, sizeof(ns1__MtaDataT), 0, soap_copy_ns1__MtaDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaDataT * SOAP_FMAC6 soap_new_ns1__MtaDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaDataT(struct soap *soap, ns1__MtaDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaDataT * SOAP_FMAC4 soap_instantiate_ns1__MtaDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaDataT;
		if (size)
			*size = sizeof(ns1__MtaDataT);
		((ns1__MtaDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaDataT);
		for (int i = 0; i < n; i++)
			((ns1__MtaDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaDataT %p -> %p\n", q, p));
	*(ns1__MtaDataT*)p = *(ns1__MtaDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__CmDataT*)this)->downstreamSNR);
	soap_default_short(soap, &((ns1__CmDataT*)this)->downstreamPower);
	soap_default_short(soap, &((ns1__CmDataT*)this)->upstreamPower);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t1Count);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t2Count);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t3Count);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t4Count);
	((ns1__CmDataT*)this)->field1 = NULL;
	((ns1__CmDataT*)this)->field2 = NULL;
	/* transient soap skipped */
}

void ns1__CmDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmDataT*)this)->downstreamSNR, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmDataT*)this)->downstreamPower, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmDataT*)this)->upstreamPower, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t1Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t1Count);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t2Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t2Count);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t3Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t3Count);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t4Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t4Count);
	soap_serialize_PointerTostd__string(soap, &((ns1__CmDataT*)this)->field1);
	soap_serialize_PointerTostd__string(soap, &((ns1__CmDataT*)this)->field2);
	/* transient soap skipped */
}

int ns1__CmDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmDataT(struct soap *soap, const char *tag, int id, const ns1__CmDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmDataT), type);
	soap_out_short(soap, "downstreamSNR", -1, &(((ns1__CmDataT*)a)->downstreamSNR), "");
	soap_out_short(soap, "downstreamPower", -1, &(((ns1__CmDataT*)a)->downstreamPower), "");
	soap_out_short(soap, "upstreamPower", -1, &(((ns1__CmDataT*)a)->upstreamPower), "");
	soap_out_std__string(soap, "t1Count", -1, &(((ns1__CmDataT*)a)->t1Count), "");
	soap_out_std__string(soap, "t2Count", -1, &(((ns1__CmDataT*)a)->t2Count), "");
	soap_out_std__string(soap, "t3Count", -1, &(((ns1__CmDataT*)a)->t3Count), "");
	soap_out_std__string(soap, "t4Count", -1, &(((ns1__CmDataT*)a)->t4Count), "");
	soap_out_PointerTostd__string(soap, "field1", -1, &(((ns1__CmDataT*)a)->field1), "");
	soap_out_PointerTostd__string(soap, "field2", -1, &(((ns1__CmDataT*)a)->field2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmDataT * SOAP_FMAC4 soap_get_ns1__CmDataT(struct soap *soap, ns1__CmDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmDataT * SOAP_FMAC4 soap_in_ns1__CmDataT(struct soap *soap, const char *tag, ns1__CmDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmDataT, sizeof(ns1__CmDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_downstreamSNR1 = 1, soap_flag_downstreamPower1 = 1, soap_flag_upstreamPower1 = 1, soap_flag_t1Count1 = 1, soap_flag_t2Count1 = 1, soap_flag_t3Count1 = 1, soap_flag_t4Count1 = 1, soap_flag_field11 = 1, soap_flag_field21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_downstreamSNR1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "downstreamSNR", &(((ns1__CmDataT*)a)->downstreamSNR), "xsd:short"))
				{	soap_flag_downstreamSNR1--;
					continue;
				}
			if (soap_flag_downstreamPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "downstreamPower", &(((ns1__CmDataT*)a)->downstreamPower), "xsd:short"))
				{	soap_flag_downstreamPower1--;
					continue;
				}
			if (soap_flag_upstreamPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "upstreamPower", &(((ns1__CmDataT*)a)->upstreamPower), "xsd:short"))
				{	soap_flag_upstreamPower1--;
					continue;
				}
			if (soap_flag_t1Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t1Count", &(((ns1__CmDataT*)a)->t1Count), "xsd:string"))
				{	soap_flag_t1Count1--;
					continue;
				}
			if (soap_flag_t2Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t2Count", &(((ns1__CmDataT*)a)->t2Count), "xsd:string"))
				{	soap_flag_t2Count1--;
					continue;
				}
			if (soap_flag_t3Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t3Count", &(((ns1__CmDataT*)a)->t3Count), "xsd:string"))
				{	soap_flag_t3Count1--;
					continue;
				}
			if (soap_flag_t4Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t4Count", &(((ns1__CmDataT*)a)->t4Count), "xsd:string"))
				{	soap_flag_t4Count1--;
					continue;
				}
			if (soap_flag_field11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field1", &(((ns1__CmDataT*)a)->field1), "xsd:string"))
				{	soap_flag_field11--;
					continue;
				}
			if (soap_flag_field21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field2", &(((ns1__CmDataT*)a)->field2), "xsd:string"))
				{	soap_flag_field21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_downstreamSNR1 > 0 || soap_flag_downstreamPower1 > 0 || soap_flag_upstreamPower1 > 0 || soap_flag_t1Count1 > 0 || soap_flag_t2Count1 > 0 || soap_flag_t3Count1 > 0 || soap_flag_t4Count1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmDataT, 0, sizeof(ns1__CmDataT), 0, soap_copy_ns1__CmDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmDataT * SOAP_FMAC6 soap_new_ns1__CmDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmDataT(struct soap *soap, ns1__CmDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmDataT * SOAP_FMAC4 soap_instantiate_ns1__CmDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmDataT;
		if (size)
			*size = sizeof(ns1__CmDataT);
		((ns1__CmDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmDataT);
		for (int i = 0; i < n; i++)
			((ns1__CmDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmDataT %p -> %p\n", q, p));
	*(ns1__CmDataT*)p = *(ns1__CmDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsCmDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmIpAddress);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmMac);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelIndex);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->downstreamChannelIndex);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelStatus);
	((ns1__CmtsCmDataT*)this)->field1 = NULL;
	((ns1__CmtsCmDataT*)this)->field2 = NULL;
	/* transient soap skipped */
}

void ns1__CmtsCmDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->cmIpAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmIpAddress);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->cmMac, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmMac);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelIndex, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelIndex);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->downstreamChannelIndex, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->downstreamChannelIndex);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelStatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelStatus);
	soap_serialize_PointerTostd__string(soap, &((ns1__CmtsCmDataT*)this)->field1);
	soap_serialize_PointerTostd__string(soap, &((ns1__CmtsCmDataT*)this)->field2);
	/* transient soap skipped */
}

int ns1__CmtsCmDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsCmDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsCmDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsCmDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsCmDataT(struct soap *soap, const char *tag, int id, const ns1__CmtsCmDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsCmDataT), type);
	soap_out_std__string(soap, "cmIpAddress", -1, &(((ns1__CmtsCmDataT*)a)->cmIpAddress), "");
	soap_out_std__string(soap, "cmMac", -1, &(((ns1__CmtsCmDataT*)a)->cmMac), "");
	soap_out_std__string(soap, "upstreamChannelIndex", -1, &(((ns1__CmtsCmDataT*)a)->upstreamChannelIndex), "");
	soap_out_std__string(soap, "downstreamChannelIndex", -1, &(((ns1__CmtsCmDataT*)a)->downstreamChannelIndex), "");
	soap_out_std__string(soap, "upstreamChannelStatus", -1, &(((ns1__CmtsCmDataT*)a)->upstreamChannelStatus), "");
	soap_out_PointerTostd__string(soap, "field1", -1, &(((ns1__CmtsCmDataT*)a)->field1), "");
	soap_out_PointerTostd__string(soap, "field2", -1, &(((ns1__CmtsCmDataT*)a)->field2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsCmDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsCmDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsCmDataT * SOAP_FMAC4 soap_get_ns1__CmtsCmDataT(struct soap *soap, ns1__CmtsCmDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsCmDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsCmDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsCmDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsCmDataT * SOAP_FMAC4 soap_in_ns1__CmtsCmDataT(struct soap *soap, const char *tag, ns1__CmtsCmDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsCmDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsCmDataT, sizeof(ns1__CmtsCmDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsCmDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsCmDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmIpAddress1 = 1, soap_flag_cmMac1 = 1, soap_flag_upstreamChannelIndex1 = 1, soap_flag_downstreamChannelIndex1 = 1, soap_flag_upstreamChannelStatus1 = 1, soap_flag_field11 = 1, soap_flag_field21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmIpAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmIpAddress", &(((ns1__CmtsCmDataT*)a)->cmIpAddress), "xsd:string"))
				{	soap_flag_cmIpAddress1--;
					continue;
				}
			if (soap_flag_cmMac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmMac", &(((ns1__CmtsCmDataT*)a)->cmMac), "xsd:string"))
				{	soap_flag_cmMac1--;
					continue;
				}
			if (soap_flag_upstreamChannelIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamChannelIndex", &(((ns1__CmtsCmDataT*)a)->upstreamChannelIndex), "xsd:string"))
				{	soap_flag_upstreamChannelIndex1--;
					continue;
				}
			if (soap_flag_downstreamChannelIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamChannelIndex", &(((ns1__CmtsCmDataT*)a)->downstreamChannelIndex), "xsd:string"))
				{	soap_flag_downstreamChannelIndex1--;
					continue;
				}
			if (soap_flag_upstreamChannelStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamChannelStatus", &(((ns1__CmtsCmDataT*)a)->upstreamChannelStatus), "xsd:string"))
				{	soap_flag_upstreamChannelStatus1--;
					continue;
				}
			if (soap_flag_field11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field1", &(((ns1__CmtsCmDataT*)a)->field1), "xsd:string"))
				{	soap_flag_field11--;
					continue;
				}
			if (soap_flag_field21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field2", &(((ns1__CmtsCmDataT*)a)->field2), "xsd:string"))
				{	soap_flag_field21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmIpAddress1 > 0 || soap_flag_cmMac1 > 0 || soap_flag_upstreamChannelIndex1 > 0 || soap_flag_downstreamChannelIndex1 > 0 || soap_flag_upstreamChannelStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsCmDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsCmDataT, 0, sizeof(ns1__CmtsCmDataT), 0, soap_copy_ns1__CmtsCmDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsCmDataT * SOAP_FMAC6 soap_new_ns1__CmtsCmDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsCmDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsCmDataT(struct soap *soap, ns1__CmtsCmDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsCmDataT * SOAP_FMAC4 soap_instantiate_ns1__CmtsCmDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsCmDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsCmDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsCmDataT;
		if (size)
			*size = sizeof(ns1__CmtsCmDataT);
		((ns1__CmtsCmDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsCmDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsCmDataT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsCmDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsCmDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsCmDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsCmDataT %p -> %p\n", q, p));
	*(ns1__CmtsCmDataT*)p = *(ns1__CmtsCmDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmPerformanceConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamSnrLower);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerLower);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerUpper);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerLower);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerUpper);
	/* transient soap skipped */
}

void ns1__CmPerformanceConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamSnrLower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamSnrLower);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerLower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerLower);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerUpper, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerUpper);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerLower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerLower);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerUpper, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerUpper);
	/* transient soap skipped */
}

int ns1__CmPerformanceConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmPerformanceConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmPerformanceConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmPerformanceConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmPerformanceConfigT(struct soap *soap, const char *tag, int id, const ns1__CmPerformanceConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmPerformanceConfigT), type);
	soap_out_std__string(soap, "downstreamSnrLower", -1, &(((ns1__CmPerformanceConfigT*)a)->downstreamSnrLower), "");
	soap_out_std__string(soap, "downstreamPowerLower", -1, &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerLower), "");
	soap_out_std__string(soap, "downstreamPowerUpper", -1, &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerUpper), "");
	soap_out_std__string(soap, "upstreamPowerLower", -1, &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerLower), "");
	soap_out_std__string(soap, "upstreamPowerUpper", -1, &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerUpper), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmPerformanceConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmPerformanceConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmPerformanceConfigT * SOAP_FMAC4 soap_get_ns1__CmPerformanceConfigT(struct soap *soap, ns1__CmPerformanceConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmPerformanceConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmPerformanceConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmPerformanceConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmPerformanceConfigT * SOAP_FMAC4 soap_in_ns1__CmPerformanceConfigT(struct soap *soap, const char *tag, ns1__CmPerformanceConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmPerformanceConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmPerformanceConfigT, sizeof(ns1__CmPerformanceConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmPerformanceConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmPerformanceConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_downstreamSnrLower1 = 1, soap_flag_downstreamPowerLower1 = 1, soap_flag_downstreamPowerUpper1 = 1, soap_flag_upstreamPowerLower1 = 1, soap_flag_upstreamPowerUpper1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_downstreamSnrLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamSnrLower", &(((ns1__CmPerformanceConfigT*)a)->downstreamSnrLower), "xsd:string"))
				{	soap_flag_downstreamSnrLower1--;
					continue;
				}
			if (soap_flag_downstreamPowerLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamPowerLower", &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerLower), "xsd:string"))
				{	soap_flag_downstreamPowerLower1--;
					continue;
				}
			if (soap_flag_downstreamPowerUpper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamPowerUpper", &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerUpper), "xsd:string"))
				{	soap_flag_downstreamPowerUpper1--;
					continue;
				}
			if (soap_flag_upstreamPowerLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamPowerLower", &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerLower), "xsd:string"))
				{	soap_flag_upstreamPowerLower1--;
					continue;
				}
			if (soap_flag_upstreamPowerUpper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamPowerUpper", &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerUpper), "xsd:string"))
				{	soap_flag_upstreamPowerUpper1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_downstreamSnrLower1 > 0 || soap_flag_downstreamPowerLower1 > 0 || soap_flag_downstreamPowerUpper1 > 0 || soap_flag_upstreamPowerLower1 > 0 || soap_flag_upstreamPowerUpper1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmPerformanceConfigT, 0, sizeof(ns1__CmPerformanceConfigT), 0, soap_copy_ns1__CmPerformanceConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmPerformanceConfigT * SOAP_FMAC6 soap_new_ns1__CmPerformanceConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmPerformanceConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmPerformanceConfigT(struct soap *soap, ns1__CmPerformanceConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmPerformanceConfigT * SOAP_FMAC4 soap_instantiate_ns1__CmPerformanceConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmPerformanceConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmPerformanceConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmPerformanceConfigT;
		if (size)
			*size = sizeof(ns1__CmPerformanceConfigT);
		((ns1__CmPerformanceConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmPerformanceConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmPerformanceConfigT);
		for (int i = 0; i < n; i++)
			((ns1__CmPerformanceConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmPerformanceConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmPerformanceConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmPerformanceConfigT %p -> %p\n", q, p));
	*(ns1__CmPerformanceConfigT*)p = *(ns1__CmPerformanceConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmsAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmsAlarmConfigT*)this)->cmsLossOfComm = NULL;
	/* transient soap skipped */
}

void ns1__CmsAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AlarmTypeConfigT(soap, &((ns1__CmsAlarmConfigT*)this)->cmsLossOfComm);
	/* transient soap skipped */
}

int ns1__CmsAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmsAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmsAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmsAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmsAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__CmsAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmsAlarmConfigT), type);
	soap_out_PointerTons1__AlarmTypeConfigT(soap, "cmsLossOfComm", -1, &(((ns1__CmsAlarmConfigT*)a)->cmsLossOfComm), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmsAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmsAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmsAlarmConfigT * SOAP_FMAC4 soap_get_ns1__CmsAlarmConfigT(struct soap *soap, ns1__CmsAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmsAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmsAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmsAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmsAlarmConfigT * SOAP_FMAC4 soap_in_ns1__CmsAlarmConfigT(struct soap *soap, const char *tag, ns1__CmsAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmsAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmsAlarmConfigT, sizeof(ns1__CmsAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmsAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmsAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmsLossOfComm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmsLossOfComm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AlarmTypeConfigT(soap, "cmsLossOfComm", &(((ns1__CmsAlarmConfigT*)a)->cmsLossOfComm), "ns1:AlarmTypeConfigT"))
				{	soap_flag_cmsLossOfComm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmsLossOfComm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmsAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmsAlarmConfigT, 0, sizeof(ns1__CmsAlarmConfigT), 0, soap_copy_ns1__CmsAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmsAlarmConfigT * SOAP_FMAC6 soap_new_ns1__CmsAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmsAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmsAlarmConfigT(struct soap *soap, ns1__CmsAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmsAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__CmsAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmsAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmsAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmsAlarmConfigT;
		if (size)
			*size = sizeof(ns1__CmsAlarmConfigT);
		((ns1__CmsAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmsAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmsAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__CmsAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmsAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmsAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmsAlarmConfigT %p -> %p\n", q, p));
	*(ns1__CmsAlarmConfigT*)p = *(ns1__CmsAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmtsAlarmConfigT*)this)->cmtsDown = NULL;
	/* transient soap skipped */
}

void ns1__CmtsAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AlarmTypeConfigT(soap, &((ns1__CmtsAlarmConfigT*)this)->cmtsDown);
	/* transient soap skipped */
}

int ns1__CmtsAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__CmtsAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsAlarmConfigT), type);
	soap_out_PointerTons1__AlarmTypeConfigT(soap, "cmtsDown", -1, &(((ns1__CmtsAlarmConfigT*)a)->cmtsDown), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT * SOAP_FMAC4 soap_get_ns1__CmtsAlarmConfigT(struct soap *soap, ns1__CmtsAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT * SOAP_FMAC4 soap_in_ns1__CmtsAlarmConfigT(struct soap *soap, const char *tag, ns1__CmtsAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsAlarmConfigT, sizeof(ns1__CmtsAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmtsDown1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmtsDown1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AlarmTypeConfigT(soap, "cmtsDown", &(((ns1__CmtsAlarmConfigT*)a)->cmtsDown), "ns1:AlarmTypeConfigT"))
				{	soap_flag_cmtsDown1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmtsDown1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsAlarmConfigT, 0, sizeof(ns1__CmtsAlarmConfigT), 0, soap_copy_ns1__CmtsAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsAlarmConfigT * SOAP_FMAC6 soap_new_ns1__CmtsAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsAlarmConfigT(struct soap *soap, ns1__CmtsAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__CmtsAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsAlarmConfigT;
		if (size)
			*size = sizeof(ns1__CmtsAlarmConfigT);
		((ns1__CmtsAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsAlarmConfigT %p -> %p\n", q, p));
	*(ns1__CmtsAlarmConfigT*)p = *(ns1__CmtsAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaAlarmConfigT*)this)->alarmTypes = NULL;
	/* transient soap skipped */
}

void ns1__MtaAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmTypeConfigT(soap, &((ns1__MtaAlarmConfigT*)this)->alarmTypes);
	/* transient soap skipped */
}

int ns1__MtaAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__MtaAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaAlarmConfigT), type);
	soap_out_PointerToArrayOfAlarmTypeConfigT(soap, "alarmTypes", -1, &(((ns1__MtaAlarmConfigT*)a)->alarmTypes), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaAlarmConfigT * SOAP_FMAC4 soap_get_ns1__MtaAlarmConfigT(struct soap *soap, ns1__MtaAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaAlarmConfigT * SOAP_FMAC4 soap_in_ns1__MtaAlarmConfigT(struct soap *soap, const char *tag, ns1__MtaAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaAlarmConfigT, sizeof(ns1__MtaAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmTypes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmTypes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmTypeConfigT(soap, "alarmTypes", &(((ns1__MtaAlarmConfigT*)a)->alarmTypes), "ns1:AlarmTypeConfigT"))
				{	soap_flag_alarmTypes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmTypes1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaAlarmConfigT, 0, sizeof(ns1__MtaAlarmConfigT), 0, soap_copy_ns1__MtaAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaAlarmConfigT * SOAP_FMAC6 soap_new_ns1__MtaAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaAlarmConfigT(struct soap *soap, ns1__MtaAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__MtaAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaAlarmConfigT;
		if (size)
			*size = sizeof(ns1__MtaAlarmConfigT);
		((ns1__MtaAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__MtaAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaAlarmConfigT %p -> %p\n", q, p));
	*(ns1__MtaAlarmConfigT*)p = *(ns1__MtaAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAlarmTypeConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAlarmTypeConfigT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAlarmTypeConfigT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AlarmTypeConfigT(soap, this->__ptr + i);
		}
}

int ArrayOfAlarmTypeConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAlarmTypeConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAlarmTypeConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAlarmTypeConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, int id, const ArrayOfAlarmTypeConfigT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AlarmTypeConfigT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AlarmTypeConfigT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAlarmTypeConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAlarmTypeConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT * SOAP_FMAC4 soap_get_ArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAlarmTypeConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAlarmTypeConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT * SOAP_FMAC4 soap_in_ArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, ArrayOfAlarmTypeConfigT *a, const char *type)
{	int i, j;
	ns1__AlarmTypeConfigT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAlarmTypeConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAlarmTypeConfigT, sizeof(ArrayOfAlarmTypeConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AlarmTypeConfigT **)soap_malloc(soap, sizeof(ns1__AlarmTypeConfigT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AlarmTypeConfigT(soap, NULL, a->__ptr + i, "ns1:AlarmTypeConfigT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AlarmTypeConfigT **)soap_push_block(soap, sizeof(ns1__AlarmTypeConfigT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AlarmTypeConfigT(soap, NULL, p, "ns1:AlarmTypeConfigT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AlarmTypeConfigT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmTypeConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAlarmTypeConfigT, 0, sizeof(ArrayOfAlarmTypeConfigT), 0, soap_copy_ArrayOfAlarmTypeConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAlarmTypeConfigT * SOAP_FMAC6 soap_new_ArrayOfAlarmTypeConfigT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAlarmTypeConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT * SOAP_FMAC4 soap_instantiate_ArrayOfAlarmTypeConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAlarmTypeConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAlarmTypeConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAlarmTypeConfigT;
		if (size)
			*size = sizeof(ArrayOfAlarmTypeConfigT);
		((ArrayOfAlarmTypeConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAlarmTypeConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAlarmTypeConfigT);
		for (int i = 0; i < n; i++)
			((ArrayOfAlarmTypeConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAlarmTypeConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAlarmTypeConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAlarmTypeConfigT %p -> %p\n", q, p));
	*(ArrayOfAlarmTypeConfigT*)p = *(ArrayOfAlarmTypeConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AlarmTypeConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__AlarmTypeConfigT*)this)->alarmType);
	((ns1__AlarmTypeConfigT*)this)->soakWindow = NULL;
	/* transient soap skipped */
}

void ns1__AlarmTypeConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AlarmTypeConfigT*)this)->alarmType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmTypeConfigT*)this)->alarmType);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__AlarmTypeConfigT*)this)->soakWindow);
	/* transient soap skipped */
}

int ns1__AlarmTypeConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AlarmTypeConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AlarmTypeConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AlarmTypeConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AlarmTypeConfigT(struct soap *soap, const char *tag, int id, const ns1__AlarmTypeConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AlarmTypeConfigT), type);
	soap_out_std__string(soap, "alarmType", -1, &(((ns1__AlarmTypeConfigT*)a)->alarmType), "");
	soap_out_PointerTons1__SoakWindowT(soap, "soakWindow", -1, &(((ns1__AlarmTypeConfigT*)a)->soakWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AlarmTypeConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AlarmTypeConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT * SOAP_FMAC4 soap_get_ns1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AlarmTypeConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AlarmTypeConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT * SOAP_FMAC4 soap_in_ns1__AlarmTypeConfigT(struct soap *soap, const char *tag, ns1__AlarmTypeConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AlarmTypeConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AlarmTypeConfigT, sizeof(ns1__AlarmTypeConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AlarmTypeConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AlarmTypeConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmType1 = 1, soap_flag_soakWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmType", &(((ns1__AlarmTypeConfigT*)a)->alarmType), "xsd:string"))
				{	soap_flag_alarmType1--;
					continue;
				}
			if (soap_flag_soakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "soakWindow", &(((ns1__AlarmTypeConfigT*)a)->soakWindow), "ns1:SoakWindowT"))
				{	soap_flag_soakWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmType1 > 0 || soap_flag_soakWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AlarmTypeConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AlarmTypeConfigT, 0, sizeof(ns1__AlarmTypeConfigT), 0, soap_copy_ns1__AlarmTypeConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AlarmTypeConfigT * SOAP_FMAC6 soap_new_ns1__AlarmTypeConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AlarmTypeConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT * SOAP_FMAC4 soap_instantiate_ns1__AlarmTypeConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AlarmTypeConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AlarmTypeConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AlarmTypeConfigT;
		if (size)
			*size = sizeof(ns1__AlarmTypeConfigT);
		((ns1__AlarmTypeConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AlarmTypeConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AlarmTypeConfigT);
		for (int i = 0; i < n; i++)
			((ns1__AlarmTypeConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AlarmTypeConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AlarmTypeConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AlarmTypeConfigT %p -> %p\n", q, p));
	*(ns1__AlarmTypeConfigT*)p = *(ns1__AlarmTypeConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcAlarmConfigT*)this)->cmThresold = NULL;
	((ns1__HfcAlarmConfigT*)this)->cmSoakWindow = NULL;
	((ns1__HfcAlarmConfigT*)this)->mtaThresold = NULL;
	((ns1__HfcAlarmConfigT*)this)->mtaSoakWindow = NULL;
	((ns1__HfcAlarmConfigT*)this)->powerThresold = NULL;
	((ns1__HfcAlarmConfigT*)this)->powerSoakWindow = NULL;
	/* transient soap skipped */
}

void ns1__HfcAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AggregateCmOfflineTresholdT(soap, &((ns1__HfcAlarmConfigT*)this)->cmThresold);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__HfcAlarmConfigT*)this)->cmSoakWindow);
	soap_serialize_PointerTons1__AggregateMtaTresholdT(soap, &((ns1__HfcAlarmConfigT*)this)->mtaThresold);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__HfcAlarmConfigT*)this)->mtaSoakWindow);
	soap_serialize_PointerTons1__HfcPowerTresholdT(soap, &((ns1__HfcAlarmConfigT*)this)->powerThresold);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__HfcAlarmConfigT*)this)->powerSoakWindow);
	/* transient soap skipped */
}

int ns1__HfcAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__HfcAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcAlarmConfigT), type);
	soap_out_PointerTons1__AggregateCmOfflineTresholdT(soap, "cmThresold", -1, &(((ns1__HfcAlarmConfigT*)a)->cmThresold), "");
	soap_out_PointerTons1__SoakWindowT(soap, "cmSoakWindow", -1, &(((ns1__HfcAlarmConfigT*)a)->cmSoakWindow), "");
	soap_out_PointerTons1__AggregateMtaTresholdT(soap, "mtaThresold", -1, &(((ns1__HfcAlarmConfigT*)a)->mtaThresold), "");
	soap_out_PointerTons1__SoakWindowT(soap, "mtaSoakWindow", -1, &(((ns1__HfcAlarmConfigT*)a)->mtaSoakWindow), "");
	soap_out_PointerTons1__HfcPowerTresholdT(soap, "powerThresold", -1, &(((ns1__HfcAlarmConfigT*)a)->powerThresold), "");
	soap_out_PointerTons1__SoakWindowT(soap, "powerSoakWindow", -1, &(((ns1__HfcAlarmConfigT*)a)->powerSoakWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcAlarmConfigT * SOAP_FMAC4 soap_get_ns1__HfcAlarmConfigT(struct soap *soap, ns1__HfcAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcAlarmConfigT * SOAP_FMAC4 soap_in_ns1__HfcAlarmConfigT(struct soap *soap, const char *tag, ns1__HfcAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcAlarmConfigT, sizeof(ns1__HfcAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmThresold1 = 1, soap_flag_cmSoakWindow1 = 1, soap_flag_mtaThresold1 = 1, soap_flag_mtaSoakWindow1 = 1, soap_flag_powerThresold1 = 1, soap_flag_powerSoakWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmThresold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AggregateCmOfflineTresholdT(soap, "cmThresold", &(((ns1__HfcAlarmConfigT*)a)->cmThresold), "ns1:AggregateCmOfflineTresholdT"))
				{	soap_flag_cmThresold1--;
					continue;
				}
			if (soap_flag_cmSoakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "cmSoakWindow", &(((ns1__HfcAlarmConfigT*)a)->cmSoakWindow), "ns1:SoakWindowT"))
				{	soap_flag_cmSoakWindow1--;
					continue;
				}
			if (soap_flag_mtaThresold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AggregateMtaTresholdT(soap, "mtaThresold", &(((ns1__HfcAlarmConfigT*)a)->mtaThresold), "ns1:AggregateMtaTresholdT"))
				{	soap_flag_mtaThresold1--;
					continue;
				}
			if (soap_flag_mtaSoakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "mtaSoakWindow", &(((ns1__HfcAlarmConfigT*)a)->mtaSoakWindow), "ns1:SoakWindowT"))
				{	soap_flag_mtaSoakWindow1--;
					continue;
				}
			if (soap_flag_powerThresold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HfcPowerTresholdT(soap, "powerThresold", &(((ns1__HfcAlarmConfigT*)a)->powerThresold), "ns1:HfcPowerTresholdT"))
				{	soap_flag_powerThresold1--;
					continue;
				}
			if (soap_flag_powerSoakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "powerSoakWindow", &(((ns1__HfcAlarmConfigT*)a)->powerSoakWindow), "ns1:SoakWindowT"))
				{	soap_flag_powerSoakWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmThresold1 > 0 || soap_flag_cmSoakWindow1 > 0 || soap_flag_mtaThresold1 > 0 || soap_flag_mtaSoakWindow1 > 0 || soap_flag_powerThresold1 > 0 || soap_flag_powerSoakWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcAlarmConfigT, 0, sizeof(ns1__HfcAlarmConfigT), 0, soap_copy_ns1__HfcAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcAlarmConfigT * SOAP_FMAC6 soap_new_ns1__HfcAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcAlarmConfigT(struct soap *soap, ns1__HfcAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__HfcAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcAlarmConfigT;
		if (size)
			*size = sizeof(ns1__HfcAlarmConfigT);
		((ns1__HfcAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__HfcAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcAlarmConfigT %p -> %p\n", q, p));
	*(ns1__HfcAlarmConfigT*)p = *(ns1__HfcAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcPowerTresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->thresholdCount);
	soap_default_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

void ns1__HfcPowerTresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__HfcPowerTresholdT*)this)->thresholdCount, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->thresholdCount);
	soap_embedded(soap, &((ns1__HfcPowerTresholdT*)this)->detectionWindow, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

int ns1__HfcPowerTresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcPowerTresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcPowerTresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcPowerTresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcPowerTresholdT(struct soap *soap, const char *tag, int id, const ns1__HfcPowerTresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcPowerTresholdT), type);
	soap_out_std__string(soap, "thresholdCount", -1, &(((ns1__HfcPowerTresholdT*)a)->thresholdCount), "");
	soap_out_std__string(soap, "detectionWindow", -1, &(((ns1__HfcPowerTresholdT*)a)->detectionWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcPowerTresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcPowerTresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT * SOAP_FMAC4 soap_get_ns1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcPowerTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcPowerTresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcPowerTresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT * SOAP_FMAC4 soap_in_ns1__HfcPowerTresholdT(struct soap *soap, const char *tag, ns1__HfcPowerTresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcPowerTresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcPowerTresholdT, sizeof(ns1__HfcPowerTresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcPowerTresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcPowerTresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_thresholdCount1 = 1, soap_flag_detectionWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_thresholdCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "thresholdCount", &(((ns1__HfcPowerTresholdT*)a)->thresholdCount), "xsd:string"))
				{	soap_flag_thresholdCount1--;
					continue;
				}
			if (soap_flag_detectionWindow1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "detectionWindow", &(((ns1__HfcPowerTresholdT*)a)->detectionWindow), "xsd:string"))
				{	soap_flag_detectionWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_thresholdCount1 > 0 || soap_flag_detectionWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcPowerTresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcPowerTresholdT, 0, sizeof(ns1__HfcPowerTresholdT), 0, soap_copy_ns1__HfcPowerTresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcPowerTresholdT * SOAP_FMAC6 soap_new_ns1__HfcPowerTresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcPowerTresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT * SOAP_FMAC4 soap_instantiate_ns1__HfcPowerTresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcPowerTresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcPowerTresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcPowerTresholdT;
		if (size)
			*size = sizeof(ns1__HfcPowerTresholdT);
		((ns1__HfcPowerTresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcPowerTresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcPowerTresholdT);
		for (int i = 0; i < n; i++)
			((ns1__HfcPowerTresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcPowerTresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcPowerTresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcPowerTresholdT %p -> %p\n", q, p));
	*(ns1__HfcPowerTresholdT*)p = *(ns1__HfcPowerTresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AggregateMtaTresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->mtaThresholdCount);
	soap_default_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

void ns1__AggregateMtaTresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AggregateMtaTresholdT*)this)->mtaThresholdCount, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->mtaThresholdCount);
	soap_embedded(soap, &((ns1__AggregateMtaTresholdT*)this)->detectionWindow, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

int ns1__AggregateMtaTresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AggregateMtaTresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AggregateMtaTresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AggregateMtaTresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AggregateMtaTresholdT(struct soap *soap, const char *tag, int id, const ns1__AggregateMtaTresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AggregateMtaTresholdT), type);
	soap_out_std__string(soap, "mtaThresholdCount", -1, &(((ns1__AggregateMtaTresholdT*)a)->mtaThresholdCount), "");
	soap_out_std__string(soap, "detectionWindow", -1, &(((ns1__AggregateMtaTresholdT*)a)->detectionWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AggregateMtaTresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AggregateMtaTresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT * SOAP_FMAC4 soap_get_ns1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AggregateMtaTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AggregateMtaTresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AggregateMtaTresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT * SOAP_FMAC4 soap_in_ns1__AggregateMtaTresholdT(struct soap *soap, const char *tag, ns1__AggregateMtaTresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AggregateMtaTresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AggregateMtaTresholdT, sizeof(ns1__AggregateMtaTresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AggregateMtaTresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AggregateMtaTresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mtaThresholdCount1 = 1, soap_flag_detectionWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtaThresholdCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mtaThresholdCount", &(((ns1__AggregateMtaTresholdT*)a)->mtaThresholdCount), "xsd:string"))
				{	soap_flag_mtaThresholdCount1--;
					continue;
				}
			if (soap_flag_detectionWindow1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "detectionWindow", &(((ns1__AggregateMtaTresholdT*)a)->detectionWindow), "xsd:string"))
				{	soap_flag_detectionWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mtaThresholdCount1 > 0 || soap_flag_detectionWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AggregateMtaTresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AggregateMtaTresholdT, 0, sizeof(ns1__AggregateMtaTresholdT), 0, soap_copy_ns1__AggregateMtaTresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AggregateMtaTresholdT * SOAP_FMAC6 soap_new_ns1__AggregateMtaTresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AggregateMtaTresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT * SOAP_FMAC4 soap_instantiate_ns1__AggregateMtaTresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AggregateMtaTresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AggregateMtaTresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AggregateMtaTresholdT;
		if (size)
			*size = sizeof(ns1__AggregateMtaTresholdT);
		((ns1__AggregateMtaTresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AggregateMtaTresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AggregateMtaTresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AggregateMtaTresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AggregateMtaTresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AggregateMtaTresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AggregateMtaTresholdT %p -> %p\n", q, p));
	*(ns1__AggregateMtaTresholdT*)p = *(ns1__AggregateMtaTresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AggregateCmOfflineTresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE1);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE1);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE2);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE2);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

void ns1__AggregateCmOfflineTresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE1);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE1);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE2);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE2);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->detectionWindow, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

int ns1__AggregateCmOfflineTresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AggregateCmOfflineTresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AggregateCmOfflineTresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, int id, const ns1__AggregateCmOfflineTresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT), type);
	soap_out_std__string(soap, "percentCmOffline_1", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE1), "");
	soap_out_std__string(soap, "maxCm_1", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE1), "");
	soap_out_std__string(soap, "percentCmOffline_2", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE2), "");
	soap_out_std__string(soap, "maxCm_2", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE2), "");
	soap_out_std__string(soap, "detectionWindow", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->detectionWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AggregateCmOfflineTresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AggregateCmOfflineTresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC4 soap_get_ns1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AggregateCmOfflineTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AggregateCmOfflineTresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AggregateCmOfflineTresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC4 soap_in_ns1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, ns1__AggregateCmOfflineTresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AggregateCmOfflineTresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, sizeof(ns1__AggregateCmOfflineTresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AggregateCmOfflineTresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AggregateCmOfflineTresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_percentCmOffline_USCORE11 = 1, soap_flag_maxCm_USCORE11 = 1, soap_flag_percentCmOffline_USCORE21 = 1, soap_flag_maxCm_USCORE21 = 1, soap_flag_detectionWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentCmOffline_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "percentCmOffline_1", &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE1), "xsd:string"))
				{	soap_flag_percentCmOffline_USCORE11--;
					continue;
				}
			if (soap_flag_maxCm_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "maxCm_1", &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE1), "xsd:string"))
				{	soap_flag_maxCm_USCORE11--;
					continue;
				}
			if (soap_flag_percentCmOffline_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "percentCmOffline_2", &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE2), "xsd:string"))
				{	soap_flag_percentCmOffline_USCORE21--;
					continue;
				}
			if (soap_flag_maxCm_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "maxCm_2", &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE2), "xsd:string"))
				{	soap_flag_maxCm_USCORE21--;
					continue;
				}
			if (soap_flag_detectionWindow1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "detectionWindow", &(((ns1__AggregateCmOfflineTresholdT*)a)->detectionWindow), "xsd:string"))
				{	soap_flag_detectionWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentCmOffline_USCORE11 > 0 || soap_flag_maxCm_USCORE11 > 0 || soap_flag_percentCmOffline_USCORE21 > 0 || soap_flag_maxCm_USCORE21 > 0 || soap_flag_detectionWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AggregateCmOfflineTresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, 0, sizeof(ns1__AggregateCmOfflineTresholdT), 0, soap_copy_ns1__AggregateCmOfflineTresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC6 soap_new_ns1__AggregateCmOfflineTresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AggregateCmOfflineTresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC4 soap_instantiate_ns1__AggregateCmOfflineTresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AggregateCmOfflineTresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AggregateCmOfflineTresholdT;
		if (size)
			*size = sizeof(ns1__AggregateCmOfflineTresholdT);
		((ns1__AggregateCmOfflineTresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AggregateCmOfflineTresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AggregateCmOfflineTresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AggregateCmOfflineTresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AggregateCmOfflineTresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AggregateCmOfflineTresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AggregateCmOfflineTresholdT %p -> %p\n", q, p));
	*(ns1__AggregateCmOfflineTresholdT*)p = *(ns1__AggregateCmOfflineTresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SoakWindowT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREStartTime);
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREDuration);
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREStartTime);
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREDuration);
	/* transient soap skipped */
}

void ns1__SoakWindowT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREStartTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREStartTime);
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREDuration, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREDuration);
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREStartTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREStartTime);
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREDuration, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREDuration);
	/* transient soap skipped */
}

int ns1__SoakWindowT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoakWindowT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SoakWindowT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoakWindowT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoakWindowT(struct soap *soap, const char *tag, int id, const ns1__SoakWindowT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoakWindowT), type);
	soap_out_std__string(soap, "soakWindow_1_StartTime", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREStartTime), "");
	soap_out_std__string(soap, "soakWindow_1_Duration", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREDuration), "");
	soap_out_std__string(soap, "soakWindow_2_StartTime", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREStartTime), "");
	soap_out_std__string(soap, "soakWindow_2_Duration", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREDuration), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SoakWindowT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoakWindowT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoakWindowT * SOAP_FMAC4 soap_get_ns1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoakWindowT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SoakWindowT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoakWindowT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoakWindowT * SOAP_FMAC4 soap_in_ns1__SoakWindowT(struct soap *soap, const char *tag, ns1__SoakWindowT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoakWindowT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoakWindowT, sizeof(ns1__SoakWindowT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoakWindowT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoakWindowT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_soakWindow_USCORE1_USCOREStartTime1 = 1, soap_flag_soakWindow_USCORE1_USCOREDuration1 = 1, soap_flag_soakWindow_USCORE2_USCOREStartTime1 = 1, soap_flag_soakWindow_USCORE2_USCOREDuration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soakWindow_USCORE1_USCOREStartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_1_StartTime", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREStartTime), "xsd:string"))
				{	soap_flag_soakWindow_USCORE1_USCOREStartTime1--;
					continue;
				}
			if (soap_flag_soakWindow_USCORE1_USCOREDuration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_1_Duration", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREDuration), "xsd:string"))
				{	soap_flag_soakWindow_USCORE1_USCOREDuration1--;
					continue;
				}
			if (soap_flag_soakWindow_USCORE2_USCOREStartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_2_StartTime", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREStartTime), "xsd:string"))
				{	soap_flag_soakWindow_USCORE2_USCOREStartTime1--;
					continue;
				}
			if (soap_flag_soakWindow_USCORE2_USCOREDuration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_2_Duration", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREDuration), "xsd:string"))
				{	soap_flag_soakWindow_USCORE2_USCOREDuration1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_soakWindow_USCORE1_USCOREStartTime1 > 0 || soap_flag_soakWindow_USCORE1_USCOREDuration1 > 0 || soap_flag_soakWindow_USCORE2_USCOREStartTime1 > 0 || soap_flag_soakWindow_USCORE2_USCOREDuration1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoakWindowT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoakWindowT, 0, sizeof(ns1__SoakWindowT), 0, soap_copy_ns1__SoakWindowT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SoakWindowT * SOAP_FMAC6 soap_new_ns1__SoakWindowT(struct soap *soap, int n)
{	return soap_instantiate_ns1__SoakWindowT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SoakWindowT * SOAP_FMAC4 soap_instantiate_ns1__SoakWindowT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoakWindowT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoakWindowT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SoakWindowT;
		if (size)
			*size = sizeof(ns1__SoakWindowT);
		((ns1__SoakWindowT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SoakWindowT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoakWindowT);
		for (int i = 0; i < n; i++)
			((ns1__SoakWindowT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoakWindowT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoakWindowT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoakWindowT %p -> %p\n", q, p));
	*(ns1__SoakWindowT*)p = *(ns1__SoakWindowT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmsStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmsStatusThresholdT*)this)->alarmThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__CmsStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__CmsStatusThresholdT*)this)->alarmThreshArray);
	/* transient soap skipped */
}

int ns1__CmsStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmsStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmsStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmsStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmsStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__CmsStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmsStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__CmsStatusThresholdT*)a)->alarmThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmsStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmsStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmsStatusThresholdT * SOAP_FMAC4 soap_get_ns1__CmsStatusThresholdT(struct soap *soap, ns1__CmsStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmsStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmsStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmsStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmsStatusThresholdT * SOAP_FMAC4 soap_in_ns1__CmsStatusThresholdT(struct soap *soap, const char *tag, ns1__CmsStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmsStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmsStatusThresholdT, sizeof(ns1__CmsStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmsStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmsStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__CmsStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmsStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmsStatusThresholdT, 0, sizeof(ns1__CmsStatusThresholdT), 0, soap_copy_ns1__CmsStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmsStatusThresholdT * SOAP_FMAC6 soap_new_ns1__CmsStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmsStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmsStatusThresholdT(struct soap *soap, ns1__CmsStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmsStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__CmsStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmsStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmsStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmsStatusThresholdT;
		if (size)
			*size = sizeof(ns1__CmsStatusThresholdT);
		((ns1__CmsStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmsStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmsStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__CmsStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmsStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmsStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmsStatusThresholdT %p -> %p\n", q, p));
	*(ns1__CmsStatusThresholdT*)p = *(ns1__CmsStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmtsStatusThresholdT*)this)->alarmThreshArray = NULL;
	((ns1__CmtsStatusThresholdT*)this)->aggThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__CmtsStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__CmtsStatusThresholdT*)this)->alarmThreshArray);
	soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, &((ns1__CmtsStatusThresholdT*)this)->aggThreshArray);
	/* transient soap skipped */
}

int ns1__CmtsStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__CmtsStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__CmtsStatusThresholdT*)a)->alarmThreshArray), "");
	soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", -1, &(((ns1__CmtsStatusThresholdT*)a)->aggThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT * SOAP_FMAC4 soap_get_ns1__CmtsStatusThresholdT(struct soap *soap, ns1__CmtsStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT * SOAP_FMAC4 soap_in_ns1__CmtsStatusThresholdT(struct soap *soap, const char *tag, ns1__CmtsStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsStatusThresholdT, sizeof(ns1__CmtsStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1, soap_flag_aggThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__CmtsStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			if (soap_flag_aggThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", &(((ns1__CmtsStatusThresholdT*)a)->aggThreshArray), "ns1:AggregateStatusThresholdT"))
				{	soap_flag_aggThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0 || soap_flag_aggThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsStatusThresholdT, 0, sizeof(ns1__CmtsStatusThresholdT), 0, soap_copy_ns1__CmtsStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsStatusThresholdT * SOAP_FMAC6 soap_new_ns1__CmtsStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsStatusThresholdT(struct soap *soap, ns1__CmtsStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__CmtsStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsStatusThresholdT;
		if (size)
			*size = sizeof(ns1__CmtsStatusThresholdT);
		((ns1__CmtsStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsStatusThresholdT %p -> %p\n", q, p));
	*(ns1__CmtsStatusThresholdT*)p = *(ns1__CmtsStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ChannelStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ChannelStatusThresholdT*)this)->alarmThreshArray = NULL;
	((ns1__ChannelStatusThresholdT*)this)->aggThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__ChannelStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__ChannelStatusThresholdT*)this)->alarmThreshArray);
	soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, &((ns1__ChannelStatusThresholdT*)this)->aggThreshArray);
	/* transient soap skipped */
}

int ns1__ChannelStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ChannelStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ChannelStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChannelStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChannelStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__ChannelStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChannelStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__ChannelStatusThresholdT*)a)->alarmThreshArray), "");
	soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", -1, &(((ns1__ChannelStatusThresholdT*)a)->aggThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ChannelStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChannelStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT * SOAP_FMAC4 soap_get_ns1__ChannelStatusThresholdT(struct soap *soap, ns1__ChannelStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChannelStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ChannelStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ChannelStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT * SOAP_FMAC4 soap_in_ns1__ChannelStatusThresholdT(struct soap *soap, const char *tag, ns1__ChannelStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChannelStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChannelStatusThresholdT, sizeof(ns1__ChannelStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ChannelStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ChannelStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1, soap_flag_aggThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__ChannelStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			if (soap_flag_aggThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", &(((ns1__ChannelStatusThresholdT*)a)->aggThreshArray), "ns1:AggregateStatusThresholdT"))
				{	soap_flag_aggThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0 || soap_flag_aggThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ChannelStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChannelStatusThresholdT, 0, sizeof(ns1__ChannelStatusThresholdT), 0, soap_copy_ns1__ChannelStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ChannelStatusThresholdT * SOAP_FMAC6 soap_new_ns1__ChannelStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ChannelStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ChannelStatusThresholdT(struct soap *soap, ns1__ChannelStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__ChannelStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChannelStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ChannelStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ChannelStatusThresholdT;
		if (size)
			*size = sizeof(ns1__ChannelStatusThresholdT);
		((ns1__ChannelStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ChannelStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ChannelStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__ChannelStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ChannelStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ChannelStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ChannelStatusThresholdT %p -> %p\n", q, p));
	*(ns1__ChannelStatusThresholdT*)p = *(ns1__ChannelStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcStatusThresholdT*)this)->alarmThreshArray = NULL;
	((ns1__HfcStatusThresholdT*)this)->aggThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__HfcStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__HfcStatusThresholdT*)this)->alarmThreshArray);
	soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, &((ns1__HfcStatusThresholdT*)this)->aggThreshArray);
	/* transient soap skipped */
}

int ns1__HfcStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__HfcStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__HfcStatusThresholdT*)a)->alarmThreshArray), "");
	soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", -1, &(((ns1__HfcStatusThresholdT*)a)->aggThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcStatusThresholdT * SOAP_FMAC4 soap_get_ns1__HfcStatusThresholdT(struct soap *soap, ns1__HfcStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcStatusThresholdT * SOAP_FMAC4 soap_in_ns1__HfcStatusThresholdT(struct soap *soap, const char *tag, ns1__HfcStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcStatusThresholdT, sizeof(ns1__HfcStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1, soap_flag_aggThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__HfcStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			if (soap_flag_aggThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", &(((ns1__HfcStatusThresholdT*)a)->aggThreshArray), "ns1:AggregateStatusThresholdT"))
				{	soap_flag_aggThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0 || soap_flag_aggThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcStatusThresholdT, 0, sizeof(ns1__HfcStatusThresholdT), 0, soap_copy_ns1__HfcStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcStatusThresholdT * SOAP_FMAC6 soap_new_ns1__HfcStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcStatusThresholdT(struct soap *soap, ns1__HfcStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__HfcStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcStatusThresholdT;
		if (size)
			*size = sizeof(ns1__HfcStatusThresholdT);
		((ns1__HfcStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__HfcStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcStatusThresholdT %p -> %p\n", q, p));
	*(ns1__HfcStatusThresholdT*)p = *(ns1__HfcStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaStatusThresholdT*)this)->alarmThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__MtaStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__MtaStatusThresholdT*)this)->alarmThreshArray);
	/* transient soap skipped */
}

int ns1__MtaStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__MtaStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__MtaStatusThresholdT*)a)->alarmThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaStatusThresholdT * SOAP_FMAC4 soap_get_ns1__MtaStatusThresholdT(struct soap *soap, ns1__MtaStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaStatusThresholdT * SOAP_FMAC4 soap_in_ns1__MtaStatusThresholdT(struct soap *soap, const char *tag, ns1__MtaStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaStatusThresholdT, sizeof(ns1__MtaStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__MtaStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaStatusThresholdT, 0, sizeof(ns1__MtaStatusThresholdT), 0, soap_copy_ns1__MtaStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaStatusThresholdT * SOAP_FMAC6 soap_new_ns1__MtaStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaStatusThresholdT(struct soap *soap, ns1__MtaStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__MtaStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaStatusThresholdT;
		if (size)
			*size = sizeof(ns1__MtaStatusThresholdT);
		((ns1__MtaStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__MtaStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaStatusThresholdT %p -> %p\n", q, p));
	*(ns1__MtaStatusThresholdT*)p = *(ns1__MtaStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAggregateStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAggregateStatusThresholdT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAggregateStatusThresholdT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AggregateStatusThresholdT(soap, this->__ptr + i);
		}
}

int ArrayOfAggregateStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAggregateStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAggregateStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAggregateStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, int id, const ArrayOfAggregateStatusThresholdT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AggregateStatusThresholdT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AggregateStatusThresholdT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAggregateStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAggregateStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT * SOAP_FMAC4 soap_get_ArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAggregateStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAggregateStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT * SOAP_FMAC4 soap_in_ArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAggregateStatusThresholdT *a, const char *type)
{	int i, j;
	ns1__AggregateStatusThresholdT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAggregateStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, sizeof(ArrayOfAggregateStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AggregateStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AggregateStatusThresholdT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AggregateStatusThresholdT(soap, NULL, a->__ptr + i, "ns1:AggregateStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AggregateStatusThresholdT **)soap_push_block(soap, sizeof(ns1__AggregateStatusThresholdT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AggregateStatusThresholdT(soap, NULL, p, "ns1:AggregateStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AggregateStatusThresholdT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAggregateStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, 0, sizeof(ArrayOfAggregateStatusThresholdT), 0, soap_copy_ArrayOfAggregateStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAggregateStatusThresholdT * SOAP_FMAC6 soap_new_ArrayOfAggregateStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAggregateStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT * SOAP_FMAC4 soap_instantiate_ArrayOfAggregateStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAggregateStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAggregateStatusThresholdT;
		if (size)
			*size = sizeof(ArrayOfAggregateStatusThresholdT);
		((ArrayOfAggregateStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAggregateStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAggregateStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ArrayOfAggregateStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAggregateStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAggregateStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAggregateStatusThresholdT %p -> %p\n", q, p));
	*(ArrayOfAggregateStatusThresholdT*)p = *(ArrayOfAggregateStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AggregateStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__StatusColorT(soap, &((ns1__AggregateStatusThresholdT*)this)->color);
	soap_default_ns1__StatusColorT(soap, &((ns1__AggregateStatusThresholdT*)this)->childColor);
	soap_default_std__string(soap, &((ns1__AggregateStatusThresholdT*)this)->thresholdPercent);
	/* transient soap skipped */
}

void ns1__AggregateStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AggregateStatusThresholdT*)this)->thresholdPercent, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateStatusThresholdT*)this)->thresholdPercent);
	/* transient soap skipped */
}

int ns1__AggregateStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AggregateStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AggregateStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AggregateStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AggregateStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__AggregateStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AggregateStatusThresholdT), type);
	soap_out_ns1__StatusColorT(soap, "color", -1, &(((ns1__AggregateStatusThresholdT*)a)->color), "");
	soap_out_ns1__StatusColorT(soap, "childColor", -1, &(((ns1__AggregateStatusThresholdT*)a)->childColor), "");
	soap_out_std__string(soap, "thresholdPercent", -1, &(((ns1__AggregateStatusThresholdT*)a)->thresholdPercent), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AggregateStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AggregateStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT * SOAP_FMAC4 soap_get_ns1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AggregateStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AggregateStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT * SOAP_FMAC4 soap_in_ns1__AggregateStatusThresholdT(struct soap *soap, const char *tag, ns1__AggregateStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AggregateStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AggregateStatusThresholdT, sizeof(ns1__AggregateStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AggregateStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AggregateStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_color1 = 1, soap_flag_childColor1 = 1, soap_flag_thresholdPercent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "color", &(((ns1__AggregateStatusThresholdT*)a)->color), "ns1:StatusColorT"))
				{	soap_flag_color1--;
					continue;
				}
			if (soap_flag_childColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "childColor", &(((ns1__AggregateStatusThresholdT*)a)->childColor), "ns1:StatusColorT"))
				{	soap_flag_childColor1--;
					continue;
				}
			if (soap_flag_thresholdPercent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "thresholdPercent", &(((ns1__AggregateStatusThresholdT*)a)->thresholdPercent), "xsd:string"))
				{	soap_flag_thresholdPercent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_color1 > 0 || soap_flag_childColor1 > 0 || soap_flag_thresholdPercent1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AggregateStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AggregateStatusThresholdT, 0, sizeof(ns1__AggregateStatusThresholdT), 0, soap_copy_ns1__AggregateStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AggregateStatusThresholdT * SOAP_FMAC6 soap_new_ns1__AggregateStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AggregateStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__AggregateStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AggregateStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AggregateStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AggregateStatusThresholdT;
		if (size)
			*size = sizeof(ns1__AggregateStatusThresholdT);
		((ns1__AggregateStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AggregateStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AggregateStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AggregateStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AggregateStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AggregateStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AggregateStatusThresholdT %p -> %p\n", q, p));
	*(ns1__AggregateStatusThresholdT*)p = *(ns1__AggregateStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAlarmStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAlarmStatusThresholdT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAlarmStatusThresholdT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(soap, this->__ptr + i);
		}
}

int ArrayOfAlarmStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAlarmStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAlarmStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAlarmStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, int id, const ArrayOfAlarmStatusThresholdT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AlarmBasedStatusThresholdT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmStatusThresholdT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAlarmStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAlarmStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT * SOAP_FMAC4 soap_get_ArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAlarmStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAlarmStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAlarmStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT * SOAP_FMAC4 soap_in_ArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAlarmStatusThresholdT *a, const char *type)
{	int i, j;
	ns1__AlarmBasedStatusThresholdT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAlarmStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, sizeof(ArrayOfAlarmStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AlarmBasedStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AlarmBasedStatusThresholdT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, NULL, a->__ptr + i, "ns1:AlarmBasedStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AlarmBasedStatusThresholdT **)soap_push_block(soap, sizeof(ns1__AlarmBasedStatusThresholdT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, NULL, p, "ns1:AlarmBasedStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AlarmBasedStatusThresholdT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, 0, sizeof(ArrayOfAlarmStatusThresholdT), 0, soap_copy_ArrayOfAlarmStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAlarmStatusThresholdT * SOAP_FMAC6 soap_new_ArrayOfAlarmStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAlarmStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT * SOAP_FMAC4 soap_instantiate_ArrayOfAlarmStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAlarmStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAlarmStatusThresholdT;
		if (size)
			*size = sizeof(ArrayOfAlarmStatusThresholdT);
		((ArrayOfAlarmStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAlarmStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAlarmStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ArrayOfAlarmStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAlarmStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAlarmStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAlarmStatusThresholdT %p -> %p\n", q, p));
	*(ArrayOfAlarmStatusThresholdT*)p = *(ArrayOfAlarmStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AlarmBasedStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__StatusColorT(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->color);
	soap_default_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmType);
	soap_default_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmState);
	/* transient soap skipped */
}

void ns1__AlarmBasedStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmType);
	soap_embedded(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmState, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmState);
	/* transient soap skipped */
}

int ns1__AlarmBasedStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AlarmBasedStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AlarmBasedStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__AlarmBasedStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT), type);
	soap_out_ns1__StatusColorT(soap, "color", -1, &(((ns1__AlarmBasedStatusThresholdT*)a)->color), "");
	soap_out_std__string(soap, "alarmType", -1, &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmType), "");
	soap_out_std__string(soap, "alarmState", -1, &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AlarmBasedStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AlarmBasedStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC4 soap_get_ns1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AlarmBasedStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AlarmBasedStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AlarmBasedStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC4 soap_in_ns1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, ns1__AlarmBasedStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AlarmBasedStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, sizeof(ns1__AlarmBasedStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AlarmBasedStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AlarmBasedStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_color1 = 1, soap_flag_alarmType1 = 1, soap_flag_alarmState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "color", &(((ns1__AlarmBasedStatusThresholdT*)a)->color), "ns1:StatusColorT"))
				{	soap_flag_color1--;
					continue;
				}
			if (soap_flag_alarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmType", &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmType), "xsd:string"))
				{	soap_flag_alarmType1--;
					continue;
				}
			if (soap_flag_alarmState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmState", &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmState), "xsd:string"))
				{	soap_flag_alarmState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_color1 > 0 || soap_flag_alarmType1 > 0 || soap_flag_alarmState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AlarmBasedStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, 0, sizeof(ns1__AlarmBasedStatusThresholdT), 0, soap_copy_ns1__AlarmBasedStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC6 soap_new_ns1__AlarmBasedStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AlarmBasedStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__AlarmBasedStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AlarmBasedStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AlarmBasedStatusThresholdT;
		if (size)
			*size = sizeof(ns1__AlarmBasedStatusThresholdT);
		((ns1__AlarmBasedStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AlarmBasedStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AlarmBasedStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AlarmBasedStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AlarmBasedStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AlarmBasedStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AlarmBasedStatusThresholdT %p -> %p\n", q, p));
	*(ns1__AlarmBasedStatusThresholdT*)p = *(ns1__AlarmBasedStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__PollingIntervalsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmtsPollInterval);
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmPollInterval);
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPollInterval);
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPingInterval);
	/* transient soap skipped */
}

void ns1__PollingIntervalsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->cmtsPollInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmtsPollInterval);
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->cmPollInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmPollInterval);
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->mtaPollInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPollInterval);
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->mtaPingInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPingInterval);
	/* transient soap skipped */
}

int ns1__PollingIntervalsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PollingIntervalsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PollingIntervalsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PollingIntervalsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PollingIntervalsT(struct soap *soap, const char *tag, int id, const ns1__PollingIntervalsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PollingIntervalsT), type);
	soap_out_std__string(soap, "cmtsPollInterval", -1, &(((ns1__PollingIntervalsT*)a)->cmtsPollInterval), "");
	soap_out_std__string(soap, "cmPollInterval", -1, &(((ns1__PollingIntervalsT*)a)->cmPollInterval), "");
	soap_out_std__string(soap, "mtaPollInterval", -1, &(((ns1__PollingIntervalsT*)a)->mtaPollInterval), "");
	soap_out_std__string(soap, "mtaPingInterval", -1, &(((ns1__PollingIntervalsT*)a)->mtaPingInterval), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PollingIntervalsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PollingIntervalsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PollingIntervalsT * SOAP_FMAC4 soap_get_ns1__PollingIntervalsT(struct soap *soap, ns1__PollingIntervalsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PollingIntervalsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PollingIntervalsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PollingIntervalsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PollingIntervalsT * SOAP_FMAC4 soap_in_ns1__PollingIntervalsT(struct soap *soap, const char *tag, ns1__PollingIntervalsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PollingIntervalsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PollingIntervalsT, sizeof(ns1__PollingIntervalsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PollingIntervalsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PollingIntervalsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmtsPollInterval1 = 1, soap_flag_cmPollInterval1 = 1, soap_flag_mtaPollInterval1 = 1, soap_flag_mtaPingInterval1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmtsPollInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsPollInterval", &(((ns1__PollingIntervalsT*)a)->cmtsPollInterval), "xsd:string"))
				{	soap_flag_cmtsPollInterval1--;
					continue;
				}
			if (soap_flag_cmPollInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmPollInterval", &(((ns1__PollingIntervalsT*)a)->cmPollInterval), "xsd:string"))
				{	soap_flag_cmPollInterval1--;
					continue;
				}
			if (soap_flag_mtaPollInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mtaPollInterval", &(((ns1__PollingIntervalsT*)a)->mtaPollInterval), "xsd:string"))
				{	soap_flag_mtaPollInterval1--;
					continue;
				}
			if (soap_flag_mtaPingInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mtaPingInterval", &(((ns1__PollingIntervalsT*)a)->mtaPingInterval), "xsd:string"))
				{	soap_flag_mtaPingInterval1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmtsPollInterval1 > 0 || soap_flag_cmPollInterval1 > 0 || soap_flag_mtaPollInterval1 > 0 || soap_flag_mtaPingInterval1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PollingIntervalsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PollingIntervalsT, 0, sizeof(ns1__PollingIntervalsT), 0, soap_copy_ns1__PollingIntervalsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PollingIntervalsT * SOAP_FMAC6 soap_new_ns1__PollingIntervalsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__PollingIntervalsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PollingIntervalsT(struct soap *soap, ns1__PollingIntervalsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__PollingIntervalsT * SOAP_FMAC4 soap_instantiate_ns1__PollingIntervalsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PollingIntervalsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PollingIntervalsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PollingIntervalsT;
		if (size)
			*size = sizeof(ns1__PollingIntervalsT);
		((ns1__PollingIntervalsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PollingIntervalsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PollingIntervalsT);
		for (int i = 0; i < n; i++)
			((ns1__PollingIntervalsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PollingIntervalsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PollingIntervalsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PollingIntervalsT %p -> %p\n", q, p));
	*(ns1__PollingIntervalsT*)p = *(ns1__PollingIntervalsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__UserAccessPrivilegesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__UserAccessPrivilegesT*)this)->userId);
	((ns1__UserAccessPrivilegesT*)this)->role = NULL;
	((ns1__UserAccessPrivilegesT*)this)->oaPairs = NULL;
	/* transient soap skipped */
}

void ns1__UserAccessPrivilegesT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__UserAccessPrivilegesT*)this)->userId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserAccessPrivilegesT*)this)->userId);
	soap_serialize_PointerTons1__UserRoleT(soap, &((ns1__UserAccessPrivilegesT*)this)->role);
	soap_serialize_PointerToArrayOfOAPairT(soap, &((ns1__UserAccessPrivilegesT*)this)->oaPairs);
	/* transient soap skipped */
}

int ns1__UserAccessPrivilegesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UserAccessPrivilegesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__UserAccessPrivilegesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserAccessPrivilegesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserAccessPrivilegesT(struct soap *soap, const char *tag, int id, const ns1__UserAccessPrivilegesT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserAccessPrivilegesT), type);
	soap_out_std__string(soap, "userId", -1, &(((ns1__UserAccessPrivilegesT*)a)->userId), "");
	soap_out_PointerTons1__UserRoleT(soap, "role", -1, &(((ns1__UserAccessPrivilegesT*)a)->role), "");
	soap_out_PointerToArrayOfOAPairT(soap, "oaPairs", -1, &(((ns1__UserAccessPrivilegesT*)a)->oaPairs), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__UserAccessPrivilegesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserAccessPrivilegesT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserAccessPrivilegesT * SOAP_FMAC4 soap_get_ns1__UserAccessPrivilegesT(struct soap *soap, ns1__UserAccessPrivilegesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserAccessPrivilegesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__UserAccessPrivilegesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserAccessPrivilegesT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserAccessPrivilegesT * SOAP_FMAC4 soap_in_ns1__UserAccessPrivilegesT(struct soap *soap, const char *tag, ns1__UserAccessPrivilegesT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserAccessPrivilegesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserAccessPrivilegesT, sizeof(ns1__UserAccessPrivilegesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UserAccessPrivilegesT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UserAccessPrivilegesT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_userId1 = 1, soap_flag_role1 = 1, soap_flag_oaPairs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userId", &(((ns1__UserAccessPrivilegesT*)a)->userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_role1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UserRoleT(soap, "role", &(((ns1__UserAccessPrivilegesT*)a)->role), "ns1:UserRoleT"))
				{	soap_flag_role1--;
					continue;
				}
			if (soap_flag_oaPairs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfOAPairT(soap, "oaPairs", &(((ns1__UserAccessPrivilegesT*)a)->oaPairs), "ns1:OAPairT"))
				{	soap_flag_oaPairs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UserAccessPrivilegesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserAccessPrivilegesT, 0, sizeof(ns1__UserAccessPrivilegesT), 0, soap_copy_ns1__UserAccessPrivilegesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__UserAccessPrivilegesT * SOAP_FMAC6 soap_new_ns1__UserAccessPrivilegesT(struct soap *soap, int n)
{	return soap_instantiate_ns1__UserAccessPrivilegesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UserAccessPrivilegesT(struct soap *soap, ns1__UserAccessPrivilegesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__UserAccessPrivilegesT * SOAP_FMAC4 soap_instantiate_ns1__UserAccessPrivilegesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserAccessPrivilegesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserAccessPrivilegesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UserAccessPrivilegesT;
		if (size)
			*size = sizeof(ns1__UserAccessPrivilegesT);
		((ns1__UserAccessPrivilegesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UserAccessPrivilegesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UserAccessPrivilegesT);
		for (int i = 0; i < n; i++)
			((ns1__UserAccessPrivilegesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UserAccessPrivilegesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UserAccessPrivilegesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UserAccessPrivilegesT %p -> %p\n", q, p));
	*(ns1__UserAccessPrivilegesT*)p = *(ns1__UserAccessPrivilegesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfUserT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfUserT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfUserT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__UserT(soap, this->__ptr + i);
		}
}

int ArrayOfUserT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfUserT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfUserT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfUserT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfUserT(struct soap *soap, const char *tag, int id, const ArrayOfUserT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:UserT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfUserT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__UserT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfUserT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfUserT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfUserT * SOAP_FMAC4 soap_get_ArrayOfUserT(struct soap *soap, ArrayOfUserT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfUserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfUserT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfUserT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfUserT * SOAP_FMAC4 soap_in_ArrayOfUserT(struct soap *soap, const char *tag, ArrayOfUserT *a, const char *type)
{	int i, j;
	ns1__UserT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfUserT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfUserT, sizeof(ArrayOfUserT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__UserT **)soap_malloc(soap, sizeof(ns1__UserT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__UserT(soap, NULL, a->__ptr + i, "ns1:UserT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__UserT **)soap_push_block(soap, sizeof(ns1__UserT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__UserT(soap, NULL, p, "ns1:UserT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__UserT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfUserT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfUserT, 0, sizeof(ArrayOfUserT), 0, soap_copy_ArrayOfUserT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfUserT * SOAP_FMAC6 soap_new_ArrayOfUserT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfUserT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfUserT(struct soap *soap, ArrayOfUserT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfUserT * SOAP_FMAC4 soap_instantiate_ArrayOfUserT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfUserT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfUserT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfUserT;
		if (size)
			*size = sizeof(ArrayOfUserT);
		((ArrayOfUserT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfUserT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfUserT);
		for (int i = 0; i < n; i++)
			((ArrayOfUserT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfUserT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfUserT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfUserT %p -> %p\n", q, p));
	*(ArrayOfUserT*)p = *(ArrayOfUserT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__UserT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__UserT*)this)->userId);
	soap_default_std__string(soap, &((ns1__UserT*)this)->firstName);
	soap_default_std__string(soap, &((ns1__UserT*)this)->lastName);
	((ns1__UserT*)this)->middleInitial = NULL;
	soap_default_std__string(soap, &((ns1__UserT*)this)->location);
	soap_default_std__string(soap, &((ns1__UserT*)this)->loginName);
	((ns1__UserT*)this)->loginPassword = NULL;
	((ns1__UserT*)this)->isActive = NULL;
	/* transient soap skipped */
}

void ns1__UserT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__UserT*)this)->userId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->userId);
	soap_embedded(soap, &((ns1__UserT*)this)->firstName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->firstName);
	soap_embedded(soap, &((ns1__UserT*)this)->lastName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->lastName);
	soap_serialize_PointerTostd__string(soap, &((ns1__UserT*)this)->middleInitial);
	soap_embedded(soap, &((ns1__UserT*)this)->location, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->location);
	soap_embedded(soap, &((ns1__UserT*)this)->loginName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->loginName);
	soap_serialize_PointerTostd__string(soap, &((ns1__UserT*)this)->loginPassword);
	soap_serialize_PointerToshort(soap, &((ns1__UserT*)this)->isActive);
	/* transient soap skipped */
}

int ns1__UserT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UserT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__UserT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserT(struct soap *soap, const char *tag, int id, const ns1__UserT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserT), type);
	soap_out_std__string(soap, "userId", -1, &(((ns1__UserT*)a)->userId), "");
	soap_out_std__string(soap, "firstName", -1, &(((ns1__UserT*)a)->firstName), "");
	soap_out_std__string(soap, "lastName", -1, &(((ns1__UserT*)a)->lastName), "");
	soap_out_PointerTostd__string(soap, "middleInitial", -1, &(((ns1__UserT*)a)->middleInitial), "");
	soap_out_std__string(soap, "location", -1, &(((ns1__UserT*)a)->location), "");
	soap_out_std__string(soap, "loginName", -1, &(((ns1__UserT*)a)->loginName), "");
	soap_out_PointerTostd__string(soap, "loginPassword", -1, &(((ns1__UserT*)a)->loginPassword), "");
	soap_out_PointerToshort(soap, "isActive", -1, &(((ns1__UserT*)a)->isActive), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__UserT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserT * SOAP_FMAC4 soap_get_ns1__UserT(struct soap *soap, ns1__UserT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__UserT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserT * SOAP_FMAC4 soap_in_ns1__UserT(struct soap *soap, const char *tag, ns1__UserT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserT, sizeof(ns1__UserT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UserT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UserT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_userId1 = 1, soap_flag_firstName1 = 1, soap_flag_lastName1 = 1, soap_flag_middleInitial1 = 1, soap_flag_location1 = 1, soap_flag_loginName1 = 1, soap_flag_loginPassword1 = 1, soap_flag_isActive1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userId", &(((ns1__UserT*)a)->userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "firstName", &(((ns1__UserT*)a)->firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "lastName", &(((ns1__UserT*)a)->lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_middleInitial1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "middleInitial", &(((ns1__UserT*)a)->middleInitial), "xsd:string"))
				{	soap_flag_middleInitial1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "location", &(((ns1__UserT*)a)->location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_loginName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginName", &(((ns1__UserT*)a)->loginName), "xsd:string"))
				{	soap_flag_loginName1--;
					continue;
				}
			if (soap_flag_loginPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "loginPassword", &(((ns1__UserT*)a)->loginPassword), "xsd:string"))
				{	soap_flag_loginPassword1--;
					continue;
				}
			if (soap_flag_isActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToshort(soap, "isActive", &(((ns1__UserT*)a)->isActive), "xsd:short"))
				{	soap_flag_isActive1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userId1 > 0 || soap_flag_firstName1 > 0 || soap_flag_lastName1 > 0 || soap_flag_location1 > 0 || soap_flag_loginName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UserT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserT, 0, sizeof(ns1__UserT), 0, soap_copy_ns1__UserT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__UserT * SOAP_FMAC6 soap_new_ns1__UserT(struct soap *soap, int n)
{	return soap_instantiate_ns1__UserT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UserT(struct soap *soap, ns1__UserT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__UserT * SOAP_FMAC4 soap_instantiate_ns1__UserT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UserT;
		if (size)
			*size = sizeof(ns1__UserT);
		((ns1__UserT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UserT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UserT);
		for (int i = 0; i < n; i++)
			((ns1__UserT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UserT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UserT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UserT %p -> %p\n", q, p));
	*(ns1__UserT*)p = *(ns1__UserT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfUserRoleT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfUserRoleT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfUserRoleT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__UserRoleT(soap, this->__ptr + i);
		}
}

int ArrayOfUserRoleT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfUserRoleT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfUserRoleT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfUserRoleT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfUserRoleT(struct soap *soap, const char *tag, int id, const ArrayOfUserRoleT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:UserRoleT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfUserRoleT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__UserRoleT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfUserRoleT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfUserRoleT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfUserRoleT * SOAP_FMAC4 soap_get_ArrayOfUserRoleT(struct soap *soap, ArrayOfUserRoleT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfUserRoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfUserRoleT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfUserRoleT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfUserRoleT * SOAP_FMAC4 soap_in_ArrayOfUserRoleT(struct soap *soap, const char *tag, ArrayOfUserRoleT *a, const char *type)
{	int i, j;
	ns1__UserRoleT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfUserRoleT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfUserRoleT, sizeof(ArrayOfUserRoleT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__UserRoleT **)soap_malloc(soap, sizeof(ns1__UserRoleT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__UserRoleT(soap, NULL, a->__ptr + i, "ns1:UserRoleT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__UserRoleT **)soap_push_block(soap, sizeof(ns1__UserRoleT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__UserRoleT(soap, NULL, p, "ns1:UserRoleT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__UserRoleT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfUserRoleT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfUserRoleT, 0, sizeof(ArrayOfUserRoleT), 0, soap_copy_ArrayOfUserRoleT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfUserRoleT * SOAP_FMAC6 soap_new_ArrayOfUserRoleT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfUserRoleT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfUserRoleT(struct soap *soap, ArrayOfUserRoleT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfUserRoleT * SOAP_FMAC4 soap_instantiate_ArrayOfUserRoleT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfUserRoleT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfUserRoleT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfUserRoleT;
		if (size)
			*size = sizeof(ArrayOfUserRoleT);
		((ArrayOfUserRoleT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfUserRoleT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfUserRoleT);
		for (int i = 0; i < n; i++)
			((ArrayOfUserRoleT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfUserRoleT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfUserRoleT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfUserRoleT %p -> %p\n", q, p));
	*(ArrayOfUserRoleT*)p = *(ArrayOfUserRoleT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__RoleOAPairT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__RoleOAPairT*)this)->roleName);
	((ns1__RoleOAPairT*)this)->oaPairs = NULL;
	/* transient soap skipped */
}

void ns1__RoleOAPairT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__RoleOAPairT*)this)->roleName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__RoleOAPairT*)this)->roleName);
	soap_serialize_PointerToArrayOfOAPairT(soap, &((ns1__RoleOAPairT*)this)->oaPairs);
	/* transient soap skipped */
}

int ns1__RoleOAPairT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RoleOAPairT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__RoleOAPairT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RoleOAPairT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RoleOAPairT(struct soap *soap, const char *tag, int id, const ns1__RoleOAPairT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RoleOAPairT), type);
	soap_out_std__string(soap, "roleName", -1, &(((ns1__RoleOAPairT*)a)->roleName), "");
	soap_out_PointerToArrayOfOAPairT(soap, "oaPairs", -1, &(((ns1__RoleOAPairT*)a)->oaPairs), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RoleOAPairT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RoleOAPairT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RoleOAPairT * SOAP_FMAC4 soap_get_ns1__RoleOAPairT(struct soap *soap, ns1__RoleOAPairT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RoleOAPairT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RoleOAPairT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RoleOAPairT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RoleOAPairT * SOAP_FMAC4 soap_in_ns1__RoleOAPairT(struct soap *soap, const char *tag, ns1__RoleOAPairT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RoleOAPairT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RoleOAPairT, sizeof(ns1__RoleOAPairT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RoleOAPairT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RoleOAPairT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_roleName1 = 1, soap_flag_oaPairs1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "roleName", &(((ns1__RoleOAPairT*)a)->roleName), "xsd:string"))
				{	soap_flag_roleName1--;
					continue;
				}
			if (soap_flag_oaPairs1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfOAPairT(soap, "oaPairs", &(((ns1__RoleOAPairT*)a)->oaPairs), "ns1:OAPairT"))
				{	soap_flag_oaPairs1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roleName1 > 0 || soap_flag_oaPairs1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RoleOAPairT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RoleOAPairT, 0, sizeof(ns1__RoleOAPairT), 0, soap_copy_ns1__RoleOAPairT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RoleOAPairT * SOAP_FMAC6 soap_new_ns1__RoleOAPairT(struct soap *soap, int n)
{	return soap_instantiate_ns1__RoleOAPairT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RoleOAPairT(struct soap *soap, ns1__RoleOAPairT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__RoleOAPairT * SOAP_FMAC4 soap_instantiate_ns1__RoleOAPairT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RoleOAPairT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RoleOAPairT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RoleOAPairT;
		if (size)
			*size = sizeof(ns1__RoleOAPairT);
		((ns1__RoleOAPairT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RoleOAPairT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RoleOAPairT);
		for (int i = 0; i < n; i++)
			((ns1__RoleOAPairT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RoleOAPairT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RoleOAPairT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RoleOAPairT %p -> %p\n", q, p));
	*(ns1__RoleOAPairT*)p = *(ns1__RoleOAPairT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__UserRoleT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__UserRoleT*)this)->roleName);
	/* transient soap skipped */
}

void ns1__UserRoleT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__UserRoleT*)this)->roleName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserRoleT*)this)->roleName);
	/* transient soap skipped */
}

int ns1__UserRoleT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UserRoleT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__UserRoleT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserRoleT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserRoleT(struct soap *soap, const char *tag, int id, const ns1__UserRoleT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserRoleT), type);
	soap_out_std__string(soap, "roleName", -1, &(((ns1__UserRoleT*)a)->roleName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__UserRoleT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserRoleT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserRoleT * SOAP_FMAC4 soap_get_ns1__UserRoleT(struct soap *soap, ns1__UserRoleT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserRoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__UserRoleT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserRoleT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserRoleT * SOAP_FMAC4 soap_in_ns1__UserRoleT(struct soap *soap, const char *tag, ns1__UserRoleT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserRoleT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserRoleT, sizeof(ns1__UserRoleT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UserRoleT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UserRoleT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_roleName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "roleName", &(((ns1__UserRoleT*)a)->roleName), "xsd:string"))
				{	soap_flag_roleName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roleName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UserRoleT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserRoleT, 0, sizeof(ns1__UserRoleT), 0, soap_copy_ns1__UserRoleT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__UserRoleT * SOAP_FMAC6 soap_new_ns1__UserRoleT(struct soap *soap, int n)
{	return soap_instantiate_ns1__UserRoleT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UserRoleT(struct soap *soap, ns1__UserRoleT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__UserRoleT * SOAP_FMAC4 soap_instantiate_ns1__UserRoleT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserRoleT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserRoleT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UserRoleT;
		if (size)
			*size = sizeof(ns1__UserRoleT);
		((ns1__UserRoleT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UserRoleT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UserRoleT);
		for (int i = 0; i < n; i++)
			((ns1__UserRoleT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UserRoleT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UserRoleT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UserRoleT %p -> %p\n", q, p));
	*(ns1__UserRoleT*)p = *(ns1__UserRoleT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfOAPairT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfOAPairT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfOAPairT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__OAPairT(soap, this->__ptr + i);
		}
}

int ArrayOfOAPairT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfOAPairT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfOAPairT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfOAPairT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfOAPairT(struct soap *soap, const char *tag, int id, const ArrayOfOAPairT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:OAPairT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfOAPairT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__OAPairT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfOAPairT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfOAPairT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfOAPairT * SOAP_FMAC4 soap_get_ArrayOfOAPairT(struct soap *soap, ArrayOfOAPairT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfOAPairT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfOAPairT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfOAPairT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfOAPairT * SOAP_FMAC4 soap_in_ArrayOfOAPairT(struct soap *soap, const char *tag, ArrayOfOAPairT *a, const char *type)
{	int i, j;
	ns1__OAPairT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfOAPairT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfOAPairT, sizeof(ArrayOfOAPairT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__OAPairT **)soap_malloc(soap, sizeof(ns1__OAPairT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__OAPairT(soap, NULL, a->__ptr + i, "ns1:OAPairT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__OAPairT **)soap_push_block(soap, sizeof(ns1__OAPairT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__OAPairT(soap, NULL, p, "ns1:OAPairT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__OAPairT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfOAPairT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfOAPairT, 0, sizeof(ArrayOfOAPairT), 0, soap_copy_ArrayOfOAPairT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfOAPairT * SOAP_FMAC6 soap_new_ArrayOfOAPairT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfOAPairT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfOAPairT(struct soap *soap, ArrayOfOAPairT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfOAPairT * SOAP_FMAC4 soap_instantiate_ArrayOfOAPairT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfOAPairT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfOAPairT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfOAPairT;
		if (size)
			*size = sizeof(ArrayOfOAPairT);
		((ArrayOfOAPairT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfOAPairT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfOAPairT);
		for (int i = 0; i < n; i++)
			((ArrayOfOAPairT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfOAPairT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfOAPairT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfOAPairT %p -> %p\n", q, p));
	*(ArrayOfOAPairT*)p = *(ArrayOfOAPairT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__OAPairT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ApplicationDomainTypeT(soap, &((ns1__OAPairT*)this)->appDomainType);
	soap_default_ns1__UserAccessTypeT(soap, &((ns1__OAPairT*)this)->accessType);
	/* transient soap skipped */
}

void ns1__OAPairT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__OAPairT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__OAPairT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__OAPairT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__OAPairT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__OAPairT(struct soap *soap, const char *tag, int id, const ns1__OAPairT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__OAPairT), type);
	soap_out_ns1__ApplicationDomainTypeT(soap, "appDomainType", -1, &(((ns1__OAPairT*)a)->appDomainType), "");
	soap_out_ns1__UserAccessTypeT(soap, "accessType", -1, &(((ns1__OAPairT*)a)->accessType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__OAPairT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__OAPairT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__OAPairT * SOAP_FMAC4 soap_get_ns1__OAPairT(struct soap *soap, ns1__OAPairT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__OAPairT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__OAPairT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__OAPairT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__OAPairT * SOAP_FMAC4 soap_in_ns1__OAPairT(struct soap *soap, const char *tag, ns1__OAPairT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__OAPairT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__OAPairT, sizeof(ns1__OAPairT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__OAPairT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__OAPairT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_appDomainType1 = 1, soap_flag_accessType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_appDomainType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ApplicationDomainTypeT(soap, "appDomainType", &(((ns1__OAPairT*)a)->appDomainType), "ns1:ApplicationDomainTypeT"))
				{	soap_flag_appDomainType1--;
					continue;
				}
			if (soap_flag_accessType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UserAccessTypeT(soap, "accessType", &(((ns1__OAPairT*)a)->accessType), "ns1:UserAccessTypeT"))
				{	soap_flag_accessType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_appDomainType1 > 0 || soap_flag_accessType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__OAPairT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__OAPairT, 0, sizeof(ns1__OAPairT), 0, soap_copy_ns1__OAPairT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__OAPairT * SOAP_FMAC6 soap_new_ns1__OAPairT(struct soap *soap, int n)
{	return soap_instantiate_ns1__OAPairT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__OAPairT(struct soap *soap, ns1__OAPairT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__OAPairT * SOAP_FMAC4 soap_instantiate_ns1__OAPairT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__OAPairT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__OAPairT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__OAPairT;
		if (size)
			*size = sizeof(ns1__OAPairT);
		((ns1__OAPairT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__OAPairT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__OAPairT);
		for (int i = 0; i < n; i++)
			((ns1__OAPairT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__OAPairT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__OAPairT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__OAPairT %p -> %p\n", q, p));
	*(ns1__OAPairT*)p = *(ns1__OAPairT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CMSResultT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CMSResultT*)this)->line1 = NULL;
	((ns1__CMSResultT*)this)->line2 = NULL;
	/* transient soap skipped */
}

void ns1__CMSResultT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CMSLineT(soap, &((ns1__CMSResultT*)this)->line1);
	soap_serialize_PointerTons1__CMSLineT(soap, &((ns1__CMSResultT*)this)->line2);
	/* transient soap skipped */
}

int ns1__CMSResultT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CMSResultT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CMSResultT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CMSResultT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CMSResultT(struct soap *soap, const char *tag, int id, const ns1__CMSResultT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CMSResultT), type);
	soap_out_PointerTons1__CMSLineT(soap, "line1", -1, &(((ns1__CMSResultT*)a)->line1), "");
	soap_out_PointerTons1__CMSLineT(soap, "line2", -1, &(((ns1__CMSResultT*)a)->line2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CMSResultT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CMSResultT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CMSResultT * SOAP_FMAC4 soap_get_ns1__CMSResultT(struct soap *soap, ns1__CMSResultT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CMSResultT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CMSResultT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CMSResultT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CMSResultT * SOAP_FMAC4 soap_in_ns1__CMSResultT(struct soap *soap, const char *tag, ns1__CMSResultT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CMSResultT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CMSResultT, sizeof(ns1__CMSResultT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CMSResultT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CMSResultT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_line11 = 1, soap_flag_line21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_line11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CMSLineT(soap, "line1", &(((ns1__CMSResultT*)a)->line1), "ns1:CMSLineT"))
				{	soap_flag_line11--;
					continue;
				}
			if (soap_flag_line21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CMSLineT(soap, "line2", &(((ns1__CMSResultT*)a)->line2), "ns1:CMSLineT"))
				{	soap_flag_line21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_line11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CMSResultT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CMSResultT, 0, sizeof(ns1__CMSResultT), 0, soap_copy_ns1__CMSResultT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CMSResultT * SOAP_FMAC6 soap_new_ns1__CMSResultT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CMSResultT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CMSResultT(struct soap *soap, ns1__CMSResultT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CMSResultT * SOAP_FMAC4 soap_instantiate_ns1__CMSResultT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CMSResultT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CMSResultT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CMSResultT;
		if (size)
			*size = sizeof(ns1__CMSResultT);
		((ns1__CMSResultT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CMSResultT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CMSResultT);
		for (int i = 0; i < n; i++)
			((ns1__CMSResultT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CMSResultT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CMSResultT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CMSResultT %p -> %p\n", q, p));
	*(ns1__CMSResultT*)p = *(ns1__CMSResultT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCMSLineT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCMSLineT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCMSLineT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CMSLineT(soap, this->__ptr + i);
		}
}

int ArrayOfCMSLineT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCMSLineT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCMSLineT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCMSLineT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCMSLineT(struct soap *soap, const char *tag, int id, const ArrayOfCMSLineT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CMSLineT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCMSLineT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CMSLineT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCMSLineT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCMSLineT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCMSLineT * SOAP_FMAC4 soap_get_ArrayOfCMSLineT(struct soap *soap, ArrayOfCMSLineT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCMSLineT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCMSLineT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCMSLineT * SOAP_FMAC4 soap_in_ArrayOfCMSLineT(struct soap *soap, const char *tag, ArrayOfCMSLineT *a, const char *type)
{	int i, j;
	ns1__CMSLineT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCMSLineT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCMSLineT, sizeof(ArrayOfCMSLineT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CMSLineT **)soap_malloc(soap, sizeof(ns1__CMSLineT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CMSLineT(soap, NULL, a->__ptr + i, "ns1:CMSLineT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CMSLineT **)soap_push_block(soap, sizeof(ns1__CMSLineT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CMSLineT(soap, NULL, p, "ns1:CMSLineT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CMSLineT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCMSLineT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCMSLineT, 0, sizeof(ArrayOfCMSLineT), 0, soap_copy_ArrayOfCMSLineT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCMSLineT * SOAP_FMAC6 soap_new_ArrayOfCMSLineT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCMSLineT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCMSLineT(struct soap *soap, ArrayOfCMSLineT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCMSLineT * SOAP_FMAC4 soap_instantiate_ArrayOfCMSLineT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCMSLineT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCMSLineT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCMSLineT;
		if (size)
			*size = sizeof(ArrayOfCMSLineT);
		((ArrayOfCMSLineT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCMSLineT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCMSLineT);
		for (int i = 0; i < n; i++)
			((ArrayOfCMSLineT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCMSLineT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCMSLineT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCMSLineT %p -> %p\n", q, p));
	*(ArrayOfCMSLineT*)p = *(ArrayOfCMSLineT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CMSLineT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CMSLineT*)this)->number);
	soap_default_std__string(soap, &((ns1__CMSLineT*)this)->status);
	/* transient soap skipped */
}

void ns1__CMSLineT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CMSLineT*)this)->number, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CMSLineT*)this)->number);
	soap_embedded(soap, &((ns1__CMSLineT*)this)->status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CMSLineT*)this)->status);
	/* transient soap skipped */
}

int ns1__CMSLineT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CMSLineT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CMSLineT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CMSLineT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CMSLineT(struct soap *soap, const char *tag, int id, const ns1__CMSLineT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CMSLineT), type);
	soap_out_std__string(soap, "number", -1, &(((ns1__CMSLineT*)a)->number), "");
	soap_out_std__string(soap, "status", -1, &(((ns1__CMSLineT*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CMSLineT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CMSLineT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CMSLineT * SOAP_FMAC4 soap_get_ns1__CMSLineT(struct soap *soap, ns1__CMSLineT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CMSLineT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CMSLineT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CMSLineT * SOAP_FMAC4 soap_in_ns1__CMSLineT(struct soap *soap, const char *tag, ns1__CMSLineT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CMSLineT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CMSLineT, sizeof(ns1__CMSLineT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CMSLineT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CMSLineT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_number1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "number", &(((ns1__CMSLineT*)a)->number), "xsd:string"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(((ns1__CMSLineT*)a)->status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_number1 > 0 || soap_flag_status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CMSLineT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CMSLineT, 0, sizeof(ns1__CMSLineT), 0, soap_copy_ns1__CMSLineT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CMSLineT * SOAP_FMAC6 soap_new_ns1__CMSLineT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CMSLineT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CMSLineT(struct soap *soap, ns1__CMSLineT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CMSLineT * SOAP_FMAC4 soap_instantiate_ns1__CMSLineT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CMSLineT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CMSLineT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CMSLineT;
		if (size)
			*size = sizeof(ns1__CMSLineT);
		((ns1__CMSLineT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CMSLineT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CMSLineT);
		for (int i = 0; i < n; i++)
			((ns1__CMSLineT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CMSLineT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CMSLineT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CMSLineT %p -> %p\n", q, p));
	*(ns1__CMSLineT*)p = *(ns1__CMSLineT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCTEQueryInputT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCTEQueryInputT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCTEQueryInputT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTEQueryInputT(soap, this->__ptr + i);
		}
}

int ArrayOfCTEQueryInputT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCTEQueryInputT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCTEQueryInputT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTEQueryInputT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTEQueryInputT(struct soap *soap, const char *tag, int id, const ArrayOfCTEQueryInputT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CTEQueryInputT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCTEQueryInputT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTEQueryInputT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCTEQueryInputT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTEQueryInputT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTEQueryInputT * SOAP_FMAC4 soap_get_ArrayOfCTEQueryInputT(struct soap *soap, ArrayOfCTEQueryInputT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCTEQueryInputT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTEQueryInputT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTEQueryInputT * SOAP_FMAC4 soap_in_ArrayOfCTEQueryInputT(struct soap *soap, const char *tag, ArrayOfCTEQueryInputT *a, const char *type)
{	int i, j;
	ns1__CTEQueryInputT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTEQueryInputT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTEQueryInputT, sizeof(ArrayOfCTEQueryInputT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CTEQueryInputT **)soap_malloc(soap, sizeof(ns1__CTEQueryInputT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTEQueryInputT(soap, NULL, a->__ptr + i, "ns1:CTEQueryInputT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTEQueryInputT **)soap_push_block(soap, sizeof(ns1__CTEQueryInputT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTEQueryInputT(soap, NULL, p, "ns1:CTEQueryInputT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CTEQueryInputT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTEQueryInputT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTEQueryInputT, 0, sizeof(ArrayOfCTEQueryInputT), 0, soap_copy_ArrayOfCTEQueryInputT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCTEQueryInputT * SOAP_FMAC6 soap_new_ArrayOfCTEQueryInputT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCTEQueryInputT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCTEQueryInputT(struct soap *soap, ArrayOfCTEQueryInputT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCTEQueryInputT * SOAP_FMAC4 soap_instantiate_ArrayOfCTEQueryInputT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTEQueryInputT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTEQueryInputT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCTEQueryInputT;
		if (size)
			*size = sizeof(ArrayOfCTEQueryInputT);
		((ArrayOfCTEQueryInputT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCTEQueryInputT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCTEQueryInputT);
		for (int i = 0; i < n; i++)
			((ArrayOfCTEQueryInputT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCTEQueryInputT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTEQueryInputT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTEQueryInputT %p -> %p\n", q, p));
	*(ArrayOfCTEQueryInputT*)p = *(ArrayOfCTEQueryInputT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEQueryInputT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CTEQueryInputT*)this)->accountNumber = NULL;
	((ns1__CTEQueryInputT*)this)->firstName = NULL;
	((ns1__CTEQueryInputT*)this)->lastName = NULL;
	((ns1__CTEQueryInputT*)this)->primaryPhone = NULL;
	((ns1__CTEQueryInputT*)this)->cmMac = NULL;
	/* transient soap skipped */
}

void ns1__CTEQueryInputT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->accountNumber);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->firstName);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->lastName);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->primaryPhone);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->cmMac);
	/* transient soap skipped */
}

int ns1__CTEQueryInputT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEQueryInputT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEQueryInputT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEQueryInputT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEQueryInputT(struct soap *soap, const char *tag, int id, const ns1__CTEQueryInputT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEQueryInputT), type);
	soap_out_PointerTostd__string(soap, "accountNumber", -1, &(((ns1__CTEQueryInputT*)a)->accountNumber), "");
	soap_out_PointerTostd__string(soap, "firstName", -1, &(((ns1__CTEQueryInputT*)a)->firstName), "");
	soap_out_PointerTostd__string(soap, "lastName", -1, &(((ns1__CTEQueryInputT*)a)->lastName), "");
	soap_out_PointerTostd__string(soap, "primaryPhone", -1, &(((ns1__CTEQueryInputT*)a)->primaryPhone), "");
	soap_out_PointerTostd__string(soap, "cmMac", -1, &(((ns1__CTEQueryInputT*)a)->cmMac), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEQueryInputT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEQueryInputT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT * SOAP_FMAC4 soap_get_ns1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEQueryInputT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEQueryInputT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT * SOAP_FMAC4 soap_in_ns1__CTEQueryInputT(struct soap *soap, const char *tag, ns1__CTEQueryInputT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEQueryInputT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEQueryInputT, sizeof(ns1__CTEQueryInputT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEQueryInputT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEQueryInputT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accountNumber1 = 1, soap_flag_firstName1 = 1, soap_flag_lastName1 = 1, soap_flag_primaryPhone1 = 1, soap_flag_cmMac1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "accountNumber", &(((ns1__CTEQueryInputT*)a)->accountNumber), "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "firstName", &(((ns1__CTEQueryInputT*)a)->firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "lastName", &(((ns1__CTEQueryInputT*)a)->lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_primaryPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "primaryPhone", &(((ns1__CTEQueryInputT*)a)->primaryPhone), "xsd:string"))
				{	soap_flag_primaryPhone1--;
					continue;
				}
			if (soap_flag_cmMac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "cmMac", &(((ns1__CTEQueryInputT*)a)->cmMac), "xsd:string"))
				{	soap_flag_cmMac1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEQueryInputT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEQueryInputT, 0, sizeof(ns1__CTEQueryInputT), 0, soap_copy_ns1__CTEQueryInputT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEQueryInputT * SOAP_FMAC6 soap_new_ns1__CTEQueryInputT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEQueryInputT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEQueryInputT * SOAP_FMAC4 soap_instantiate_ns1__CTEQueryInputT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEQueryInputT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEQueryInputT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEQueryInputT;
		if (size)
			*size = sizeof(ns1__CTEQueryInputT);
		((ns1__CTEQueryInputT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEQueryInputT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEQueryInputT);
		for (int i = 0; i < n; i++)
			((ns1__CTEQueryInputT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEQueryInputT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEQueryInputT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEQueryInputT %p -> %p\n", q, p));
	*(ns1__CTEQueryInputT*)p = *(ns1__CTEQueryInputT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCTEDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCTEDataT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCTEDataT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTEDataT(soap, this->__ptr + i);
		}
}

int ArrayOfCTEDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCTEDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCTEDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTEDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTEDataT(struct soap *soap, const char *tag, int id, const ArrayOfCTEDataT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CTEDataT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCTEDataT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTEDataT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCTEDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTEDataT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTEDataT * SOAP_FMAC4 soap_get_ArrayOfCTEDataT(struct soap *soap, ArrayOfCTEDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCTEDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTEDataT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTEDataT * SOAP_FMAC4 soap_in_ArrayOfCTEDataT(struct soap *soap, const char *tag, ArrayOfCTEDataT *a, const char *type)
{	int i, j;
	ns1__CTEDataT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTEDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTEDataT, sizeof(ArrayOfCTEDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CTEDataT **)soap_malloc(soap, sizeof(ns1__CTEDataT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTEDataT(soap, NULL, a->__ptr + i, "ns1:CTEDataT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTEDataT **)soap_push_block(soap, sizeof(ns1__CTEDataT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTEDataT(soap, NULL, p, "ns1:CTEDataT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CTEDataT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTEDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTEDataT, 0, sizeof(ArrayOfCTEDataT), 0, soap_copy_ArrayOfCTEDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCTEDataT * SOAP_FMAC6 soap_new_ArrayOfCTEDataT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCTEDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCTEDataT(struct soap *soap, ArrayOfCTEDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCTEDataT * SOAP_FMAC4 soap_instantiate_ArrayOfCTEDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTEDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTEDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCTEDataT;
		if (size)
			*size = sizeof(ArrayOfCTEDataT);
		((ArrayOfCTEDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCTEDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCTEDataT);
		for (int i = 0; i < n; i++)
			((ArrayOfCTEDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCTEDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTEDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTEDataT %p -> %p\n", q, p));
	*(ArrayOfCTEDataT*)p = *(ArrayOfCTEDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CTEDataT*)this)->customer = NULL;
	((ns1__CTEDataT*)this)->cm = NULL;
	((ns1__CTEDataT*)this)->mta = NULL;
	((ns1__CTEDataT*)this)->cmts = NULL;
	((ns1__CTEDataT*)this)->cms = NULL;
	((ns1__CTEDataT*)this)->hfcName = NULL;
	/* transient soap skipped */
}

void ns1__CTEDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTECustomerT(soap, &((ns1__CTEDataT*)this)->customer);
	soap_serialize_PointerTons1__CTEAbstractMacT(soap, &((ns1__CTEDataT*)this)->cm);
	soap_serialize_PointerTons1__CTEAbstractMacT(soap, &((ns1__CTEDataT*)this)->mta);
	soap_serialize_PointerTons1__CTEAbstractNameT(soap, &((ns1__CTEDataT*)this)->cmts);
	soap_serialize_PointerTons1__CTEAbstractNameT(soap, &((ns1__CTEDataT*)this)->cms);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEDataT*)this)->hfcName);
	/* transient soap skipped */
}

int ns1__CTEDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEDataT(struct soap *soap, const char *tag, int id, const ns1__CTEDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEDataT), type);
	soap_out_PointerTons1__CTECustomerT(soap, "customer", -1, &(((ns1__CTEDataT*)a)->customer), "");
	soap_out_PointerTons1__CTEAbstractMacT(soap, "cm", -1, &(((ns1__CTEDataT*)a)->cm), "");
	soap_out_PointerTons1__CTEAbstractMacT(soap, "mta", -1, &(((ns1__CTEDataT*)a)->mta), "");
	soap_out_PointerTons1__CTEAbstractNameT(soap, "cmts", -1, &(((ns1__CTEDataT*)a)->cmts), "");
	soap_out_PointerTons1__CTEAbstractNameT(soap, "cms", -1, &(((ns1__CTEDataT*)a)->cms), "");
	soap_out_PointerTostd__string(soap, "hfcName", -1, &(((ns1__CTEDataT*)a)->hfcName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEDataT * SOAP_FMAC4 soap_get_ns1__CTEDataT(struct soap *soap, ns1__CTEDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEDataT * SOAP_FMAC4 soap_in_ns1__CTEDataT(struct soap *soap, const char *tag, ns1__CTEDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEDataT, sizeof(ns1__CTEDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_customer1 = 1, soap_flag_cm1 = 1, soap_flag_mta1 = 1, soap_flag_cmts1 = 1, soap_flag_cms1 = 1, soap_flag_hfcName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTECustomerT(soap, "customer", &(((ns1__CTEDataT*)a)->customer), "ns1:CTECustomerT"))
				{	soap_flag_customer1--;
					continue;
				}
			if (soap_flag_cm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractMacT(soap, "cm", &(((ns1__CTEDataT*)a)->cm), "ns1:CTEAbstractMacT"))
				{	soap_flag_cm1--;
					continue;
				}
			if (soap_flag_mta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractMacT(soap, "mta", &(((ns1__CTEDataT*)a)->mta), "ns1:CTEAbstractMacT"))
				{	soap_flag_mta1--;
					continue;
				}
			if (soap_flag_cmts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractNameT(soap, "cmts", &(((ns1__CTEDataT*)a)->cmts), "ns1:CTEAbstractNameT"))
				{	soap_flag_cmts1--;
					continue;
				}
			if (soap_flag_cms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractNameT(soap, "cms", &(((ns1__CTEDataT*)a)->cms), "ns1:CTEAbstractNameT"))
				{	soap_flag_cms1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "hfcName", &(((ns1__CTEDataT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_customer1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEDataT, 0, sizeof(ns1__CTEDataT), 0, soap_copy_ns1__CTEDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEDataT * SOAP_FMAC6 soap_new_ns1__CTEDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEDataT(struct soap *soap, ns1__CTEDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEDataT * SOAP_FMAC4 soap_instantiate_ns1__CTEDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEDataT;
		if (size)
			*size = sizeof(ns1__CTEDataT);
		((ns1__CTEDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEDataT);
		for (int i = 0; i < n; i++)
			((ns1__CTEDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEDataT %p -> %p\n", q, p));
	*(ns1__CTEDataT*)p = *(ns1__CTEDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEAbstractNameT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CTEAbstractNameT*)this)->mac);
	((ns1__CTEAbstractNameT*)this)->fqdn = NULL;
	/* transient soap skipped */
}

void ns1__CTEAbstractNameT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CTEAbstractNameT*)this)->mac, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTEAbstractNameT*)this)->mac);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEAbstractNameT*)this)->fqdn);
	/* transient soap skipped */
}

int ns1__CTEAbstractNameT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEAbstractNameT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEAbstractNameT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEAbstractNameT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEAbstractNameT(struct soap *soap, const char *tag, int id, const ns1__CTEAbstractNameT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEAbstractNameT), type);
	soap_out_std__string(soap, "mac", -1, &(((ns1__CTEAbstractNameT*)a)->mac), "");
	soap_out_PointerTostd__string(soap, "fqdn", -1, &(((ns1__CTEAbstractNameT*)a)->fqdn), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEAbstractNameT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEAbstractNameT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEAbstractNameT * SOAP_FMAC4 soap_get_ns1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEAbstractNameT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEAbstractNameT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEAbstractNameT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEAbstractNameT * SOAP_FMAC4 soap_in_ns1__CTEAbstractNameT(struct soap *soap, const char *tag, ns1__CTEAbstractNameT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEAbstractNameT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEAbstractNameT, sizeof(ns1__CTEAbstractNameT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEAbstractNameT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEAbstractNameT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mac1 = 1, soap_flag_fqdn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mac", &(((ns1__CTEAbstractNameT*)a)->mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_fqdn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "fqdn", &(((ns1__CTEAbstractNameT*)a)->fqdn), "xsd:string"))
				{	soap_flag_fqdn1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mac1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractNameT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEAbstractNameT, 0, sizeof(ns1__CTEAbstractNameT), 0, soap_copy_ns1__CTEAbstractNameT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEAbstractNameT * SOAP_FMAC6 soap_new_ns1__CTEAbstractNameT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEAbstractNameT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEAbstractNameT * SOAP_FMAC4 soap_instantiate_ns1__CTEAbstractNameT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEAbstractNameT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEAbstractNameT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEAbstractNameT;
		if (size)
			*size = sizeof(ns1__CTEAbstractNameT);
		((ns1__CTEAbstractNameT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEAbstractNameT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEAbstractNameT);
		for (int i = 0; i < n; i++)
			((ns1__CTEAbstractNameT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEAbstractNameT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEAbstractNameT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEAbstractNameT %p -> %p\n", q, p));
	*(ns1__CTEAbstractNameT*)p = *(ns1__CTEAbstractNameT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEAbstractMacT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CTEAbstractMacT*)this)->mac);
	((ns1__CTEAbstractMacT*)this)->fqdn = NULL;
	/* transient soap skipped */
}

void ns1__CTEAbstractMacT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CTEAbstractMacT*)this)->mac, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTEAbstractMacT*)this)->mac);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEAbstractMacT*)this)->fqdn);
	/* transient soap skipped */
}

int ns1__CTEAbstractMacT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEAbstractMacT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEAbstractMacT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEAbstractMacT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEAbstractMacT(struct soap *soap, const char *tag, int id, const ns1__CTEAbstractMacT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEAbstractMacT), type);
	soap_out_std__string(soap, "mac", -1, &(((ns1__CTEAbstractMacT*)a)->mac), "");
	soap_out_PointerTostd__string(soap, "fqdn", -1, &(((ns1__CTEAbstractMacT*)a)->fqdn), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEAbstractMacT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEAbstractMacT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEAbstractMacT * SOAP_FMAC4 soap_get_ns1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEAbstractMacT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEAbstractMacT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEAbstractMacT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEAbstractMacT * SOAP_FMAC4 soap_in_ns1__CTEAbstractMacT(struct soap *soap, const char *tag, ns1__CTEAbstractMacT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEAbstractMacT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEAbstractMacT, sizeof(ns1__CTEAbstractMacT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEAbstractMacT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEAbstractMacT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mac1 = 1, soap_flag_fqdn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mac", &(((ns1__CTEAbstractMacT*)a)->mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_fqdn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "fqdn", &(((ns1__CTEAbstractMacT*)a)->fqdn), "xsd:string"))
				{	soap_flag_fqdn1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mac1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractMacT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEAbstractMacT, 0, sizeof(ns1__CTEAbstractMacT), 0, soap_copy_ns1__CTEAbstractMacT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEAbstractMacT * SOAP_FMAC6 soap_new_ns1__CTEAbstractMacT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEAbstractMacT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEAbstractMacT * SOAP_FMAC4 soap_instantiate_ns1__CTEAbstractMacT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEAbstractMacT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEAbstractMacT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEAbstractMacT;
		if (size)
			*size = sizeof(ns1__CTEAbstractMacT);
		((ns1__CTEAbstractMacT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEAbstractMacT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEAbstractMacT);
		for (int i = 0; i < n; i++)
			((ns1__CTEAbstractMacT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEAbstractMacT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEAbstractMacT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEAbstractMacT %p -> %p\n", q, p));
	*(ns1__CTEAbstractMacT*)p = *(ns1__CTEAbstractMacT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCTECustomerT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCTECustomerT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCTECustomerT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTECustomerT(soap, this->__ptr + i);
		}
}

int ArrayOfCTECustomerT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCTECustomerT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCTECustomerT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTECustomerT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTECustomerT(struct soap *soap, const char *tag, int id, const ArrayOfCTECustomerT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CTECustomerT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCTECustomerT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTECustomerT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCTECustomerT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTECustomerT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTECustomerT * SOAP_FMAC4 soap_get_ArrayOfCTECustomerT(struct soap *soap, ArrayOfCTECustomerT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCTECustomerT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTECustomerT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTECustomerT * SOAP_FMAC4 soap_in_ArrayOfCTECustomerT(struct soap *soap, const char *tag, ArrayOfCTECustomerT *a, const char *type)
{	int i, j;
	ns1__CTECustomerT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTECustomerT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTECustomerT, sizeof(ArrayOfCTECustomerT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CTECustomerT **)soap_malloc(soap, sizeof(ns1__CTECustomerT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTECustomerT(soap, NULL, a->__ptr + i, "ns1:CTECustomerT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTECustomerT **)soap_push_block(soap, sizeof(ns1__CTECustomerT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTECustomerT(soap, NULL, p, "ns1:CTECustomerT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CTECustomerT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTECustomerT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTECustomerT, 0, sizeof(ArrayOfCTECustomerT), 0, soap_copy_ArrayOfCTECustomerT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCTECustomerT * SOAP_FMAC6 soap_new_ArrayOfCTECustomerT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCTECustomerT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCTECustomerT(struct soap *soap, ArrayOfCTECustomerT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCTECustomerT * SOAP_FMAC4 soap_instantiate_ArrayOfCTECustomerT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTECustomerT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTECustomerT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCTECustomerT;
		if (size)
			*size = sizeof(ArrayOfCTECustomerT);
		((ArrayOfCTECustomerT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCTECustomerT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCTECustomerT);
		for (int i = 0; i < n; i++)
			((ArrayOfCTECustomerT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCTECustomerT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTECustomerT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTECustomerT %p -> %p\n", q, p));
	*(ArrayOfCTECustomerT*)p = *(ArrayOfCTECustomerT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTECustomerT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CTECustomerT*)this)->accountNumber = NULL;
	((ns1__CTECustomerT*)this)->accountActive = NULL;
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->firstName);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->lastName);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->street1);
	((ns1__CTECustomerT*)this)->street2 = NULL;
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->city);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->state);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->zip);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->phone1);
	((ns1__CTECustomerT*)this)->phone2 = NULL;
	/* transient soap skipped */
}

void ns1__CTECustomerT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns1__CTECustomerT*)this)->accountNumber);
	soap_serialize_PointerToshort(soap, &((ns1__CTECustomerT*)this)->accountActive);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->firstName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->firstName);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->lastName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->lastName);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->street1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->street1);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTECustomerT*)this)->street2);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->city, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->city);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->state, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->state);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->zip, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->zip);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->phone1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->phone1);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTECustomerT*)this)->phone2);
	/* transient soap skipped */
}

int ns1__CTECustomerT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTECustomerT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTECustomerT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTECustomerT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTECustomerT(struct soap *soap, const char *tag, int id, const ns1__CTECustomerT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTECustomerT), type);
	soap_out_PointerTostd__string(soap, "accountNumber", -1, &(((ns1__CTECustomerT*)a)->accountNumber), "");
	soap_out_PointerToshort(soap, "accountActive", -1, &(((ns1__CTECustomerT*)a)->accountActive), "");
	soap_out_std__string(soap, "firstName", -1, &(((ns1__CTECustomerT*)a)->firstName), "");
	soap_out_std__string(soap, "lastName", -1, &(((ns1__CTECustomerT*)a)->lastName), "");
	soap_out_std__string(soap, "street1", -1, &(((ns1__CTECustomerT*)a)->street1), "");
	soap_out_PointerTostd__string(soap, "street2", -1, &(((ns1__CTECustomerT*)a)->street2), "");
	soap_out_std__string(soap, "city", -1, &(((ns1__CTECustomerT*)a)->city), "");
	soap_out_std__string(soap, "state", -1, &(((ns1__CTECustomerT*)a)->state), "");
	soap_out_std__string(soap, "zip", -1, &(((ns1__CTECustomerT*)a)->zip), "");
	soap_out_std__string(soap, "phone1", -1, &(((ns1__CTECustomerT*)a)->phone1), "");
	soap_out_PointerTostd__string(soap, "phone2", -1, &(((ns1__CTECustomerT*)a)->phone2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTECustomerT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTECustomerT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTECustomerT * SOAP_FMAC4 soap_get_ns1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTECustomerT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTECustomerT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTECustomerT * SOAP_FMAC4 soap_in_ns1__CTECustomerT(struct soap *soap, const char *tag, ns1__CTECustomerT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTECustomerT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTECustomerT, sizeof(ns1__CTECustomerT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTECustomerT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTECustomerT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accountNumber1 = 1, soap_flag_accountActive1 = 1, soap_flag_firstName1 = 1, soap_flag_lastName1 = 1, soap_flag_street11 = 1, soap_flag_street21 = 1, soap_flag_city1 = 1, soap_flag_state1 = 1, soap_flag_zip1 = 1, soap_flag_phone11 = 1, soap_flag_phone21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "accountNumber", &(((ns1__CTECustomerT*)a)->accountNumber), "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_accountActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToshort(soap, "accountActive", &(((ns1__CTECustomerT*)a)->accountActive), "xsd:short"))
				{	soap_flag_accountActive1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "firstName", &(((ns1__CTECustomerT*)a)->firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "lastName", &(((ns1__CTECustomerT*)a)->lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "street1", &(((ns1__CTECustomerT*)a)->street1), "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "street2", &(((ns1__CTECustomerT*)a)->street2), "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "city", &(((ns1__CTECustomerT*)a)->city), "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "state", &(((ns1__CTECustomerT*)a)->state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_zip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "zip", &(((ns1__CTECustomerT*)a)->zip), "xsd:string"))
				{	soap_flag_zip1--;
					continue;
				}
			if (soap_flag_phone11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "phone1", &(((ns1__CTECustomerT*)a)->phone1), "xsd:string"))
				{	soap_flag_phone11--;
					continue;
				}
			if (soap_flag_phone21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "phone2", &(((ns1__CTECustomerT*)a)->phone2), "xsd:string"))
				{	soap_flag_phone21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_firstName1 > 0 || soap_flag_lastName1 > 0 || soap_flag_street11 > 0 || soap_flag_city1 > 0 || soap_flag_state1 > 0 || soap_flag_zip1 > 0 || soap_flag_phone11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTECustomerT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTECustomerT, 0, sizeof(ns1__CTECustomerT), 0, soap_copy_ns1__CTECustomerT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTECustomerT * SOAP_FMAC6 soap_new_ns1__CTECustomerT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTECustomerT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTECustomerT * SOAP_FMAC4 soap_instantiate_ns1__CTECustomerT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTECustomerT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTECustomerT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTECustomerT;
		if (size)
			*size = sizeof(ns1__CTECustomerT);
		((ns1__CTECustomerT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTECustomerT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTECustomerT);
		for (int i = 0; i < n; i++)
			((ns1__CTECustomerT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTECustomerT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTECustomerT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTECustomerT %p -> %p\n", q, p));
	*(ns1__CTECustomerT*)p = *(ns1__CTECustomerT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmPerformanceHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmPerformanceHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmPerformanceHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmPerformanceHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfCmPerformanceHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmPerformanceHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmPerformanceHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmPerformanceHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmPerformanceHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfCmPerformanceHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmPerformanceHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmPerformanceHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmPerformanceHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmPerformanceHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmPerformanceHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmPerformanceHistoryT * SOAP_FMAC4 soap_get_ArrayOfCmPerformanceHistoryT(struct soap *soap, ArrayOfCmPerformanceHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmPerformanceHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmPerformanceHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmPerformanceHistoryT * SOAP_FMAC4 soap_in_ArrayOfCmPerformanceHistoryT(struct soap *soap, const char *tag, ArrayOfCmPerformanceHistoryT *a, const char *type)
{	int i, j;
	ns1__CmPerformanceHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmPerformanceHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmPerformanceHistoryT, sizeof(ArrayOfCmPerformanceHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmPerformanceHistoryT **)soap_malloc(soap, sizeof(ns1__CmPerformanceHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmPerformanceHistoryT(soap, NULL, a->__ptr + i, "ns1:CmPerformanceHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmPerformanceHistoryT **)soap_push_block(soap, sizeof(ns1__CmPerformanceHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmPerformanceHistoryT(soap, NULL, p, "ns1:CmPerformanceHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmPerformanceHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmPerformanceHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmPerformanceHistoryT, 0, sizeof(ArrayOfCmPerformanceHistoryT), 0, soap_copy_ArrayOfCmPerformanceHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmPerformanceHistoryT * SOAP_FMAC6 soap_new_ArrayOfCmPerformanceHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmPerformanceHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmPerformanceHistoryT(struct soap *soap, ArrayOfCmPerformanceHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmPerformanceHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfCmPerformanceHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmPerformanceHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmPerformanceHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmPerformanceHistoryT;
		if (size)
			*size = sizeof(ArrayOfCmPerformanceHistoryT);
		((ArrayOfCmPerformanceHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmPerformanceHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmPerformanceHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmPerformanceHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmPerformanceHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmPerformanceHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmPerformanceHistoryT %p -> %p\n", q, p));
	*(ArrayOfCmPerformanceHistoryT*)p = *(ArrayOfCmPerformanceHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmCurrentPerformanceT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmCurrentPerformanceT*)this)->cmPerformance = NULL;
	soap_default_std__string(soap, &((ns1__CmCurrentPerformanceT*)this)->recordedTime);
	/* transient soap skipped */
}

void ns1__CmCurrentPerformanceT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmPerformanceT(soap, &((ns1__CmCurrentPerformanceT*)this)->cmPerformance);
	soap_embedded(soap, &((ns1__CmCurrentPerformanceT*)this)->recordedTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmCurrentPerformanceT*)this)->recordedTime);
	/* transient soap skipped */
}

int ns1__CmCurrentPerformanceT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmCurrentPerformanceT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmCurrentPerformanceT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmCurrentPerformanceT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmCurrentPerformanceT(struct soap *soap, const char *tag, int id, const ns1__CmCurrentPerformanceT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmCurrentPerformanceT), type);
	soap_out_PointerTons1__CmPerformanceT(soap, "cmPerformance", -1, &(((ns1__CmCurrentPerformanceT*)a)->cmPerformance), "");
	soap_out_std__string(soap, "recordedTime", -1, &(((ns1__CmCurrentPerformanceT*)a)->recordedTime), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmCurrentPerformanceT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmCurrentPerformanceT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmCurrentPerformanceT * SOAP_FMAC4 soap_get_ns1__CmCurrentPerformanceT(struct soap *soap, ns1__CmCurrentPerformanceT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmCurrentPerformanceT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmCurrentPerformanceT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmCurrentPerformanceT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmCurrentPerformanceT * SOAP_FMAC4 soap_in_ns1__CmCurrentPerformanceT(struct soap *soap, const char *tag, ns1__CmCurrentPerformanceT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmCurrentPerformanceT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmCurrentPerformanceT, sizeof(ns1__CmCurrentPerformanceT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmCurrentPerformanceT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmCurrentPerformanceT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmPerformance1 = 1, soap_flag_recordedTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmPerformance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmPerformanceT(soap, "cmPerformance", &(((ns1__CmCurrentPerformanceT*)a)->cmPerformance), "ns1:CmPerformanceT"))
				{	soap_flag_cmPerformance1--;
					continue;
				}
			if (soap_flag_recordedTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "recordedTime", &(((ns1__CmCurrentPerformanceT*)a)->recordedTime), "xsd:string"))
				{	soap_flag_recordedTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmPerformance1 > 0 || soap_flag_recordedTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmCurrentPerformanceT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmCurrentPerformanceT, 0, sizeof(ns1__CmCurrentPerformanceT), 0, soap_copy_ns1__CmCurrentPerformanceT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmCurrentPerformanceT * SOAP_FMAC6 soap_new_ns1__CmCurrentPerformanceT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmCurrentPerformanceT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmCurrentPerformanceT(struct soap *soap, ns1__CmCurrentPerformanceT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmCurrentPerformanceT * SOAP_FMAC4 soap_instantiate_ns1__CmCurrentPerformanceT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmCurrentPerformanceT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmCurrentPerformanceT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmCurrentPerformanceT;
		if (size)
			*size = sizeof(ns1__CmCurrentPerformanceT);
		((ns1__CmCurrentPerformanceT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmCurrentPerformanceT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmCurrentPerformanceT);
		for (int i = 0; i < n; i++)
			((ns1__CmCurrentPerformanceT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmCurrentPerformanceT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmCurrentPerformanceT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmCurrentPerformanceT %p -> %p\n", q, p));
	*(ns1__CmCurrentPerformanceT*)p = *(ns1__CmCurrentPerformanceT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmPerformanceHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmPerformanceHistoryT*)this)->cmPerformance = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmPerformanceHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__CmPerformanceHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmPerformanceT(soap, &((ns1__CmPerformanceHistoryT*)this)->cmPerformance);
	soap_embedded(soap, &((ns1__CmPerformanceHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmPerformanceHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__CmPerformanceHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmPerformanceHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmPerformanceHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmPerformanceHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmPerformanceHistoryT(struct soap *soap, const char *tag, int id, const ns1__CmPerformanceHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmPerformanceHistoryT), type);
	soap_out_PointerTons1__CmPerformanceT(soap, "cmPerformance", -1, &(((ns1__CmPerformanceHistoryT*)a)->cmPerformance), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__CmPerformanceHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmPerformanceHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmPerformanceHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT * SOAP_FMAC4 soap_get_ns1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmPerformanceHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmPerformanceHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT * SOAP_FMAC4 soap_in_ns1__CmPerformanceHistoryT(struct soap *soap, const char *tag, ns1__CmPerformanceHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmPerformanceHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmPerformanceHistoryT, sizeof(ns1__CmPerformanceHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmPerformanceHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmPerformanceHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmPerformance1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmPerformance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmPerformanceT(soap, "cmPerformance", &(((ns1__CmPerformanceHistoryT*)a)->cmPerformance), "ns1:CmPerformanceT"))
				{	soap_flag_cmPerformance1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__CmPerformanceHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmPerformance1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmPerformanceHistoryT, 0, sizeof(ns1__CmPerformanceHistoryT), 0, soap_copy_ns1__CmPerformanceHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmPerformanceHistoryT * SOAP_FMAC6 soap_new_ns1__CmPerformanceHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmPerformanceHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT * SOAP_FMAC4 soap_instantiate_ns1__CmPerformanceHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmPerformanceHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmPerformanceHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmPerformanceHistoryT;
		if (size)
			*size = sizeof(ns1__CmPerformanceHistoryT);
		((ns1__CmPerformanceHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmPerformanceHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmPerformanceHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__CmPerformanceHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmPerformanceHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmPerformanceHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmPerformanceHistoryT %p -> %p\n", q, p));
	*(ns1__CmPerformanceHistoryT*)p = *(ns1__CmPerformanceHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmPerformanceT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->downstreamSNR);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->downstreamPower);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->upstreamPower);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t1Timeouts);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t2Timeouts);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t3Timeouts);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t4Timeouts);
	/* transient soap skipped */
}

void ns1__CmPerformanceT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->downstreamSNR, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->downstreamPower, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->upstreamPower, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t1Timeouts, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t2Timeouts, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t3Timeouts, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t4Timeouts, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__CmPerformanceT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmPerformanceT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmPerformanceT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmPerformanceT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmPerformanceT(struct soap *soap, const char *tag, int id, const ns1__CmPerformanceT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmPerformanceT), type);
	soap_out_short(soap, "downstreamSNR", -1, &(((ns1__CmPerformanceT*)a)->downstreamSNR), "");
	soap_out_short(soap, "downstreamPower", -1, &(((ns1__CmPerformanceT*)a)->downstreamPower), "");
	soap_out_short(soap, "upstreamPower", -1, &(((ns1__CmPerformanceT*)a)->upstreamPower), "");
	soap_out_short(soap, "t1Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t1Timeouts), "");
	soap_out_short(soap, "t2Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t2Timeouts), "");
	soap_out_short(soap, "t3Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t3Timeouts), "");
	soap_out_short(soap, "t4Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t4Timeouts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmPerformanceT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmPerformanceT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmPerformanceT * SOAP_FMAC4 soap_get_ns1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmPerformanceT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmPerformanceT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmPerformanceT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmPerformanceT * SOAP_FMAC4 soap_in_ns1__CmPerformanceT(struct soap *soap, const char *tag, ns1__CmPerformanceT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmPerformanceT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmPerformanceT, sizeof(ns1__CmPerformanceT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmPerformanceT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmPerformanceT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_downstreamSNR1 = 1, soap_flag_downstreamPower1 = 1, soap_flag_upstreamPower1 = 1, soap_flag_t1Timeouts1 = 1, soap_flag_t2Timeouts1 = 1, soap_flag_t3Timeouts1 = 1, soap_flag_t4Timeouts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_downstreamSNR1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "downstreamSNR", &(((ns1__CmPerformanceT*)a)->downstreamSNR), "xsd:short"))
				{	soap_flag_downstreamSNR1--;
					continue;
				}
			if (soap_flag_downstreamPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "downstreamPower", &(((ns1__CmPerformanceT*)a)->downstreamPower), "xsd:short"))
				{	soap_flag_downstreamPower1--;
					continue;
				}
			if (soap_flag_upstreamPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "upstreamPower", &(((ns1__CmPerformanceT*)a)->upstreamPower), "xsd:short"))
				{	soap_flag_upstreamPower1--;
					continue;
				}
			if (soap_flag_t1Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t1Timeouts", &(((ns1__CmPerformanceT*)a)->t1Timeouts), "xsd:short"))
				{	soap_flag_t1Timeouts1--;
					continue;
				}
			if (soap_flag_t2Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t2Timeouts", &(((ns1__CmPerformanceT*)a)->t2Timeouts), "xsd:short"))
				{	soap_flag_t2Timeouts1--;
					continue;
				}
			if (soap_flag_t3Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t3Timeouts", &(((ns1__CmPerformanceT*)a)->t3Timeouts), "xsd:short"))
				{	soap_flag_t3Timeouts1--;
					continue;
				}
			if (soap_flag_t4Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t4Timeouts", &(((ns1__CmPerformanceT*)a)->t4Timeouts), "xsd:short"))
				{	soap_flag_t4Timeouts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_downstreamSNR1 > 0 || soap_flag_downstreamPower1 > 0 || soap_flag_upstreamPower1 > 0 || soap_flag_t1Timeouts1 > 0 || soap_flag_t2Timeouts1 > 0 || soap_flag_t3Timeouts1 > 0 || soap_flag_t4Timeouts1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmPerformanceT, 0, sizeof(ns1__CmPerformanceT), 0, soap_copy_ns1__CmPerformanceT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmPerformanceT * SOAP_FMAC6 soap_new_ns1__CmPerformanceT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmPerformanceT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmPerformanceT * SOAP_FMAC4 soap_instantiate_ns1__CmPerformanceT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmPerformanceT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmPerformanceT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmPerformanceT;
		if (size)
			*size = sizeof(ns1__CmPerformanceT);
		((ns1__CmPerformanceT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmPerformanceT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmPerformanceT);
		for (int i = 0; i < n; i++)
			((ns1__CmPerformanceT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmPerformanceT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmPerformanceT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmPerformanceT %p -> %p\n", q, p));
	*(ns1__CmPerformanceT*)p = *(ns1__CmPerformanceT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaPingStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaPingStatusHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaPingStatusHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaPingStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaPingStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaPingStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaPingStatusHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaPingStatusHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaPingStatusHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaPingStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaPingStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC4 soap_get_ArrayOfMtaPingStatusHistoryT(struct soap *soap, ArrayOfMtaPingStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaPingStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaPingStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC4 soap_in_ArrayOfMtaPingStatusHistoryT(struct soap *soap, const char *tag, ArrayOfMtaPingStatusHistoryT *a, const char *type)
{	int i, j;
	ns1__MtaPingStatusHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaPingStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT, sizeof(ArrayOfMtaPingStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaPingStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaPingStatusHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaPingStatusHistoryT(soap, NULL, a->__ptr + i, "ns1:MtaPingStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaPingStatusHistoryT **)soap_push_block(soap, sizeof(ns1__MtaPingStatusHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaPingStatusHistoryT(soap, NULL, p, "ns1:MtaPingStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaPingStatusHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaPingStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT, 0, sizeof(ArrayOfMtaPingStatusHistoryT), 0, soap_copy_ArrayOfMtaPingStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC6 soap_new_ArrayOfMtaPingStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaPingStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaPingStatusHistoryT(struct soap *soap, ArrayOfMtaPingStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaPingStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaPingStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaPingStatusHistoryT;
		if (size)
			*size = sizeof(ArrayOfMtaPingStatusHistoryT);
		((ArrayOfMtaPingStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaPingStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaPingStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaPingStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaPingStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaPingStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaPingStatusHistoryT %p -> %p\n", q, p));
	*(ArrayOfMtaPingStatusHistoryT*)p = *(ArrayOfMtaPingStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaPingStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaPingStatusHistoryT*)this)->pingStatus = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaPingStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__MtaPingStatusHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaPingStatusT(soap, &((ns1__MtaPingStatusHistoryT*)this)->pingStatus);
	soap_embedded(soap, &((ns1__MtaPingStatusHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaPingStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__MtaPingStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaPingStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaPingStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaPingStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, const ns1__MtaPingStatusHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaPingStatusHistoryT), type);
	soap_out_PointerTons1__MtaPingStatusT(soap, "pingStatus", -1, &(((ns1__MtaPingStatusHistoryT*)a)->pingStatus), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__MtaPingStatusHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaPingStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaPingStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT * SOAP_FMAC4 soap_get_ns1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaPingStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaPingStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT * SOAP_FMAC4 soap_in_ns1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaPingStatusHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaPingStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaPingStatusHistoryT, sizeof(ns1__MtaPingStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaPingStatusHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaPingStatusHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_pingStatus1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pingStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaPingStatusT(soap, "pingStatus", &(((ns1__MtaPingStatusHistoryT*)a)->pingStatus), "ns1:MtaPingStatusT"))
				{	soap_flag_pingStatus1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__MtaPingStatusHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pingStatus1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaPingStatusHistoryT, 0, sizeof(ns1__MtaPingStatusHistoryT), 0, soap_copy_ns1__MtaPingStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaPingStatusHistoryT * SOAP_FMAC6 soap_new_ns1__MtaPingStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaPingStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT * SOAP_FMAC4 soap_instantiate_ns1__MtaPingStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaPingStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaPingStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaPingStatusHistoryT;
		if (size)
			*size = sizeof(ns1__MtaPingStatusHistoryT);
		((ns1__MtaPingStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaPingStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaPingStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaPingStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaPingStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaPingStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaPingStatusHistoryT %p -> %p\n", q, p));
	*(ns1__MtaPingStatusHistoryT*)p = *(ns1__MtaPingStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaPingStatusT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__MtaPingStatusT*)this)->pingState);
	/* transient soap skipped */
}

void ns1__MtaPingStatusT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaPingStatusT*)this)->pingState, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__MtaPingStatusT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaPingStatusT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaPingStatusT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaPingStatusT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaPingStatusT(struct soap *soap, const char *tag, int id, const ns1__MtaPingStatusT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaPingStatusT), type);
	soap_out_short(soap, "pingState", -1, &(((ns1__MtaPingStatusT*)a)->pingState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaPingStatusT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaPingStatusT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaPingStatusT * SOAP_FMAC4 soap_get_ns1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaPingStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaPingStatusT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaPingStatusT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaPingStatusT * SOAP_FMAC4 soap_in_ns1__MtaPingStatusT(struct soap *soap, const char *tag, ns1__MtaPingStatusT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaPingStatusT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaPingStatusT, sizeof(ns1__MtaPingStatusT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaPingStatusT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaPingStatusT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_pingState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pingState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "pingState", &(((ns1__MtaPingStatusT*)a)->pingState), "xsd:short"))
				{	soap_flag_pingState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pingState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaPingStatusT, 0, sizeof(ns1__MtaPingStatusT), 0, soap_copy_ns1__MtaPingStatusT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaPingStatusT * SOAP_FMAC6 soap_new_ns1__MtaPingStatusT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaPingStatusT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaPingStatusT * SOAP_FMAC4 soap_instantiate_ns1__MtaPingStatusT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaPingStatusT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaPingStatusT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaPingStatusT;
		if (size)
			*size = sizeof(ns1__MtaPingStatusT);
		((ns1__MtaPingStatusT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaPingStatusT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaPingStatusT);
		for (int i = 0; i < n; i++)
			((ns1__MtaPingStatusT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaPingStatusT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaPingStatusT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaPingStatusT %p -> %p\n", q, p));
	*(ns1__MtaPingStatusT*)p = *(ns1__MtaPingStatusT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaProvStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaProvStatusHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaProvStatusHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaProvStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaProvStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaProvStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaProvStatusHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaProvStatusHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaProvStatusHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaProvStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaProvStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC4 soap_get_ArrayOfMtaProvStatusHistoryT(struct soap *soap, ArrayOfMtaProvStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaProvStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaProvStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC4 soap_in_ArrayOfMtaProvStatusHistoryT(struct soap *soap, const char *tag, ArrayOfMtaProvStatusHistoryT *a, const char *type)
{	int i, j;
	ns1__MtaProvStatusHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaProvStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT, sizeof(ArrayOfMtaProvStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaProvStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaProvStatusHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaProvStatusHistoryT(soap, NULL, a->__ptr + i, "ns1:MtaProvStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaProvStatusHistoryT **)soap_push_block(soap, sizeof(ns1__MtaProvStatusHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaProvStatusHistoryT(soap, NULL, p, "ns1:MtaProvStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaProvStatusHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaProvStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT, 0, sizeof(ArrayOfMtaProvStatusHistoryT), 0, soap_copy_ArrayOfMtaProvStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC6 soap_new_ArrayOfMtaProvStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaProvStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaProvStatusHistoryT(struct soap *soap, ArrayOfMtaProvStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaProvStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaProvStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaProvStatusHistoryT;
		if (size)
			*size = sizeof(ArrayOfMtaProvStatusHistoryT);
		((ArrayOfMtaProvStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaProvStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaProvStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaProvStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaProvStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaProvStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaProvStatusHistoryT %p -> %p\n", q, p));
	*(ArrayOfMtaProvStatusHistoryT*)p = *(ArrayOfMtaProvStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaProvStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaProvStatusHistoryT*)this)->provStatus = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaProvStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__MtaProvStatusHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaProvStatusT(soap, &((ns1__MtaProvStatusHistoryT*)this)->provStatus);
	soap_embedded(soap, &((ns1__MtaProvStatusHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaProvStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__MtaProvStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaProvStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaProvStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaProvStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, const ns1__MtaProvStatusHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaProvStatusHistoryT), type);
	soap_out_PointerTons1__MtaProvStatusT(soap, "provStatus", -1, &(((ns1__MtaProvStatusHistoryT*)a)->provStatus), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__MtaProvStatusHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaProvStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaProvStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT * SOAP_FMAC4 soap_get_ns1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaProvStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaProvStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT * SOAP_FMAC4 soap_in_ns1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaProvStatusHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaProvStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaProvStatusHistoryT, sizeof(ns1__MtaProvStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaProvStatusHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaProvStatusHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_provStatus1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_provStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaProvStatusT(soap, "provStatus", &(((ns1__MtaProvStatusHistoryT*)a)->provStatus), "ns1:MtaProvStatusT"))
				{	soap_flag_provStatus1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__MtaProvStatusHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_provStatus1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaProvStatusHistoryT, 0, sizeof(ns1__MtaProvStatusHistoryT), 0, soap_copy_ns1__MtaProvStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaProvStatusHistoryT * SOAP_FMAC6 soap_new_ns1__MtaProvStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaProvStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT * SOAP_FMAC4 soap_instantiate_ns1__MtaProvStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaProvStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaProvStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaProvStatusHistoryT;
		if (size)
			*size = sizeof(ns1__MtaProvStatusHistoryT);
		((ns1__MtaProvStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaProvStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaProvStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaProvStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaProvStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaProvStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaProvStatusHistoryT %p -> %p\n", q, p));
	*(ns1__MtaProvStatusHistoryT*)p = *(ns1__MtaProvStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaProvStatusT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__MtaProvStatusT*)this)->provState);
	/* transient soap skipped */
}

void ns1__MtaProvStatusT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaProvStatusT*)this)->provState, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__MtaProvStatusT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaProvStatusT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaProvStatusT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaProvStatusT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaProvStatusT(struct soap *soap, const char *tag, int id, const ns1__MtaProvStatusT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaProvStatusT), type);
	soap_out_short(soap, "provState", -1, &(((ns1__MtaProvStatusT*)a)->provState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaProvStatusT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaProvStatusT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaProvStatusT * SOAP_FMAC4 soap_get_ns1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaProvStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaProvStatusT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaProvStatusT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaProvStatusT * SOAP_FMAC4 soap_in_ns1__MtaProvStatusT(struct soap *soap, const char *tag, ns1__MtaProvStatusT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaProvStatusT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaProvStatusT, sizeof(ns1__MtaProvStatusT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaProvStatusT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaProvStatusT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_provState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_provState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "provState", &(((ns1__MtaProvStatusT*)a)->provState), "xsd:short"))
				{	soap_flag_provState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_provState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaProvStatusT, 0, sizeof(ns1__MtaProvStatusT), 0, soap_copy_ns1__MtaProvStatusT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaProvStatusT * SOAP_FMAC6 soap_new_ns1__MtaProvStatusT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaProvStatusT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaProvStatusT * SOAP_FMAC4 soap_instantiate_ns1__MtaProvStatusT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaProvStatusT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaProvStatusT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaProvStatusT;
		if (size)
			*size = sizeof(ns1__MtaProvStatusT);
		((ns1__MtaProvStatusT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaProvStatusT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaProvStatusT);
		for (int i = 0; i < n; i++)
			((ns1__MtaProvStatusT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaProvStatusT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaProvStatusT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaProvStatusT %p -> %p\n", q, p));
	*(ns1__MtaProvStatusT*)p = *(ns1__MtaProvStatusT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaAvailabilityHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaAvailabilityHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaAvailabilityHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaAvailabilityHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaAvailabilityHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaAvailabilityHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaAvailabilityHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaAvailabilityHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaAvailabilityHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaAvailabilityHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC4 soap_get_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, ArrayOfMtaAvailabilityHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaAvailabilityHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaAvailabilityHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC4 soap_in_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, const char *tag, ArrayOfMtaAvailabilityHistoryT *a, const char *type)
{	int i, j;
	ns1__MtaAvailabilityHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaAvailabilityHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT, sizeof(ArrayOfMtaAvailabilityHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaAvailabilityHistoryT **)soap_malloc(soap, sizeof(ns1__MtaAvailabilityHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, NULL, a->__ptr + i, "ns1:MtaAvailabilityHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaAvailabilityHistoryT **)soap_push_block(soap, sizeof(ns1__MtaAvailabilityHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, NULL, p, "ns1:MtaAvailabilityHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaAvailabilityHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaAvailabilityHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT, 0, sizeof(ArrayOfMtaAvailabilityHistoryT), 0, soap_copy_ArrayOfMtaAvailabilityHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC6 soap_new_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaAvailabilityHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, ArrayOfMtaAvailabilityHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaAvailabilityHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaAvailabilityHistoryT;
		if (size)
			*size = sizeof(ArrayOfMtaAvailabilityHistoryT);
		((ArrayOfMtaAvailabilityHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaAvailabilityHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaAvailabilityHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaAvailabilityHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaAvailabilityHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaAvailabilityHistoryT %p -> %p\n", q, p));
	*(ArrayOfMtaAvailabilityHistoryT*)p = *(ArrayOfMtaAvailabilityHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaAvailabilityHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaAvailabilityHistoryT*)this)->available = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaAvailabilityHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__MtaAvailabilityHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaAvailabilityT(soap, &((ns1__MtaAvailabilityHistoryT*)this)->available);
	soap_embedded(soap, &((ns1__MtaAvailabilityHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaAvailabilityHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__MtaAvailabilityHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaAvailabilityHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaAvailabilityHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaAvailabilityHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, const ns1__MtaAvailabilityHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT), type);
	soap_out_PointerTons1__MtaAvailabilityT(soap, "available", -1, &(((ns1__MtaAvailabilityHistoryT*)a)->available), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__MtaAvailabilityHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaAvailabilityHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaAvailabilityHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT * SOAP_FMAC4 soap_get_ns1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaAvailabilityHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaAvailabilityHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT * SOAP_FMAC4 soap_in_ns1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, ns1__MtaAvailabilityHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaAvailabilityHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, sizeof(ns1__MtaAvailabilityHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaAvailabilityHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaAvailabilityHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_available1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_available1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaAvailabilityT(soap, "available", &(((ns1__MtaAvailabilityHistoryT*)a)->available), "ns1:MtaAvailabilityT"))
				{	soap_flag_available1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__MtaAvailabilityHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_available1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, 0, sizeof(ns1__MtaAvailabilityHistoryT), 0, soap_copy_ns1__MtaAvailabilityHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaAvailabilityHistoryT * SOAP_FMAC6 soap_new_ns1__MtaAvailabilityHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaAvailabilityHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT * SOAP_FMAC4 soap_instantiate_ns1__MtaAvailabilityHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaAvailabilityHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaAvailabilityHistoryT;
		if (size)
			*size = sizeof(ns1__MtaAvailabilityHistoryT);
		((ns1__MtaAvailabilityHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaAvailabilityHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaAvailabilityHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaAvailabilityHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaAvailabilityHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaAvailabilityHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaAvailabilityHistoryT %p -> %p\n", q, p));
	*(ns1__MtaAvailabilityHistoryT*)p = *(ns1__MtaAvailabilityHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaAvailabilityT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__MtaAvailabilityT*)this)->available);
	/* transient soap skipped */
}

void ns1__MtaAvailabilityT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaAvailabilityT*)this)->available, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__MtaAvailabilityT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaAvailabilityT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaAvailabilityT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaAvailabilityT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaAvailabilityT(struct soap *soap, const char *tag, int id, const ns1__MtaAvailabilityT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaAvailabilityT), type);
	soap_out_short(soap, "available", -1, &(((ns1__MtaAvailabilityT*)a)->available), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaAvailabilityT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaAvailabilityT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityT * SOAP_FMAC4 soap_get_ns1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaAvailabilityT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaAvailabilityT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaAvailabilityT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityT * SOAP_FMAC4 soap_in_ns1__MtaAvailabilityT(struct soap *soap, const char *tag, ns1__MtaAvailabilityT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaAvailabilityT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaAvailabilityT, sizeof(ns1__MtaAvailabilityT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaAvailabilityT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaAvailabilityT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_available1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_available1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "available", &(((ns1__MtaAvailabilityT*)a)->available), "xsd:short"))
				{	soap_flag_available1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_available1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaAvailabilityT, 0, sizeof(ns1__MtaAvailabilityT), 0, soap_copy_ns1__MtaAvailabilityT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaAvailabilityT * SOAP_FMAC6 soap_new_ns1__MtaAvailabilityT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaAvailabilityT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaAvailabilityT * SOAP_FMAC4 soap_instantiate_ns1__MtaAvailabilityT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaAvailabilityT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaAvailabilityT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaAvailabilityT;
		if (size)
			*size = sizeof(ns1__MtaAvailabilityT);
		((ns1__MtaAvailabilityT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaAvailabilityT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaAvailabilityT);
		for (int i = 0; i < n; i++)
			((ns1__MtaAvailabilityT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaAvailabilityT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaAvailabilityT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaAvailabilityT %p -> %p\n", q, p));
	*(ns1__MtaAvailabilityT*)p = *(ns1__MtaAvailabilityT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmStatusHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmStatusHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmStatusHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfCmStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmStatusHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfCmStatusHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmStatusHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmStatusHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmStatusHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmStatusHistoryT * SOAP_FMAC4 soap_get_ArrayOfCmStatusHistoryT(struct soap *soap, ArrayOfCmStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmStatusHistoryT * SOAP_FMAC4 soap_in_ArrayOfCmStatusHistoryT(struct soap *soap, const char *tag, ArrayOfCmStatusHistoryT *a, const char *type)
{	int i, j;
	ns1__CmStatusHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmStatusHistoryT, sizeof(ArrayOfCmStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmStatusHistoryT **)soap_malloc(soap, sizeof(ns1__CmStatusHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmStatusHistoryT(soap, NULL, a->__ptr + i, "ns1:CmStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmStatusHistoryT **)soap_push_block(soap, sizeof(ns1__CmStatusHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmStatusHistoryT(soap, NULL, p, "ns1:CmStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmStatusHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmStatusHistoryT, 0, sizeof(ArrayOfCmStatusHistoryT), 0, soap_copy_ArrayOfCmStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmStatusHistoryT * SOAP_FMAC6 soap_new_ArrayOfCmStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmStatusHistoryT(struct soap *soap, ArrayOfCmStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmStatusHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfCmStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmStatusHistoryT;
		if (size)
			*size = sizeof(ArrayOfCmStatusHistoryT);
		((ArrayOfCmStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmStatusHistoryT %p -> %p\n", q, p));
	*(ArrayOfCmStatusHistoryT*)p = *(ArrayOfCmStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmStatusHistoryT*)this)->cmStatus = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__CmStatusHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmStatusT(soap, &((ns1__CmStatusHistoryT*)this)->cmStatus);
	soap_embedded(soap, &((ns1__CmStatusHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__CmStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusHistoryT(struct soap *soap, const char *tag, int id, const ns1__CmStatusHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusHistoryT), type);
	soap_out_PointerTons1__CmStatusT(soap, "cmStatus", -1, &(((ns1__CmStatusHistoryT*)a)->cmStatus), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__CmStatusHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT * SOAP_FMAC4 soap_get_ns1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT * SOAP_FMAC4 soap_in_ns1__CmStatusHistoryT(struct soap *soap, const char *tag, ns1__CmStatusHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusHistoryT, sizeof(ns1__CmStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmStatus1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmStatusT(soap, "cmStatus", &(((ns1__CmStatusHistoryT*)a)->cmStatus), "ns1:CmStatusT"))
				{	soap_flag_cmStatus1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__CmStatusHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmStatus1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusHistoryT, 0, sizeof(ns1__CmStatusHistoryT), 0, soap_copy_ns1__CmStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusHistoryT * SOAP_FMAC6 soap_new_ns1__CmStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusHistoryT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusHistoryT;
		if (size)
			*size = sizeof(ns1__CmStatusHistoryT);
		((ns1__CmStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusHistoryT %p -> %p\n", q, p));
	*(ns1__CmStatusHistoryT*)p = *(ns1__CmStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__CmStatusT*)this)->docsisState);
	/* transient soap skipped */
}

void ns1__CmStatusT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmStatusT*)this)->docsisState, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__CmStatusT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusT(struct soap *soap, const char *tag, int id, const ns1__CmStatusT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusT), type);
	soap_out_short(soap, "docsisState", -1, &(((ns1__CmStatusT*)a)->docsisState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusT * SOAP_FMAC4 soap_get_ns1__CmStatusT(struct soap *soap, ns1__CmStatusT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusT * SOAP_FMAC4 soap_in_ns1__CmStatusT(struct soap *soap, const char *tag, ns1__CmStatusT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusT, sizeof(ns1__CmStatusT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_docsisState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_docsisState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "docsisState", &(((ns1__CmStatusT*)a)->docsisState), "xsd:short"))
				{	soap_flag_docsisState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_docsisState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusT, 0, sizeof(ns1__CmStatusT), 0, soap_copy_ns1__CmStatusT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusT * SOAP_FMAC6 soap_new_ns1__CmStatusT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusT(struct soap *soap, ns1__CmStatusT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusT;
		if (size)
			*size = sizeof(ns1__CmStatusT);
		((ns1__CmStatusT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusT %p -> %p\n", q, p));
	*(ns1__CmStatusT*)p = *(ns1__CmStatusT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfGenericCountsHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfGenericCountsHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfGenericCountsHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__GenericCountsHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfGenericCountsHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfGenericCountsHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfGenericCountsHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfGenericCountsHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfGenericCountsHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfGenericCountsHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:GenericCountsHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfGenericCountsHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__GenericCountsHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfGenericCountsHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfGenericCountsHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfGenericCountsHistoryT * SOAP_FMAC4 soap_get_ArrayOfGenericCountsHistoryT(struct soap *soap, ArrayOfGenericCountsHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfGenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfGenericCountsHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfGenericCountsHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfGenericCountsHistoryT * SOAP_FMAC4 soap_in_ArrayOfGenericCountsHistoryT(struct soap *soap, const char *tag, ArrayOfGenericCountsHistoryT *a, const char *type)
{	int i, j;
	ns1__GenericCountsHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfGenericCountsHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfGenericCountsHistoryT, sizeof(ArrayOfGenericCountsHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__GenericCountsHistoryT **)soap_malloc(soap, sizeof(ns1__GenericCountsHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__GenericCountsHistoryT(soap, NULL, a->__ptr + i, "ns1:GenericCountsHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__GenericCountsHistoryT **)soap_push_block(soap, sizeof(ns1__GenericCountsHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__GenericCountsHistoryT(soap, NULL, p, "ns1:GenericCountsHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__GenericCountsHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfGenericCountsHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfGenericCountsHistoryT, 0, sizeof(ArrayOfGenericCountsHistoryT), 0, soap_copy_ArrayOfGenericCountsHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfGenericCountsHistoryT * SOAP_FMAC6 soap_new_ArrayOfGenericCountsHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfGenericCountsHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfGenericCountsHistoryT(struct soap *soap, ArrayOfGenericCountsHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfGenericCountsHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfGenericCountsHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfGenericCountsHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfGenericCountsHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfGenericCountsHistoryT;
		if (size)
			*size = sizeof(ArrayOfGenericCountsHistoryT);
		((ArrayOfGenericCountsHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfGenericCountsHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfGenericCountsHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfGenericCountsHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfGenericCountsHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfGenericCountsHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfGenericCountsHistoryT %p -> %p\n", q, p));
	*(ArrayOfGenericCountsHistoryT*)p = *(ArrayOfGenericCountsHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__GenericCountsHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__GenericCountsHistoryT*)this)->counts = NULL;
	soap_default_xsd__integer(soap, &((ns1__GenericCountsHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__GenericCountsHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__GenericCountsHistoryT*)this)->counts);
	soap_embedded(soap, &((ns1__GenericCountsHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__GenericCountsHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__GenericCountsHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GenericCountsHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__GenericCountsHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericCountsHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericCountsHistoryT(struct soap *soap, const char *tag, int id, const ns1__GenericCountsHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericCountsHistoryT), type);
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__GenericCountsHistoryT*)a)->counts), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__GenericCountsHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__GenericCountsHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericCountsHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT * SOAP_FMAC4 soap_get_ns1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__GenericCountsHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GenericCountsHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT * SOAP_FMAC4 soap_in_ns1__GenericCountsHistoryT(struct soap *soap, const char *tag, ns1__GenericCountsHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericCountsHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericCountsHistoryT, sizeof(ns1__GenericCountsHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GenericCountsHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GenericCountsHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_counts1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__GenericCountsHistoryT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__GenericCountsHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_counts1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericCountsHistoryT, 0, sizeof(ns1__GenericCountsHistoryT), 0, soap_copy_ns1__GenericCountsHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__GenericCountsHistoryT * SOAP_FMAC6 soap_new_ns1__GenericCountsHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__GenericCountsHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT * SOAP_FMAC4 soap_instantiate_ns1__GenericCountsHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericCountsHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GenericCountsHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__GenericCountsHistoryT;
		if (size)
			*size = sizeof(ns1__GenericCountsHistoryT);
		((ns1__GenericCountsHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__GenericCountsHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GenericCountsHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__GenericCountsHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GenericCountsHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GenericCountsHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GenericCountsHistoryT %p -> %p\n", q, p));
	*(ns1__GenericCountsHistoryT*)p = *(ns1__GenericCountsHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfQueryStateT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfQueryStateT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfQueryStateT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__QueryStateT(soap, this->__ptr + i);
		}
}

int ArrayOfQueryStateT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfQueryStateT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfQueryStateT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfQueryStateT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfQueryStateT(struct soap *soap, const char *tag, int id, const ArrayOfQueryStateT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:QueryStateT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfQueryStateT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__QueryStateT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfQueryStateT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfQueryStateT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfQueryStateT * SOAP_FMAC4 soap_get_ArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfQueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfQueryStateT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfQueryStateT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfQueryStateT * SOAP_FMAC4 soap_in_ArrayOfQueryStateT(struct soap *soap, const char *tag, ArrayOfQueryStateT *a, const char *type)
{	int i, j;
	ns1__QueryStateT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfQueryStateT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfQueryStateT, sizeof(ArrayOfQueryStateT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__QueryStateT **)soap_malloc(soap, sizeof(ns1__QueryStateT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__QueryStateT(soap, NULL, a->__ptr + i, "ns1:QueryStateT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__QueryStateT **)soap_push_block(soap, sizeof(ns1__QueryStateT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__QueryStateT(soap, NULL, p, "ns1:QueryStateT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__QueryStateT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfQueryStateT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfQueryStateT, 0, sizeof(ArrayOfQueryStateT), 0, soap_copy_ArrayOfQueryStateT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfQueryStateT * SOAP_FMAC6 soap_new_ArrayOfQueryStateT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfQueryStateT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfQueryStateT * SOAP_FMAC4 soap_instantiate_ArrayOfQueryStateT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfQueryStateT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfQueryStateT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfQueryStateT;
		if (size)
			*size = sizeof(ArrayOfQueryStateT);
		((ArrayOfQueryStateT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfQueryStateT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfQueryStateT);
		for (int i = 0; i < n; i++)
			((ArrayOfQueryStateT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfQueryStateT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfQueryStateT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfQueryStateT %p -> %p\n", q, p));
	*(ArrayOfQueryStateT*)p = *(ArrayOfQueryStateT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__QueryStateT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__QueryStateT*)this)->topologyKey = NULL;
	((ns1__QueryStateT*)this)->pages = NULL;
	/* transient soap skipped */
}

void ns1__QueryStateT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__QueryStateT*)this)->topologyKey);
	soap_serialize_PointerToArrayOfScrollPageT(soap, &((ns1__QueryStateT*)this)->pages);
	/* transient soap skipped */
}

int ns1__QueryStateT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__QueryStateT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__QueryStateT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QueryStateT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QueryStateT(struct soap *soap, const char *tag, int id, const ns1__QueryStateT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QueryStateT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__QueryStateT*)a)->topologyKey), "");
	soap_out_PointerToArrayOfScrollPageT(soap, "pages", -1, &(((ns1__QueryStateT*)a)->pages), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__QueryStateT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QueryStateT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QueryStateT * SOAP_FMAC4 soap_get_ns1__QueryStateT(struct soap *soap, ns1__QueryStateT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__QueryStateT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__QueryStateT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QueryStateT * SOAP_FMAC4 soap_in_ns1__QueryStateT(struct soap *soap, const char *tag, ns1__QueryStateT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QueryStateT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryStateT, sizeof(ns1__QueryStateT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__QueryStateT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__QueryStateT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_pages1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__QueryStateT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_pages1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfScrollPageT(soap, "pages", &(((ns1__QueryStateT*)a)->pages), "ns1:ScrollPageT"))
				{	soap_flag_pages1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pages1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QueryStateT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QueryStateT, 0, sizeof(ns1__QueryStateT), 0, soap_copy_ns1__QueryStateT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__QueryStateT * SOAP_FMAC6 soap_new_ns1__QueryStateT(struct soap *soap, int n)
{	return soap_instantiate_ns1__QueryStateT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__QueryStateT(struct soap *soap, ns1__QueryStateT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__QueryStateT * SOAP_FMAC4 soap_instantiate_ns1__QueryStateT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QueryStateT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__QueryStateT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__QueryStateT;
		if (size)
			*size = sizeof(ns1__QueryStateT);
		((ns1__QueryStateT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__QueryStateT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__QueryStateT);
		for (int i = 0; i < n; i++)
			((ns1__QueryStateT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__QueryStateT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__QueryStateT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__QueryStateT %p -> %p\n", q, p));
	*(ns1__QueryStateT*)p = *(ns1__QueryStateT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfScrollPageT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfScrollPageT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfScrollPageT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ScrollPageT(soap, this->__ptr + i);
		}
}

int ArrayOfScrollPageT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfScrollPageT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfScrollPageT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfScrollPageT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfScrollPageT(struct soap *soap, const char *tag, int id, const ArrayOfScrollPageT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ScrollPageT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfScrollPageT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ScrollPageT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfScrollPageT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfScrollPageT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfScrollPageT * SOAP_FMAC4 soap_get_ArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfScrollPageT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfScrollPageT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfScrollPageT * SOAP_FMAC4 soap_in_ArrayOfScrollPageT(struct soap *soap, const char *tag, ArrayOfScrollPageT *a, const char *type)
{	int i, j;
	ns1__ScrollPageT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfScrollPageT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfScrollPageT, sizeof(ArrayOfScrollPageT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ScrollPageT **)soap_malloc(soap, sizeof(ns1__ScrollPageT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ScrollPageT(soap, NULL, a->__ptr + i, "ns1:ScrollPageT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ScrollPageT **)soap_push_block(soap, sizeof(ns1__ScrollPageT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ScrollPageT(soap, NULL, p, "ns1:ScrollPageT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__ScrollPageT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfScrollPageT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfScrollPageT, 0, sizeof(ArrayOfScrollPageT), 0, soap_copy_ArrayOfScrollPageT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfScrollPageT * SOAP_FMAC6 soap_new_ArrayOfScrollPageT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfScrollPageT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfScrollPageT * SOAP_FMAC4 soap_instantiate_ArrayOfScrollPageT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfScrollPageT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfScrollPageT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfScrollPageT;
		if (size)
			*size = sizeof(ArrayOfScrollPageT);
		((ArrayOfScrollPageT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfScrollPageT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfScrollPageT);
		for (int i = 0; i < n; i++)
			((ArrayOfScrollPageT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfScrollPageT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfScrollPageT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfScrollPageT %p -> %p\n", q, p));
	*(ArrayOfScrollPageT*)p = *(ArrayOfScrollPageT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ScrollPageT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ScrollPageT*)this)->batch = NULL;
	soap_default_std__string(soap, &((ns1__ScrollPageT*)this)->start);
	/* transient soap skipped */
}

void ns1__ScrollPageT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ResultBatchT(soap, &((ns1__ScrollPageT*)this)->batch);
	soap_embedded(soap, &((ns1__ScrollPageT*)this)->start, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__ScrollPageT*)this)->start);
	/* transient soap skipped */
}

int ns1__ScrollPageT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ScrollPageT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ScrollPageT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScrollPageT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScrollPageT(struct soap *soap, const char *tag, int id, const ns1__ScrollPageT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScrollPageT), type);
	soap_out_PointerTons1__ResultBatchT(soap, "batch", -1, &(((ns1__ScrollPageT*)a)->batch), "");
	soap_out_std__string(soap, "start", -1, &(((ns1__ScrollPageT*)a)->start), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ScrollPageT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScrollPageT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScrollPageT * SOAP_FMAC4 soap_get_ns1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ScrollPageT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ScrollPageT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScrollPageT * SOAP_FMAC4 soap_in_ns1__ScrollPageT(struct soap *soap, const char *tag, ns1__ScrollPageT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScrollPageT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScrollPageT, sizeof(ns1__ScrollPageT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ScrollPageT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ScrollPageT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_batch1 = 1, soap_flag_start1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ResultBatchT(soap, "batch", &(((ns1__ScrollPageT*)a)->batch), "ns1:ResultBatchT"))
				{	soap_flag_batch1--;
					continue;
				}
			if (soap_flag_start1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "start", &(((ns1__ScrollPageT*)a)->start), "xsd:string"))
				{	soap_flag_start1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_batch1 > 0 || soap_flag_start1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScrollPageT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScrollPageT, 0, sizeof(ns1__ScrollPageT), 0, soap_copy_ns1__ScrollPageT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ScrollPageT * SOAP_FMAC6 soap_new_ns1__ScrollPageT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ScrollPageT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ScrollPageT * SOAP_FMAC4 soap_instantiate_ns1__ScrollPageT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScrollPageT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ScrollPageT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ScrollPageT;
		if (size)
			*size = sizeof(ns1__ScrollPageT);
		((ns1__ScrollPageT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ScrollPageT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ScrollPageT);
		for (int i = 0; i < n; i++)
			((ns1__ScrollPageT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ScrollPageT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ScrollPageT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ScrollPageT %p -> %p\n", q, p));
	*(ns1__ScrollPageT*)p = *(ns1__ScrollPageT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MappedEuDevicesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MappedEuDevicesT*)this)->cm = NULL;
	((ns1__MappedEuDevicesT*)this)->mta = NULL;
	/* transient soap skipped */
}

void ns1__MappedEuDevicesT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CableModemT(soap, &((ns1__MappedEuDevicesT*)this)->cm);
	soap_serialize_PointerTons1__EmtaT(soap, &((ns1__MappedEuDevicesT*)this)->mta);
	/* transient soap skipped */
}

int ns1__MappedEuDevicesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MappedEuDevicesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MappedEuDevicesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MappedEuDevicesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MappedEuDevicesT(struct soap *soap, const char *tag, int id, const ns1__MappedEuDevicesT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MappedEuDevicesT), type);
	soap_out_PointerTons1__CableModemT(soap, "cm", -1, &(((ns1__MappedEuDevicesT*)a)->cm), "");
	soap_out_PointerTons1__EmtaT(soap, "mta", -1, &(((ns1__MappedEuDevicesT*)a)->mta), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MappedEuDevicesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MappedEuDevicesT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MappedEuDevicesT * SOAP_FMAC4 soap_get_ns1__MappedEuDevicesT(struct soap *soap, ns1__MappedEuDevicesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MappedEuDevicesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MappedEuDevicesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MappedEuDevicesT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MappedEuDevicesT * SOAP_FMAC4 soap_in_ns1__MappedEuDevicesT(struct soap *soap, const char *tag, ns1__MappedEuDevicesT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MappedEuDevicesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MappedEuDevicesT, sizeof(ns1__MappedEuDevicesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MappedEuDevicesT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MappedEuDevicesT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cm1 = 1, soap_flag_mta1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CableModemT(soap, "cm", &(((ns1__MappedEuDevicesT*)a)->cm), "ns1:CableModemT"))
				{	soap_flag_cm1--;
					continue;
				}
			if (soap_flag_mta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EmtaT(soap, "mta", &(((ns1__MappedEuDevicesT*)a)->mta), "ns1:EmtaT"))
				{	soap_flag_mta1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MappedEuDevicesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MappedEuDevicesT, 0, sizeof(ns1__MappedEuDevicesT), 0, soap_copy_ns1__MappedEuDevicesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MappedEuDevicesT * SOAP_FMAC6 soap_new_ns1__MappedEuDevicesT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MappedEuDevicesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MappedEuDevicesT(struct soap *soap, ns1__MappedEuDevicesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MappedEuDevicesT * SOAP_FMAC4 soap_instantiate_ns1__MappedEuDevicesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MappedEuDevicesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MappedEuDevicesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MappedEuDevicesT;
		if (size)
			*size = sizeof(ns1__MappedEuDevicesT);
		((ns1__MappedEuDevicesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MappedEuDevicesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MappedEuDevicesT);
		for (int i = 0; i < n; i++)
			((ns1__MappedEuDevicesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MappedEuDevicesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MappedEuDevicesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MappedEuDevicesT %p -> %p\n", q, p));
	*(ns1__MappedEuDevicesT*)p = *(ns1__MappedEuDevicesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAlarmHistoriesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAlarmHistoriesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAlarmHistoriesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AlarmHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfAlarmHistoriesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAlarmHistoriesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAlarmHistoriesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAlarmHistoriesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAlarmHistoriesT(struct soap *soap, const char *tag, int id, const ArrayOfAlarmHistoriesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AlarmHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmHistoriesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AlarmHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAlarmHistoriesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAlarmHistoriesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAlarmHistoriesT * SOAP_FMAC4 soap_get_ArrayOfAlarmHistoriesT(struct soap *soap, ArrayOfAlarmHistoriesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAlarmHistoriesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAlarmHistoriesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAlarmHistoriesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAlarmHistoriesT * SOAP_FMAC4 soap_in_ArrayOfAlarmHistoriesT(struct soap *soap, const char *tag, ArrayOfAlarmHistoriesT *a, const char *type)
{	int i, j;
	ns1__AlarmHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAlarmHistoriesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAlarmHistoriesT, sizeof(ArrayOfAlarmHistoriesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AlarmHistoryT **)soap_malloc(soap, sizeof(ns1__AlarmHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AlarmHistoryT(soap, NULL, a->__ptr + i, "ns1:AlarmHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AlarmHistoryT **)soap_push_block(soap, sizeof(ns1__AlarmHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AlarmHistoryT(soap, NULL, p, "ns1:AlarmHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AlarmHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmHistoriesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAlarmHistoriesT, 0, sizeof(ArrayOfAlarmHistoriesT), 0, soap_copy_ArrayOfAlarmHistoriesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAlarmHistoriesT * SOAP_FMAC6 soap_new_ArrayOfAlarmHistoriesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAlarmHistoriesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAlarmHistoriesT(struct soap *soap, ArrayOfAlarmHistoriesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAlarmHistoriesT * SOAP_FMAC4 soap_instantiate_ArrayOfAlarmHistoriesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAlarmHistoriesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAlarmHistoriesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAlarmHistoriesT;
		if (size)
			*size = sizeof(ArrayOfAlarmHistoriesT);
		((ArrayOfAlarmHistoriesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAlarmHistoriesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAlarmHistoriesT);
		for (int i = 0; i < n; i++)
			((ArrayOfAlarmHistoriesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAlarmHistoriesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAlarmHistoriesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAlarmHistoriesT %p -> %p\n", q, p));
	*(ArrayOfAlarmHistoriesT*)p = *(ArrayOfAlarmHistoriesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfHistoricalAlarmsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfHistoricalAlarmsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfHistoricalAlarmsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__HistoricalAlarmT(soap, this->__ptr + i);
		}
}

int ArrayOfHistoricalAlarmsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfHistoricalAlarmsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfHistoricalAlarmsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfHistoricalAlarmsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, int id, const ArrayOfHistoricalAlarmsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:HistoricalAlarmT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfHistoricalAlarmsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__HistoricalAlarmT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfHistoricalAlarmsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfHistoricalAlarmsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT * SOAP_FMAC4 soap_get_ArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfHistoricalAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfHistoricalAlarmsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfHistoricalAlarmsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT * SOAP_FMAC4 soap_in_ArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, ArrayOfHistoricalAlarmsT *a, const char *type)
{	int i, j;
	ns1__HistoricalAlarmT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfHistoricalAlarmsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfHistoricalAlarmsT, sizeof(ArrayOfHistoricalAlarmsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__HistoricalAlarmT **)soap_malloc(soap, sizeof(ns1__HistoricalAlarmT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__HistoricalAlarmT(soap, NULL, a->__ptr + i, "ns1:HistoricalAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__HistoricalAlarmT **)soap_push_block(soap, sizeof(ns1__HistoricalAlarmT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__HistoricalAlarmT(soap, NULL, p, "ns1:HistoricalAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__HistoricalAlarmT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfHistoricalAlarmsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfHistoricalAlarmsT, 0, sizeof(ArrayOfHistoricalAlarmsT), 0, soap_copy_ArrayOfHistoricalAlarmsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfHistoricalAlarmsT * SOAP_FMAC6 soap_new_ArrayOfHistoricalAlarmsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfHistoricalAlarmsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT * SOAP_FMAC4 soap_instantiate_ArrayOfHistoricalAlarmsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfHistoricalAlarmsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfHistoricalAlarmsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfHistoricalAlarmsT;
		if (size)
			*size = sizeof(ArrayOfHistoricalAlarmsT);
		((ArrayOfHistoricalAlarmsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfHistoricalAlarmsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfHistoricalAlarmsT);
		for (int i = 0; i < n; i++)
			((ArrayOfHistoricalAlarmsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfHistoricalAlarmsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfHistoricalAlarmsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfHistoricalAlarmsT %p -> %p\n", q, p));
	*(ArrayOfHistoricalAlarmsT*)p = *(ArrayOfHistoricalAlarmsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCurrentAlarmsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCurrentAlarmsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCurrentAlarmsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CurrentAlarmT(soap, this->__ptr + i);
		}
}

int ArrayOfCurrentAlarmsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCurrentAlarmsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCurrentAlarmsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCurrentAlarmsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, int id, const ArrayOfCurrentAlarmsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CurrentAlarmT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCurrentAlarmsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CurrentAlarmT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCurrentAlarmsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCurrentAlarmsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT * SOAP_FMAC4 soap_get_ArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCurrentAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCurrentAlarmsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCurrentAlarmsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT * SOAP_FMAC4 soap_in_ArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, ArrayOfCurrentAlarmsT *a, const char *type)
{	int i, j;
	ns1__CurrentAlarmT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCurrentAlarmsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCurrentAlarmsT, sizeof(ArrayOfCurrentAlarmsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CurrentAlarmT **)soap_malloc(soap, sizeof(ns1__CurrentAlarmT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CurrentAlarmT(soap, NULL, a->__ptr + i, "ns1:CurrentAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CurrentAlarmT **)soap_push_block(soap, sizeof(ns1__CurrentAlarmT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CurrentAlarmT(soap, NULL, p, "ns1:CurrentAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CurrentAlarmT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCurrentAlarmsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCurrentAlarmsT, 0, sizeof(ArrayOfCurrentAlarmsT), 0, soap_copy_ArrayOfCurrentAlarmsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCurrentAlarmsT * SOAP_FMAC6 soap_new_ArrayOfCurrentAlarmsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCurrentAlarmsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT * SOAP_FMAC4 soap_instantiate_ArrayOfCurrentAlarmsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCurrentAlarmsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCurrentAlarmsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCurrentAlarmsT;
		if (size)
			*size = sizeof(ArrayOfCurrentAlarmsT);
		((ArrayOfCurrentAlarmsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCurrentAlarmsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCurrentAlarmsT);
		for (int i = 0; i < n; i++)
			((ArrayOfCurrentAlarmsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCurrentAlarmsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCurrentAlarmsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCurrentAlarmsT %p -> %p\n", q, p));
	*(ArrayOfCurrentAlarmsT*)p = *(ArrayOfCurrentAlarmsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfEmtasT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfEmtasT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfEmtasT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__EmtaT(soap, this->__ptr + i);
		}
}

int ArrayOfEmtasT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfEmtasT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfEmtasT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfEmtasT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfEmtasT(struct soap *soap, const char *tag, int id, const ArrayOfEmtasT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:EmtaT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfEmtasT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__EmtaT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfEmtasT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfEmtasT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfEmtasT * SOAP_FMAC4 soap_get_ArrayOfEmtasT(struct soap *soap, ArrayOfEmtasT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfEmtasT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfEmtasT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfEmtasT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfEmtasT * SOAP_FMAC4 soap_in_ArrayOfEmtasT(struct soap *soap, const char *tag, ArrayOfEmtasT *a, const char *type)
{	int i, j;
	ns1__EmtaT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfEmtasT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfEmtasT, sizeof(ArrayOfEmtasT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__EmtaT **)soap_malloc(soap, sizeof(ns1__EmtaT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__EmtaT(soap, NULL, a->__ptr + i, "ns1:EmtaT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__EmtaT **)soap_push_block(soap, sizeof(ns1__EmtaT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__EmtaT(soap, NULL, p, "ns1:EmtaT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__EmtaT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfEmtasT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfEmtasT, 0, sizeof(ArrayOfEmtasT), 0, soap_copy_ArrayOfEmtasT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfEmtasT * SOAP_FMAC6 soap_new_ArrayOfEmtasT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfEmtasT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfEmtasT(struct soap *soap, ArrayOfEmtasT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfEmtasT * SOAP_FMAC4 soap_instantiate_ArrayOfEmtasT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfEmtasT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfEmtasT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfEmtasT;
		if (size)
			*size = sizeof(ArrayOfEmtasT);
		((ArrayOfEmtasT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfEmtasT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfEmtasT);
		for (int i = 0; i < n; i++)
			((ArrayOfEmtasT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfEmtasT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfEmtasT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfEmtasT %p -> %p\n", q, p));
	*(ArrayOfEmtasT*)p = *(ArrayOfEmtasT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCableModemsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCableModemsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCableModemsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CableModemT(soap, this->__ptr + i);
		}
}

int ArrayOfCableModemsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCableModemsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCableModemsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCableModemsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCableModemsT(struct soap *soap, const char *tag, int id, const ArrayOfCableModemsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CableModemT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCableModemsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CableModemT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCableModemsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCableModemsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCableModemsT * SOAP_FMAC4 soap_get_ArrayOfCableModemsT(struct soap *soap, ArrayOfCableModemsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCableModemsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCableModemsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCableModemsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCableModemsT * SOAP_FMAC4 soap_in_ArrayOfCableModemsT(struct soap *soap, const char *tag, ArrayOfCableModemsT *a, const char *type)
{	int i, j;
	ns1__CableModemT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCableModemsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCableModemsT, sizeof(ArrayOfCableModemsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CableModemT **)soap_malloc(soap, sizeof(ns1__CableModemT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CableModemT(soap, NULL, a->__ptr + i, "ns1:CableModemT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CableModemT **)soap_push_block(soap, sizeof(ns1__CableModemT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CableModemT(soap, NULL, p, "ns1:CableModemT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CableModemT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCableModemsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCableModemsT, 0, sizeof(ArrayOfCableModemsT), 0, soap_copy_ArrayOfCableModemsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCableModemsT * SOAP_FMAC6 soap_new_ArrayOfCableModemsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCableModemsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCableModemsT(struct soap *soap, ArrayOfCableModemsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCableModemsT * SOAP_FMAC4 soap_instantiate_ArrayOfCableModemsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCableModemsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCableModemsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCableModemsT;
		if (size)
			*size = sizeof(ArrayOfCableModemsT);
		((ArrayOfCableModemsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCableModemsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCableModemsT);
		for (int i = 0; i < n; i++)
			((ArrayOfCableModemsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCableModemsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCableModemsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCableModemsT %p -> %p\n", q, p));
	*(ArrayOfCableModemsT*)p = *(ArrayOfCableModemsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfHfcsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfHfcsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfHfcsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__HfcT(soap, this->__ptr + i);
		}
}

int ArrayOfHfcsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfHfcsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfHfcsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfHfcsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfHfcsT(struct soap *soap, const char *tag, int id, const ArrayOfHfcsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:HfcT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfHfcsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__HfcT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfHfcsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfHfcsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfHfcsT * SOAP_FMAC4 soap_get_ArrayOfHfcsT(struct soap *soap, ArrayOfHfcsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfHfcsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfHfcsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfHfcsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfHfcsT * SOAP_FMAC4 soap_in_ArrayOfHfcsT(struct soap *soap, const char *tag, ArrayOfHfcsT *a, const char *type)
{	int i, j;
	ns1__HfcT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfHfcsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfHfcsT, sizeof(ArrayOfHfcsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__HfcT **)soap_malloc(soap, sizeof(ns1__HfcT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__HfcT(soap, NULL, a->__ptr + i, "ns1:HfcT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__HfcT **)soap_push_block(soap, sizeof(ns1__HfcT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__HfcT(soap, NULL, p, "ns1:HfcT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__HfcT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfHfcsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfHfcsT, 0, sizeof(ArrayOfHfcsT), 0, soap_copy_ArrayOfHfcsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfHfcsT * SOAP_FMAC6 soap_new_ArrayOfHfcsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfHfcsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfHfcsT(struct soap *soap, ArrayOfHfcsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfHfcsT * SOAP_FMAC4 soap_instantiate_ArrayOfHfcsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfHfcsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfHfcsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfHfcsT;
		if (size)
			*size = sizeof(ArrayOfHfcsT);
		((ArrayOfHfcsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfHfcsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfHfcsT);
		for (int i = 0; i < n; i++)
			((ArrayOfHfcsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfHfcsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfHfcsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfHfcsT %p -> %p\n", q, p));
	*(ArrayOfHfcsT*)p = *(ArrayOfHfcsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfChannelsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfChannelsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfChannelsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ChannelT(soap, this->__ptr + i);
		}
}

int ArrayOfChannelsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfChannelsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfChannelsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfChannelsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfChannelsT(struct soap *soap, const char *tag, int id, const ArrayOfChannelsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ChannelT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfChannelsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ChannelT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfChannelsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfChannelsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfChannelsT * SOAP_FMAC4 soap_get_ArrayOfChannelsT(struct soap *soap, ArrayOfChannelsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfChannelsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfChannelsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfChannelsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfChannelsT * SOAP_FMAC4 soap_in_ArrayOfChannelsT(struct soap *soap, const char *tag, ArrayOfChannelsT *a, const char *type)
{	int i, j;
	ns1__ChannelT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfChannelsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfChannelsT, sizeof(ArrayOfChannelsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ChannelT **)soap_malloc(soap, sizeof(ns1__ChannelT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ChannelT(soap, NULL, a->__ptr + i, "ns1:ChannelT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ChannelT **)soap_push_block(soap, sizeof(ns1__ChannelT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ChannelT(soap, NULL, p, "ns1:ChannelT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__ChannelT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfChannelsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfChannelsT, 0, sizeof(ArrayOfChannelsT), 0, soap_copy_ArrayOfChannelsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfChannelsT * SOAP_FMAC6 soap_new_ArrayOfChannelsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfChannelsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfChannelsT(struct soap *soap, ArrayOfChannelsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfChannelsT * SOAP_FMAC4 soap_instantiate_ArrayOfChannelsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfChannelsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfChannelsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfChannelsT;
		if (size)
			*size = sizeof(ArrayOfChannelsT);
		((ArrayOfChannelsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfChannelsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfChannelsT);
		for (int i = 0; i < n; i++)
			((ArrayOfChannelsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfChannelsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfChannelsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfChannelsT %p -> %p\n", q, p));
	*(ArrayOfChannelsT*)p = *(ArrayOfChannelsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfSnmpV2CAttributesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfSnmpV2CAttributesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfSnmpV2CAttributesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__SnmpV2CAttributesT(soap, this->__ptr + i);
		}
}

int ArrayOfSnmpV2CAttributesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfSnmpV2CAttributesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfSnmpV2CAttributesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfSnmpV2CAttributesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSnmpV2CAttributesT(struct soap *soap, const char *tag, int id, const ArrayOfSnmpV2CAttributesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:SnmpV2CAttributesT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfSnmpV2CAttributesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__SnmpV2CAttributesT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfSnmpV2CAttributesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfSnmpV2CAttributesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT * SOAP_FMAC4 soap_get_ArrayOfSnmpV2CAttributesT(struct soap *soap, ArrayOfSnmpV2CAttributesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfSnmpV2CAttributesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfSnmpV2CAttributesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT * SOAP_FMAC4 soap_in_ArrayOfSnmpV2CAttributesT(struct soap *soap, const char *tag, ArrayOfSnmpV2CAttributesT *a, const char *type)
{	int i, j;
	ns1__SnmpV2CAttributesT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfSnmpV2CAttributesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSnmpV2CAttributesT, sizeof(ArrayOfSnmpV2CAttributesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__SnmpV2CAttributesT **)soap_malloc(soap, sizeof(ns1__SnmpV2CAttributesT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__SnmpV2CAttributesT(soap, NULL, a->__ptr + i, "ns1:SnmpV2CAttributesT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__SnmpV2CAttributesT **)soap_push_block(soap, sizeof(ns1__SnmpV2CAttributesT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__SnmpV2CAttributesT(soap, NULL, p, "ns1:SnmpV2CAttributesT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__SnmpV2CAttributesT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfSnmpV2CAttributesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfSnmpV2CAttributesT, 0, sizeof(ArrayOfSnmpV2CAttributesT), 0, soap_copy_ArrayOfSnmpV2CAttributesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfSnmpV2CAttributesT * SOAP_FMAC6 soap_new_ArrayOfSnmpV2CAttributesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfSnmpV2CAttributesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfSnmpV2CAttributesT(struct soap *soap, ArrayOfSnmpV2CAttributesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT * SOAP_FMAC4 soap_instantiate_ArrayOfSnmpV2CAttributesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfSnmpV2CAttributesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfSnmpV2CAttributesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfSnmpV2CAttributesT;
		if (size)
			*size = sizeof(ArrayOfSnmpV2CAttributesT);
		((ArrayOfSnmpV2CAttributesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfSnmpV2CAttributesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfSnmpV2CAttributesT);
		for (int i = 0; i < n; i++)
			((ArrayOfSnmpV2CAttributesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfSnmpV2CAttributesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfSnmpV2CAttributesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfSnmpV2CAttributesT %p -> %p\n", q, p));
	*(ArrayOfSnmpV2CAttributesT*)p = *(ArrayOfSnmpV2CAttributesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmtsesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmtsesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmtsesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmtsT(soap, this->__ptr + i);
		}
}

int ArrayOfCmtsesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmtsesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmtsesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmtsesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmtsesT(struct soap *soap, const char *tag, int id, const ArrayOfCmtsesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmtsT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmtsesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmtsT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmtsesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmtsesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmtsesT * SOAP_FMAC4 soap_get_ArrayOfCmtsesT(struct soap *soap, ArrayOfCmtsesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmtsesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmtsesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmtsesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmtsesT * SOAP_FMAC4 soap_in_ArrayOfCmtsesT(struct soap *soap, const char *tag, ArrayOfCmtsesT *a, const char *type)
{	int i, j;
	ns1__CmtsT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmtsesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmtsesT, sizeof(ArrayOfCmtsesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmtsT **)soap_malloc(soap, sizeof(ns1__CmtsT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmtsT(soap, NULL, a->__ptr + i, "ns1:CmtsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmtsT **)soap_push_block(soap, sizeof(ns1__CmtsT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmtsT(soap, NULL, p, "ns1:CmtsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmtsT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmtsesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmtsesT, 0, sizeof(ArrayOfCmtsesT), 0, soap_copy_ArrayOfCmtsesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmtsesT * SOAP_FMAC6 soap_new_ArrayOfCmtsesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmtsesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmtsesT(struct soap *soap, ArrayOfCmtsesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmtsesT * SOAP_FMAC4 soap_instantiate_ArrayOfCmtsesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmtsesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmtsesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmtsesT;
		if (size)
			*size = sizeof(ArrayOfCmtsesT);
		((ArrayOfCmtsesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmtsesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmtsesT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmtsesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmtsesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmtsesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmtsesT %p -> %p\n", q, p));
	*(ArrayOfCmtsesT*)p = *(ArrayOfCmtsesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmsesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmsesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmsesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmsT(soap, this->__ptr + i);
		}
}

int ArrayOfCmsesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmsesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmsesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmsesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmsesT(struct soap *soap, const char *tag, int id, const ArrayOfCmsesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmsT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmsesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmsT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmsesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmsesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmsesT * SOAP_FMAC4 soap_get_ArrayOfCmsesT(struct soap *soap, ArrayOfCmsesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmsesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmsesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmsesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmsesT * SOAP_FMAC4 soap_in_ArrayOfCmsesT(struct soap *soap, const char *tag, ArrayOfCmsesT *a, const char *type)
{	int i, j;
	ns1__CmsT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmsesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmsesT, sizeof(ArrayOfCmsesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmsT **)soap_malloc(soap, sizeof(ns1__CmsT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmsT(soap, NULL, a->__ptr + i, "ns1:CmsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmsT **)soap_push_block(soap, sizeof(ns1__CmsT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmsT(soap, NULL, p, "ns1:CmsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmsT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmsesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmsesT, 0, sizeof(ArrayOfCmsesT), 0, soap_copy_ArrayOfCmsesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmsesT * SOAP_FMAC6 soap_new_ArrayOfCmsesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmsesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmsesT(struct soap *soap, ArrayOfCmsesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmsesT * SOAP_FMAC4 soap_instantiate_ArrayOfCmsesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmsesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmsesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmsesT;
		if (size)
			*size = sizeof(ArrayOfCmsesT);
		((ArrayOfCmsesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmsesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmsesT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmsesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmsesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmsesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmsesT %p -> %p\n", q, p));
	*(ArrayOfCmsesT*)p = *(ArrayOfCmsesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfBladesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfBladesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfBladesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__BladeT(soap, this->__ptr + i);
		}
}

int ArrayOfBladesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfBladesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfBladesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfBladesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfBladesT(struct soap *soap, const char *tag, int id, const ArrayOfBladesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:BladeT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfBladesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__BladeT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfBladesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfBladesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfBladesT * SOAP_FMAC4 soap_get_ArrayOfBladesT(struct soap *soap, ArrayOfBladesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfBladesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfBladesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfBladesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfBladesT * SOAP_FMAC4 soap_in_ArrayOfBladesT(struct soap *soap, const char *tag, ArrayOfBladesT *a, const char *type)
{	int i, j;
	ns1__BladeT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfBladesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBladesT, sizeof(ArrayOfBladesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__BladeT **)soap_malloc(soap, sizeof(ns1__BladeT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__BladeT(soap, NULL, a->__ptr + i, "ns1:BladeT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__BladeT **)soap_push_block(soap, sizeof(ns1__BladeT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__BladeT(soap, NULL, p, "ns1:BladeT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__BladeT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfBladesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfBladesT, 0, sizeof(ArrayOfBladesT), 0, soap_copy_ArrayOfBladesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfBladesT * SOAP_FMAC6 soap_new_ArrayOfBladesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfBladesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfBladesT(struct soap *soap, ArrayOfBladesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfBladesT * SOAP_FMAC4 soap_instantiate_ArrayOfBladesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfBladesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfBladesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfBladesT;
		if (size)
			*size = sizeof(ArrayOfBladesT);
		((ArrayOfBladesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfBladesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfBladesT);
		for (int i = 0; i < n; i++)
			((ArrayOfBladesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfBladesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfBladesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfBladesT %p -> %p\n", q, p));
	*(ArrayOfBladesT*)p = *(ArrayOfBladesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMarketsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMarketsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMarketsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MarketT(soap, this->__ptr + i);
		}
}

int ArrayOfMarketsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMarketsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMarketsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMarketsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMarketsT(struct soap *soap, const char *tag, int id, const ArrayOfMarketsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MarketT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMarketsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MarketT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMarketsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMarketsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMarketsT * SOAP_FMAC4 soap_get_ArrayOfMarketsT(struct soap *soap, ArrayOfMarketsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMarketsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMarketsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMarketsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMarketsT * SOAP_FMAC4 soap_in_ArrayOfMarketsT(struct soap *soap, const char *tag, ArrayOfMarketsT *a, const char *type)
{	int i, j;
	ns1__MarketT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMarketsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMarketsT, sizeof(ArrayOfMarketsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MarketT **)soap_malloc(soap, sizeof(ns1__MarketT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MarketT(soap, NULL, a->__ptr + i, "ns1:MarketT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MarketT **)soap_push_block(soap, sizeof(ns1__MarketT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MarketT(soap, NULL, p, "ns1:MarketT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MarketT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMarketsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMarketsT, 0, sizeof(ArrayOfMarketsT), 0, soap_copy_ArrayOfMarketsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMarketsT * SOAP_FMAC6 soap_new_ArrayOfMarketsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMarketsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMarketsT(struct soap *soap, ArrayOfMarketsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMarketsT * SOAP_FMAC4 soap_instantiate_ArrayOfMarketsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMarketsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMarketsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMarketsT;
		if (size)
			*size = sizeof(ArrayOfMarketsT);
		((ArrayOfMarketsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMarketsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMarketsT);
		for (int i = 0; i < n; i++)
			((ArrayOfMarketsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMarketsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMarketsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMarketsT %p -> %p\n", q, p));
	*(ArrayOfMarketsT*)p = *(ArrayOfMarketsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfRegionsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfRegionsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfRegionsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__RegionT(soap, this->__ptr + i);
		}
}

int ArrayOfRegionsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfRegionsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfRegionsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfRegionsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfRegionsT(struct soap *soap, const char *tag, int id, const ArrayOfRegionsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:RegionT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfRegionsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__RegionT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfRegionsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfRegionsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfRegionsT * SOAP_FMAC4 soap_get_ArrayOfRegionsT(struct soap *soap, ArrayOfRegionsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfRegionsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfRegionsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfRegionsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfRegionsT * SOAP_FMAC4 soap_in_ArrayOfRegionsT(struct soap *soap, const char *tag, ArrayOfRegionsT *a, const char *type)
{	int i, j;
	ns1__RegionT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfRegionsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRegionsT, sizeof(ArrayOfRegionsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__RegionT **)soap_malloc(soap, sizeof(ns1__RegionT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__RegionT(soap, NULL, a->__ptr + i, "ns1:RegionT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__RegionT **)soap_push_block(soap, sizeof(ns1__RegionT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__RegionT(soap, NULL, p, "ns1:RegionT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__RegionT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfRegionsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfRegionsT, 0, sizeof(ArrayOfRegionsT), 0, soap_copy_ArrayOfRegionsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfRegionsT * SOAP_FMAC6 soap_new_ArrayOfRegionsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfRegionsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfRegionsT(struct soap *soap, ArrayOfRegionsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfRegionsT * SOAP_FMAC4 soap_instantiate_ArrayOfRegionsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfRegionsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfRegionsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfRegionsT;
		if (size)
			*size = sizeof(ArrayOfRegionsT);
		((ArrayOfRegionsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfRegionsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfRegionsT);
		for (int i = 0; i < n; i++)
			((ArrayOfRegionsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfRegionsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfRegionsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfRegionsT %p -> %p\n", q, p));
	*(ArrayOfRegionsT*)p = *(ArrayOfRegionsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AlarmHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__AlarmHistoryT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__AlarmHistoryT*)this)->alarmId);
	soap_default_std__string(soap, &((ns1__AlarmHistoryT*)this)->timeStamp);
	soap_default_std__string(soap, &((ns1__AlarmHistoryT*)this)->alarmState);
	/* transient soap skipped */
}

void ns1__AlarmHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__AlarmHistoryT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__AlarmHistoryT*)this)->alarmId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AlarmHistoryT*)this)->alarmId);
	soap_embedded(soap, &((ns1__AlarmHistoryT*)this)->timeStamp, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmHistoryT*)this)->timeStamp);
	soap_embedded(soap, &((ns1__AlarmHistoryT*)this)->alarmState, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmHistoryT*)this)->alarmState);
	/* transient soap skipped */
}

int ns1__AlarmHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AlarmHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AlarmHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AlarmHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AlarmHistoryT(struct soap *soap, const char *tag, int id, const ns1__AlarmHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AlarmHistoryT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__AlarmHistoryT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "alarmId", -1, &(((ns1__AlarmHistoryT*)a)->alarmId), "");
	soap_out_std__string(soap, "timeStamp", -1, &(((ns1__AlarmHistoryT*)a)->timeStamp), "");
	soap_out_std__string(soap, "alarmState", -1, &(((ns1__AlarmHistoryT*)a)->alarmState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AlarmHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AlarmHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT * SOAP_FMAC4 soap_get_ns1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AlarmHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AlarmHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AlarmHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT * SOAP_FMAC4 soap_in_ns1__AlarmHistoryT(struct soap *soap, const char *tag, ns1__AlarmHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AlarmHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AlarmHistoryT, sizeof(ns1__AlarmHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AlarmHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AlarmHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_alarmId1 = 1, soap_flag_timeStamp1 = 1, soap_flag_alarmState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__AlarmHistoryT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_alarmId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmId", &(((ns1__AlarmHistoryT*)a)->alarmId), "xsd:integer"))
				{	soap_flag_alarmId1--;
					continue;
				}
			if (soap_flag_timeStamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "timeStamp", &(((ns1__AlarmHistoryT*)a)->timeStamp), "xsd:string"))
				{	soap_flag_timeStamp1--;
					continue;
				}
			if (soap_flag_alarmState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmState", &(((ns1__AlarmHistoryT*)a)->alarmState), "xsd:string"))
				{	soap_flag_alarmState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_alarmId1 > 0 || soap_flag_timeStamp1 > 0 || soap_flag_alarmState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AlarmHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AlarmHistoryT, 0, sizeof(ns1__AlarmHistoryT), 0, soap_copy_ns1__AlarmHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AlarmHistoryT * SOAP_FMAC6 soap_new_ns1__AlarmHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AlarmHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AlarmHistoryT * SOAP_FMAC4 soap_instantiate_ns1__AlarmHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AlarmHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AlarmHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AlarmHistoryT;
		if (size)
			*size = sizeof(ns1__AlarmHistoryT);
		((ns1__AlarmHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AlarmHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AlarmHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__AlarmHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AlarmHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AlarmHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AlarmHistoryT %p -> %p\n", q, p));
	*(ns1__AlarmHistoryT*)p = *(ns1__AlarmHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HistoricalAlarmDetailsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HistoricalAlarmDetailsT*)this)->historicalAlarm = NULL;
	soap_default_std__string(soap, &((ns1__HistoricalAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

void ns1__HistoricalAlarmDetailsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HistoricalAlarmT(soap, &((ns1__HistoricalAlarmDetailsT*)this)->historicalAlarm);
	soap_embedded(soap, &((ns1__HistoricalAlarmDetailsT*)this)->alarmDetails, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HistoricalAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

int ns1__HistoricalAlarmDetailsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HistoricalAlarmDetailsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HistoricalAlarmDetailsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistoricalAlarmDetailsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistoricalAlarmDetailsT(struct soap *soap, const char *tag, int id, const ns1__HistoricalAlarmDetailsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistoricalAlarmDetailsT), type);
	soap_out_PointerTons1__HistoricalAlarmT(soap, "historicalAlarm", -1, &(((ns1__HistoricalAlarmDetailsT*)a)->historicalAlarm), "");
	soap_out_std__string(soap, "alarmDetails", -1, &(((ns1__HistoricalAlarmDetailsT*)a)->alarmDetails), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HistoricalAlarmDetailsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistoricalAlarmDetailsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmDetailsT * SOAP_FMAC4 soap_get_ns1__HistoricalAlarmDetailsT(struct soap *soap, ns1__HistoricalAlarmDetailsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistoricalAlarmDetailsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HistoricalAlarmDetailsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HistoricalAlarmDetailsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmDetailsT * SOAP_FMAC4 soap_in_ns1__HistoricalAlarmDetailsT(struct soap *soap, const char *tag, ns1__HistoricalAlarmDetailsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistoricalAlarmDetailsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistoricalAlarmDetailsT, sizeof(ns1__HistoricalAlarmDetailsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HistoricalAlarmDetailsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HistoricalAlarmDetailsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_historicalAlarm1 = 1, soap_flag_alarmDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_historicalAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HistoricalAlarmT(soap, "historicalAlarm", &(((ns1__HistoricalAlarmDetailsT*)a)->historicalAlarm), "ns1:HistoricalAlarmT"))
				{	soap_flag_historicalAlarm1--;
					continue;
				}
			if (soap_flag_alarmDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmDetails", &(((ns1__HistoricalAlarmDetailsT*)a)->alarmDetails), "xsd:string"))
				{	soap_flag_alarmDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_historicalAlarm1 > 0 || soap_flag_alarmDetails1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmDetailsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistoricalAlarmDetailsT, 0, sizeof(ns1__HistoricalAlarmDetailsT), 0, soap_copy_ns1__HistoricalAlarmDetailsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HistoricalAlarmDetailsT * SOAP_FMAC6 soap_new_ns1__HistoricalAlarmDetailsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HistoricalAlarmDetailsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HistoricalAlarmDetailsT(struct soap *soap, ns1__HistoricalAlarmDetailsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HistoricalAlarmDetailsT * SOAP_FMAC4 soap_instantiate_ns1__HistoricalAlarmDetailsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistoricalAlarmDetailsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HistoricalAlarmDetailsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HistoricalAlarmDetailsT;
		if (size)
			*size = sizeof(ns1__HistoricalAlarmDetailsT);
		((ns1__HistoricalAlarmDetailsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HistoricalAlarmDetailsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HistoricalAlarmDetailsT);
		for (int i = 0; i < n; i++)
			((ns1__HistoricalAlarmDetailsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HistoricalAlarmDetailsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HistoricalAlarmDetailsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HistoricalAlarmDetailsT %p -> %p\n", q, p));
	*(ns1__HistoricalAlarmDetailsT*)p = *(ns1__HistoricalAlarmDetailsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HistoricalAlarmT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HistoricalAlarmT*)this)->abstractAlarm = NULL;
	soap_default_std__string(soap, &((ns1__HistoricalAlarmT*)this)->clearedUser);
	/* transient soap skipped */
}

void ns1__HistoricalAlarmT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AbstractAlarmT(soap, &((ns1__HistoricalAlarmT*)this)->abstractAlarm);
	soap_embedded(soap, &((ns1__HistoricalAlarmT*)this)->clearedUser, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HistoricalAlarmT*)this)->clearedUser);
	/* transient soap skipped */
}

int ns1__HistoricalAlarmT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HistoricalAlarmT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HistoricalAlarmT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistoricalAlarmT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistoricalAlarmT(struct soap *soap, const char *tag, int id, const ns1__HistoricalAlarmT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistoricalAlarmT), type);
	soap_out_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", -1, &(((ns1__HistoricalAlarmT*)a)->abstractAlarm), "");
	soap_out_std__string(soap, "clearedUser", -1, &(((ns1__HistoricalAlarmT*)a)->clearedUser), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HistoricalAlarmT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistoricalAlarmT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT * SOAP_FMAC4 soap_get_ns1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistoricalAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HistoricalAlarmT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HistoricalAlarmT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT * SOAP_FMAC4 soap_in_ns1__HistoricalAlarmT(struct soap *soap, const char *tag, ns1__HistoricalAlarmT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistoricalAlarmT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistoricalAlarmT, sizeof(ns1__HistoricalAlarmT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HistoricalAlarmT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HistoricalAlarmT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_abstractAlarm1 = 1, soap_flag_clearedUser1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_abstractAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", &(((ns1__HistoricalAlarmT*)a)->abstractAlarm), "ns1:AbstractAlarmT"))
				{	soap_flag_abstractAlarm1--;
					continue;
				}
			if (soap_flag_clearedUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "clearedUser", &(((ns1__HistoricalAlarmT*)a)->clearedUser), "xsd:string"))
				{	soap_flag_clearedUser1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_abstractAlarm1 > 0 || soap_flag_clearedUser1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistoricalAlarmT, 0, sizeof(ns1__HistoricalAlarmT), 0, soap_copy_ns1__HistoricalAlarmT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HistoricalAlarmT * SOAP_FMAC6 soap_new_ns1__HistoricalAlarmT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HistoricalAlarmT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HistoricalAlarmT * SOAP_FMAC4 soap_instantiate_ns1__HistoricalAlarmT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistoricalAlarmT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HistoricalAlarmT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HistoricalAlarmT;
		if (size)
			*size = sizeof(ns1__HistoricalAlarmT);
		((ns1__HistoricalAlarmT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HistoricalAlarmT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HistoricalAlarmT);
		for (int i = 0; i < n; i++)
			((ns1__HistoricalAlarmT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HistoricalAlarmT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HistoricalAlarmT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HistoricalAlarmT %p -> %p\n", q, p));
	*(ns1__HistoricalAlarmT*)p = *(ns1__HistoricalAlarmT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CurrentAlarmDetailsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CurrentAlarmDetailsT*)this)->currentAlarm = NULL;
	soap_default_std__string(soap, &((ns1__CurrentAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

void ns1__CurrentAlarmDetailsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CurrentAlarmT(soap, &((ns1__CurrentAlarmDetailsT*)this)->currentAlarm);
	soap_embedded(soap, &((ns1__CurrentAlarmDetailsT*)this)->alarmDetails, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CurrentAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

int ns1__CurrentAlarmDetailsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CurrentAlarmDetailsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CurrentAlarmDetailsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CurrentAlarmDetailsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CurrentAlarmDetailsT(struct soap *soap, const char *tag, int id, const ns1__CurrentAlarmDetailsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CurrentAlarmDetailsT), type);
	soap_out_PointerTons1__CurrentAlarmT(soap, "currentAlarm", -1, &(((ns1__CurrentAlarmDetailsT*)a)->currentAlarm), "");
	soap_out_std__string(soap, "alarmDetails", -1, &(((ns1__CurrentAlarmDetailsT*)a)->alarmDetails), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CurrentAlarmDetailsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CurrentAlarmDetailsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CurrentAlarmDetailsT * SOAP_FMAC4 soap_get_ns1__CurrentAlarmDetailsT(struct soap *soap, ns1__CurrentAlarmDetailsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CurrentAlarmDetailsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CurrentAlarmDetailsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CurrentAlarmDetailsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CurrentAlarmDetailsT * SOAP_FMAC4 soap_in_ns1__CurrentAlarmDetailsT(struct soap *soap, const char *tag, ns1__CurrentAlarmDetailsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CurrentAlarmDetailsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CurrentAlarmDetailsT, sizeof(ns1__CurrentAlarmDetailsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CurrentAlarmDetailsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CurrentAlarmDetailsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_currentAlarm1 = 1, soap_flag_alarmDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CurrentAlarmT(soap, "currentAlarm", &(((ns1__CurrentAlarmDetailsT*)a)->currentAlarm), "ns1:CurrentAlarmT"))
				{	soap_flag_currentAlarm1--;
					continue;
				}
			if (soap_flag_alarmDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmDetails", &(((ns1__CurrentAlarmDetailsT*)a)->alarmDetails), "xsd:string"))
				{	soap_flag_alarmDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentAlarm1 > 0 || soap_flag_alarmDetails1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmDetailsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CurrentAlarmDetailsT, 0, sizeof(ns1__CurrentAlarmDetailsT), 0, soap_copy_ns1__CurrentAlarmDetailsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CurrentAlarmDetailsT * SOAP_FMAC6 soap_new_ns1__CurrentAlarmDetailsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CurrentAlarmDetailsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CurrentAlarmDetailsT(struct soap *soap, ns1__CurrentAlarmDetailsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CurrentAlarmDetailsT * SOAP_FMAC4 soap_instantiate_ns1__CurrentAlarmDetailsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CurrentAlarmDetailsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CurrentAlarmDetailsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CurrentAlarmDetailsT;
		if (size)
			*size = sizeof(ns1__CurrentAlarmDetailsT);
		((ns1__CurrentAlarmDetailsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CurrentAlarmDetailsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CurrentAlarmDetailsT);
		for (int i = 0; i < n; i++)
			((ns1__CurrentAlarmDetailsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CurrentAlarmDetailsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CurrentAlarmDetailsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CurrentAlarmDetailsT %p -> %p\n", q, p));
	*(ns1__CurrentAlarmDetailsT*)p = *(ns1__CurrentAlarmDetailsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CurrentAlarmT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CurrentAlarmT*)this)->abstractAlarm = NULL;
	/* transient soap skipped */
}

void ns1__CurrentAlarmT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AbstractAlarmT(soap, &((ns1__CurrentAlarmT*)this)->abstractAlarm);
	/* transient soap skipped */
}

int ns1__CurrentAlarmT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CurrentAlarmT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CurrentAlarmT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CurrentAlarmT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CurrentAlarmT(struct soap *soap, const char *tag, int id, const ns1__CurrentAlarmT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CurrentAlarmT), type);
	soap_out_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", -1, &(((ns1__CurrentAlarmT*)a)->abstractAlarm), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CurrentAlarmT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CurrentAlarmT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT * SOAP_FMAC4 soap_get_ns1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CurrentAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CurrentAlarmT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CurrentAlarmT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT * SOAP_FMAC4 soap_in_ns1__CurrentAlarmT(struct soap *soap, const char *tag, ns1__CurrentAlarmT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CurrentAlarmT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CurrentAlarmT, sizeof(ns1__CurrentAlarmT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CurrentAlarmT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CurrentAlarmT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_abstractAlarm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_abstractAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", &(((ns1__CurrentAlarmT*)a)->abstractAlarm), "ns1:AbstractAlarmT"))
				{	soap_flag_abstractAlarm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_abstractAlarm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CurrentAlarmT, 0, sizeof(ns1__CurrentAlarmT), 0, soap_copy_ns1__CurrentAlarmT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CurrentAlarmT * SOAP_FMAC6 soap_new_ns1__CurrentAlarmT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CurrentAlarmT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CurrentAlarmT * SOAP_FMAC4 soap_instantiate_ns1__CurrentAlarmT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CurrentAlarmT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CurrentAlarmT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CurrentAlarmT;
		if (size)
			*size = sizeof(ns1__CurrentAlarmT);
		((ns1__CurrentAlarmT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CurrentAlarmT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CurrentAlarmT);
		for (int i = 0; i < n; i++)
			((ns1__CurrentAlarmT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CurrentAlarmT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CurrentAlarmT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CurrentAlarmT %p -> %p\n", q, p));
	*(ns1__CurrentAlarmT*)p = *(ns1__CurrentAlarmT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AbstractAlarmT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__AbstractAlarmT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmId);
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->resourceId);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->resourceName);
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTime);
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTimeUSec);
	soap_default_short(soap, &((ns1__AbstractAlarmT*)this)->soakDuration);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmState);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmType);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmSubType);
	/* transient soap skipped */
}

void ns1__AbstractAlarmT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__AbstractAlarmT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmId);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->resourceId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->resourceId);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->resourceName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->resourceName);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmTime, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTime);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmTimeUSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTimeUSec);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->soakDuration, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmState, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmState);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmType);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmSubType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmSubType);
	/* transient soap skipped */
}

int ns1__AbstractAlarmT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AbstractAlarmT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AbstractAlarmT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AbstractAlarmT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AbstractAlarmT(struct soap *soap, const char *tag, int id, const ns1__AbstractAlarmT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AbstractAlarmT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__AbstractAlarmT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "alarmId", -1, &(((ns1__AbstractAlarmT*)a)->alarmId), "");
	soap_out_xsd__integer(soap, "resourceId", -1, &(((ns1__AbstractAlarmT*)a)->resourceId), "");
	soap_out_std__string(soap, "resourceName", -1, &(((ns1__AbstractAlarmT*)a)->resourceName), "");
	soap_out_xsd__integer(soap, "alarmTime", -1, &(((ns1__AbstractAlarmT*)a)->alarmTime), "");
	soap_out_xsd__integer(soap, "alarmTimeUSec", -1, &(((ns1__AbstractAlarmT*)a)->alarmTimeUSec), "");
	soap_out_short(soap, "soakDuration", -1, &(((ns1__AbstractAlarmT*)a)->soakDuration), "");
	soap_out_std__string(soap, "alarmState", -1, &(((ns1__AbstractAlarmT*)a)->alarmState), "");
	soap_out_std__string(soap, "alarmType", -1, &(((ns1__AbstractAlarmT*)a)->alarmType), "");
	soap_out_std__string(soap, "alarmSubType", -1, &(((ns1__AbstractAlarmT*)a)->alarmSubType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AbstractAlarmT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AbstractAlarmT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AbstractAlarmT * SOAP_FMAC4 soap_get_ns1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AbstractAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AbstractAlarmT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AbstractAlarmT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AbstractAlarmT * SOAP_FMAC4 soap_in_ns1__AbstractAlarmT(struct soap *soap, const char *tag, ns1__AbstractAlarmT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AbstractAlarmT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AbstractAlarmT, sizeof(ns1__AbstractAlarmT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AbstractAlarmT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AbstractAlarmT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_alarmId1 = 1, soap_flag_resourceId1 = 1, soap_flag_resourceName1 = 1, soap_flag_alarmTime1 = 1, soap_flag_alarmTimeUSec1 = 1, soap_flag_soakDuration1 = 1, soap_flag_alarmState1 = 1, soap_flag_alarmType1 = 1, soap_flag_alarmSubType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__AbstractAlarmT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_alarmId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmId", &(((ns1__AbstractAlarmT*)a)->alarmId), "xsd:integer"))
				{	soap_flag_alarmId1--;
					continue;
				}
			if (soap_flag_resourceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "resourceId", &(((ns1__AbstractAlarmT*)a)->resourceId), "xsd:integer"))
				{	soap_flag_resourceId1--;
					continue;
				}
			if (soap_flag_resourceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "resourceName", &(((ns1__AbstractAlarmT*)a)->resourceName), "xsd:string"))
				{	soap_flag_resourceName1--;
					continue;
				}
			if (soap_flag_alarmTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmTime", &(((ns1__AbstractAlarmT*)a)->alarmTime), "xsd:integer"))
				{	soap_flag_alarmTime1--;
					continue;
				}
			if (soap_flag_alarmTimeUSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmTimeUSec", &(((ns1__AbstractAlarmT*)a)->alarmTimeUSec), "xsd:integer"))
				{	soap_flag_alarmTimeUSec1--;
					continue;
				}
			if (soap_flag_soakDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "soakDuration", &(((ns1__AbstractAlarmT*)a)->soakDuration), "xsd:short"))
				{	soap_flag_soakDuration1--;
					continue;
				}
			if (soap_flag_alarmState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmState", &(((ns1__AbstractAlarmT*)a)->alarmState), "xsd:string"))
				{	soap_flag_alarmState1--;
					continue;
				}
			if (soap_flag_alarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmType", &(((ns1__AbstractAlarmT*)a)->alarmType), "xsd:string"))
				{	soap_flag_alarmType1--;
					continue;
				}
			if (soap_flag_alarmSubType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmSubType", &(((ns1__AbstractAlarmT*)a)->alarmSubType), "xsd:string"))
				{	soap_flag_alarmSubType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_alarmId1 > 0 || soap_flag_resourceId1 > 0 || soap_flag_resourceName1 > 0 || soap_flag_alarmTime1 > 0 || soap_flag_alarmTimeUSec1 > 0 || soap_flag_soakDuration1 > 0 || soap_flag_alarmState1 > 0 || soap_flag_alarmType1 > 0 || soap_flag_alarmSubType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AbstractAlarmT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AbstractAlarmT, 0, sizeof(ns1__AbstractAlarmT), 0, soap_copy_ns1__AbstractAlarmT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AbstractAlarmT * SOAP_FMAC6 soap_new_ns1__AbstractAlarmT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AbstractAlarmT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AbstractAlarmT * SOAP_FMAC4 soap_instantiate_ns1__AbstractAlarmT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AbstractAlarmT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AbstractAlarmT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AbstractAlarmT;
		if (size)
			*size = sizeof(ns1__AbstractAlarmT);
		((ns1__AbstractAlarmT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AbstractAlarmT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AbstractAlarmT);
		for (int i = 0; i < n; i++)
			((ns1__AbstractAlarmT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AbstractAlarmT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AbstractAlarmT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AbstractAlarmT %p -> %p\n", q, p));
	*(ns1__AbstractAlarmT*)p = *(ns1__AbstractAlarmT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__EmtaT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__EmtaT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__EmtaT*)this)->emtaResId);
	((ns1__EmtaT*)this)->cmResId = NULL;
	soap_default_std__string(soap, &((ns1__EmtaT*)this)->macAddress);
	soap_default_ns1__StatusColorT(soap, &((ns1__EmtaT*)this)->statusColor);
	/* transient soap skipped */
}

void ns1__EmtaT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__EmtaT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__EmtaT*)this)->emtaResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__EmtaT*)this)->emtaResId);
	soap_serialize_PointerToxsd__integer(soap, &((ns1__EmtaT*)this)->cmResId);
	soap_embedded(soap, &((ns1__EmtaT*)this)->macAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__EmtaT*)this)->macAddress);
	/* transient soap skipped */
}

int ns1__EmtaT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EmtaT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__EmtaT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EmtaT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EmtaT(struct soap *soap, const char *tag, int id, const ns1__EmtaT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EmtaT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__EmtaT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "emtaResId", -1, &(((ns1__EmtaT*)a)->emtaResId), "");
	soap_out_PointerToxsd__integer(soap, "cmResId", -1, &(((ns1__EmtaT*)a)->cmResId), "");
	soap_out_std__string(soap, "macAddress", -1, &(((ns1__EmtaT*)a)->macAddress), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__EmtaT*)a)->statusColor), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__EmtaT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EmtaT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EmtaT * SOAP_FMAC4 soap_get_ns1__EmtaT(struct soap *soap, ns1__EmtaT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EmtaT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__EmtaT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EmtaT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EmtaT * SOAP_FMAC4 soap_in_ns1__EmtaT(struct soap *soap, const char *tag, ns1__EmtaT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EmtaT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EmtaT, sizeof(ns1__EmtaT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EmtaT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EmtaT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_emtaResId1 = 1, soap_flag_cmResId1 = 1, soap_flag_macAddress1 = 1, soap_flag_statusColor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__EmtaT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_emtaResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "emtaResId", &(((ns1__EmtaT*)a)->emtaResId), "xsd:integer"))
				{	soap_flag_emtaResId1--;
					continue;
				}
			if (soap_flag_cmResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "cmResId", &(((ns1__EmtaT*)a)->cmResId), "xsd:integer"))
				{	soap_flag_cmResId1--;
					continue;
				}
			if (soap_flag_macAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "macAddress", &(((ns1__EmtaT*)a)->macAddress), "xsd:string"))
				{	soap_flag_macAddress1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__EmtaT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_emtaResId1 > 0 || soap_flag_macAddress1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EmtaT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EmtaT, 0, sizeof(ns1__EmtaT), 0, soap_copy_ns1__EmtaT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__EmtaT * SOAP_FMAC6 soap_new_ns1__EmtaT(struct soap *soap, int n)
{	return soap_instantiate_ns1__EmtaT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__EmtaT(struct soap *soap, ns1__EmtaT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__EmtaT * SOAP_FMAC4 soap_instantiate_ns1__EmtaT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EmtaT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EmtaT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__EmtaT;
		if (size)
			*size = sizeof(ns1__EmtaT);
		((ns1__EmtaT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__EmtaT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EmtaT);
		for (int i = 0; i < n; i++)
			((ns1__EmtaT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EmtaT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EmtaT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EmtaT %p -> %p\n", q, p));
	*(ns1__EmtaT*)p = *(ns1__EmtaT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CableModemT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CableModemT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->cmResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->cmtsResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->upChannelResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->downChannelResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->hfcResId);
	soap_default_std__string(soap, &((ns1__CableModemT*)this)->macAddress);
	soap_default_ns1__StatusColorT(soap, &((ns1__CableModemT*)this)->statusColor);
	/* transient soap skipped */
}

void ns1__CableModemT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__CableModemT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__CableModemT*)this)->cmResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->cmResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->upChannelResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->upChannelResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->downChannelResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->downChannelResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->macAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CableModemT*)this)->macAddress);
	/* transient soap skipped */
}

int ns1__CableModemT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CableModemT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CableModemT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CableModemT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CableModemT(struct soap *soap, const char *tag, int id, const ns1__CableModemT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CableModemT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__CableModemT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "cmResId", -1, &(((ns1__CableModemT*)a)->cmResId), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__CableModemT*)a)->cmtsResId), "");
	soap_out_xsd__integer(soap, "upChannelResId", -1, &(((ns1__CableModemT*)a)->upChannelResId), "");
	soap_out_xsd__integer(soap, "downChannelResId", -1, &(((ns1__CableModemT*)a)->downChannelResId), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__CableModemT*)a)->hfcResId), "");
	soap_out_std__string(soap, "macAddress", -1, &(((ns1__CableModemT*)a)->macAddress), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__CableModemT*)a)->statusColor), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CableModemT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CableModemT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CableModemT * SOAP_FMAC4 soap_get_ns1__CableModemT(struct soap *soap, ns1__CableModemT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CableModemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CableModemT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CableModemT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CableModemT * SOAP_FMAC4 soap_in_ns1__CableModemT(struct soap *soap, const char *tag, ns1__CableModemT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CableModemT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CableModemT, sizeof(ns1__CableModemT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CableModemT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CableModemT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_cmResId1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_upChannelResId1 = 1, soap_flag_downChannelResId1 = 1, soap_flag_hfcResId1 = 1, soap_flag_macAddress1 = 1, soap_flag_statusColor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__CableModemT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_cmResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmResId", &(((ns1__CableModemT*)a)->cmResId), "xsd:integer"))
				{	soap_flag_cmResId1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__CableModemT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_upChannelResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "upChannelResId", &(((ns1__CableModemT*)a)->upChannelResId), "xsd:integer"))
				{	soap_flag_upChannelResId1--;
					continue;
				}
			if (soap_flag_downChannelResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "downChannelResId", &(((ns1__CableModemT*)a)->downChannelResId), "xsd:integer"))
				{	soap_flag_downChannelResId1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__CableModemT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_macAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "macAddress", &(((ns1__CableModemT*)a)->macAddress), "xsd:string"))
				{	soap_flag_macAddress1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__CableModemT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_cmResId1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_upChannelResId1 > 0 || soap_flag_downChannelResId1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_macAddress1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CableModemT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CableModemT, 0, sizeof(ns1__CableModemT), 0, soap_copy_ns1__CableModemT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CableModemT * SOAP_FMAC6 soap_new_ns1__CableModemT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CableModemT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CableModemT(struct soap *soap, ns1__CableModemT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CableModemT * SOAP_FMAC4 soap_instantiate_ns1__CableModemT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CableModemT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CableModemT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CableModemT;
		if (size)
			*size = sizeof(ns1__CableModemT);
		((ns1__CableModemT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CableModemT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CableModemT);
		for (int i = 0; i < n; i++)
			((ns1__CableModemT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CableModemT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CableModemT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CableModemT %p -> %p\n", q, p));
	*(ns1__CableModemT*)p = *(ns1__CableModemT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__HfcT*)this)->hfcResId);
	soap_default_xsd__integer(soap, &((ns1__HfcT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__HfcT*)this)->hfcName);
	soap_default_ns1__StatusColorT(soap, &((ns1__HfcT*)this)->statusColor);
	((ns1__HfcT*)this)->counts = NULL;
	/* transient soap skipped */
}

void ns1__HfcT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__HfcT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__HfcT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__HfcT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__HfcT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__HfcT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__HfcT*)this)->hfcName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcT*)this)->hfcName);
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__HfcT*)this)->counts);
	/* transient soap skipped */
}

int ns1__HfcT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcT(struct soap *soap, const char *tag, int id, const ns1__HfcT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__HfcT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__HfcT*)a)->hfcResId), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__HfcT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "hfcName", -1, &(((ns1__HfcT*)a)->hfcName), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__HfcT*)a)->statusColor), "");
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__HfcT*)a)->counts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcT * SOAP_FMAC4 soap_get_ns1__HfcT(struct soap *soap, ns1__HfcT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcT * SOAP_FMAC4 soap_in_ns1__HfcT(struct soap *soap, const char *tag, ns1__HfcT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcT, sizeof(ns1__HfcT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_hfcResId1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_hfcName1 = 1, soap_flag_statusColor1 = 1, soap_flag_counts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__HfcT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__HfcT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__HfcT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "hfcName", &(((ns1__HfcT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__HfcT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__HfcT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_hfcName1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcT, 0, sizeof(ns1__HfcT), 0, soap_copy_ns1__HfcT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcT * SOAP_FMAC6 soap_new_ns1__HfcT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcT(struct soap *soap, ns1__HfcT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcT * SOAP_FMAC4 soap_instantiate_ns1__HfcT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcT;
		if (size)
			*size = sizeof(ns1__HfcT);
		((ns1__HfcT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcT);
		for (int i = 0; i < n; i++)
			((ns1__HfcT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcT %p -> %p\n", q, p));
	*(ns1__HfcT*)p = *(ns1__HfcT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ChannelT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ChannelT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__ChannelT*)this)->channelResId);
	soap_default_xsd__integer(soap, &((ns1__ChannelT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__ChannelT*)this)->channelName);
	soap_default_ns1__ChannelTypeT(soap, &((ns1__ChannelT*)this)->channelType);
	soap_default_ns1__StatusColorT(soap, &((ns1__ChannelT*)this)->statusColor);
	((ns1__ChannelT*)this)->counts = NULL;
	/* transient soap skipped */
}

void ns1__ChannelT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__ChannelT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__ChannelT*)this)->channelResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__ChannelT*)this)->channelResId);
	soap_embedded(soap, &((ns1__ChannelT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__ChannelT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__ChannelT*)this)->channelName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__ChannelT*)this)->channelName);
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__ChannelT*)this)->counts);
	/* transient soap skipped */
}

int ns1__ChannelT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ChannelT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ChannelT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChannelT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChannelT(struct soap *soap, const char *tag, int id, const ns1__ChannelT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChannelT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__ChannelT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "channelResId", -1, &(((ns1__ChannelT*)a)->channelResId), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__ChannelT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "channelName", -1, &(((ns1__ChannelT*)a)->channelName), "");
	soap_out_ns1__ChannelTypeT(soap, "channelType", -1, &(((ns1__ChannelT*)a)->channelType), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__ChannelT*)a)->statusColor), "");
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__ChannelT*)a)->counts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ChannelT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChannelT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChannelT * SOAP_FMAC4 soap_get_ns1__ChannelT(struct soap *soap, ns1__ChannelT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChannelT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ChannelT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ChannelT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChannelT * SOAP_FMAC4 soap_in_ns1__ChannelT(struct soap *soap, const char *tag, ns1__ChannelT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChannelT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChannelT, sizeof(ns1__ChannelT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ChannelT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ChannelT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_channelResId1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_channelName1 = 1, soap_flag_channelType1 = 1, soap_flag_statusColor1 = 1, soap_flag_counts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__ChannelT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_channelResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "channelResId", &(((ns1__ChannelT*)a)->channelResId), "xsd:integer"))
				{	soap_flag_channelResId1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__ChannelT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_channelName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "channelName", &(((ns1__ChannelT*)a)->channelName), "xsd:string"))
				{	soap_flag_channelName1--;
					continue;
				}
			if (soap_flag_channelType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ChannelTypeT(soap, "channelType", &(((ns1__ChannelT*)a)->channelType), "ns1:ChannelTypeT"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__ChannelT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__ChannelT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_channelResId1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_channelName1 > 0 || soap_flag_channelType1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ChannelT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChannelT, 0, sizeof(ns1__ChannelT), 0, soap_copy_ns1__ChannelT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ChannelT * SOAP_FMAC6 soap_new_ns1__ChannelT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ChannelT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ChannelT(struct soap *soap, ns1__ChannelT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ChannelT * SOAP_FMAC4 soap_instantiate_ns1__ChannelT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChannelT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ChannelT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ChannelT;
		if (size)
			*size = sizeof(ns1__ChannelT);
		((ns1__ChannelT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ChannelT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ChannelT);
		for (int i = 0; i < n; i++)
			((ns1__ChannelT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ChannelT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ChannelT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ChannelT %p -> %p\n", q, p));
	*(ns1__ChannelT*)p = *(ns1__ChannelT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmtsT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmtsT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__CmtsT*)this)->cmtsName);
	soap_default_std__string(soap, &((ns1__CmtsT*)this)->cmtsHost);
	soap_default_ns1__SnmpVersionT(soap, &((ns1__CmtsT*)this)->cmtsSnmpVersion);
	soap_default_ns1__SnmpVersionT(soap, &((ns1__CmtsT*)this)->cmSnmpVersion);
	soap_default_ns1__SnmpVersionT(soap, &((ns1__CmtsT*)this)->mtaSnmpVersion);
	soap_default_ns1__StatusColorT(soap, &((ns1__CmtsT*)this)->statusColor);
	((ns1__CmtsT*)this)->counts = NULL;
	/* transient soap skipped */
}

void ns1__CmtsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__CmtsT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__CmtsT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmtsT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__CmtsT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsT*)this)->cmtsName);
	soap_embedded(soap, &((ns1__CmtsT*)this)->cmtsHost, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsT*)this)->cmtsHost);
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__CmtsT*)this)->counts);
	/* transient soap skipped */
}

int ns1__CmtsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsT(struct soap *soap, const char *tag, int id, const ns1__CmtsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__CmtsT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__CmtsT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__CmtsT*)a)->cmtsName), "");
	soap_out_std__string(soap, "cmtsHost", -1, &(((ns1__CmtsT*)a)->cmtsHost), "");
	soap_out_ns1__SnmpVersionT(soap, "cmtsSnmpVersion", -1, &(((ns1__CmtsT*)a)->cmtsSnmpVersion), "");
	soap_out_ns1__SnmpVersionT(soap, "cmSnmpVersion", -1, &(((ns1__CmtsT*)a)->cmSnmpVersion), "");
	soap_out_ns1__SnmpVersionT(soap, "mtaSnmpVersion", -1, &(((ns1__CmtsT*)a)->mtaSnmpVersion), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__CmtsT*)a)->statusColor), "");
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__CmtsT*)a)->counts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsT * SOAP_FMAC4 soap_get_ns1__CmtsT(struct soap *soap, ns1__CmtsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsT * SOAP_FMAC4 soap_in_ns1__CmtsT(struct soap *soap, const char *tag, ns1__CmtsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsT, sizeof(ns1__CmtsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1, soap_flag_cmtsHost1 = 1, soap_flag_cmtsSnmpVersion1 = 1, soap_flag_cmSnmpVersion1 = 1, soap_flag_mtaSnmpVersion1 = 1, soap_flag_statusColor1 = 1, soap_flag_counts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__CmtsT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__CmtsT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__CmtsT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			if (soap_flag_cmtsHost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsHost", &(((ns1__CmtsT*)a)->cmtsHost), "xsd:string"))
				{	soap_flag_cmtsHost1--;
					continue;
				}
			if (soap_flag_cmtsSnmpVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SnmpVersionT(soap, "cmtsSnmpVersion", &(((ns1__CmtsT*)a)->cmtsSnmpVersion), "ns1:SnmpVersionT"))
				{	soap_flag_cmtsSnmpVersion1--;
					continue;
				}
			if (soap_flag_cmSnmpVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SnmpVersionT(soap, "cmSnmpVersion", &(((ns1__CmtsT*)a)->cmSnmpVersion), "ns1:SnmpVersionT"))
				{	soap_flag_cmSnmpVersion1--;
					continue;
				}
			if (soap_flag_mtaSnmpVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SnmpVersionT(soap, "mtaSnmpVersion", &(((ns1__CmtsT*)a)->mtaSnmpVersion), "ns1:SnmpVersionT"))
				{	soap_flag_mtaSnmpVersion1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__CmtsT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__CmtsT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0 || soap_flag_cmtsHost1 > 0 || soap_flag_cmtsSnmpVersion1 > 0 || soap_flag_cmSnmpVersion1 > 0 || soap_flag_mtaSnmpVersion1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsT, 0, sizeof(ns1__CmtsT), 0, soap_copy_ns1__CmtsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsT * SOAP_FMAC6 soap_new_ns1__CmtsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsT(struct soap *soap, ns1__CmtsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsT * SOAP_FMAC4 soap_instantiate_ns1__CmtsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsT;
		if (size)
			*size = sizeof(ns1__CmtsT);
		((ns1__CmtsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsT %p -> %p\n", q, p));
	*(ns1__CmtsT*)p = *(ns1__CmtsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmsT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmsT*)this)->cmsResId);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsName);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsType);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsSubType);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsHost);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->loginName);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->loginPassword);
	soap_default_ns1__StatusColorT(soap, &((ns1__CmsT*)this)->statusColor);
	/* transient soap skipped */
}

void ns1__CmsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__CmsT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmsT*)this)->cmsResId);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsName);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsType);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsSubType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsSubType);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsHost, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsHost);
	soap_embedded(soap, &((ns1__CmsT*)this)->loginName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->loginName);
	soap_embedded(soap, &((ns1__CmsT*)this)->loginPassword, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->loginPassword);
	/* transient soap skipped */
}

int ns1__CmsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmsT(struct soap *soap, const char *tag, int id, const ns1__CmsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmsT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__CmsT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "cmsResId", -1, &(((ns1__CmsT*)a)->cmsResId), "");
	soap_out_std__string(soap, "cmsName", -1, &(((ns1__CmsT*)a)->cmsName), "");
	soap_out_std__string(soap, "cmsType", -1, &(((ns1__CmsT*)a)->cmsType), "");
	soap_out_std__string(soap, "cmsSubType", -1, &(((ns1__CmsT*)a)->cmsSubType), "");
	soap_out_std__string(soap, "cmsHost", -1, &(((ns1__CmsT*)a)->cmsHost), "");
	soap_out_std__string(soap, "loginName", -1, &(((ns1__CmsT*)a)->loginName), "");
	soap_out_std__string(soap, "loginPassword", -1, &(((ns1__CmsT*)a)->loginPassword), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__CmsT*)a)->statusColor), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmsT * SOAP_FMAC4 soap_get_ns1__CmsT(struct soap *soap, ns1__CmsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmsT * SOAP_FMAC4 soap_in_ns1__CmsT(struct soap *soap, const char *tag, ns1__CmsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmsT, sizeof(ns1__CmsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_cmsResId1 = 1, soap_flag_cmsName1 = 1, soap_flag_cmsType1 = 1, soap_flag_cmsSubType1 = 1, soap_flag_cmsHost1 = 1, soap_flag_loginName1 = 1, soap_flag_loginPassword1 = 1, soap_flag_statusColor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__CmsT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_cmsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmsResId", &(((ns1__CmsT*)a)->cmsResId), "xsd:integer"))
				{	soap_flag_cmsResId1--;
					continue;
				}
			if (soap_flag_cmsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsName", &(((ns1__CmsT*)a)->cmsName), "xsd:string"))
				{	soap_flag_cmsName1--;
					continue;
				}
			if (soap_flag_cmsType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsType", &(((ns1__CmsT*)a)->cmsType), "xsd:string"))
				{	soap_flag_cmsType1--;
					continue;
				}
			if (soap_flag_cmsSubType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsSubType", &(((ns1__CmsT*)a)->cmsSubType), "xsd:string"))
				{	soap_flag_cmsSubType1--;
					continue;
				}
			if (soap_flag_cmsHost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsHost", &(((ns1__CmsT*)a)->cmsHost), "xsd:string"))
				{	soap_flag_cmsHost1--;
					continue;
				}
			if (soap_flag_loginName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginName", &(((ns1__CmsT*)a)->loginName), "xsd:string"))
				{	soap_flag_loginName1--;
					continue;
				}
			if (soap_flag_loginPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginPassword", &(((ns1__CmsT*)a)->loginPassword), "xsd:string"))
				{	soap_flag_loginPassword1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__CmsT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_cmsResId1 > 0 || soap_flag_cmsName1 > 0 || soap_flag_cmsType1 > 0 || soap_flag_cmsSubType1 > 0 || soap_flag_cmsHost1 > 0 || soap_flag_loginName1 > 0 || soap_flag_loginPassword1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmsT, 0, sizeof(ns1__CmsT), 0, soap_copy_ns1__CmsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmsT * SOAP_FMAC6 soap_new_ns1__CmsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmsT(struct soap *soap, ns1__CmsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmsT * SOAP_FMAC4 soap_instantiate_ns1__CmsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmsT;
		if (size)
			*size = sizeof(ns1__CmsT);
		((ns1__CmsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmsT);
		for (int i = 0; i < n; i++)
			((ns1__CmsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmsT %p -> %p\n", q, p));
	*(ns1__CmsT*)p = *(ns1__CmsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__BladeT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__BladeT*)this)->regionId);
	soap_default_xsd__integer(soap, &((ns1__BladeT*)this)->marketId);
	soap_default_xsd__integer(soap, &((ns1__BladeT*)this)->bladeId);
	soap_default_std__string(soap, &((ns1__BladeT*)this)->name);
	soap_default_std__string(soap, &((ns1__BladeT*)this)->host);
	/* transient soap skipped */
}

void ns1__BladeT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__BladeT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__BladeT*)this)->regionId);
	soap_embedded(soap, &((ns1__BladeT*)this)->marketId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__BladeT*)this)->marketId);
	soap_embedded(soap, &((ns1__BladeT*)this)->bladeId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__BladeT*)this)->bladeId);
	soap_embedded(soap, &((ns1__BladeT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__BladeT*)this)->name);
	soap_embedded(soap, &((ns1__BladeT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__BladeT*)this)->host);
	/* transient soap skipped */
}

int ns1__BladeT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BladeT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__BladeT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BladeT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BladeT(struct soap *soap, const char *tag, int id, const ns1__BladeT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BladeT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__BladeT*)a)->regionId), "");
	soap_out_xsd__integer(soap, "marketId", -1, &(((ns1__BladeT*)a)->marketId), "");
	soap_out_xsd__integer(soap, "bladeId", -1, &(((ns1__BladeT*)a)->bladeId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__BladeT*)a)->name), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__BladeT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__BladeT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BladeT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BladeT * SOAP_FMAC4 soap_get_ns1__BladeT(struct soap *soap, ns1__BladeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BladeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__BladeT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BladeT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BladeT * SOAP_FMAC4 soap_in_ns1__BladeT(struct soap *soap, const char *tag, ns1__BladeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BladeT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BladeT, sizeof(ns1__BladeT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BladeT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BladeT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_marketId1 = 1, soap_flag_bladeId1 = 1, soap_flag_name1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__BladeT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_marketId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "marketId", &(((ns1__BladeT*)a)->marketId), "xsd:integer"))
				{	soap_flag_marketId1--;
					continue;
				}
			if (soap_flag_bladeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "bladeId", &(((ns1__BladeT*)a)->bladeId), "xsd:integer"))
				{	soap_flag_bladeId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__BladeT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__BladeT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_marketId1 > 0 || soap_flag_bladeId1 > 0 || soap_flag_name1 > 0 || soap_flag_host1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BladeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BladeT, 0, sizeof(ns1__BladeT), 0, soap_copy_ns1__BladeT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__BladeT * SOAP_FMAC6 soap_new_ns1__BladeT(struct soap *soap, int n)
{	return soap_instantiate_ns1__BladeT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BladeT(struct soap *soap, ns1__BladeT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__BladeT * SOAP_FMAC4 soap_instantiate_ns1__BladeT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BladeT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BladeT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__BladeT;
		if (size)
			*size = sizeof(ns1__BladeT);
		((ns1__BladeT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__BladeT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BladeT);
		for (int i = 0; i < n; i++)
			((ns1__BladeT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BladeT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BladeT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BladeT %p -> %p\n", q, p));
	*(ns1__BladeT*)p = *(ns1__BladeT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MarketT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__MarketT*)this)->regionId);
	soap_default_xsd__integer(soap, &((ns1__MarketT*)this)->marketId);
	soap_default_std__string(soap, &((ns1__MarketT*)this)->name);
	soap_default_std__string(soap, &((ns1__MarketT*)this)->host);
	/* transient soap skipped */
}

void ns1__MarketT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MarketT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MarketT*)this)->regionId);
	soap_embedded(soap, &((ns1__MarketT*)this)->marketId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MarketT*)this)->marketId);
	soap_embedded(soap, &((ns1__MarketT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MarketT*)this)->name);
	soap_embedded(soap, &((ns1__MarketT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MarketT*)this)->host);
	/* transient soap skipped */
}

int ns1__MarketT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MarketT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MarketT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MarketT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketT(struct soap *soap, const char *tag, int id, const ns1__MarketT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__MarketT*)a)->regionId), "");
	soap_out_xsd__integer(soap, "marketId", -1, &(((ns1__MarketT*)a)->marketId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__MarketT*)a)->name), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__MarketT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MarketT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MarketT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MarketT * SOAP_FMAC4 soap_get_ns1__MarketT(struct soap *soap, ns1__MarketT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MarketT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MarketT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MarketT * SOAP_FMAC4 soap_in_ns1__MarketT(struct soap *soap, const char *tag, ns1__MarketT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MarketT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketT, sizeof(ns1__MarketT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MarketT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MarketT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_marketId1 = 1, soap_flag_name1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__MarketT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_marketId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "marketId", &(((ns1__MarketT*)a)->marketId), "xsd:integer"))
				{	soap_flag_marketId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__MarketT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__MarketT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_marketId1 > 0 || soap_flag_name1 > 0 || soap_flag_host1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MarketT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketT, 0, sizeof(ns1__MarketT), 0, soap_copy_ns1__MarketT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MarketT * SOAP_FMAC6 soap_new_ns1__MarketT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MarketT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MarketT(struct soap *soap, ns1__MarketT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MarketT * SOAP_FMAC4 soap_instantiate_ns1__MarketT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MarketT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MarketT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MarketT;
		if (size)
			*size = sizeof(ns1__MarketT);
		((ns1__MarketT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MarketT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MarketT);
		for (int i = 0; i < n; i++)
			((ns1__MarketT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MarketT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MarketT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MarketT %p -> %p\n", q, p));
	*(ns1__MarketT*)p = *(ns1__MarketT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__RegionT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__RegionT*)this)->regionId);
	soap_default_std__string(soap, &((ns1__RegionT*)this)->name);
	soap_default_std__string(soap, &((ns1__RegionT*)this)->host);
	/* transient soap skipped */
}

void ns1__RegionT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__RegionT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__RegionT*)this)->regionId);
	soap_embedded(soap, &((ns1__RegionT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__RegionT*)this)->name);
	soap_embedded(soap, &((ns1__RegionT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__RegionT*)this)->host);
	/* transient soap skipped */
}

int ns1__RegionT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RegionT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__RegionT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RegionT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RegionT(struct soap *soap, const char *tag, int id, const ns1__RegionT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RegionT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__RegionT*)a)->regionId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__RegionT*)a)->name), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__RegionT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RegionT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RegionT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RegionT * SOAP_FMAC4 soap_get_ns1__RegionT(struct soap *soap, ns1__RegionT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RegionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RegionT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RegionT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RegionT * SOAP_FMAC4 soap_in_ns1__RegionT(struct soap *soap, const char *tag, ns1__RegionT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RegionT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RegionT, sizeof(ns1__RegionT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RegionT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RegionT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_name1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__RegionT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__RegionT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__RegionT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_name1 > 0 || soap_flag_host1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RegionT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RegionT, 0, sizeof(ns1__RegionT), 0, soap_copy_ns1__RegionT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RegionT * SOAP_FMAC6 soap_new_ns1__RegionT(struct soap *soap, int n)
{	return soap_instantiate_ns1__RegionT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RegionT(struct soap *soap, ns1__RegionT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__RegionT * SOAP_FMAC4 soap_instantiate_ns1__RegionT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RegionT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RegionT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RegionT;
		if (size)
			*size = sizeof(ns1__RegionT);
		((ns1__RegionT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RegionT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RegionT);
		for (int i = 0; i < n; i++)
			((ns1__RegionT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RegionT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RegionT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RegionT %p -> %p\n", q, p));
	*(ns1__RegionT*)p = *(ns1__RegionT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__LocalSystemT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__SystemTypeT(soap, &((ns1__LocalSystemT*)this)->systemType);
	soap_default_std__string(soap, &((ns1__LocalSystemT*)this)->systemName);
	soap_default_std__string(soap, &((ns1__LocalSystemT*)this)->parentHost);
	/* transient soap skipped */
}

void ns1__LocalSystemT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__LocalSystemT*)this)->systemName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LocalSystemT*)this)->systemName);
	soap_embedded(soap, &((ns1__LocalSystemT*)this)->parentHost, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LocalSystemT*)this)->parentHost);
	/* transient soap skipped */
}

int ns1__LocalSystemT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LocalSystemT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__LocalSystemT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LocalSystemT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LocalSystemT(struct soap *soap, const char *tag, int id, const ns1__LocalSystemT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LocalSystemT), type);
	soap_out_ns1__SystemTypeT(soap, "systemType", -1, &(((ns1__LocalSystemT*)a)->systemType), "");
	soap_out_std__string(soap, "systemName", -1, &(((ns1__LocalSystemT*)a)->systemName), "");
	soap_out_std__string(soap, "parentHost", -1, &(((ns1__LocalSystemT*)a)->parentHost), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__LocalSystemT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LocalSystemT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LocalSystemT * SOAP_FMAC4 soap_get_ns1__LocalSystemT(struct soap *soap, ns1__LocalSystemT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LocalSystemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__LocalSystemT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LocalSystemT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LocalSystemT * SOAP_FMAC4 soap_in_ns1__LocalSystemT(struct soap *soap, const char *tag, ns1__LocalSystemT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LocalSystemT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LocalSystemT, sizeof(ns1__LocalSystemT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LocalSystemT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LocalSystemT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_systemType1 = 1, soap_flag_systemName1 = 1, soap_flag_parentHost1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_systemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SystemTypeT(soap, "systemType", &(((ns1__LocalSystemT*)a)->systemType), "ns1:SystemTypeT"))
				{	soap_flag_systemType1--;
					continue;
				}
			if (soap_flag_systemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "systemName", &(((ns1__LocalSystemT*)a)->systemName), "xsd:string"))
				{	soap_flag_systemName1--;
					continue;
				}
			if (soap_flag_parentHost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "parentHost", &(((ns1__LocalSystemT*)a)->parentHost), "xsd:string"))
				{	soap_flag_parentHost1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_systemType1 > 0 || soap_flag_systemName1 > 0 || soap_flag_parentHost1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LocalSystemT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LocalSystemT, 0, sizeof(ns1__LocalSystemT), 0, soap_copy_ns1__LocalSystemT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__LocalSystemT * SOAP_FMAC6 soap_new_ns1__LocalSystemT(struct soap *soap, int n)
{	return soap_instantiate_ns1__LocalSystemT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__LocalSystemT(struct soap *soap, ns1__LocalSystemT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__LocalSystemT * SOAP_FMAC4 soap_instantiate_ns1__LocalSystemT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LocalSystemT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LocalSystemT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__LocalSystemT;
		if (size)
			*size = sizeof(ns1__LocalSystemT);
		((ns1__LocalSystemT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__LocalSystemT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LocalSystemT);
		for (int i = 0; i < n; i++)
			((ns1__LocalSystemT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LocalSystemT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LocalSystemT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LocalSystemT %p -> %p\n", q, p));
	*(ns1__LocalSystemT*)p = *(ns1__LocalSystemT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__TopoHierarchyKeyT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->regionId);
	soap_default_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->marketId);
	soap_default_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->bladeId);
	/* transient soap skipped */
}

void ns1__TopoHierarchyKeyT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__TopoHierarchyKeyT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->regionId);
	soap_embedded(soap, &((ns1__TopoHierarchyKeyT*)this)->marketId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->marketId);
	soap_embedded(soap, &((ns1__TopoHierarchyKeyT*)this)->bladeId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->bladeId);
	/* transient soap skipped */
}

int ns1__TopoHierarchyKeyT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TopoHierarchyKeyT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__TopoHierarchyKeyT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TopoHierarchyKeyT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TopoHierarchyKeyT(struct soap *soap, const char *tag, int id, const ns1__TopoHierarchyKeyT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TopoHierarchyKeyT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__TopoHierarchyKeyT*)a)->regionId), "");
	soap_out_xsd__integer(soap, "marketId", -1, &(((ns1__TopoHierarchyKeyT*)a)->marketId), "");
	soap_out_xsd__integer(soap, "bladeId", -1, &(((ns1__TopoHierarchyKeyT*)a)->bladeId), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__TopoHierarchyKeyT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TopoHierarchyKeyT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT * SOAP_FMAC4 soap_get_ns1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TopoHierarchyKeyT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__TopoHierarchyKeyT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TopoHierarchyKeyT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT * SOAP_FMAC4 soap_in_ns1__TopoHierarchyKeyT(struct soap *soap, const char *tag, ns1__TopoHierarchyKeyT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TopoHierarchyKeyT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TopoHierarchyKeyT, sizeof(ns1__TopoHierarchyKeyT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TopoHierarchyKeyT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TopoHierarchyKeyT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_marketId1 = 1, soap_flag_bladeId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__TopoHierarchyKeyT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_marketId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "marketId", &(((ns1__TopoHierarchyKeyT*)a)->marketId), "xsd:integer"))
				{	soap_flag_marketId1--;
					continue;
				}
			if (soap_flag_bladeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "bladeId", &(((ns1__TopoHierarchyKeyT*)a)->bladeId), "xsd:integer"))
				{	soap_flag_bladeId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_marketId1 > 0 || soap_flag_bladeId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TopoHierarchyKeyT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TopoHierarchyKeyT, 0, sizeof(ns1__TopoHierarchyKeyT), 0, soap_copy_ns1__TopoHierarchyKeyT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__TopoHierarchyKeyT * SOAP_FMAC6 soap_new_ns1__TopoHierarchyKeyT(struct soap *soap, int n)
{	return soap_instantiate_ns1__TopoHierarchyKeyT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT * SOAP_FMAC4 soap_instantiate_ns1__TopoHierarchyKeyT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TopoHierarchyKeyT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TopoHierarchyKeyT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__TopoHierarchyKeyT;
		if (size)
			*size = sizeof(ns1__TopoHierarchyKeyT);
		((ns1__TopoHierarchyKeyT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__TopoHierarchyKeyT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TopoHierarchyKeyT);
		for (int i = 0; i < n; i++)
			((ns1__TopoHierarchyKeyT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TopoHierarchyKeyT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TopoHierarchyKeyT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TopoHierarchyKeyT %p -> %p\n", q, p));
	*(ns1__TopoHierarchyKeyT*)p = *(ns1__TopoHierarchyKeyT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ResultBatchT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__ResultBatchT*)this)->fromIndex);
	soap_default_short(soap, &((ns1__ResultBatchT*)this)->toIndex);
	/* transient soap skipped */
}

void ns1__ResultBatchT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__ResultBatchT*)this)->fromIndex, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__ResultBatchT*)this)->toIndex, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__ResultBatchT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ResultBatchT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ResultBatchT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ResultBatchT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResultBatchT(struct soap *soap, const char *tag, int id, const ns1__ResultBatchT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResultBatchT), type);
	soap_out_short(soap, "fromIndex", -1, &(((ns1__ResultBatchT*)a)->fromIndex), "");
	soap_out_short(soap, "toIndex", -1, &(((ns1__ResultBatchT*)a)->toIndex), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ResultBatchT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ResultBatchT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ResultBatchT * SOAP_FMAC4 soap_get_ns1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResultBatchT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ResultBatchT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ResultBatchT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ResultBatchT * SOAP_FMAC4 soap_in_ns1__ResultBatchT(struct soap *soap, const char *tag, ns1__ResultBatchT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ResultBatchT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResultBatchT, sizeof(ns1__ResultBatchT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ResultBatchT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ResultBatchT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fromIndex1 = 1, soap_flag_toIndex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fromIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "fromIndex", &(((ns1__ResultBatchT*)a)->fromIndex), "xsd:short"))
				{	soap_flag_fromIndex1--;
					continue;
				}
			if (soap_flag_toIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "toIndex", &(((ns1__ResultBatchT*)a)->toIndex), "xsd:short"))
				{	soap_flag_toIndex1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fromIndex1 > 0 || soap_flag_toIndex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ResultBatchT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResultBatchT, 0, sizeof(ns1__ResultBatchT), 0, soap_copy_ns1__ResultBatchT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ResultBatchT * SOAP_FMAC6 soap_new_ns1__ResultBatchT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ResultBatchT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ResultBatchT * SOAP_FMAC4 soap_instantiate_ns1__ResultBatchT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ResultBatchT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ResultBatchT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ResultBatchT;
		if (size)
			*size = sizeof(ns1__ResultBatchT);
		((ns1__ResultBatchT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ResultBatchT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ResultBatchT);
		for (int i = 0; i < n; i++)
			((ns1__ResultBatchT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ResultBatchT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ResultBatchT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ResultBatchT %p -> %p\n", q, p));
	*(ns1__ResultBatchT*)p = *(ns1__ResultBatchT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__InputTimeT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__InputTimeT*)this)->year);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->monthOfYear);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->dayOfMonth);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->hourOfDay);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->minuteOfHour);
	/* transient soap skipped */
}

void ns1__InputTimeT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__InputTimeT*)this)->year, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->monthOfYear, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->dayOfMonth, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->hourOfDay, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->minuteOfHour, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__InputTimeT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__InputTimeT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__InputTimeT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InputTimeT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InputTimeT(struct soap *soap, const char *tag, int id, const ns1__InputTimeT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InputTimeT), type);
	soap_out_short(soap, "year", -1, &(((ns1__InputTimeT*)a)->year), "");
	soap_out_short(soap, "monthOfYear", -1, &(((ns1__InputTimeT*)a)->monthOfYear), "");
	soap_out_short(soap, "dayOfMonth", -1, &(((ns1__InputTimeT*)a)->dayOfMonth), "");
	soap_out_short(soap, "hourOfDay", -1, &(((ns1__InputTimeT*)a)->hourOfDay), "");
	soap_out_short(soap, "minuteOfHour", -1, &(((ns1__InputTimeT*)a)->minuteOfHour), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__InputTimeT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InputTimeT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InputTimeT * SOAP_FMAC4 soap_get_ns1__InputTimeT(struct soap *soap, ns1__InputTimeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InputTimeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__InputTimeT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__InputTimeT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InputTimeT * SOAP_FMAC4 soap_in_ns1__InputTimeT(struct soap *soap, const char *tag, ns1__InputTimeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InputTimeT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InputTimeT, sizeof(ns1__InputTimeT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__InputTimeT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__InputTimeT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_year1 = 1, soap_flag_monthOfYear1 = 1, soap_flag_dayOfMonth1 = 1, soap_flag_hourOfDay1 = 1, soap_flag_minuteOfHour1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_year1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "year", &(((ns1__InputTimeT*)a)->year), "xsd:short"))
				{	soap_flag_year1--;
					continue;
				}
			if (soap_flag_monthOfYear1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "monthOfYear", &(((ns1__InputTimeT*)a)->monthOfYear), "xsd:short"))
				{	soap_flag_monthOfYear1--;
					continue;
				}
			if (soap_flag_dayOfMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "dayOfMonth", &(((ns1__InputTimeT*)a)->dayOfMonth), "xsd:short"))
				{	soap_flag_dayOfMonth1--;
					continue;
				}
			if (soap_flag_hourOfDay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "hourOfDay", &(((ns1__InputTimeT*)a)->hourOfDay), "xsd:short"))
				{	soap_flag_hourOfDay1--;
					continue;
				}
			if (soap_flag_minuteOfHour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "minuteOfHour", &(((ns1__InputTimeT*)a)->minuteOfHour), "xsd:short"))
				{	soap_flag_minuteOfHour1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_year1 > 0 || soap_flag_monthOfYear1 > 0 || soap_flag_dayOfMonth1 > 0 || soap_flag_hourOfDay1 > 0 || soap_flag_minuteOfHour1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__InputTimeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InputTimeT, 0, sizeof(ns1__InputTimeT), 0, soap_copy_ns1__InputTimeT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__InputTimeT * SOAP_FMAC6 soap_new_ns1__InputTimeT(struct soap *soap, int n)
{	return soap_instantiate_ns1__InputTimeT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__InputTimeT(struct soap *soap, ns1__InputTimeT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__InputTimeT * SOAP_FMAC4 soap_instantiate_ns1__InputTimeT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InputTimeT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__InputTimeT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__InputTimeT;
		if (size)
			*size = sizeof(ns1__InputTimeT);
		((ns1__InputTimeT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__InputTimeT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__InputTimeT);
		for (int i = 0; i < n; i++)
			((ns1__InputTimeT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__InputTimeT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__InputTimeT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__InputTimeT %p -> %p\n", q, p));
	*(ns1__InputTimeT*)p = *(ns1__InputTimeT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__GenericCountsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->totalCm);
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->onlineCm);
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->totalMta);
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->availableMta);
	/* transient soap skipped */
}

void ns1__GenericCountsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->totalCm, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->onlineCm, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->totalMta, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->availableMta, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__GenericCountsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GenericCountsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__GenericCountsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericCountsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericCountsT(struct soap *soap, const char *tag, int id, const ns1__GenericCountsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericCountsT), type);
	soap_out_short(soap, "totalCm", -1, &(((ns1__GenericCountsT*)a)->totalCm), "");
	soap_out_short(soap, "onlineCm", -1, &(((ns1__GenericCountsT*)a)->onlineCm), "");
	soap_out_short(soap, "totalMta", -1, &(((ns1__GenericCountsT*)a)->totalMta), "");
	soap_out_short(soap, "availableMta", -1, &(((ns1__GenericCountsT*)a)->availableMta), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__GenericCountsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericCountsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericCountsT * SOAP_FMAC4 soap_get_ns1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericCountsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__GenericCountsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GenericCountsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericCountsT * SOAP_FMAC4 soap_in_ns1__GenericCountsT(struct soap *soap, const char *tag, ns1__GenericCountsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericCountsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericCountsT, sizeof(ns1__GenericCountsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GenericCountsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GenericCountsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_totalCm1 = 1, soap_flag_onlineCm1 = 1, soap_flag_totalMta1 = 1, soap_flag_availableMta1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_totalCm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "totalCm", &(((ns1__GenericCountsT*)a)->totalCm), "xsd:short"))
				{	soap_flag_totalCm1--;
					continue;
				}
			if (soap_flag_onlineCm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "onlineCm", &(((ns1__GenericCountsT*)a)->onlineCm), "xsd:short"))
				{	soap_flag_onlineCm1--;
					continue;
				}
			if (soap_flag_totalMta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "totalMta", &(((ns1__GenericCountsT*)a)->totalMta), "xsd:short"))
				{	soap_flag_totalMta1--;
					continue;
				}
			if (soap_flag_availableMta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "availableMta", &(((ns1__GenericCountsT*)a)->availableMta), "xsd:short"))
				{	soap_flag_availableMta1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_totalCm1 > 0 || soap_flag_onlineCm1 > 0 || soap_flag_totalMta1 > 0 || soap_flag_availableMta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericCountsT, 0, sizeof(ns1__GenericCountsT), 0, soap_copy_ns1__GenericCountsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__GenericCountsT * SOAP_FMAC6 soap_new_ns1__GenericCountsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__GenericCountsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__GenericCountsT * SOAP_FMAC4 soap_instantiate_ns1__GenericCountsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericCountsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GenericCountsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__GenericCountsT;
		if (size)
			*size = sizeof(ns1__GenericCountsT);
		((ns1__GenericCountsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__GenericCountsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GenericCountsT);
		for (int i = 0; i < n; i++)
			((ns1__GenericCountsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GenericCountsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GenericCountsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GenericCountsT %p -> %p\n", q, p));
	*(ns1__GenericCountsT*)p = *(ns1__GenericCountsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SnmpV2CAttributesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__SnmpV2CAttributesT*)this)->readCommnunity);
	((ns1__SnmpV2CAttributesT*)this)->writeCommnunity = NULL;
	/* transient soap skipped */
}

void ns1__SnmpV2CAttributesT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__SnmpV2CAttributesT*)this)->readCommnunity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SnmpV2CAttributesT*)this)->readCommnunity);
	soap_serialize_PointerTostd__string(soap, &((ns1__SnmpV2CAttributesT*)this)->writeCommnunity);
	/* transient soap skipped */
}

int ns1__SnmpV2CAttributesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnmpV2CAttributesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SnmpV2CAttributesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnmpV2CAttributesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnmpV2CAttributesT(struct soap *soap, const char *tag, int id, const ns1__SnmpV2CAttributesT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnmpV2CAttributesT), type);
	soap_out_std__string(soap, "readCommnunity", -1, &(((ns1__SnmpV2CAttributesT*)a)->readCommnunity), "");
	soap_out_PointerTostd__string(soap, "writeCommnunity", -1, &(((ns1__SnmpV2CAttributesT*)a)->writeCommnunity), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SnmpV2CAttributesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnmpV2CAttributesT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT * SOAP_FMAC4 soap_get_ns1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SnmpV2CAttributesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnmpV2CAttributesT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT * SOAP_FMAC4 soap_in_ns1__SnmpV2CAttributesT(struct soap *soap, const char *tag, ns1__SnmpV2CAttributesT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnmpV2CAttributesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnmpV2CAttributesT, sizeof(ns1__SnmpV2CAttributesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnmpV2CAttributesT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnmpV2CAttributesT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_readCommnunity1 = 1, soap_flag_writeCommnunity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_readCommnunity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "readCommnunity", &(((ns1__SnmpV2CAttributesT*)a)->readCommnunity), "xsd:string"))
				{	soap_flag_readCommnunity1--;
					continue;
				}
			if (soap_flag_writeCommnunity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "writeCommnunity", &(((ns1__SnmpV2CAttributesT*)a)->writeCommnunity), "xsd:string"))
				{	soap_flag_writeCommnunity1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_readCommnunity1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnmpV2CAttributesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnmpV2CAttributesT, 0, sizeof(ns1__SnmpV2CAttributesT), 0, soap_copy_ns1__SnmpV2CAttributesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SnmpV2CAttributesT * SOAP_FMAC6 soap_new_ns1__SnmpV2CAttributesT(struct soap *soap, int n)
{	return soap_instantiate_ns1__SnmpV2CAttributesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT * SOAP_FMAC4 soap_instantiate_ns1__SnmpV2CAttributesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnmpV2CAttributesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnmpV2CAttributesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SnmpV2CAttributesT;
		if (size)
			*size = sizeof(ns1__SnmpV2CAttributesT);
		((ns1__SnmpV2CAttributesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SnmpV2CAttributesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnmpV2CAttributesT);
		for (int i = 0; i < n; i++)
			((ns1__SnmpV2CAttributesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnmpV2CAttributesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnmpV2CAttributesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnmpV2CAttributesT %p -> %p\n", q, p));
	*(ns1__SnmpV2CAttributesT*)p = *(ns1__SnmpV2CAttributesT*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__SOAP_ENC__arrayType);
	if (soap_out__SOAP_ENC__arrayType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE__SOAP_ENC__arrayType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in__SOAP_ENC__arrayType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in__SOAP_ENC__arrayType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE__SOAP_ENC__arrayType, 0, sizeof(std::string), 0, soap_copy__SOAP_ENC__arrayType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new__SOAP_ENC__arrayType(struct soap *soap, int n)
{	return soap_instantiate__SOAP_ENC__arrayType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__SOAP_ENC__arrayType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__SOAP_ENC__arrayType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__SOAP_ENC__arrayType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__integer(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::string), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__integer(struct soap *soap, int n)
{	return soap_instantiate_xsd__integer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__integer(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__integer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__integer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__integer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__integer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}
#ifdef __cplusplus
}
#endif

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cte__getCteData(struct soap *soap, struct cte__getCteData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->queryInput = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cte__getCteData(struct soap *soap, const struct cte__getCteData *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCTEQueryInputT(soap, &a->queryInput);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cte__getCteData(struct soap *soap, const struct cte__getCteData *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cte__getCteData);
	if (soap_out_cte__getCteData(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cte__getCteData(struct soap *soap, const char *tag, int id, const struct cte__getCteData *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cte__getCteData), type);
	soap_out_PointerToArrayOfCTEQueryInputT(soap, "queryInput", -1, &a->queryInput, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct cte__getCteData * SOAP_FMAC4 soap_get_cte__getCteData(struct soap *soap, struct cte__getCteData *p, const char *tag, const char *type)
{
	if ((p = soap_in_cte__getCteData(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct cte__getCteData * SOAP_FMAC4 soap_in_cte__getCteData(struct soap *soap, const char *tag, struct cte__getCteData *a, const char *type)
{
	short soap_flag_queryInput = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cte__getCteData *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cte__getCteData, sizeof(struct cte__getCteData), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cte__getCteData(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_queryInput && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTEQueryInputT(soap, "queryInput", &a->queryInput, "ns1:CTEQueryInputT"))
				{	soap_flag_queryInput--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cte__getCteData *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cte__getCteData, 0, sizeof(struct cte__getCteData), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct cte__getCteData * SOAP_FMAC6 soap_new_cte__getCteData(struct soap *soap, int n)
{	return soap_instantiate_cte__getCteData(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_cte__getCteData(struct soap *soap, struct cte__getCteData *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct cte__getCteData * SOAP_FMAC4 soap_instantiate_cte__getCteData(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_cte__getCteData(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cte__getCteData, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct cte__getCteData;
		if (size)
			*size = sizeof(struct cte__getCteData);
	}
	else
	{	cp->ptr = (void*)new struct cte__getCteData[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct cte__getCteData);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct cte__getCteData*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_cte__getCteData(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct cte__getCteData %p -> %p\n", q, p));
	*(struct cte__getCteData*)p = *(struct cte__getCteData*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_cte__getCteDataResponse(struct soap *soap, struct cte__getCteDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_cte__getCteDataResponse(struct soap *soap, const struct cte__getCteDataResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCTEDataT(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_cte__getCteDataResponse(struct soap *soap, const struct cte__getCteDataResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_cte__getCteDataResponse);
	if (soap_out_cte__getCteDataResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_cte__getCteDataResponse(struct soap *soap, const char *tag, int id, const struct cte__getCteDataResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_cte__getCteDataResponse), type);
	if (a->name)
		soap_element_result(soap, "name");
	soap_out_PointerToArrayOfCTEDataT(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct cte__getCteDataResponse * SOAP_FMAC4 soap_get_cte__getCteDataResponse(struct soap *soap, struct cte__getCteDataResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_cte__getCteDataResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct cte__getCteDataResponse * SOAP_FMAC4 soap_in_cte__getCteDataResponse(struct soap *soap, const char *tag, struct cte__getCteDataResponse *a, const char *type)
{
	short soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct cte__getCteDataResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_cte__getCteDataResponse, sizeof(struct cte__getCteDataResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_cte__getCteDataResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCTEDataT(soap, "name", &a->name, "ns1:CTEDataT"))
				{	soap_flag_name--;
					continue;
				}
			soap_check_result(soap, "name");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct cte__getCteDataResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_cte__getCteDataResponse, 0, sizeof(struct cte__getCteDataResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct cte__getCteDataResponse * SOAP_FMAC6 soap_new_cte__getCteDataResponse(struct soap *soap, int n)
{	return soap_instantiate_cte__getCteDataResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_cte__getCteDataResponse(struct soap *soap, struct cte__getCteDataResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct cte__getCteDataResponse * SOAP_FMAC4 soap_instantiate_cte__getCteDataResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_cte__getCteDataResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_cte__getCteDataResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct cte__getCteDataResponse;
		if (size)
			*size = sizeof(struct cte__getCteDataResponse);
	}
	else
	{	cp->ptr = (void*)new struct cte__getCteDataResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct cte__getCteDataResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct cte__getCteDataResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_cte__getCteDataResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct cte__getCteDataResponse %p -> %p\n", q, p));
	*(struct cte__getCteDataResponse*)p = *(struct cte__getCteDataResponse*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCTEQueryInputT(struct soap *soap, ArrayOfCTEQueryInputT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCTEQueryInputT(struct soap *soap, ArrayOfCTEQueryInputT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCTEQueryInputT);
	if (soap_out_PointerToArrayOfCTEQueryInputT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCTEQueryInputT(struct soap *soap, const char *tag, int id, ArrayOfCTEQueryInputT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCTEQueryInputT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCTEQueryInputT ** SOAP_FMAC4 soap_get_PointerToArrayOfCTEQueryInputT(struct soap *soap, ArrayOfCTEQueryInputT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfCTEQueryInputT ** SOAP_FMAC4 soap_in_PointerToArrayOfCTEQueryInputT(struct soap *soap, const char *tag, ArrayOfCTEQueryInputT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCTEQueryInputT **)soap_malloc(soap, sizeof(ArrayOfCTEQueryInputT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCTEQueryInputT *)soap_instantiate_ArrayOfCTEQueryInputT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfCTEQueryInputT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCTEQueryInputT, sizeof(ArrayOfCTEQueryInputT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCTEDataT(struct soap *soap, ArrayOfCTEDataT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCTEDataT(struct soap *soap, ArrayOfCTEDataT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCTEDataT);
	if (soap_out_PointerToArrayOfCTEDataT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCTEDataT(struct soap *soap, const char *tag, int id, ArrayOfCTEDataT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCTEDataT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCTEDataT ** SOAP_FMAC4 soap_get_PointerToArrayOfCTEDataT(struct soap *soap, ArrayOfCTEDataT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfCTEDataT ** SOAP_FMAC4 soap_in_PointerToArrayOfCTEDataT(struct soap *soap, const char *tag, ArrayOfCTEDataT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCTEDataT **)soap_malloc(soap, sizeof(ArrayOfCTEDataT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCTEDataT *)soap_instantiate_ArrayOfCTEDataT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfCTEDataT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCTEDataT, sizeof(ArrayOfCTEDataT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmStatusSummaryT))
		soap_serialize_PointerTons1__CmStatusSummaryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT);
	if (soap_out_PointerToPointerTons1__CmStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__CmStatusSummaryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmStatusSummaryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmStatusSummaryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusSummaryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, ns1__CmStatusSummaryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusSummaryT ***)soap_malloc(soap, sizeof(ns1__CmStatusSummaryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmStatusSummaryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmStatusSummaryT, sizeof(ns1__CmStatusSummaryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmStatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmStatusSummaryT);
	if (soap_out_PointerTons1__CmStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__CmStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, ns1__CmStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusSummaryT **)soap_malloc(soap, sizeof(ns1__CmStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmStatusSummaryT *)soap_instantiate_ns1__CmStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmStatusSummaryT, sizeof(ns1__CmStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaStatusSummaryT))
		soap_serialize_PointerTons1__MtaStatusSummaryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT);
	if (soap_out_PointerToPointerTons1__MtaStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__MtaStatusSummaryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaStatusSummaryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaStatusSummaryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaStatusSummaryT ***)soap_malloc(soap, sizeof(ns1__MtaStatusSummaryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaStatusSummaryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaStatusSummaryT, sizeof(ns1__MtaStatusSummaryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaStatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaStatusSummaryT);
	if (soap_out_PointerTons1__MtaStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__MtaStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaStatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaStatusSummaryT **)soap_malloc(soap, sizeof(ns1__MtaStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaStatusSummaryT *)soap_instantiate_ns1__MtaStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaStatusSummaryT, sizeof(ns1__MtaStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__HfcStatusSummaryT))
		soap_serialize_PointerTons1__HfcStatusSummaryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT);
	if (soap_out_PointerToPointerTons1__HfcStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__HfcStatusSummaryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__HfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__HfcStatusSummaryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__HfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcStatusSummaryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcStatusSummaryT ***)soap_malloc(soap, sizeof(ns1__HfcStatusSummaryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__HfcStatusSummaryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__HfcStatusSummaryT, sizeof(ns1__HfcStatusSummaryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcStatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcStatusSummaryT);
	if (soap_out_PointerTons1__HfcStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__HfcStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcStatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcStatusSummaryT **)soap_malloc(soap, sizeof(ns1__HfcStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcStatusSummaryT *)soap_instantiate_ns1__HfcStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcStatusSummaryT, sizeof(ns1__HfcStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AlarmTypeConfigT))
		soap_serialize_PointerTons1__AlarmTypeConfigT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT);
	if (soap_out_PointerToPointerTons1__AlarmTypeConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, int id, ns1__AlarmTypeConfigT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AlarmTypeConfigT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmTypeConfigT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, ns1__AlarmTypeConfigT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmTypeConfigT ***)soap_malloc(soap, sizeof(ns1__AlarmTypeConfigT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AlarmTypeConfigT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AlarmTypeConfigT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AlarmTypeConfigT, sizeof(ns1__AlarmTypeConfigT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT))
		soap_serialize_PointerTons1__AggregateStatusThresholdT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT);
	if (soap_out_PointerToPointerTons1__AggregateStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateStatusThresholdT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AggregateStatusThresholdT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, ns1__AggregateStatusThresholdT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateStatusThresholdT ***)soap_malloc(soap, sizeof(ns1__AggregateStatusThresholdT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AggregateStatusThresholdT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AggregateStatusThresholdT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT, sizeof(ns1__AggregateStatusThresholdT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AggregateStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT);
	if (soap_out_PointerTons1__AggregateStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, ns1__AggregateStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AggregateStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AggregateStatusThresholdT *)soap_instantiate_ns1__AggregateStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AggregateStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AggregateStatusThresholdT, sizeof(ns1__AggregateStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT))
		soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT);
	if (soap_out_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AlarmBasedStatusThresholdT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, ns1__AlarmBasedStatusThresholdT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmBasedStatusThresholdT ***)soap_malloc(soap, sizeof(ns1__AlarmBasedStatusThresholdT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AlarmBasedStatusThresholdT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT, sizeof(ns1__AlarmBasedStatusThresholdT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT);
	if (soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AlarmBasedStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, ns1__AlarmBasedStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmBasedStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AlarmBasedStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AlarmBasedStatusThresholdT *)soap_instantiate_ns1__AlarmBasedStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AlarmBasedStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, sizeof(ns1__AlarmBasedStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UserT(struct soap *soap, ns1__UserT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UserT))
		soap_serialize_PointerTons1__UserT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UserT(struct soap *soap, ns1__UserT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UserT);
	if (soap_out_PointerToPointerTons1__UserT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UserT(struct soap *soap, const char *tag, int id, ns1__UserT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UserT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UserT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UserT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UserT(struct soap *soap, ns1__UserT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UserT(struct soap *soap, const char *tag, ns1__UserT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserT ***)soap_malloc(soap, sizeof(ns1__UserT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UserT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UserT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UserT, sizeof(ns1__UserT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserT(struct soap *soap, ns1__UserT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserT(struct soap *soap, ns1__UserT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserT);
	if (soap_out_PointerTons1__UserT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserT(struct soap *soap, const char *tag, int id, ns1__UserT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UserT ** SOAP_FMAC4 soap_get_PointerTons1__UserT(struct soap *soap, ns1__UserT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserT ** SOAP_FMAC4 soap_in_PointerTons1__UserT(struct soap *soap, const char *tag, ns1__UserT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserT **)soap_malloc(soap, sizeof(ns1__UserT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UserT *)soap_instantiate_ns1__UserT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__UserT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserT, sizeof(ns1__UserT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UserRoleT(struct soap *soap, ns1__UserRoleT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UserRoleT))
		soap_serialize_PointerTons1__UserRoleT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UserRoleT(struct soap *soap, ns1__UserRoleT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UserRoleT);
	if (soap_out_PointerToPointerTons1__UserRoleT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UserRoleT(struct soap *soap, const char *tag, int id, ns1__UserRoleT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UserRoleT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UserRoleT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UserRoleT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UserRoleT(struct soap *soap, ns1__UserRoleT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UserRoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserRoleT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UserRoleT(struct soap *soap, const char *tag, ns1__UserRoleT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserRoleT ***)soap_malloc(soap, sizeof(ns1__UserRoleT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UserRoleT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UserRoleT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UserRoleT, sizeof(ns1__UserRoleT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__OAPairT(struct soap *soap, ns1__OAPairT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__OAPairT))
		soap_serialize_PointerTons1__OAPairT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__OAPairT(struct soap *soap, ns1__OAPairT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__OAPairT);
	if (soap_out_PointerToPointerTons1__OAPairT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__OAPairT(struct soap *soap, const char *tag, int id, ns1__OAPairT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__OAPairT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__OAPairT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__OAPairT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__OAPairT(struct soap *soap, ns1__OAPairT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__OAPairT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__OAPairT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__OAPairT(struct soap *soap, const char *tag, ns1__OAPairT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OAPairT ***)soap_malloc(soap, sizeof(ns1__OAPairT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__OAPairT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__OAPairT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__OAPairT, sizeof(ns1__OAPairT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__OAPairT(struct soap *soap, ns1__OAPairT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__OAPairT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__OAPairT(struct soap *soap, ns1__OAPairT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__OAPairT);
	if (soap_out_PointerTons1__OAPairT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__OAPairT(struct soap *soap, const char *tag, int id, ns1__OAPairT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__OAPairT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__OAPairT ** SOAP_FMAC4 soap_get_PointerTons1__OAPairT(struct soap *soap, ns1__OAPairT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__OAPairT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__OAPairT ** SOAP_FMAC4 soap_in_PointerTons1__OAPairT(struct soap *soap, const char *tag, ns1__OAPairT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__OAPairT **)soap_malloc(soap, sizeof(ns1__OAPairT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__OAPairT *)soap_instantiate_ns1__OAPairT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__OAPairT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__OAPairT, sizeof(ns1__OAPairT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CMSLineT))
		soap_serialize_PointerTons1__CMSLineT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CMSLineT);
	if (soap_out_PointerToPointerTons1__CMSLineT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CMSLineT(struct soap *soap, const char *tag, int id, ns1__CMSLineT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CMSLineT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CMSLineT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CMSLineT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CMSLineT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CMSLineT(struct soap *soap, const char *tag, ns1__CMSLineT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CMSLineT ***)soap_malloc(soap, sizeof(ns1__CMSLineT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CMSLineT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CMSLineT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CMSLineT, sizeof(ns1__CMSLineT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTEQueryInputT))
		soap_serialize_PointerTons1__CTEQueryInputT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT);
	if (soap_out_PointerToPointerTons1__CTEQueryInputT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, int id, ns1__CTEQueryInputT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTEQueryInputT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTEQueryInputT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEQueryInputT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, ns1__CTEQueryInputT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEQueryInputT ***)soap_malloc(soap, sizeof(ns1__CTEQueryInputT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTEQueryInputT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTEQueryInputT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTEQueryInputT, sizeof(ns1__CTEQueryInputT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEQueryInputT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEQueryInputT);
	if (soap_out_PointerTons1__CTEQueryInputT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, int id, ns1__CTEQueryInputT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEQueryInputT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT ** SOAP_FMAC4 soap_get_PointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEQueryInputT ** SOAP_FMAC4 soap_in_PointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, ns1__CTEQueryInputT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEQueryInputT **)soap_malloc(soap, sizeof(ns1__CTEQueryInputT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEQueryInputT *)soap_instantiate_ns1__CTEQueryInputT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEQueryInputT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEQueryInputT, sizeof(ns1__CTEQueryInputT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTEDataT))
		soap_serialize_PointerTons1__CTEDataT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTEDataT);
	if (soap_out_PointerToPointerTons1__CTEDataT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTEDataT(struct soap *soap, const char *tag, int id, ns1__CTEDataT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTEDataT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTEDataT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTEDataT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEDataT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTEDataT(struct soap *soap, const char *tag, ns1__CTEDataT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEDataT ***)soap_malloc(soap, sizeof(ns1__CTEDataT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTEDataT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTEDataT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTEDataT, sizeof(ns1__CTEDataT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEDataT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEDataT);
	if (soap_out_PointerTons1__CTEDataT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEDataT(struct soap *soap, const char *tag, int id, ns1__CTEDataT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEDataT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEDataT ** SOAP_FMAC4 soap_get_PointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEDataT ** SOAP_FMAC4 soap_in_PointerTons1__CTEDataT(struct soap *soap, const char *tag, ns1__CTEDataT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEDataT **)soap_malloc(soap, sizeof(ns1__CTEDataT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEDataT *)soap_instantiate_ns1__CTEDataT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEDataT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEDataT, sizeof(ns1__CTEDataT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTECustomerT))
		soap_serialize_PointerTons1__CTECustomerT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTECustomerT);
	if (soap_out_PointerToPointerTons1__CTECustomerT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTECustomerT(struct soap *soap, const char *tag, int id, ns1__CTECustomerT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTECustomerT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTECustomerT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTECustomerT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTECustomerT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTECustomerT(struct soap *soap, const char *tag, ns1__CTECustomerT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTECustomerT ***)soap_malloc(soap, sizeof(ns1__CTECustomerT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTECustomerT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTECustomerT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTECustomerT, sizeof(ns1__CTECustomerT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT))
		soap_serialize_PointerTons1__CmPerformanceHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT);
	if (soap_out_PointerToPointerTons1__CmPerformanceHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, int id, ns1__CmPerformanceHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmPerformanceHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, ns1__CmPerformanceHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmPerformanceHistoryT ***)soap_malloc(soap, sizeof(ns1__CmPerformanceHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmPerformanceHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT, sizeof(ns1__CmPerformanceHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmPerformanceHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT);
	if (soap_out_PointerTons1__CmPerformanceHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, int id, ns1__CmPerformanceHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmPerformanceHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, ns1__CmPerformanceHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmPerformanceHistoryT **)soap_malloc(soap, sizeof(ns1__CmPerformanceHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmPerformanceHistoryT *)soap_instantiate_ns1__CmPerformanceHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmPerformanceHistoryT, sizeof(ns1__CmPerformanceHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT))
		soap_serialize_PointerTons1__MtaPingStatusHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT);
	if (soap_out_PointerToPointerTons1__MtaPingStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaPingStatusHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaPingStatusHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaPingStatusHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaPingStatusHistoryT ***)soap_malloc(soap, sizeof(ns1__MtaPingStatusHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaPingStatusHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT, sizeof(ns1__MtaPingStatusHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaPingStatusHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT);
	if (soap_out_PointerTons1__MtaPingStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaPingStatusHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaPingStatusHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaPingStatusHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaPingStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaPingStatusHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaPingStatusHistoryT *)soap_instantiate_ns1__MtaPingStatusHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaPingStatusHistoryT, sizeof(ns1__MtaPingStatusHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT))
		soap_serialize_PointerTons1__MtaProvStatusHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT);
	if (soap_out_PointerToPointerTons1__MtaProvStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaProvStatusHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaProvStatusHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaProvStatusHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaProvStatusHistoryT ***)soap_malloc(soap, sizeof(ns1__MtaProvStatusHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaProvStatusHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT, sizeof(ns1__MtaProvStatusHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaProvStatusHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT);
	if (soap_out_PointerTons1__MtaProvStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaProvStatusHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaProvStatusHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaProvStatusHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaProvStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaProvStatusHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaProvStatusHistoryT *)soap_instantiate_ns1__MtaProvStatusHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaProvStatusHistoryT, sizeof(ns1__MtaProvStatusHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT))
		soap_serialize_PointerTons1__MtaAvailabilityHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT);
	if (soap_out_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaAvailabilityHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, ns1__MtaAvailabilityHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaAvailabilityHistoryT ***)soap_malloc(soap, sizeof(ns1__MtaAvailabilityHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT, sizeof(ns1__MtaAvailabilityHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT);
	if (soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaAvailabilityHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaAvailabilityHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, ns1__MtaAvailabilityHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaAvailabilityHistoryT **)soap_malloc(soap, sizeof(ns1__MtaAvailabilityHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaAvailabilityHistoryT *)soap_instantiate_ns1__MtaAvailabilityHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, sizeof(ns1__MtaAvailabilityHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmStatusHistoryT))
		soap_serialize_PointerTons1__CmStatusHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT);
	if (soap_out_PointerToPointerTons1__CmStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__CmStatusHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmStatusHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmStatusHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, ns1__CmStatusHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusHistoryT ***)soap_malloc(soap, sizeof(ns1__CmStatusHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmStatusHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmStatusHistoryT, sizeof(ns1__CmStatusHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmStatusHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmStatusHistoryT);
	if (soap_out_PointerTons1__CmStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__CmStatusHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmStatusHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, ns1__CmStatusHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusHistoryT **)soap_malloc(soap, sizeof(ns1__CmStatusHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmStatusHistoryT *)soap_instantiate_ns1__CmStatusHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmStatusHistoryT, sizeof(ns1__CmStatusHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__GenericCountsHistoryT))
		soap_serialize_PointerTons1__GenericCountsHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT);
	if (soap_out_PointerToPointerTons1__GenericCountsHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, int id, ns1__GenericCountsHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__GenericCountsHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__GenericCountsHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__GenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GenericCountsHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, ns1__GenericCountsHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericCountsHistoryT ***)soap_malloc(soap, sizeof(ns1__GenericCountsHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__GenericCountsHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__GenericCountsHistoryT, sizeof(ns1__GenericCountsHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericCountsHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GenericCountsHistoryT);
	if (soap_out_PointerTons1__GenericCountsHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, int id, ns1__GenericCountsHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericCountsHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GenericCountsHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, ns1__GenericCountsHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericCountsHistoryT **)soap_malloc(soap, sizeof(ns1__GenericCountsHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericCountsHistoryT *)soap_instantiate_ns1__GenericCountsHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericCountsHistoryT, sizeof(ns1__GenericCountsHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__QueryStateT))
		soap_serialize_PointerTons1__QueryStateT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__QueryStateT);
	if (soap_out_PointerToPointerTons1__QueryStateT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__QueryStateT(struct soap *soap, const char *tag, int id, ns1__QueryStateT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__QueryStateT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__QueryStateT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__QueryStateT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__QueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__QueryStateT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__QueryStateT(struct soap *soap, const char *tag, ns1__QueryStateT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QueryStateT ***)soap_malloc(soap, sizeof(ns1__QueryStateT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__QueryStateT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__QueryStateT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__QueryStateT, sizeof(ns1__QueryStateT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QueryStateT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__QueryStateT);
	if (soap_out_PointerTons1__QueryStateT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QueryStateT(struct soap *soap, const char *tag, int id, ns1__QueryStateT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QueryStateT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__QueryStateT ** SOAP_FMAC4 soap_get_PointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__QueryStateT ** SOAP_FMAC4 soap_in_PointerTons1__QueryStateT(struct soap *soap, const char *tag, ns1__QueryStateT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QueryStateT **)soap_malloc(soap, sizeof(ns1__QueryStateT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QueryStateT *)soap_instantiate_ns1__QueryStateT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__QueryStateT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QueryStateT, sizeof(ns1__QueryStateT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ScrollPageT))
		soap_serialize_PointerTons1__ScrollPageT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ScrollPageT);
	if (soap_out_PointerToPointerTons1__ScrollPageT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ScrollPageT(struct soap *soap, const char *tag, int id, ns1__ScrollPageT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ScrollPageT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ScrollPageT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ScrollPageT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ScrollPageT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ScrollPageT(struct soap *soap, const char *tag, ns1__ScrollPageT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScrollPageT ***)soap_malloc(soap, sizeof(ns1__ScrollPageT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ScrollPageT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ScrollPageT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ScrollPageT, sizeof(ns1__ScrollPageT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScrollPageT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ScrollPageT);
	if (soap_out_PointerTons1__ScrollPageT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScrollPageT(struct soap *soap, const char *tag, int id, ns1__ScrollPageT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScrollPageT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ScrollPageT ** SOAP_FMAC4 soap_get_PointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ScrollPageT ** SOAP_FMAC4 soap_in_PointerTons1__ScrollPageT(struct soap *soap, const char *tag, ns1__ScrollPageT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScrollPageT **)soap_malloc(soap, sizeof(ns1__ScrollPageT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScrollPageT *)soap_instantiate_ns1__ScrollPageT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ScrollPageT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScrollPageT, sizeof(ns1__ScrollPageT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AlarmHistoryT))
		soap_serialize_PointerTons1__AlarmHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT);
	if (soap_out_PointerToPointerTons1__AlarmHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, int id, ns1__AlarmHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AlarmHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AlarmHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AlarmHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, ns1__AlarmHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmHistoryT ***)soap_malloc(soap, sizeof(ns1__AlarmHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AlarmHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AlarmHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AlarmHistoryT, sizeof(ns1__AlarmHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AlarmHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AlarmHistoryT);
	if (soap_out_PointerTons1__AlarmHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, int id, ns1__AlarmHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AlarmHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AlarmHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, ns1__AlarmHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmHistoryT **)soap_malloc(soap, sizeof(ns1__AlarmHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AlarmHistoryT *)soap_instantiate_ns1__AlarmHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AlarmHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AlarmHistoryT, sizeof(ns1__AlarmHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__HistoricalAlarmT))
		soap_serialize_PointerTons1__HistoricalAlarmT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT);
	if (soap_out_PointerToPointerTons1__HistoricalAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, int id, ns1__HistoricalAlarmT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__HistoricalAlarmT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__HistoricalAlarmT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__HistoricalAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HistoricalAlarmT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, ns1__HistoricalAlarmT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HistoricalAlarmT ***)soap_malloc(soap, sizeof(ns1__HistoricalAlarmT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__HistoricalAlarmT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__HistoricalAlarmT, sizeof(ns1__HistoricalAlarmT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CurrentAlarmT))
		soap_serialize_PointerTons1__CurrentAlarmT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT);
	if (soap_out_PointerToPointerTons1__CurrentAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, int id, ns1__CurrentAlarmT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CurrentAlarmT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CurrentAlarmT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CurrentAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CurrentAlarmT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, ns1__CurrentAlarmT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CurrentAlarmT ***)soap_malloc(soap, sizeof(ns1__CurrentAlarmT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CurrentAlarmT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CurrentAlarmT, sizeof(ns1__CurrentAlarmT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__EmtaT(struct soap *soap, ns1__EmtaT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__EmtaT))
		soap_serialize_PointerTons1__EmtaT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__EmtaT(struct soap *soap, ns1__EmtaT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__EmtaT);
	if (soap_out_PointerToPointerTons1__EmtaT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__EmtaT(struct soap *soap, const char *tag, int id, ns1__EmtaT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__EmtaT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__EmtaT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__EmtaT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__EmtaT(struct soap *soap, ns1__EmtaT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__EmtaT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__EmtaT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__EmtaT(struct soap *soap, const char *tag, ns1__EmtaT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EmtaT ***)soap_malloc(soap, sizeof(ns1__EmtaT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__EmtaT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__EmtaT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__EmtaT, sizeof(ns1__EmtaT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CableModemT(struct soap *soap, ns1__CableModemT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CableModemT))
		soap_serialize_PointerTons1__CableModemT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CableModemT(struct soap *soap, ns1__CableModemT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CableModemT);
	if (soap_out_PointerToPointerTons1__CableModemT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CableModemT(struct soap *soap, const char *tag, int id, ns1__CableModemT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CableModemT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CableModemT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CableModemT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CableModemT(struct soap *soap, ns1__CableModemT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CableModemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CableModemT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CableModemT(struct soap *soap, const char *tag, ns1__CableModemT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CableModemT ***)soap_malloc(soap, sizeof(ns1__CableModemT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CableModemT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CableModemT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CableModemT, sizeof(ns1__CableModemT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__HfcT(struct soap *soap, ns1__HfcT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__HfcT))
		soap_serialize_PointerTons1__HfcT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__HfcT(struct soap *soap, ns1__HfcT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__HfcT);
	if (soap_out_PointerToPointerTons1__HfcT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__HfcT(struct soap *soap, const char *tag, int id, ns1__HfcT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__HfcT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__HfcT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__HfcT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__HfcT(struct soap *soap, ns1__HfcT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__HfcT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__HfcT(struct soap *soap, const char *tag, ns1__HfcT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcT ***)soap_malloc(soap, sizeof(ns1__HfcT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__HfcT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__HfcT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__HfcT, sizeof(ns1__HfcT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcT(struct soap *soap, ns1__HfcT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcT(struct soap *soap, ns1__HfcT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcT);
	if (soap_out_PointerTons1__HfcT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcT(struct soap *soap, const char *tag, int id, ns1__HfcT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcT ** SOAP_FMAC4 soap_get_PointerTons1__HfcT(struct soap *soap, ns1__HfcT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcT ** SOAP_FMAC4 soap_in_PointerTons1__HfcT(struct soap *soap, const char *tag, ns1__HfcT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcT **)soap_malloc(soap, sizeof(ns1__HfcT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcT *)soap_instantiate_ns1__HfcT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcT, sizeof(ns1__HfcT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ChannelT(struct soap *soap, ns1__ChannelT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ChannelT))
		soap_serialize_PointerTons1__ChannelT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ChannelT(struct soap *soap, ns1__ChannelT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ChannelT);
	if (soap_out_PointerToPointerTons1__ChannelT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ChannelT(struct soap *soap, const char *tag, int id, ns1__ChannelT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ChannelT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ChannelT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ChannelT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ChannelT(struct soap *soap, ns1__ChannelT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ChannelT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ChannelT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ChannelT(struct soap *soap, const char *tag, ns1__ChannelT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChannelT ***)soap_malloc(soap, sizeof(ns1__ChannelT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ChannelT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ChannelT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ChannelT, sizeof(ns1__ChannelT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChannelT(struct soap *soap, ns1__ChannelT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChannelT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChannelT(struct soap *soap, ns1__ChannelT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChannelT);
	if (soap_out_PointerTons1__ChannelT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChannelT(struct soap *soap, const char *tag, int id, ns1__ChannelT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChannelT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ChannelT ** SOAP_FMAC4 soap_get_PointerTons1__ChannelT(struct soap *soap, ns1__ChannelT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChannelT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ChannelT ** SOAP_FMAC4 soap_in_PointerTons1__ChannelT(struct soap *soap, const char *tag, ns1__ChannelT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChannelT **)soap_malloc(soap, sizeof(ns1__ChannelT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ChannelT *)soap_instantiate_ns1__ChannelT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ChannelT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChannelT, sizeof(ns1__ChannelT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT))
		soap_serialize_PointerTons1__SnmpV2CAttributesT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT);
	if (soap_out_PointerToPointerTons1__SnmpV2CAttributesT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, int id, ns1__SnmpV2CAttributesT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SnmpV2CAttributesT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, ns1__SnmpV2CAttributesT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnmpV2CAttributesT ***)soap_malloc(soap, sizeof(ns1__SnmpV2CAttributesT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SnmpV2CAttributesT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SnmpV2CAttributesT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT, sizeof(ns1__SnmpV2CAttributesT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnmpV2CAttributesT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT);
	if (soap_out_PointerTons1__SnmpV2CAttributesT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, int id, ns1__SnmpV2CAttributesT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnmpV2CAttributesT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT ** SOAP_FMAC4 soap_get_PointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT ** SOAP_FMAC4 soap_in_PointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, ns1__SnmpV2CAttributesT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnmpV2CAttributesT **)soap_malloc(soap, sizeof(ns1__SnmpV2CAttributesT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnmpV2CAttributesT *)soap_instantiate_ns1__SnmpV2CAttributesT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SnmpV2CAttributesT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnmpV2CAttributesT, sizeof(ns1__SnmpV2CAttributesT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmtsT(struct soap *soap, ns1__CmtsT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmtsT))
		soap_serialize_PointerTons1__CmtsT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmtsT(struct soap *soap, ns1__CmtsT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmtsT);
	if (soap_out_PointerToPointerTons1__CmtsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmtsT(struct soap *soap, const char *tag, int id, ns1__CmtsT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmtsT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmtsT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmtsT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmtsT(struct soap *soap, ns1__CmtsT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmtsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmtsT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmtsT(struct soap *soap, const char *tag, ns1__CmtsT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmtsT ***)soap_malloc(soap, sizeof(ns1__CmtsT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmtsT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmtsT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmtsT, sizeof(ns1__CmtsT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmtsT(struct soap *soap, ns1__CmtsT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmtsT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmtsT(struct soap *soap, ns1__CmtsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmtsT);
	if (soap_out_PointerTons1__CmtsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmtsT(struct soap *soap, const char *tag, int id, ns1__CmtsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmtsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmtsT ** SOAP_FMAC4 soap_get_PointerTons1__CmtsT(struct soap *soap, ns1__CmtsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmtsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmtsT ** SOAP_FMAC4 soap_in_PointerTons1__CmtsT(struct soap *soap, const char *tag, ns1__CmtsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmtsT **)soap_malloc(soap, sizeof(ns1__CmtsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmtsT *)soap_instantiate_ns1__CmtsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmtsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmtsT, sizeof(ns1__CmtsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmsT(struct soap *soap, ns1__CmsT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmsT))
		soap_serialize_PointerTons1__CmsT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmsT(struct soap *soap, ns1__CmsT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmsT);
	if (soap_out_PointerToPointerTons1__CmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmsT(struct soap *soap, const char *tag, int id, ns1__CmsT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmsT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmsT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmsT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmsT(struct soap *soap, ns1__CmsT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmsT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmsT(struct soap *soap, const char *tag, ns1__CmsT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmsT ***)soap_malloc(soap, sizeof(ns1__CmsT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmsT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmsT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmsT, sizeof(ns1__CmsT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmsT(struct soap *soap, ns1__CmsT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmsT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmsT(struct soap *soap, ns1__CmsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmsT);
	if (soap_out_PointerTons1__CmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmsT(struct soap *soap, const char *tag, int id, ns1__CmsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmsT ** SOAP_FMAC4 soap_get_PointerTons1__CmsT(struct soap *soap, ns1__CmsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmsT ** SOAP_FMAC4 soap_in_PointerTons1__CmsT(struct soap *soap, const char *tag, ns1__CmsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmsT **)soap_malloc(soap, sizeof(ns1__CmsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmsT *)soap_instantiate_ns1__CmsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmsT, sizeof(ns1__CmsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__BladeT(struct soap *soap, ns1__BladeT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__BladeT))
		soap_serialize_PointerTons1__BladeT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__BladeT(struct soap *soap, ns1__BladeT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__BladeT);
	if (soap_out_PointerToPointerTons1__BladeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__BladeT(struct soap *soap, const char *tag, int id, ns1__BladeT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__BladeT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__BladeT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__BladeT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__BladeT(struct soap *soap, ns1__BladeT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__BladeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__BladeT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__BladeT(struct soap *soap, const char *tag, ns1__BladeT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BladeT ***)soap_malloc(soap, sizeof(ns1__BladeT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__BladeT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__BladeT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__BladeT, sizeof(ns1__BladeT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BladeT(struct soap *soap, ns1__BladeT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BladeT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BladeT(struct soap *soap, ns1__BladeT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BladeT);
	if (soap_out_PointerTons1__BladeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BladeT(struct soap *soap, const char *tag, int id, ns1__BladeT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BladeT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BladeT ** SOAP_FMAC4 soap_get_PointerTons1__BladeT(struct soap *soap, ns1__BladeT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BladeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__BladeT ** SOAP_FMAC4 soap_in_PointerTons1__BladeT(struct soap *soap, const char *tag, ns1__BladeT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BladeT **)soap_malloc(soap, sizeof(ns1__BladeT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BladeT *)soap_instantiate_ns1__BladeT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__BladeT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BladeT, sizeof(ns1__BladeT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MarketT(struct soap *soap, ns1__MarketT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MarketT))
		soap_serialize_PointerTons1__MarketT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MarketT(struct soap *soap, ns1__MarketT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MarketT);
	if (soap_out_PointerToPointerTons1__MarketT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MarketT(struct soap *soap, const char *tag, int id, ns1__MarketT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MarketT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MarketT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MarketT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MarketT(struct soap *soap, ns1__MarketT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MarketT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MarketT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MarketT(struct soap *soap, const char *tag, ns1__MarketT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketT ***)soap_malloc(soap, sizeof(ns1__MarketT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MarketT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MarketT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MarketT, sizeof(ns1__MarketT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MarketT(struct soap *soap, ns1__MarketT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MarketT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MarketT(struct soap *soap, ns1__MarketT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MarketT);
	if (soap_out_PointerTons1__MarketT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MarketT(struct soap *soap, const char *tag, int id, ns1__MarketT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MarketT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MarketT ** SOAP_FMAC4 soap_get_PointerTons1__MarketT(struct soap *soap, ns1__MarketT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MarketT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MarketT ** SOAP_FMAC4 soap_in_PointerTons1__MarketT(struct soap *soap, const char *tag, ns1__MarketT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketT **)soap_malloc(soap, sizeof(ns1__MarketT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MarketT *)soap_instantiate_ns1__MarketT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MarketT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MarketT, sizeof(ns1__MarketT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__RegionT(struct soap *soap, ns1__RegionT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__RegionT))
		soap_serialize_PointerTons1__RegionT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__RegionT(struct soap *soap, ns1__RegionT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__RegionT);
	if (soap_out_PointerToPointerTons1__RegionT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__RegionT(struct soap *soap, const char *tag, int id, ns1__RegionT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__RegionT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__RegionT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__RegionT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__RegionT(struct soap *soap, ns1__RegionT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__RegionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RegionT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__RegionT(struct soap *soap, const char *tag, ns1__RegionT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RegionT ***)soap_malloc(soap, sizeof(ns1__RegionT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__RegionT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__RegionT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__RegionT, sizeof(ns1__RegionT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RegionT(struct soap *soap, ns1__RegionT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RegionT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RegionT(struct soap *soap, ns1__RegionT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RegionT);
	if (soap_out_PointerTons1__RegionT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RegionT(struct soap *soap, const char *tag, int id, ns1__RegionT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RegionT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RegionT ** SOAP_FMAC4 soap_get_PointerTons1__RegionT(struct soap *soap, ns1__RegionT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RegionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RegionT ** SOAP_FMAC4 soap_in_PointerTons1__RegionT(struct soap *soap, const char *tag, ns1__RegionT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RegionT **)soap_malloc(soap, sizeof(ns1__RegionT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RegionT *)soap_instantiate_ns1__RegionT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__RegionT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RegionT, sizeof(ns1__RegionT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT);
	if (soap_out_PointerToArrayOfHistoricalAlarmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, int id, ArrayOfHistoricalAlarmsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfHistoricalAlarmsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT ** SOAP_FMAC4 soap_get_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfHistoricalAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT ** SOAP_FMAC4 soap_in_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, ArrayOfHistoricalAlarmsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfHistoricalAlarmsT **)soap_malloc(soap, sizeof(ArrayOfHistoricalAlarmsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfHistoricalAlarmsT *)soap_instantiate_ArrayOfHistoricalAlarmsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfHistoricalAlarmsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfHistoricalAlarmsT, sizeof(ArrayOfHistoricalAlarmsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCurrentAlarmsT);
	if (soap_out_PointerToArrayOfCurrentAlarmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, int id, ArrayOfCurrentAlarmsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCurrentAlarmsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT ** SOAP_FMAC4 soap_get_PointerToArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCurrentAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT ** SOAP_FMAC4 soap_in_PointerToArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, ArrayOfCurrentAlarmsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCurrentAlarmsT **)soap_malloc(soap, sizeof(ArrayOfCurrentAlarmsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCurrentAlarmsT *)soap_instantiate_ArrayOfCurrentAlarmsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfCurrentAlarmsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCurrentAlarmsT, sizeof(ArrayOfCurrentAlarmsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCmStatusSummaryT);
	if (soap_out_PointerToArrayOfCmStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, int id, ArrayOfCmStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCmStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT ** SOAP_FMAC4 soap_get_PointerToArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT ** SOAP_FMAC4 soap_in_PointerToArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, ArrayOfCmStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCmStatusSummaryT **)soap_malloc(soap, sizeof(ArrayOfCmStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCmStatusSummaryT *)soap_instantiate_ArrayOfCmStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfCmStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCmStatusSummaryT, sizeof(ArrayOfCmStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT);
	if (soap_out_PointerToArrayOfHfcStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, int id, ArrayOfHfcStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfHfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT ** SOAP_FMAC4 soap_get_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfHfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT ** SOAP_FMAC4 soap_in_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, ArrayOfHfcStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfHfcStatusSummaryT **)soap_malloc(soap, sizeof(ArrayOfHfcStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfHfcStatusSummaryT *)soap_instantiate_ArrayOfHfcStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfHfcStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfHfcStatusSummaryT, sizeof(ArrayOfHfcStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfQueryStateT);
	if (soap_out_PointerToArrayOfQueryStateT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfQueryStateT(struct soap *soap, const char *tag, int id, ArrayOfQueryStateT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfQueryStateT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfQueryStateT ** SOAP_FMAC4 soap_get_PointerToArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfQueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfQueryStateT ** SOAP_FMAC4 soap_in_PointerToArrayOfQueryStateT(struct soap *soap, const char *tag, ArrayOfQueryStateT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfQueryStateT **)soap_malloc(soap, sizeof(ArrayOfQueryStateT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfQueryStateT *)soap_instantiate_ArrayOfQueryStateT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfQueryStateT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfQueryStateT, sizeof(ArrayOfQueryStateT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT);
	if (soap_out_PointerToArrayOfMtaStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, int id, ArrayOfMtaStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT ** SOAP_FMAC4 soap_get_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfMtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT ** SOAP_FMAC4 soap_in_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, ArrayOfMtaStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfMtaStatusSummaryT **)soap_malloc(soap, sizeof(ArrayOfMtaStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfMtaStatusSummaryT *)soap_instantiate_ArrayOfMtaStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfMtaStatusSummaryT, sizeof(ArrayOfMtaStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StatusSummaryT);
	if (soap_out_PointerTons1__StatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StatusSummaryT(struct soap *soap, const char *tag, int id, ns1__StatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__StatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__StatusSummaryT(struct soap *soap, const char *tag, ns1__StatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StatusSummaryT **)soap_malloc(soap, sizeof(ns1__StatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StatusSummaryT *)soap_instantiate_ns1__StatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__StatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StatusSummaryT, sizeof(ns1__StatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AlarmTypeConfigT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AlarmTypeConfigT);
	if (soap_out_PointerTons1__AlarmTypeConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, int id, ns1__AlarmTypeConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT ** SOAP_FMAC4 soap_get_PointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmTypeConfigT ** SOAP_FMAC4 soap_in_PointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, ns1__AlarmTypeConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmTypeConfigT **)soap_malloc(soap, sizeof(ns1__AlarmTypeConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AlarmTypeConfigT *)soap_instantiate_ns1__AlarmTypeConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AlarmTypeConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AlarmTypeConfigT, sizeof(ns1__AlarmTypeConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT);
	if (soap_out_PointerToArrayOfAlarmTypeConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, int id, ArrayOfAlarmTypeConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT ** SOAP_FMAC4 soap_get_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT ** SOAP_FMAC4 soap_in_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, ArrayOfAlarmTypeConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfAlarmTypeConfigT **)soap_malloc(soap, sizeof(ArrayOfAlarmTypeConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfAlarmTypeConfigT *)soap_instantiate_ArrayOfAlarmTypeConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmTypeConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAlarmTypeConfigT, sizeof(ArrayOfAlarmTypeConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcPowerTresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcPowerTresholdT);
	if (soap_out_PointerTons1__HfcPowerTresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcPowerTresholdT(struct soap *soap, const char *tag, int id, ns1__HfcPowerTresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcPowerTresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT ** SOAP_FMAC4 soap_get_PointerTons1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcPowerTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcPowerTresholdT ** SOAP_FMAC4 soap_in_PointerTons1__HfcPowerTresholdT(struct soap *soap, const char *tag, ns1__HfcPowerTresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcPowerTresholdT **)soap_malloc(soap, sizeof(ns1__HfcPowerTresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcPowerTresholdT *)soap_instantiate_ns1__HfcPowerTresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcPowerTresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcPowerTresholdT, sizeof(ns1__HfcPowerTresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AggregateMtaTresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AggregateMtaTresholdT);
	if (soap_out_PointerTons1__AggregateMtaTresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AggregateMtaTresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateMtaTresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AggregateMtaTresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AggregateMtaTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AggregateMtaTresholdT(struct soap *soap, const char *tag, ns1__AggregateMtaTresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateMtaTresholdT **)soap_malloc(soap, sizeof(ns1__AggregateMtaTresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AggregateMtaTresholdT *)soap_instantiate_ns1__AggregateMtaTresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AggregateMtaTresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AggregateMtaTresholdT, sizeof(ns1__AggregateMtaTresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoakWindowT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoakWindowT);
	if (soap_out_PointerTons1__SoakWindowT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoakWindowT(struct soap *soap, const char *tag, int id, ns1__SoakWindowT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoakWindowT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoakWindowT ** SOAP_FMAC4 soap_get_PointerTons1__SoakWindowT(struct soap *soap, ns1__SoakWindowT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoakWindowT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SoakWindowT ** SOAP_FMAC4 soap_in_PointerTons1__SoakWindowT(struct soap *soap, const char *tag, ns1__SoakWindowT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoakWindowT **)soap_malloc(soap, sizeof(ns1__SoakWindowT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoakWindowT *)soap_instantiate_ns1__SoakWindowT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SoakWindowT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoakWindowT, sizeof(ns1__SoakWindowT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT);
	if (soap_out_PointerTons1__AggregateCmOfflineTresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateCmOfflineTresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AggregateCmOfflineTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, ns1__AggregateCmOfflineTresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateCmOfflineTresholdT **)soap_malloc(soap, sizeof(ns1__AggregateCmOfflineTresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AggregateCmOfflineTresholdT *)soap_instantiate_ns1__AggregateCmOfflineTresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AggregateCmOfflineTresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, sizeof(ns1__AggregateCmOfflineTresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT);
	if (soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, int id, ArrayOfAggregateStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT ** SOAP_FMAC4 soap_get_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT ** SOAP_FMAC4 soap_in_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAggregateStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfAggregateStatusThresholdT **)soap_malloc(soap, sizeof(ArrayOfAggregateStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfAggregateStatusThresholdT *)soap_instantiate_ArrayOfAggregateStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfAggregateStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, sizeof(ArrayOfAggregateStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT);
	if (soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, int id, ArrayOfAlarmStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT ** SOAP_FMAC4 soap_get_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT ** SOAP_FMAC4 soap_in_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAlarmStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfAlarmStatusThresholdT **)soap_malloc(soap, sizeof(ArrayOfAlarmStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfAlarmStatusThresholdT *)soap_instantiate_ArrayOfAlarmStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, sizeof(ArrayOfAlarmStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserRoleT(struct soap *soap, ns1__UserRoleT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserRoleT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserRoleT(struct soap *soap, ns1__UserRoleT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserRoleT);
	if (soap_out_PointerTons1__UserRoleT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserRoleT(struct soap *soap, const char *tag, int id, ns1__UserRoleT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserRoleT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UserRoleT ** SOAP_FMAC4 soap_get_PointerTons1__UserRoleT(struct soap *soap, ns1__UserRoleT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserRoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserRoleT ** SOAP_FMAC4 soap_in_PointerTons1__UserRoleT(struct soap *soap, const char *tag, ns1__UserRoleT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserRoleT **)soap_malloc(soap, sizeof(ns1__UserRoleT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UserRoleT *)soap_instantiate_ns1__UserRoleT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__UserRoleT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserRoleT, sizeof(ns1__UserRoleT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfOAPairT(struct soap *soap, ArrayOfOAPairT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfOAPairT(struct soap *soap, ArrayOfOAPairT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfOAPairT);
	if (soap_out_PointerToArrayOfOAPairT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfOAPairT(struct soap *soap, const char *tag, int id, ArrayOfOAPairT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfOAPairT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfOAPairT ** SOAP_FMAC4 soap_get_PointerToArrayOfOAPairT(struct soap *soap, ArrayOfOAPairT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfOAPairT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfOAPairT ** SOAP_FMAC4 soap_in_PointerToArrayOfOAPairT(struct soap *soap, const char *tag, ArrayOfOAPairT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfOAPairT **)soap_malloc(soap, sizeof(ArrayOfOAPairT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfOAPairT *)soap_instantiate_ArrayOfOAPairT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfOAPairT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfOAPairT, sizeof(ArrayOfOAPairT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CMSLineT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CMSLineT);
	if (soap_out_PointerTons1__CMSLineT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CMSLineT(struct soap *soap, const char *tag, int id, ns1__CMSLineT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CMSLineT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CMSLineT ** SOAP_FMAC4 soap_get_PointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CMSLineT ** SOAP_FMAC4 soap_in_PointerTons1__CMSLineT(struct soap *soap, const char *tag, ns1__CMSLineT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CMSLineT **)soap_malloc(soap, sizeof(ns1__CMSLineT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CMSLineT *)soap_instantiate_ns1__CMSLineT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CMSLineT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CMSLineT, sizeof(ns1__CMSLineT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEAbstractNameT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEAbstractNameT);
	if (soap_out_PointerTons1__CTEAbstractNameT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEAbstractNameT(struct soap *soap, const char *tag, int id, ns1__CTEAbstractNameT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEAbstractNameT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEAbstractNameT ** SOAP_FMAC4 soap_get_PointerTons1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEAbstractNameT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEAbstractNameT ** SOAP_FMAC4 soap_in_PointerTons1__CTEAbstractNameT(struct soap *soap, const char *tag, ns1__CTEAbstractNameT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEAbstractNameT **)soap_malloc(soap, sizeof(ns1__CTEAbstractNameT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEAbstractNameT *)soap_instantiate_ns1__CTEAbstractNameT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractNameT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEAbstractNameT, sizeof(ns1__CTEAbstractNameT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEAbstractMacT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEAbstractMacT);
	if (soap_out_PointerTons1__CTEAbstractMacT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEAbstractMacT(struct soap *soap, const char *tag, int id, ns1__CTEAbstractMacT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEAbstractMacT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEAbstractMacT ** SOAP_FMAC4 soap_get_PointerTons1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEAbstractMacT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEAbstractMacT ** SOAP_FMAC4 soap_in_PointerTons1__CTEAbstractMacT(struct soap *soap, const char *tag, ns1__CTEAbstractMacT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEAbstractMacT **)soap_malloc(soap, sizeof(ns1__CTEAbstractMacT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEAbstractMacT *)soap_instantiate_ns1__CTEAbstractMacT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractMacT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEAbstractMacT, sizeof(ns1__CTEAbstractMacT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTECustomerT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTECustomerT);
	if (soap_out_PointerTons1__CTECustomerT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTECustomerT(struct soap *soap, const char *tag, int id, ns1__CTECustomerT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTECustomerT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTECustomerT ** SOAP_FMAC4 soap_get_PointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTECustomerT ** SOAP_FMAC4 soap_in_PointerTons1__CTECustomerT(struct soap *soap, const char *tag, ns1__CTECustomerT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTECustomerT **)soap_malloc(soap, sizeof(ns1__CTECustomerT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTECustomerT *)soap_instantiate_ns1__CTECustomerT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTECustomerT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTECustomerT, sizeof(ns1__CTECustomerT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToshort(struct soap *soap, short *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToshort(struct soap *soap, short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToshort);
	if (soap_out_PointerToshort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToshort(struct soap *soap, const char *tag, int id, short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_short);
	if (id < 0)
		return soap->error;
	return soap_out_short(soap, tag, id, *a, type);
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_get_PointerToshort(struct soap *soap, short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToshort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_in_PointerToshort(struct soap *soap, const char *tag, short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (short **)soap_malloc(soap, sizeof(short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_short(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_short, sizeof(short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmPerformanceT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmPerformanceT);
	if (soap_out_PointerTons1__CmPerformanceT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmPerformanceT(struct soap *soap, const char *tag, int id, ns1__CmPerformanceT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmPerformanceT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmPerformanceT ** SOAP_FMAC4 soap_get_PointerTons1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmPerformanceT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmPerformanceT ** SOAP_FMAC4 soap_in_PointerTons1__CmPerformanceT(struct soap *soap, const char *tag, ns1__CmPerformanceT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmPerformanceT **)soap_malloc(soap, sizeof(ns1__CmPerformanceT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmPerformanceT *)soap_instantiate_ns1__CmPerformanceT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmPerformanceT, sizeof(ns1__CmPerformanceT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaPingStatusT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaPingStatusT);
	if (soap_out_PointerTons1__MtaPingStatusT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaPingStatusT(struct soap *soap, const char *tag, int id, ns1__MtaPingStatusT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaPingStatusT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaPingStatusT ** SOAP_FMAC4 soap_get_PointerTons1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaPingStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaPingStatusT ** SOAP_FMAC4 soap_in_PointerTons1__MtaPingStatusT(struct soap *soap, const char *tag, ns1__MtaPingStatusT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaPingStatusT **)soap_malloc(soap, sizeof(ns1__MtaPingStatusT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaPingStatusT *)soap_instantiate_ns1__MtaPingStatusT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaPingStatusT, sizeof(ns1__MtaPingStatusT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaProvStatusT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaProvStatusT);
	if (soap_out_PointerTons1__MtaProvStatusT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaProvStatusT(struct soap *soap, const char *tag, int id, ns1__MtaProvStatusT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaProvStatusT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaProvStatusT ** SOAP_FMAC4 soap_get_PointerTons1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaProvStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaProvStatusT ** SOAP_FMAC4 soap_in_PointerTons1__MtaProvStatusT(struct soap *soap, const char *tag, ns1__MtaProvStatusT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaProvStatusT **)soap_malloc(soap, sizeof(ns1__MtaProvStatusT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaProvStatusT *)soap_instantiate_ns1__MtaProvStatusT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaProvStatusT, sizeof(ns1__MtaProvStatusT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaAvailabilityT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaAvailabilityT);
	if (soap_out_PointerTons1__MtaAvailabilityT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaAvailabilityT(struct soap *soap, const char *tag, int id, ns1__MtaAvailabilityT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaAvailabilityT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityT ** SOAP_FMAC4 soap_get_PointerTons1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaAvailabilityT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaAvailabilityT ** SOAP_FMAC4 soap_in_PointerTons1__MtaAvailabilityT(struct soap *soap, const char *tag, ns1__MtaAvailabilityT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaAvailabilityT **)soap_malloc(soap, sizeof(ns1__MtaAvailabilityT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaAvailabilityT *)soap_instantiate_ns1__MtaAvailabilityT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaAvailabilityT, sizeof(ns1__MtaAvailabilityT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmStatusT(struct soap *soap, ns1__CmStatusT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmStatusT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmStatusT(struct soap *soap, ns1__CmStatusT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmStatusT);
	if (soap_out_PointerTons1__CmStatusT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmStatusT(struct soap *soap, const char *tag, int id, ns1__CmStatusT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmStatusT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmStatusT ** SOAP_FMAC4 soap_get_PointerTons1__CmStatusT(struct soap *soap, ns1__CmStatusT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusT ** SOAP_FMAC4 soap_in_PointerTons1__CmStatusT(struct soap *soap, const char *tag, ns1__CmStatusT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusT **)soap_malloc(soap, sizeof(ns1__CmStatusT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmStatusT *)soap_instantiate_ns1__CmStatusT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmStatusT, sizeof(ns1__CmStatusT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfScrollPageT);
	if (soap_out_PointerToArrayOfScrollPageT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfScrollPageT(struct soap *soap, const char *tag, int id, ArrayOfScrollPageT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfScrollPageT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfScrollPageT ** SOAP_FMAC4 soap_get_PointerToArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfScrollPageT ** SOAP_FMAC4 soap_in_PointerToArrayOfScrollPageT(struct soap *soap, const char *tag, ArrayOfScrollPageT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfScrollPageT **)soap_malloc(soap, sizeof(ArrayOfScrollPageT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfScrollPageT *)soap_instantiate_ArrayOfScrollPageT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfScrollPageT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfScrollPageT, sizeof(ArrayOfScrollPageT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ResultBatchT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ResultBatchT);
	if (soap_out_PointerTons1__ResultBatchT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ResultBatchT(struct soap *soap, const char *tag, int id, ns1__ResultBatchT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ResultBatchT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ResultBatchT ** SOAP_FMAC4 soap_get_PointerTons1__ResultBatchT(struct soap *soap, ns1__ResultBatchT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ResultBatchT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ResultBatchT ** SOAP_FMAC4 soap_in_PointerTons1__ResultBatchT(struct soap *soap, const char *tag, ns1__ResultBatchT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ResultBatchT **)soap_malloc(soap, sizeof(ns1__ResultBatchT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ResultBatchT *)soap_instantiate_ns1__ResultBatchT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ResultBatchT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ResultBatchT, sizeof(ns1__ResultBatchT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EmtaT(struct soap *soap, ns1__EmtaT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EmtaT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EmtaT(struct soap *soap, ns1__EmtaT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EmtaT);
	if (soap_out_PointerTons1__EmtaT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EmtaT(struct soap *soap, const char *tag, int id, ns1__EmtaT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EmtaT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EmtaT ** SOAP_FMAC4 soap_get_PointerTons1__EmtaT(struct soap *soap, ns1__EmtaT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EmtaT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__EmtaT ** SOAP_FMAC4 soap_in_PointerTons1__EmtaT(struct soap *soap, const char *tag, ns1__EmtaT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EmtaT **)soap_malloc(soap, sizeof(ns1__EmtaT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EmtaT *)soap_instantiate_ns1__EmtaT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__EmtaT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EmtaT, sizeof(ns1__EmtaT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CableModemT(struct soap *soap, ns1__CableModemT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CableModemT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CableModemT(struct soap *soap, ns1__CableModemT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CableModemT);
	if (soap_out_PointerTons1__CableModemT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CableModemT(struct soap *soap, const char *tag, int id, ns1__CableModemT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CableModemT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CableModemT ** SOAP_FMAC4 soap_get_PointerTons1__CableModemT(struct soap *soap, ns1__CableModemT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CableModemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CableModemT ** SOAP_FMAC4 soap_in_PointerTons1__CableModemT(struct soap *soap, const char *tag, ns1__CableModemT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CableModemT **)soap_malloc(soap, sizeof(ns1__CableModemT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CableModemT *)soap_instantiate_ns1__CableModemT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CableModemT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CableModemT, sizeof(ns1__CableModemT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HistoricalAlarmT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HistoricalAlarmT);
	if (soap_out_PointerTons1__HistoricalAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, int id, ns1__HistoricalAlarmT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HistoricalAlarmT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT ** SOAP_FMAC4 soap_get_PointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HistoricalAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HistoricalAlarmT ** SOAP_FMAC4 soap_in_PointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, ns1__HistoricalAlarmT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HistoricalAlarmT **)soap_malloc(soap, sizeof(ns1__HistoricalAlarmT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HistoricalAlarmT *)soap_instantiate_ns1__HistoricalAlarmT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HistoricalAlarmT, sizeof(ns1__HistoricalAlarmT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CurrentAlarmT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CurrentAlarmT);
	if (soap_out_PointerTons1__CurrentAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, int id, ns1__CurrentAlarmT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CurrentAlarmT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT ** SOAP_FMAC4 soap_get_PointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CurrentAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CurrentAlarmT ** SOAP_FMAC4 soap_in_PointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, ns1__CurrentAlarmT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CurrentAlarmT **)soap_malloc(soap, sizeof(ns1__CurrentAlarmT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CurrentAlarmT *)soap_instantiate_ns1__CurrentAlarmT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CurrentAlarmT, sizeof(ns1__CurrentAlarmT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AbstractAlarmT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AbstractAlarmT);
	if (soap_out_PointerTons1__AbstractAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AbstractAlarmT(struct soap *soap, const char *tag, int id, ns1__AbstractAlarmT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AbstractAlarmT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AbstractAlarmT ** SOAP_FMAC4 soap_get_PointerTons1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AbstractAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AbstractAlarmT ** SOAP_FMAC4 soap_in_PointerTons1__AbstractAlarmT(struct soap *soap, const char *tag, ns1__AbstractAlarmT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AbstractAlarmT **)soap_malloc(soap, sizeof(ns1__AbstractAlarmT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AbstractAlarmT *)soap_instantiate_ns1__AbstractAlarmT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AbstractAlarmT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AbstractAlarmT, sizeof(ns1__AbstractAlarmT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericCountsT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GenericCountsT);
	if (soap_out_PointerTons1__GenericCountsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericCountsT(struct soap *soap, const char *tag, int id, ns1__GenericCountsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericCountsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GenericCountsT ** SOAP_FMAC4 soap_get_PointerTons1__GenericCountsT(struct soap *soap, ns1__GenericCountsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericCountsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GenericCountsT ** SOAP_FMAC4 soap_in_PointerTons1__GenericCountsT(struct soap *soap, const char *tag, ns1__GenericCountsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericCountsT **)soap_malloc(soap, sizeof(ns1__GenericCountsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericCountsT *)soap_instantiate_ns1__GenericCountsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericCountsT, sizeof(ns1__GenericCountsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TopoHierarchyKeyT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TopoHierarchyKeyT);
	if (soap_out_PointerTons1__TopoHierarchyKeyT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TopoHierarchyKeyT(struct soap *soap, const char *tag, int id, ns1__TopoHierarchyKeyT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TopoHierarchyKeyT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT ** SOAP_FMAC4 soap_get_PointerTons1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TopoHierarchyKeyT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT ** SOAP_FMAC4 soap_in_PointerTons1__TopoHierarchyKeyT(struct soap *soap, const char *tag, ns1__TopoHierarchyKeyT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TopoHierarchyKeyT **)soap_malloc(soap, sizeof(ns1__TopoHierarchyKeyT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TopoHierarchyKeyT *)soap_instantiate_ns1__TopoHierarchyKeyT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__TopoHierarchyKeyT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TopoHierarchyKeyT, sizeof(ns1__TopoHierarchyKeyT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of CteServC.cpp */
