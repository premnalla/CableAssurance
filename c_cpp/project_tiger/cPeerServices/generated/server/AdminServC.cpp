/* AdminServC.cpp
   Generated by gSOAP 2.7.9c from include/AdminServices.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#include "AdminServH.h"

SOAP_SOURCE_STAMP("@(#) AdminServC.cpp ver 2.7.9c 2007-07-14 19:32:08 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->header)
	{	soap->part = SOAP_IN_HEADER;
		soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, NULL);
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", NULL, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (!soap->fault)
	{	soap->fault = soap_new_SOAP_ENV__Fault(soap, -1);
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = soap_new_SOAP_ENV__Code(soap, -1);
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = soap_new_SOAP_ENV__Reason(soap, -1);
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	soap_fault(soap);
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", NULL);
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (!soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = soap_new_SOAP_ENV__Code(soap, -1);
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)&soap->fault->faultstring;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 1)
	{	if (!soap->fault->detail)
		{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
		}
		return (const char**)&soap->fault->detail->__any;
	}
	if (!soap->fault->SOAP_ENV__Detail)
	{	soap->fault->SOAP_ENV__Detail = soap_new_SOAP_ENV__Detail(soap, -1);
		soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
	}
	return (const char**)&soap->fault->SOAP_ENV__Detail->__any;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	for (;;)
		if (!soap_getelement(soap, &t))
			if (soap->error || soap_ignore_element(soap))
				break;
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{
	if (soap_peek_element(soap))
		return NULL;
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_in_short(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__EventCategoryT:
		return soap_in_ns1__EventCategoryT(soap, NULL, NULL, "ns1:EventCategoryT");
	case SOAP_TYPE_ns1__EventTypeT:
		return soap_in_ns1__EventTypeT(soap, NULL, NULL, "ns1:EventTypeT");
	case SOAP_TYPE_ns1__ApplicationDomainTypeT:
		return soap_in_ns1__ApplicationDomainTypeT(soap, NULL, NULL, "ns1:ApplicationDomainTypeT");
	case SOAP_TYPE_ns1__UserAccessTypeT:
		return soap_in_ns1__UserAccessTypeT(soap, NULL, NULL, "ns1:UserAccessTypeT");
	case SOAP_TYPE_ns1__EndUserDeviceTypeT:
		return soap_in_ns1__EndUserDeviceTypeT(soap, NULL, NULL, "ns1:EndUserDeviceTypeT");
	case SOAP_TYPE_ns1__ChannelTypeT:
		return soap_in_ns1__ChannelTypeT(soap, NULL, NULL, "ns1:ChannelTypeT");
	case SOAP_TYPE_ns1__SnmpVersionT:
		return soap_in_ns1__SnmpVersionT(soap, NULL, NULL, "ns1:SnmpVersionT");
	case SOAP_TYPE_ns1__StatusColorT:
		return soap_in_ns1__StatusColorT(soap, NULL, NULL, "ns1:StatusColorT");
	case SOAP_TYPE_ns1__ResourceTypeT:
		return soap_in_ns1__ResourceTypeT(soap, NULL, NULL, "ns1:ResourceTypeT");
	case SOAP_TYPE_ns1__SystemTypeT:
		return soap_in_ns1__SystemTypeT(soap, NULL, NULL, "ns1:SystemTypeT");
	case SOAP_TYPE_ns1__EventMessageT:
		return soap_in_ns1__EventMessageT(soap, NULL, NULL, "ns1:EventMessageT");
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		return soap_in_ns1__HistoricalAlarmsRespT(soap, NULL, NULL, "ns1:HistoricalAlarmsRespT");
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		return soap_in_ns1__CurrentAlarmsRespT(soap, NULL, NULL, "ns1:CurrentAlarmsRespT");
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		return soap_in_ns1__CmStatusSummaryRespT(soap, NULL, NULL, "ns1:CmStatusSummaryRespT");
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		return soap_in_ns1__HfcStatusSummaryRespT(soap, NULL, NULL, "ns1:HfcStatusSummaryRespT");
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		return soap_in_ns1__MtaStatusSummaryRespT(soap, NULL, NULL, "ns1:MtaStatusSummaryRespT");
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		return soap_in_ArrayOfCmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		return soap_in_ns1__CmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		return soap_in_ArrayOfMtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		return soap_in_ns1__MtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		return soap_in_ArrayOfHfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		return soap_in_ns1__HfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__StatusSummaryT:
		return soap_in_ns1__StatusSummaryT(soap, NULL, NULL, "ns1:StatusSummaryT");
	case SOAP_TYPE_ns1__MtaDataT:
		return soap_in_ns1__MtaDataT(soap, NULL, NULL, "ns1:MtaDataT");
	case SOAP_TYPE_ns1__CmDataT:
		return soap_in_ns1__CmDataT(soap, NULL, NULL, "ns1:CmDataT");
	case SOAP_TYPE_ns1__CmtsCmDataT:
		return soap_in_ns1__CmtsCmDataT(soap, NULL, NULL, "ns1:CmtsCmDataT");
	case SOAP_TYPE_ns1__ConfigDownloadT:
		return soap_in_ns1__ConfigDownloadT(soap, NULL, NULL, "ns1:ConfigDownloadT");
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		return soap_in_ns1__CmPerformanceConfigT(soap, NULL, NULL, "ns1:CmPerformanceConfigT");
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		return soap_in_ns1__CmsAlarmConfigT(soap, NULL, NULL, "ns1:CmsAlarmConfigT");
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		return soap_in_ns1__CmtsAlarmConfigT(soap, NULL, NULL, "ns1:CmtsAlarmConfigT");
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		return soap_in_ns1__MtaAlarmConfigT(soap, NULL, NULL, "ns1:MtaAlarmConfigT");
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		return soap_in_ArrayOfAlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		return soap_in_ns1__AlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		return soap_in_ns1__HfcAlarmConfigT(soap, NULL, NULL, "ns1:HfcAlarmConfigT");
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		return soap_in_ns1__HfcPowerTresholdT(soap, NULL, NULL, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		return soap_in_ns1__AggregateMtaTresholdT(soap, NULL, NULL, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		return soap_in_ns1__AggregateCmOfflineTresholdT(soap, NULL, NULL, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_ns1__SoakWindowT:
		return soap_in_ns1__SoakWindowT(soap, NULL, NULL, "ns1:SoakWindowT");
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		return soap_in_ns1__CmsStatusThresholdT(soap, NULL, NULL, "ns1:CmsStatusThresholdT");
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		return soap_in_ns1__CmtsStatusThresholdT(soap, NULL, NULL, "ns1:CmtsStatusThresholdT");
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		return soap_in_ns1__ChannelStatusThresholdT(soap, NULL, NULL, "ns1:ChannelStatusThresholdT");
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		return soap_in_ns1__HfcStatusThresholdT(soap, NULL, NULL, "ns1:HfcStatusThresholdT");
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		return soap_in_ns1__MtaStatusThresholdT(soap, NULL, NULL, "ns1:MtaStatusThresholdT");
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		return soap_in_ArrayOfAggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		return soap_in_ns1__AggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		return soap_in_ArrayOfAlarmStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		return soap_in_ns1__AlarmBasedStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__PollingIntervalsT:
		return soap_in_ns1__PollingIntervalsT(soap, NULL, NULL, "ns1:PollingIntervalsT");
	case SOAP_TYPE_ArrayOfUserT:
		return soap_in_ArrayOfUserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_ns1__UserT:
		return soap_in_ns1__UserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_ArrayOfRoleT:
		return soap_in_ArrayOfRoleT(soap, NULL, NULL, "ns1:RoleT");
	case SOAP_TYPE_ns1__RoleT:
		return soap_in_ns1__RoleT(soap, NULL, NULL, "ns1:RoleT");
	case SOAP_TYPE_ArrayOfApplicationDomainT:
		return soap_in_ArrayOfApplicationDomainT(soap, NULL, NULL, "ns1:ApplicationDomainT");
	case SOAP_TYPE_ns1__ApplicationDomainT:
		return soap_in_ns1__ApplicationDomainT(soap, NULL, NULL, "ns1:ApplicationDomainT");
	case SOAP_TYPE_ArrayOfUserAccessT:
		return soap_in_ArrayOfUserAccessT(soap, NULL, NULL, "ns1:UserAccessT");
	case SOAP_TYPE_ns1__UserAccessT:
		return soap_in_ns1__UserAccessT(soap, NULL, NULL, "ns1:UserAccessT");
	case SOAP_TYPE_ns1__CMSResultT:
		return soap_in_ns1__CMSResultT(soap, NULL, NULL, "ns1:CMSResultT");
	case SOAP_TYPE_ArrayOfCMSLineT:
		return soap_in_ArrayOfCMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_ns1__CMSLineT:
		return soap_in_ns1__CMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		return soap_in_ArrayOfCTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ns1__CTEQueryInputT:
		return soap_in_ns1__CTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ArrayOfCTEDataT:
		return soap_in_ArrayOfCTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEDataT:
		return soap_in_ns1__CTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		return soap_in_ns1__CTEAbstractNameT(soap, NULL, NULL, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		return soap_in_ns1__CTEAbstractMacT(soap, NULL, NULL, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_ArrayOfCTECustomerT:
		return soap_in_ArrayOfCTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_ns1__CTECustomerT:
		return soap_in_ns1__CTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		return soap_in_ArrayOfCmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		return soap_in_ns1__CmCurrentPerformanceT(soap, NULL, NULL, "ns1:CmCurrentPerformanceT");
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		return soap_in_ns1__CmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmPerformanceT:
		return soap_in_ns1__CmPerformanceT(soap, NULL, NULL, "ns1:CmPerformanceT");
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		return soap_in_ArrayOfMtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		return soap_in_ns1__MtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusT:
		return soap_in_ns1__MtaPingStatusT(soap, NULL, NULL, "ns1:MtaPingStatusT");
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		return soap_in_ArrayOfMtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		return soap_in_ns1__MtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusT:
		return soap_in_ns1__MtaProvStatusT(soap, NULL, NULL, "ns1:MtaProvStatusT");
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		return soap_in_ArrayOfMtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		return soap_in_ns1__MtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		return soap_in_ns1__MtaAvailabilityT(soap, NULL, NULL, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		return soap_in_ArrayOfCmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		return soap_in_ns1__CmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusT:
		return soap_in_ns1__CmStatusT(soap, NULL, NULL, "ns1:CmStatusT");
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		return soap_in_ArrayOfGenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		return soap_in_ns1__GenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ArrayOfQueryStateT:
		return soap_in_ArrayOfQueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_ns1__QueryStateT:
		return soap_in_ns1__QueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_ArrayOfScrollPageT:
		return soap_in_ArrayOfScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__ScrollPageT:
		return soap_in_ns1__ScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		return soap_in_ns1__MappedEuDevicesT(soap, NULL, NULL, "ns1:MappedEuDevicesT");
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		return soap_in_ArrayOfAlarmHistoriesT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		return soap_in_ArrayOfHistoricalAlarmsT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		return soap_in_ArrayOfCurrentAlarmsT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ArrayOfEmtasT:
		return soap_in_ArrayOfEmtasT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_ArrayOfCableModemsT:
		return soap_in_ArrayOfCableModemsT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_ArrayOfHfcsT:
		return soap_in_ArrayOfHfcsT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_ArrayOfChannelsT:
		return soap_in_ArrayOfChannelsT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		return soap_in_ArrayOfSnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_ArrayOfCmtsesT:
		return soap_in_ArrayOfCmtsesT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_ArrayOfCmsesT:
		return soap_in_ArrayOfCmsesT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_ArrayOfBladesT:
		return soap_in_ArrayOfBladesT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_ArrayOfMarketsT:
		return soap_in_ArrayOfMarketsT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_ArrayOfRegionsT:
		return soap_in_ArrayOfRegionsT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_ns1__AlarmHistoryT:
		return soap_in_ns1__AlarmHistoryT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		return soap_in_ns1__HistoricalAlarmDetailsT(soap, NULL, NULL, "ns1:HistoricalAlarmDetailsT");
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		return soap_in_ns1__HistoricalAlarmT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		return soap_in_ns1__CurrentAlarmDetailsT(soap, NULL, NULL, "ns1:CurrentAlarmDetailsT");
	case SOAP_TYPE_ns1__CurrentAlarmT:
		return soap_in_ns1__CurrentAlarmT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ns1__AbstractAlarmT:
		return soap_in_ns1__AbstractAlarmT(soap, NULL, NULL, "ns1:AbstractAlarmT");
	case SOAP_TYPE_ns1__EmtaSecondaryT:
		return soap_in_ns1__EmtaSecondaryT(soap, NULL, NULL, "ns1:EmtaSecondaryT");
	case SOAP_TYPE_ns1__EmtaT:
		return soap_in_ns1__EmtaT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_ns1__CableModemT:
		return soap_in_ns1__CableModemT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_ns1__HfcT:
		return soap_in_ns1__HfcT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_ns1__ChannelT:
		return soap_in_ns1__ChannelT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_ns1__CmtsT:
		return soap_in_ns1__CmtsT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_ns1__CmsT:
		return soap_in_ns1__CmsT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_ns1__BladeT:
		return soap_in_ns1__BladeT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_ns1__MarketT:
		return soap_in_ns1__MarketT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_ns1__RegionT:
		return soap_in_ns1__RegionT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_ns1__LocalSystemT:
		return soap_in_ns1__LocalSystemT(soap, NULL, NULL, "ns1:LocalSystemT");
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		return soap_in_ns1__TopoHierarchyKeyT(soap, NULL, NULL, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_ns1__ResultBatchT:
		return soap_in_ns1__ResultBatchT(soap, NULL, NULL, "ns1:ResultBatchT");
	case SOAP_TYPE_ns1__InputTimeT:
		return soap_in_ns1__InputTimeT(soap, NULL, NULL, "ns1:InputTimeT");
	case SOAP_TYPE_ns1__GenericCountsT:
		return soap_in_ns1__GenericCountsT(soap, NULL, NULL, "ns1:GenericCountsT");
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		return soap_in_ns1__SnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_xsd__integer:
		return soap_in_xsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_std__string:
		return soap_in_std__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_adm__getConfig:
		return soap_in_adm__getConfig(soap, NULL, NULL, "adm:getConfig");
	case SOAP_TYPE_adm__getConfigResponse:
		return soap_in_adm__getConfigResponse(soap, NULL, NULL, "adm:getConfigResponse");
	case SOAP_TYPE_adm__downloadConfigFromParent:
		return soap_in_adm__downloadConfigFromParent(soap, NULL, NULL, "adm:downloadConfigFromParent");
	case SOAP_TYPE_adm__downloadConfigFromParentResponse:
		return soap_in_adm__downloadConfigFromParentResponse(soap, NULL, NULL, "adm:downloadConfigFromParentResponse");
	case SOAP_TYPE_adm__updateRole:
		return soap_in_adm__updateRole(soap, NULL, NULL, "adm:updateRole");
	case SOAP_TYPE_adm__updateRoleResponse:
		return soap_in_adm__updateRoleResponse(soap, NULL, NULL, "adm:updateRoleResponse");
	case SOAP_TYPE_adm__getRole:
		return soap_in_adm__getRole(soap, NULL, NULL, "adm:getRole");
	case SOAP_TYPE_adm__getRoleResponse:
		return soap_in_adm__getRoleResponse(soap, NULL, NULL, "adm:getRoleResponse");
	case SOAP_TYPE_adm__getRoles:
		return soap_in_adm__getRoles(soap, NULL, NULL, "adm:getRoles");
	case SOAP_TYPE_adm__getRolesResponse:
		return soap_in_adm__getRolesResponse(soap, NULL, NULL, "adm:getRolesResponse");
	case SOAP_TYPE_adm__updateUserPassword:
		return soap_in_adm__updateUserPassword(soap, NULL, NULL, "adm:updateUserPassword");
	case SOAP_TYPE_adm__updateUserPasswordResponse:
		return soap_in_adm__updateUserPasswordResponse(soap, NULL, NULL, "adm:updateUserPasswordResponse");
	case SOAP_TYPE_adm__updateUser:
		return soap_in_adm__updateUser(soap, NULL, NULL, "adm:updateUser");
	case SOAP_TYPE_adm__updateUserResponse:
		return soap_in_adm__updateUserResponse(soap, NULL, NULL, "adm:updateUserResponse");
	case SOAP_TYPE_adm__getUser:
		return soap_in_adm__getUser(soap, NULL, NULL, "adm:getUser");
	case SOAP_TYPE_adm__getUserResponse:
		return soap_in_adm__getUserResponse(soap, NULL, NULL, "adm:getUserResponse");
	case SOAP_TYPE_adm__getUsers:
		return soap_in_adm__getUsers(soap, NULL, NULL, "adm:getUsers");
	case SOAP_TYPE_adm__getUsersResponse:
		return soap_in_adm__getUsersResponse(soap, NULL, NULL, "adm:getUsersResponse");
	case SOAP_TYPE_adm__addUser:
		return soap_in_adm__addUser(soap, NULL, NULL, "adm:addUser");
	case SOAP_TYPE_adm__addUserResponse:
		return soap_in_adm__addUserResponse(soap, NULL, NULL, "adm:addUserResponse");
	case SOAP_TYPE_adm__updateCmPerfConfig:
		return soap_in_adm__updateCmPerfConfig(soap, NULL, NULL, "adm:updateCmPerfConfig");
	case SOAP_TYPE_adm__updateCmPerfConfigResponse:
		return soap_in_adm__updateCmPerfConfigResponse(soap, NULL, NULL, "adm:updateCmPerfConfigResponse");
	case SOAP_TYPE_adm__getCmPerfConfig:
		return soap_in_adm__getCmPerfConfig(soap, NULL, NULL, "adm:getCmPerfConfig");
	case SOAP_TYPE_adm__getCmPerfConfigResponse:
		return soap_in_adm__getCmPerfConfigResponse(soap, NULL, NULL, "adm:getCmPerfConfigResponse");
	case SOAP_TYPE_adm__deleteBlade:
		return soap_in_adm__deleteBlade(soap, NULL, NULL, "adm:deleteBlade");
	case SOAP_TYPE_adm__deleteBladeResponse:
		return soap_in_adm__deleteBladeResponse(soap, NULL, NULL, "adm:deleteBladeResponse");
	case SOAP_TYPE_adm__addBlade:
		return soap_in_adm__addBlade(soap, NULL, NULL, "adm:addBlade");
	case SOAP_TYPE_adm__addBladeResponse:
		return soap_in_adm__addBladeResponse(soap, NULL, NULL, "adm:addBladeResponse");
	case SOAP_TYPE_adm__updateBlade:
		return soap_in_adm__updateBlade(soap, NULL, NULL, "adm:updateBlade");
	case SOAP_TYPE_adm__updateBladeResponse:
		return soap_in_adm__updateBladeResponse(soap, NULL, NULL, "adm:updateBladeResponse");
	case SOAP_TYPE_adm__addMarket:
		return soap_in_adm__addMarket(soap, NULL, NULL, "adm:addMarket");
	case SOAP_TYPE_adm__addMarketResponse:
		return soap_in_adm__addMarketResponse(soap, NULL, NULL, "adm:addMarketResponse");
	case SOAP_TYPE_adm__updateMarket:
		return soap_in_adm__updateMarket(soap, NULL, NULL, "adm:updateMarket");
	case SOAP_TYPE_adm__updateMarketResponse:
		return soap_in_adm__updateMarketResponse(soap, NULL, NULL, "adm:updateMarketResponse");
	case SOAP_TYPE_adm__addRegion:
		return soap_in_adm__addRegion(soap, NULL, NULL, "adm:addRegion");
	case SOAP_TYPE_adm__addRegionResponse:
		return soap_in_adm__addRegionResponse(soap, NULL, NULL, "adm:addRegionResponse");
	case SOAP_TYPE_adm__updateRegion:
		return soap_in_adm__updateRegion(soap, NULL, NULL, "adm:updateRegion");
	case SOAP_TYPE_adm__updateRegionResponse:
		return soap_in_adm__updateRegionResponse(soap, NULL, NULL, "adm:updateRegionResponse");
	case SOAP_TYPE_adm__updateLocalSystem:
		return soap_in_adm__updateLocalSystem(soap, NULL, NULL, "adm:updateLocalSystem");
	case SOAP_TYPE_adm__updateLocalSystemResponse:
		return soap_in_adm__updateLocalSystemResponse(soap, NULL, NULL, "adm:updateLocalSystemResponse");
	case SOAP_TYPE_adm__updateCmsAlarmConfig:
		return soap_in_adm__updateCmsAlarmConfig(soap, NULL, NULL, "adm:updateCmsAlarmConfig");
	case SOAP_TYPE_adm__updateCmsAlarmConfigResponse:
		return soap_in_adm__updateCmsAlarmConfigResponse(soap, NULL, NULL, "adm:updateCmsAlarmConfigResponse");
	case SOAP_TYPE_adm__getCmsAlarmConfig:
		return soap_in_adm__getCmsAlarmConfig(soap, NULL, NULL, "adm:getCmsAlarmConfig");
	case SOAP_TYPE_adm__getCmsAlarmConfigResponse:
		return soap_in_adm__getCmsAlarmConfigResponse(soap, NULL, NULL, "adm:getCmsAlarmConfigResponse");
	case SOAP_TYPE_adm__updateCmtsAlarmConfig:
		return soap_in_adm__updateCmtsAlarmConfig(soap, NULL, NULL, "adm:updateCmtsAlarmConfig");
	case SOAP_TYPE_adm__updateCmtsAlarmConfigResponse:
		return soap_in_adm__updateCmtsAlarmConfigResponse(soap, NULL, NULL, "adm:updateCmtsAlarmConfigResponse");
	case SOAP_TYPE_adm__getCmtsAlarmConfig:
		return soap_in_adm__getCmtsAlarmConfig(soap, NULL, NULL, "adm:getCmtsAlarmConfig");
	case SOAP_TYPE_adm__getCmtsAlarmConfigResponse:
		return soap_in_adm__getCmtsAlarmConfigResponse(soap, NULL, NULL, "adm:getCmtsAlarmConfigResponse");
	case SOAP_TYPE_adm__updateHfcAlarmConfig:
		return soap_in_adm__updateHfcAlarmConfig(soap, NULL, NULL, "adm:updateHfcAlarmConfig");
	case SOAP_TYPE_adm__updateHfcAlarmConfigResponse:
		return soap_in_adm__updateHfcAlarmConfigResponse(soap, NULL, NULL, "adm:updateHfcAlarmConfigResponse");
	case SOAP_TYPE_adm__getHfcAlarmConfig:
		return soap_in_adm__getHfcAlarmConfig(soap, NULL, NULL, "adm:getHfcAlarmConfig");
	case SOAP_TYPE_adm__getHfcAlarmConfigResponse:
		return soap_in_adm__getHfcAlarmConfigResponse(soap, NULL, NULL, "adm:getHfcAlarmConfigResponse");
	case SOAP_TYPE_adm__updateMtaAlarmConfig:
		return soap_in_adm__updateMtaAlarmConfig(soap, NULL, NULL, "adm:updateMtaAlarmConfig");
	case SOAP_TYPE_adm__updateMtaAlarmConfigResponse:
		return soap_in_adm__updateMtaAlarmConfigResponse(soap, NULL, NULL, "adm:updateMtaAlarmConfigResponse");
	case SOAP_TYPE_adm__getMtaAlarmConfig:
		return soap_in_adm__getMtaAlarmConfig(soap, NULL, NULL, "adm:getMtaAlarmConfig");
	case SOAP_TYPE_adm__getMtaAlarmConfigResponse:
		return soap_in_adm__getMtaAlarmConfigResponse(soap, NULL, NULL, "adm:getMtaAlarmConfigResponse");
	case SOAP_TYPE_adm__updateCmsStatusThreshold:
		return soap_in_adm__updateCmsStatusThreshold(soap, NULL, NULL, "adm:updateCmsStatusThreshold");
	case SOAP_TYPE_adm__updateCmsStatusThresholdResponse:
		return soap_in_adm__updateCmsStatusThresholdResponse(soap, NULL, NULL, "adm:updateCmsStatusThresholdResponse");
	case SOAP_TYPE_adm__getCmsStatusThreshold:
		return soap_in_adm__getCmsStatusThreshold(soap, NULL, NULL, "adm:getCmsStatusThreshold");
	case SOAP_TYPE_adm__getCmsStatusThresholdResponse:
		return soap_in_adm__getCmsStatusThresholdResponse(soap, NULL, NULL, "adm:getCmsStatusThresholdResponse");
	case SOAP_TYPE_adm__updateCmtsStatusThreshold:
		return soap_in_adm__updateCmtsStatusThreshold(soap, NULL, NULL, "adm:updateCmtsStatusThreshold");
	case SOAP_TYPE_adm__updateCmtsStatusThresholdResponse:
		return soap_in_adm__updateCmtsStatusThresholdResponse(soap, NULL, NULL, "adm:updateCmtsStatusThresholdResponse");
	case SOAP_TYPE_adm__getCmtsStatusThreshold:
		return soap_in_adm__getCmtsStatusThreshold(soap, NULL, NULL, "adm:getCmtsStatusThreshold");
	case SOAP_TYPE_adm__getCmtsStatusThresholdResponse:
		return soap_in_adm__getCmtsStatusThresholdResponse(soap, NULL, NULL, "adm:getCmtsStatusThresholdResponse");
	case SOAP_TYPE_adm__updateChannelStatusThreshold:
		return soap_in_adm__updateChannelStatusThreshold(soap, NULL, NULL, "adm:updateChannelStatusThreshold");
	case SOAP_TYPE_adm__updateChannelStatusThresholdResponse:
		return soap_in_adm__updateChannelStatusThresholdResponse(soap, NULL, NULL, "adm:updateChannelStatusThresholdResponse");
	case SOAP_TYPE_adm__getChannelStatusThreshold:
		return soap_in_adm__getChannelStatusThreshold(soap, NULL, NULL, "adm:getChannelStatusThreshold");
	case SOAP_TYPE_adm__getChannelStatusThresholdResponse:
		return soap_in_adm__getChannelStatusThresholdResponse(soap, NULL, NULL, "adm:getChannelStatusThresholdResponse");
	case SOAP_TYPE_adm__updateHfcStatusThreshold:
		return soap_in_adm__updateHfcStatusThreshold(soap, NULL, NULL, "adm:updateHfcStatusThreshold");
	case SOAP_TYPE_adm__updateHfcStatusThresholdResponse:
		return soap_in_adm__updateHfcStatusThresholdResponse(soap, NULL, NULL, "adm:updateHfcStatusThresholdResponse");
	case SOAP_TYPE_adm__getHfcStatusThreshold:
		return soap_in_adm__getHfcStatusThreshold(soap, NULL, NULL, "adm:getHfcStatusThreshold");
	case SOAP_TYPE_adm__getHfcStatusThresholdResponse:
		return soap_in_adm__getHfcStatusThresholdResponse(soap, NULL, NULL, "adm:getHfcStatusThresholdResponse");
	case SOAP_TYPE_adm__updateMtaStatusThreshold:
		return soap_in_adm__updateMtaStatusThreshold(soap, NULL, NULL, "adm:updateMtaStatusThreshold");
	case SOAP_TYPE_adm__updateMtaStatusThresholdResponse:
		return soap_in_adm__updateMtaStatusThresholdResponse(soap, NULL, NULL, "adm:updateMtaStatusThresholdResponse");
	case SOAP_TYPE_adm__getMtaStatusThreshold:
		return soap_in_adm__getMtaStatusThreshold(soap, NULL, NULL, "adm:getMtaStatusThreshold");
	case SOAP_TYPE_adm__getMtaStatusThresholdResponse:
		return soap_in_adm__getMtaStatusThresholdResponse(soap, NULL, NULL, "adm:getMtaStatusThresholdResponse");
	case SOAP_TYPE_adm__updatePollingIntervals:
		return soap_in_adm__updatePollingIntervals(soap, NULL, NULL, "adm:updatePollingIntervals");
	case SOAP_TYPE_adm__updatePollingIntervalsResponse:
		return soap_in_adm__updatePollingIntervalsResponse(soap, NULL, NULL, "adm:updatePollingIntervalsResponse");
	case SOAP_TYPE_adm__getPollingIntervals:
		return soap_in_adm__getPollingIntervals(soap, NULL, NULL, "adm:getPollingIntervals");
	case SOAP_TYPE_adm__getPollingIntervalsResponse:
		return soap_in_adm__getPollingIntervalsResponse(soap, NULL, NULL, "adm:getPollingIntervalsResponse");
	case SOAP_TYPE_adm__deleteCms:
		return soap_in_adm__deleteCms(soap, NULL, NULL, "adm:deleteCms");
	case SOAP_TYPE_adm__deleteCmsResponse:
		return soap_in_adm__deleteCmsResponse(soap, NULL, NULL, "adm:deleteCmsResponse");
	case SOAP_TYPE_adm__addCms:
		return soap_in_adm__addCms(soap, NULL, NULL, "adm:addCms");
	case SOAP_TYPE_adm__addCmsResponse:
		return soap_in_adm__addCmsResponse(soap, NULL, NULL, "adm:addCmsResponse");
	case SOAP_TYPE_adm__updateCms:
		return soap_in_adm__updateCms(soap, NULL, NULL, "adm:updateCms");
	case SOAP_TYPE_adm__updateCmsResponse:
		return soap_in_adm__updateCmsResponse(soap, NULL, NULL, "adm:updateCmsResponse");
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes:
		return soap_in_adm__updateCmtsAllSnmpV2CAttributes(soap, NULL, NULL, "adm:updateCmtsAllSnmpV2CAttributes");
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse:
		return soap_in_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, NULL, NULL, "adm:updateCmtsAllSnmpV2CAttributesResponse");
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes:
		return soap_in_adm__addCmtsAllSnmpV2CAttributes(soap, NULL, NULL, "adm:addCmtsAllSnmpV2CAttributes");
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse:
		return soap_in_adm__addCmtsAllSnmpV2CAttributesResponse(soap, NULL, NULL, "adm:addCmtsAllSnmpV2CAttributesResponse");
	case SOAP_TYPE_adm__deleteCmts:
		return soap_in_adm__deleteCmts(soap, NULL, NULL, "adm:deleteCmts");
	case SOAP_TYPE_adm__deleteCmtsResponse:
		return soap_in_adm__deleteCmtsResponse(soap, NULL, NULL, "adm:deleteCmtsResponse");
	case SOAP_TYPE_adm__addCmts:
		return soap_in_adm__addCmts(soap, NULL, NULL, "adm:addCmts");
	case SOAP_TYPE_adm__addCmtsResponse:
		return soap_in_adm__addCmtsResponse(soap, NULL, NULL, "adm:addCmtsResponse");
	case SOAP_TYPE_adm__updateCmts:
		return soap_in_adm__updateCmts(soap, NULL, NULL, "adm:updateCmts");
	case SOAP_TYPE_adm__updateCmtsResponse:
		return soap_in_adm__updateCmtsResponse(soap, NULL, NULL, "adm:updateCmtsResponse");
	case SOAP_TYPE_PointerTons1__ConfigDownloadT:
		return soap_in_PointerTons1__ConfigDownloadT(soap, NULL, NULL, "ns1:ConfigDownloadT");
	case SOAP_TYPE_PointerTons1__LocalSystemT:
		return soap_in_PointerTons1__LocalSystemT(soap, NULL, NULL, "ns1:LocalSystemT");
	case SOAP_TYPE_PointerTons1__CmsStatusThresholdT:
		return soap_in_PointerTons1__CmsStatusThresholdT(soap, NULL, NULL, "ns1:CmsStatusThresholdT");
	case SOAP_TYPE_PointerTons1__CmtsStatusThresholdT:
		return soap_in_PointerTons1__CmtsStatusThresholdT(soap, NULL, NULL, "ns1:CmtsStatusThresholdT");
	case SOAP_TYPE_PointerTons1__ChannelStatusThresholdT:
		return soap_in_PointerTons1__ChannelStatusThresholdT(soap, NULL, NULL, "ns1:ChannelStatusThresholdT");
	case SOAP_TYPE_PointerTons1__HfcStatusThresholdT:
		return soap_in_PointerTons1__HfcStatusThresholdT(soap, NULL, NULL, "ns1:HfcStatusThresholdT");
	case SOAP_TYPE_PointerTons1__MtaStatusThresholdT:
		return soap_in_PointerTons1__MtaStatusThresholdT(soap, NULL, NULL, "ns1:MtaStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfSnmpV2CAttributesT:
		return soap_in_PointerToArrayOfSnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT:
		return soap_in_PointerToPointerTons1__CmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerTons1__CmStatusSummaryT:
		return soap_in_PointerTons1__CmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT:
		return soap_in_PointerToPointerTons1__MtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__MtaStatusSummaryT:
		return soap_in_PointerTons1__MtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT:
		return soap_in_PointerToPointerTons1__HfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerTons1__HfcStatusSummaryT:
		return soap_in_PointerTons1__HfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT:
		return soap_in_PointerToPointerTons1__AlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT:
		return soap_in_PointerToPointerTons1__AggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AggregateStatusThresholdT:
		return soap_in_PointerTons1__AggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT:
		return soap_in_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT:
		return soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__UserT:
		return soap_in_PointerToPointerTons1__UserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_PointerTons1__UserT:
		return soap_in_PointerTons1__UserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_PointerToPointerTons1__RoleT:
		return soap_in_PointerToPointerTons1__RoleT(soap, NULL, NULL, "ns1:RoleT");
	case SOAP_TYPE_PointerTons1__RoleT:
		return soap_in_PointerTons1__RoleT(soap, NULL, NULL, "ns1:RoleT");
	case SOAP_TYPE_PointerToPointerTons1__ApplicationDomainT:
		return soap_in_PointerToPointerTons1__ApplicationDomainT(soap, NULL, NULL, "ns1:ApplicationDomainT");
	case SOAP_TYPE_PointerTons1__ApplicationDomainT:
		return soap_in_PointerTons1__ApplicationDomainT(soap, NULL, NULL, "ns1:ApplicationDomainT");
	case SOAP_TYPE_PointerToPointerTons1__UserAccessT:
		return soap_in_PointerToPointerTons1__UserAccessT(soap, NULL, NULL, "ns1:UserAccessT");
	case SOAP_TYPE_PointerTons1__UserAccessT:
		return soap_in_PointerTons1__UserAccessT(soap, NULL, NULL, "ns1:UserAccessT");
	case SOAP_TYPE_PointerToPointerTons1__CMSLineT:
		return soap_in_PointerToPointerTons1__CMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT:
		return soap_in_PointerToPointerTons1__CTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerTons1__CTEQueryInputT:
		return soap_in_PointerTons1__CTEQueryInputT(soap, NULL, NULL, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerToPointerTons1__CTEDataT:
		return soap_in_PointerToPointerTons1__CTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_PointerTons1__CTEDataT:
		return soap_in_PointerTons1__CTEDataT(soap, NULL, NULL, "ns1:CTEDataT");
	case SOAP_TYPE_PointerToPointerTons1__CTECustomerT:
		return soap_in_PointerToPointerTons1__CTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT:
		return soap_in_PointerToPointerTons1__CmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerTons1__CmPerformanceHistoryT:
		return soap_in_PointerTons1__CmPerformanceHistoryT(soap, NULL, NULL, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT:
		return soap_in_PointerToPointerTons1__MtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT:
		return soap_in_PointerTons1__MtaPingStatusHistoryT(soap, NULL, NULL, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT:
		return soap_in_PointerToPointerTons1__MtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT:
		return soap_in_PointerTons1__MtaProvStatusHistoryT(soap, NULL, NULL, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT:
		return soap_in_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT:
		return soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, NULL, NULL, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT:
		return soap_in_PointerToPointerTons1__CmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerTons1__CmStatusHistoryT:
		return soap_in_PointerTons1__CmStatusHistoryT(soap, NULL, NULL, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT:
		return soap_in_PointerToPointerTons1__GenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerTons1__GenericCountsHistoryT:
		return soap_in_PointerTons1__GenericCountsHistoryT(soap, NULL, NULL, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__QueryStateT:
		return soap_in_PointerToPointerTons1__QueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_PointerTons1__QueryStateT:
		return soap_in_PointerTons1__QueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToPointerTons1__ScrollPageT:
		return soap_in_PointerToPointerTons1__ScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ScrollPageT:
		return soap_in_PointerTons1__ScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT:
		return soap_in_PointerToPointerTons1__AlarmHistoryT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerTons1__AlarmHistoryT:
		return soap_in_PointerTons1__AlarmHistoryT(soap, NULL, NULL, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT:
		return soap_in_PointerToPointerTons1__HistoricalAlarmT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT:
		return soap_in_PointerToPointerTons1__CurrentAlarmT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__EmtaT:
		return soap_in_PointerToPointerTons1__EmtaT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_PointerToPointerTons1__CableModemT:
		return soap_in_PointerToPointerTons1__CableModemT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_PointerToPointerTons1__HfcT:
		return soap_in_PointerToPointerTons1__HfcT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_PointerTons1__HfcT:
		return soap_in_PointerTons1__HfcT(soap, NULL, NULL, "ns1:HfcT");
	case SOAP_TYPE_PointerToPointerTons1__ChannelT:
		return soap_in_PointerToPointerTons1__ChannelT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_PointerTons1__ChannelT:
		return soap_in_PointerTons1__ChannelT(soap, NULL, NULL, "ns1:ChannelT");
	case SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT:
		return soap_in_PointerToPointerTons1__SnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerTons1__SnmpV2CAttributesT:
		return soap_in_PointerTons1__SnmpV2CAttributesT(soap, NULL, NULL, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerToPointerTons1__CmtsT:
		return soap_in_PointerToPointerTons1__CmtsT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_PointerTons1__CmtsT:
		return soap_in_PointerTons1__CmtsT(soap, NULL, NULL, "ns1:CmtsT");
	case SOAP_TYPE_PointerToPointerTons1__CmsT:
		return soap_in_PointerToPointerTons1__CmsT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_PointerTons1__CmsT:
		return soap_in_PointerTons1__CmsT(soap, NULL, NULL, "ns1:CmsT");
	case SOAP_TYPE_PointerToPointerTons1__BladeT:
		return soap_in_PointerToPointerTons1__BladeT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_PointerTons1__BladeT:
		return soap_in_PointerTons1__BladeT(soap, NULL, NULL, "ns1:BladeT");
	case SOAP_TYPE_PointerToPointerTons1__MarketT:
		return soap_in_PointerToPointerTons1__MarketT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_PointerTons1__MarketT:
		return soap_in_PointerTons1__MarketT(soap, NULL, NULL, "ns1:MarketT");
	case SOAP_TYPE_PointerToPointerTons1__RegionT:
		return soap_in_PointerToPointerTons1__RegionT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_PointerTons1__RegionT:
		return soap_in_PointerTons1__RegionT(soap, NULL, NULL, "ns1:RegionT");
	case SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT:
		return soap_in_PointerToArrayOfHistoricalAlarmsT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToArrayOfCurrentAlarmsT:
		return soap_in_PointerToArrayOfCurrentAlarmsT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToArrayOfCmStatusSummaryT:
		return soap_in_PointerToArrayOfCmStatusSummaryT(soap, NULL, NULL, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT:
		return soap_in_PointerToArrayOfHfcStatusSummaryT(soap, NULL, NULL, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfQueryStateT:
		return soap_in_PointerToArrayOfQueryStateT(soap, NULL, NULL, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT:
		return soap_in_PointerToArrayOfMtaStatusSummaryT(soap, NULL, NULL, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__StatusSummaryT:
		return soap_in_PointerTons1__StatusSummaryT(soap, NULL, NULL, "ns1:StatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfUserT:
		return soap_in_PointerToArrayOfUserT(soap, NULL, NULL, "ns1:UserT");
	case SOAP_TYPE_PointerToArrayOfRoleT:
		return soap_in_PointerToArrayOfRoleT(soap, NULL, NULL, "ns1:RoleT");
	case SOAP_TYPE_PointerTons1__PollingIntervalsT:
		return soap_in_PointerTons1__PollingIntervalsT(soap, NULL, NULL, "ns1:PollingIntervalsT");
	case SOAP_TYPE_PointerTons1__HfcAlarmConfigT:
		return soap_in_PointerTons1__HfcAlarmConfigT(soap, NULL, NULL, "ns1:HfcAlarmConfigT");
	case SOAP_TYPE_PointerTons1__MtaAlarmConfigT:
		return soap_in_PointerTons1__MtaAlarmConfigT(soap, NULL, NULL, "ns1:MtaAlarmConfigT");
	case SOAP_TYPE_PointerTons1__CmtsAlarmConfigT:
		return soap_in_PointerTons1__CmtsAlarmConfigT(soap, NULL, NULL, "ns1:CmtsAlarmConfigT");
	case SOAP_TYPE_PointerTons1__CmsAlarmConfigT:
		return soap_in_PointerTons1__CmsAlarmConfigT(soap, NULL, NULL, "ns1:CmsAlarmConfigT");
	case SOAP_TYPE_PointerTons1__CmPerformanceConfigT:
		return soap_in_PointerTons1__CmPerformanceConfigT(soap, NULL, NULL, "ns1:CmPerformanceConfigT");
	case SOAP_TYPE_PointerTons1__AlarmTypeConfigT:
		return soap_in_PointerTons1__AlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT:
		return soap_in_PointerToArrayOfAlarmTypeConfigT(soap, NULL, NULL, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerTons1__HfcPowerTresholdT:
		return soap_in_PointerTons1__HfcPowerTresholdT(soap, NULL, NULL, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_PointerTons1__AggregateMtaTresholdT:
		return soap_in_PointerTons1__AggregateMtaTresholdT(soap, NULL, NULL, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_PointerTons1__SoakWindowT:
		return soap_in_PointerTons1__SoakWindowT(soap, NULL, NULL, "ns1:SoakWindowT");
	case SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT:
		return soap_in_PointerTons1__AggregateCmOfflineTresholdT(soap, NULL, NULL, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT:
		return soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, NULL, NULL, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT:
		return soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, NULL, NULL, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfApplicationDomainT:
		return soap_in_PointerToArrayOfApplicationDomainT(soap, NULL, NULL, "ns1:ApplicationDomainT");
	case SOAP_TYPE_PointerToArrayOfUserAccessT:
		return soap_in_PointerToArrayOfUserAccessT(soap, NULL, NULL, "ns1:UserAccessT");
	case SOAP_TYPE_PointerTons1__CMSLineT:
		return soap_in_PointerTons1__CMSLineT(soap, NULL, NULL, "ns1:CMSLineT");
	case SOAP_TYPE_PointerTons1__CTEAbstractNameT:
		return soap_in_PointerTons1__CTEAbstractNameT(soap, NULL, NULL, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_PointerTons1__CTEAbstractMacT:
		return soap_in_PointerTons1__CTEAbstractMacT(soap, NULL, NULL, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_PointerTons1__CTECustomerT:
		return soap_in_PointerTons1__CTECustomerT(soap, NULL, NULL, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToshort:
		return soap_in_PointerToshort(soap, NULL, NULL, "xsd:short");
	case SOAP_TYPE_PointerTons1__CmPerformanceT:
		return soap_in_PointerTons1__CmPerformanceT(soap, NULL, NULL, "ns1:CmPerformanceT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusT:
		return soap_in_PointerTons1__MtaPingStatusT(soap, NULL, NULL, "ns1:MtaPingStatusT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusT:
		return soap_in_PointerTons1__MtaProvStatusT(soap, NULL, NULL, "ns1:MtaProvStatusT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityT:
		return soap_in_PointerTons1__MtaAvailabilityT(soap, NULL, NULL, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_PointerTons1__CmStatusT:
		return soap_in_PointerTons1__CmStatusT(soap, NULL, NULL, "ns1:CmStatusT");
	case SOAP_TYPE_PointerToArrayOfScrollPageT:
		return soap_in_PointerToArrayOfScrollPageT(soap, NULL, NULL, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ResultBatchT:
		return soap_in_PointerTons1__ResultBatchT(soap, NULL, NULL, "ns1:ResultBatchT");
	case SOAP_TYPE_PointerTons1__EmtaT:
		return soap_in_PointerTons1__EmtaT(soap, NULL, NULL, "ns1:EmtaT");
	case SOAP_TYPE_PointerTons1__CableModemT:
		return soap_in_PointerTons1__CableModemT(soap, NULL, NULL, "ns1:CableModemT");
	case SOAP_TYPE_PointerTons1__HistoricalAlarmT:
		return soap_in_PointerTons1__HistoricalAlarmT(soap, NULL, NULL, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerTons1__CurrentAlarmT:
		return soap_in_PointerTons1__CurrentAlarmT(soap, NULL, NULL, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerTons1__AbstractAlarmT:
		return soap_in_PointerTons1__AbstractAlarmT(soap, NULL, NULL, "ns1:AbstractAlarmT");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_in_PointerToxsd__integer(soap, NULL, NULL, "xsd:integer");
	case SOAP_TYPE_PointerTons1__GenericCountsT:
		return soap_in_PointerTons1__GenericCountsT(soap, NULL, NULL, "ns1:GenericCountsT");
	case SOAP_TYPE_PointerTons1__TopoHierarchyKeyT:
		return soap_in_PointerTons1__TopoHierarchyKeyT(soap, NULL, NULL, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_PointerTostd__string:
		return soap_in_PointerTostd__string(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:short"))
		{	*type = SOAP_TYPE_short;
			return soap_in_short(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EventCategoryT"))
		{	*type = SOAP_TYPE_ns1__EventCategoryT;
			return soap_in_ns1__EventCategoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EventTypeT"))
		{	*type = SOAP_TYPE_ns1__EventTypeT;
			return soap_in_ns1__EventTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApplicationDomainTypeT"))
		{	*type = SOAP_TYPE_ns1__ApplicationDomainTypeT;
			return soap_in_ns1__ApplicationDomainTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserAccessTypeT"))
		{	*type = SOAP_TYPE_ns1__UserAccessTypeT;
			return soap_in_ns1__UserAccessTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EndUserDeviceTypeT"))
		{	*type = SOAP_TYPE_ns1__EndUserDeviceTypeT;
			return soap_in_ns1__EndUserDeviceTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChannelTypeT"))
		{	*type = SOAP_TYPE_ns1__ChannelTypeT;
			return soap_in_ns1__ChannelTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnmpVersionT"))
		{	*type = SOAP_TYPE_ns1__SnmpVersionT;
			return soap_in_ns1__SnmpVersionT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatusColorT"))
		{	*type = SOAP_TYPE_ns1__StatusColorT;
			return soap_in_ns1__StatusColorT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResourceTypeT"))
		{	*type = SOAP_TYPE_ns1__ResourceTypeT;
			return soap_in_ns1__ResourceTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SystemTypeT"))
		{	*type = SOAP_TYPE_ns1__SystemTypeT;
			return soap_in_ns1__SystemTypeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EventMessageT"))
		{	*type = SOAP_TYPE_ns1__EventMessageT;
			return soap_in_ns1__EventMessageT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistoricalAlarmsRespT"))
		{	*type = SOAP_TYPE_ns1__HistoricalAlarmsRespT;
			return soap_in_ns1__HistoricalAlarmsRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CurrentAlarmsRespT"))
		{	*type = SOAP_TYPE_ns1__CurrentAlarmsRespT;
			return soap_in_ns1__CurrentAlarmsRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusSummaryRespT"))
		{	*type = SOAP_TYPE_ns1__CmStatusSummaryRespT;
			return soap_in_ns1__CmStatusSummaryRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcStatusSummaryRespT"))
		{	*type = SOAP_TYPE_ns1__HfcStatusSummaryRespT;
			return soap_in_ns1__HfcStatusSummaryRespT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaStatusSummaryRespT"))
		{	*type = SOAP_TYPE_ns1__MtaStatusSummaryRespT;
			return soap_in_ns1__MtaStatusSummaryRespT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmStatusSummaryT"))
		{	*type = SOAP_TYPE_ArrayOfCmStatusSummaryT;
			return soap_in_ArrayOfCmStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__CmStatusSummaryT;
			return soap_in_ns1__CmStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaStatusSummaryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaStatusSummaryT;
			return soap_in_ArrayOfMtaStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaStatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__MtaStatusSummaryT;
			return soap_in_ns1__MtaStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:HfcStatusSummaryT"))
		{	*type = SOAP_TYPE_ArrayOfHfcStatusSummaryT;
			return soap_in_ArrayOfHfcStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcStatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__HfcStatusSummaryT;
			return soap_in_ns1__HfcStatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:StatusSummaryT"))
		{	*type = SOAP_TYPE_ns1__StatusSummaryT;
			return soap_in_ns1__StatusSummaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaDataT"))
		{	*type = SOAP_TYPE_ns1__MtaDataT;
			return soap_in_ns1__MtaDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmDataT"))
		{	*type = SOAP_TYPE_ns1__CmDataT;
			return soap_in_ns1__CmDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsCmDataT"))
		{	*type = SOAP_TYPE_ns1__CmtsCmDataT;
			return soap_in_ns1__CmtsCmDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ConfigDownloadT"))
		{	*type = SOAP_TYPE_ns1__ConfigDownloadT;
			return soap_in_ns1__ConfigDownloadT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmPerformanceConfigT"))
		{	*type = SOAP_TYPE_ns1__CmPerformanceConfigT;
			return soap_in_ns1__CmPerformanceConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmsAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__CmsAlarmConfigT;
			return soap_in_ns1__CmsAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__CmtsAlarmConfigT;
			return soap_in_ns1__CmtsAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__MtaAlarmConfigT;
			return soap_in_ns1__MtaAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AlarmTypeConfigT"))
		{	*type = SOAP_TYPE_ArrayOfAlarmTypeConfigT;
			return soap_in_ArrayOfAlarmTypeConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmTypeConfigT"))
		{	*type = SOAP_TYPE_ns1__AlarmTypeConfigT;
			return soap_in_ns1__AlarmTypeConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcAlarmConfigT"))
		{	*type = SOAP_TYPE_ns1__HfcAlarmConfigT;
			return soap_in_ns1__HfcAlarmConfigT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcPowerTresholdT"))
		{	*type = SOAP_TYPE_ns1__HfcPowerTresholdT;
			return soap_in_ns1__HfcPowerTresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AggregateMtaTresholdT"))
		{	*type = SOAP_TYPE_ns1__AggregateMtaTresholdT;
			return soap_in_ns1__AggregateMtaTresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AggregateCmOfflineTresholdT"))
		{	*type = SOAP_TYPE_ns1__AggregateCmOfflineTresholdT;
			return soap_in_ns1__AggregateCmOfflineTresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoakWindowT"))
		{	*type = SOAP_TYPE_ns1__SoakWindowT;
			return soap_in_ns1__SoakWindowT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmsStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__CmsStatusThresholdT;
			return soap_in_ns1__CmsStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__CmtsStatusThresholdT;
			return soap_in_ns1__CmtsStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChannelStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__ChannelStatusThresholdT;
			return soap_in_ns1__ChannelStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__HfcStatusThresholdT;
			return soap_in_ns1__HfcStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__MtaStatusThresholdT;
			return soap_in_ns1__MtaStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AggregateStatusThresholdT"))
		{	*type = SOAP_TYPE_ArrayOfAggregateStatusThresholdT;
			return soap_in_ArrayOfAggregateStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AggregateStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__AggregateStatusThresholdT;
			return soap_in_ns1__AggregateStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AlarmBasedStatusThresholdT"))
		{	*type = SOAP_TYPE_ArrayOfAlarmStatusThresholdT;
			return soap_in_ArrayOfAlarmStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmBasedStatusThresholdT"))
		{	*type = SOAP_TYPE_ns1__AlarmBasedStatusThresholdT;
			return soap_in_ns1__AlarmBasedStatusThresholdT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:PollingIntervalsT"))
		{	*type = SOAP_TYPE_ns1__PollingIntervalsT;
			return soap_in_ns1__PollingIntervalsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:UserT"))
		{	*type = SOAP_TYPE_ArrayOfUserT;
			return soap_in_ArrayOfUserT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserT"))
		{	*type = SOAP_TYPE_ns1__UserT;
			return soap_in_ns1__UserT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:RoleT"))
		{	*type = SOAP_TYPE_ArrayOfRoleT;
			return soap_in_ArrayOfRoleT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RoleT"))
		{	*type = SOAP_TYPE_ns1__RoleT;
			return soap_in_ns1__RoleT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ApplicationDomainT"))
		{	*type = SOAP_TYPE_ArrayOfApplicationDomainT;
			return soap_in_ArrayOfApplicationDomainT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ApplicationDomainT"))
		{	*type = SOAP_TYPE_ns1__ApplicationDomainT;
			return soap_in_ns1__ApplicationDomainT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:UserAccessT"))
		{	*type = SOAP_TYPE_ArrayOfUserAccessT;
			return soap_in_ArrayOfUserAccessT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:UserAccessT"))
		{	*type = SOAP_TYPE_ns1__UserAccessT;
			return soap_in_ns1__UserAccessT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CMSResultT"))
		{	*type = SOAP_TYPE_ns1__CMSResultT;
			return soap_in_ns1__CMSResultT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CMSLineT"))
		{	*type = SOAP_TYPE_ArrayOfCMSLineT;
			return soap_in_ArrayOfCMSLineT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CMSLineT"))
		{	*type = SOAP_TYPE_ns1__CMSLineT;
			return soap_in_ns1__CMSLineT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTEQueryInputT"))
		{	*type = SOAP_TYPE_ArrayOfCTEQueryInputT;
			return soap_in_ArrayOfCTEQueryInputT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEQueryInputT"))
		{	*type = SOAP_TYPE_ns1__CTEQueryInputT;
			return soap_in_ns1__CTEQueryInputT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTEDataT"))
		{	*type = SOAP_TYPE_ArrayOfCTEDataT;
			return soap_in_ArrayOfCTEDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEDataT"))
		{	*type = SOAP_TYPE_ns1__CTEDataT;
			return soap_in_ns1__CTEDataT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEAbstractNameT"))
		{	*type = SOAP_TYPE_ns1__CTEAbstractNameT;
			return soap_in_ns1__CTEAbstractNameT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTEAbstractMacT"))
		{	*type = SOAP_TYPE_ns1__CTEAbstractMacT;
			return soap_in_ns1__CTEAbstractMacT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CTECustomerT"))
		{	*type = SOAP_TYPE_ArrayOfCTECustomerT;
			return soap_in_ArrayOfCTECustomerT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CTECustomerT"))
		{	*type = SOAP_TYPE_ns1__CTECustomerT;
			return soap_in_ns1__CTECustomerT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmPerformanceHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfCmPerformanceHistoryT;
			return soap_in_ArrayOfCmPerformanceHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmCurrentPerformanceT"))
		{	*type = SOAP_TYPE_ns1__CmCurrentPerformanceT;
			return soap_in_ns1__CmCurrentPerformanceT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmPerformanceHistoryT"))
		{	*type = SOAP_TYPE_ns1__CmPerformanceHistoryT;
			return soap_in_ns1__CmPerformanceHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmPerformanceT"))
		{	*type = SOAP_TYPE_ns1__CmPerformanceT;
			return soap_in_ns1__CmPerformanceT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaPingStatusHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaPingStatusHistoryT;
			return soap_in_ArrayOfMtaPingStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaPingStatusHistoryT"))
		{	*type = SOAP_TYPE_ns1__MtaPingStatusHistoryT;
			return soap_in_ns1__MtaPingStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaPingStatusT"))
		{	*type = SOAP_TYPE_ns1__MtaPingStatusT;
			return soap_in_ns1__MtaPingStatusT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaProvStatusHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaProvStatusHistoryT;
			return soap_in_ArrayOfMtaProvStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaProvStatusHistoryT"))
		{	*type = SOAP_TYPE_ns1__MtaProvStatusHistoryT;
			return soap_in_ns1__MtaProvStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaProvStatusT"))
		{	*type = SOAP_TYPE_ns1__MtaProvStatusT;
			return soap_in_ns1__MtaProvStatusT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MtaAvailabilityHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT;
			return soap_in_ArrayOfMtaAvailabilityHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaAvailabilityHistoryT"))
		{	*type = SOAP_TYPE_ns1__MtaAvailabilityHistoryT;
			return soap_in_ns1__MtaAvailabilityHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MtaAvailabilityT"))
		{	*type = SOAP_TYPE_ns1__MtaAvailabilityT;
			return soap_in_ns1__MtaAvailabilityT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmStatusHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfCmStatusHistoryT;
			return soap_in_ArrayOfCmStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusHistoryT"))
		{	*type = SOAP_TYPE_ns1__CmStatusHistoryT;
			return soap_in_ns1__CmStatusHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmStatusT"))
		{	*type = SOAP_TYPE_ns1__CmStatusT;
			return soap_in_ns1__CmStatusT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:GenericCountsHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfGenericCountsHistoryT;
			return soap_in_ArrayOfGenericCountsHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericCountsHistoryT"))
		{	*type = SOAP_TYPE_ns1__GenericCountsHistoryT;
			return soap_in_ns1__GenericCountsHistoryT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:QueryStateT"))
		{	*type = SOAP_TYPE_ArrayOfQueryStateT;
			return soap_in_ArrayOfQueryStateT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:QueryStateT"))
		{	*type = SOAP_TYPE_ns1__QueryStateT;
			return soap_in_ns1__QueryStateT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ScrollPageT"))
		{	*type = SOAP_TYPE_ArrayOfScrollPageT;
			return soap_in_ArrayOfScrollPageT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ScrollPageT"))
		{	*type = SOAP_TYPE_ns1__ScrollPageT;
			return soap_in_ns1__ScrollPageT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MappedEuDevicesT"))
		{	*type = SOAP_TYPE_ns1__MappedEuDevicesT;
			return soap_in_ns1__MappedEuDevicesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:AlarmHistoryT"))
		{	*type = SOAP_TYPE_ArrayOfAlarmHistoriesT;
			return soap_in_ArrayOfAlarmHistoriesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:HistoricalAlarmT"))
		{	*type = SOAP_TYPE_ArrayOfHistoricalAlarmsT;
			return soap_in_ArrayOfHistoricalAlarmsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CurrentAlarmT"))
		{	*type = SOAP_TYPE_ArrayOfCurrentAlarmsT;
			return soap_in_ArrayOfCurrentAlarmsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:EmtaT"))
		{	*type = SOAP_TYPE_ArrayOfEmtasT;
			return soap_in_ArrayOfEmtasT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CableModemT"))
		{	*type = SOAP_TYPE_ArrayOfCableModemsT;
			return soap_in_ArrayOfCableModemsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:HfcT"))
		{	*type = SOAP_TYPE_ArrayOfHfcsT;
			return soap_in_ArrayOfHfcsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:ChannelT"))
		{	*type = SOAP_TYPE_ArrayOfChannelsT;
			return soap_in_ArrayOfChannelsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:SnmpV2CAttributesT"))
		{	*type = SOAP_TYPE_ArrayOfSnmpV2CAttributesT;
			return soap_in_ArrayOfSnmpV2CAttributesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmtsT"))
		{	*type = SOAP_TYPE_ArrayOfCmtsesT;
			return soap_in_ArrayOfCmtsesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:CmsT"))
		{	*type = SOAP_TYPE_ArrayOfCmsesT;
			return soap_in_ArrayOfCmsesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:BladeT"))
		{	*type = SOAP_TYPE_ArrayOfBladesT;
			return soap_in_ArrayOfBladesT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:MarketT"))
		{	*type = SOAP_TYPE_ArrayOfMarketsT;
			return soap_in_ArrayOfMarketsT(soap, NULL, NULL, NULL);
		}
		if (*soap->arrayType && !soap_match_array(soap, "ns1:RegionT"))
		{	*type = SOAP_TYPE_ArrayOfRegionsT;
			return soap_in_ArrayOfRegionsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AlarmHistoryT"))
		{	*type = SOAP_TYPE_ns1__AlarmHistoryT;
			return soap_in_ns1__AlarmHistoryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistoricalAlarmDetailsT"))
		{	*type = SOAP_TYPE_ns1__HistoricalAlarmDetailsT;
			return soap_in_ns1__HistoricalAlarmDetailsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HistoricalAlarmT"))
		{	*type = SOAP_TYPE_ns1__HistoricalAlarmT;
			return soap_in_ns1__HistoricalAlarmT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CurrentAlarmDetailsT"))
		{	*type = SOAP_TYPE_ns1__CurrentAlarmDetailsT;
			return soap_in_ns1__CurrentAlarmDetailsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CurrentAlarmT"))
		{	*type = SOAP_TYPE_ns1__CurrentAlarmT;
			return soap_in_ns1__CurrentAlarmT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:AbstractAlarmT"))
		{	*type = SOAP_TYPE_ns1__AbstractAlarmT;
			return soap_in_ns1__AbstractAlarmT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EmtaSecondaryT"))
		{	*type = SOAP_TYPE_ns1__EmtaSecondaryT;
			return soap_in_ns1__EmtaSecondaryT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:EmtaT"))
		{	*type = SOAP_TYPE_ns1__EmtaT;
			return soap_in_ns1__EmtaT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CableModemT"))
		{	*type = SOAP_TYPE_ns1__CableModemT;
			return soap_in_ns1__CableModemT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:HfcT"))
		{	*type = SOAP_TYPE_ns1__HfcT;
			return soap_in_ns1__HfcT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChannelT"))
		{	*type = SOAP_TYPE_ns1__ChannelT;
			return soap_in_ns1__ChannelT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmtsT"))
		{	*type = SOAP_TYPE_ns1__CmtsT;
			return soap_in_ns1__CmtsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:CmsT"))
		{	*type = SOAP_TYPE_ns1__CmsT;
			return soap_in_ns1__CmsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:BladeT"))
		{	*type = SOAP_TYPE_ns1__BladeT;
			return soap_in_ns1__BladeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:MarketT"))
		{	*type = SOAP_TYPE_ns1__MarketT;
			return soap_in_ns1__MarketT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:RegionT"))
		{	*type = SOAP_TYPE_ns1__RegionT;
			return soap_in_ns1__RegionT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:LocalSystemT"))
		{	*type = SOAP_TYPE_ns1__LocalSystemT;
			return soap_in_ns1__LocalSystemT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:TopoHierarchyKeyT"))
		{	*type = SOAP_TYPE_ns1__TopoHierarchyKeyT;
			return soap_in_ns1__TopoHierarchyKeyT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ResultBatchT"))
		{	*type = SOAP_TYPE_ns1__ResultBatchT;
			return soap_in_ns1__ResultBatchT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:InputTimeT"))
		{	*type = SOAP_TYPE_ns1__InputTimeT;
			return soap_in_ns1__InputTimeT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:GenericCountsT"))
		{	*type = SOAP_TYPE_ns1__GenericCountsT;
			return soap_in_ns1__GenericCountsT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SnmpV2CAttributesT"))
		{	*type = SOAP_TYPE_ns1__SnmpV2CAttributesT;
			return soap_in_ns1__SnmpV2CAttributesT(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:integer"))
		{	*type = SOAP_TYPE_xsd__integer;
			return soap_in_xsd__integer(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	*type = SOAP_TYPE_std__string;
			return soap_in_std__string(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getConfig"))
		{	*type = SOAP_TYPE_adm__getConfig;
			return soap_in_adm__getConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getConfigResponse"))
		{	*type = SOAP_TYPE_adm__getConfigResponse;
			return soap_in_adm__getConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:downloadConfigFromParent"))
		{	*type = SOAP_TYPE_adm__downloadConfigFromParent;
			return soap_in_adm__downloadConfigFromParent(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:downloadConfigFromParentResponse"))
		{	*type = SOAP_TYPE_adm__downloadConfigFromParentResponse;
			return soap_in_adm__downloadConfigFromParentResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateRole"))
		{	*type = SOAP_TYPE_adm__updateRole;
			return soap_in_adm__updateRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateRoleResponse"))
		{	*type = SOAP_TYPE_adm__updateRoleResponse;
			return soap_in_adm__updateRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getRole"))
		{	*type = SOAP_TYPE_adm__getRole;
			return soap_in_adm__getRole(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getRoleResponse"))
		{	*type = SOAP_TYPE_adm__getRoleResponse;
			return soap_in_adm__getRoleResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getRoles"))
		{	*type = SOAP_TYPE_adm__getRoles;
			return soap_in_adm__getRoles(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getRolesResponse"))
		{	*type = SOAP_TYPE_adm__getRolesResponse;
			return soap_in_adm__getRolesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateUserPassword"))
		{	*type = SOAP_TYPE_adm__updateUserPassword;
			return soap_in_adm__updateUserPassword(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateUserPasswordResponse"))
		{	*type = SOAP_TYPE_adm__updateUserPasswordResponse;
			return soap_in_adm__updateUserPasswordResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateUser"))
		{	*type = SOAP_TYPE_adm__updateUser;
			return soap_in_adm__updateUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateUserResponse"))
		{	*type = SOAP_TYPE_adm__updateUserResponse;
			return soap_in_adm__updateUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getUser"))
		{	*type = SOAP_TYPE_adm__getUser;
			return soap_in_adm__getUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getUserResponse"))
		{	*type = SOAP_TYPE_adm__getUserResponse;
			return soap_in_adm__getUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getUsers"))
		{	*type = SOAP_TYPE_adm__getUsers;
			return soap_in_adm__getUsers(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getUsersResponse"))
		{	*type = SOAP_TYPE_adm__getUsersResponse;
			return soap_in_adm__getUsersResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addUser"))
		{	*type = SOAP_TYPE_adm__addUser;
			return soap_in_adm__addUser(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addUserResponse"))
		{	*type = SOAP_TYPE_adm__addUserResponse;
			return soap_in_adm__addUserResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmPerfConfig"))
		{	*type = SOAP_TYPE_adm__updateCmPerfConfig;
			return soap_in_adm__updateCmPerfConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmPerfConfigResponse"))
		{	*type = SOAP_TYPE_adm__updateCmPerfConfigResponse;
			return soap_in_adm__updateCmPerfConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmPerfConfig"))
		{	*type = SOAP_TYPE_adm__getCmPerfConfig;
			return soap_in_adm__getCmPerfConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmPerfConfigResponse"))
		{	*type = SOAP_TYPE_adm__getCmPerfConfigResponse;
			return soap_in_adm__getCmPerfConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:deleteBlade"))
		{	*type = SOAP_TYPE_adm__deleteBlade;
			return soap_in_adm__deleteBlade(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:deleteBladeResponse"))
		{	*type = SOAP_TYPE_adm__deleteBladeResponse;
			return soap_in_adm__deleteBladeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addBlade"))
		{	*type = SOAP_TYPE_adm__addBlade;
			return soap_in_adm__addBlade(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addBladeResponse"))
		{	*type = SOAP_TYPE_adm__addBladeResponse;
			return soap_in_adm__addBladeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateBlade"))
		{	*type = SOAP_TYPE_adm__updateBlade;
			return soap_in_adm__updateBlade(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateBladeResponse"))
		{	*type = SOAP_TYPE_adm__updateBladeResponse;
			return soap_in_adm__updateBladeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addMarket"))
		{	*type = SOAP_TYPE_adm__addMarket;
			return soap_in_adm__addMarket(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addMarketResponse"))
		{	*type = SOAP_TYPE_adm__addMarketResponse;
			return soap_in_adm__addMarketResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateMarket"))
		{	*type = SOAP_TYPE_adm__updateMarket;
			return soap_in_adm__updateMarket(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateMarketResponse"))
		{	*type = SOAP_TYPE_adm__updateMarketResponse;
			return soap_in_adm__updateMarketResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addRegion"))
		{	*type = SOAP_TYPE_adm__addRegion;
			return soap_in_adm__addRegion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addRegionResponse"))
		{	*type = SOAP_TYPE_adm__addRegionResponse;
			return soap_in_adm__addRegionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateRegion"))
		{	*type = SOAP_TYPE_adm__updateRegion;
			return soap_in_adm__updateRegion(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateRegionResponse"))
		{	*type = SOAP_TYPE_adm__updateRegionResponse;
			return soap_in_adm__updateRegionResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateLocalSystem"))
		{	*type = SOAP_TYPE_adm__updateLocalSystem;
			return soap_in_adm__updateLocalSystem(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateLocalSystemResponse"))
		{	*type = SOAP_TYPE_adm__updateLocalSystemResponse;
			return soap_in_adm__updateLocalSystemResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmsAlarmConfig"))
		{	*type = SOAP_TYPE_adm__updateCmsAlarmConfig;
			return soap_in_adm__updateCmsAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmsAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__updateCmsAlarmConfigResponse;
			return soap_in_adm__updateCmsAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmsAlarmConfig"))
		{	*type = SOAP_TYPE_adm__getCmsAlarmConfig;
			return soap_in_adm__getCmsAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmsAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__getCmsAlarmConfigResponse;
			return soap_in_adm__getCmsAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmtsAlarmConfig"))
		{	*type = SOAP_TYPE_adm__updateCmtsAlarmConfig;
			return soap_in_adm__updateCmtsAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmtsAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__updateCmtsAlarmConfigResponse;
			return soap_in_adm__updateCmtsAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmtsAlarmConfig"))
		{	*type = SOAP_TYPE_adm__getCmtsAlarmConfig;
			return soap_in_adm__getCmtsAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmtsAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__getCmtsAlarmConfigResponse;
			return soap_in_adm__getCmtsAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateHfcAlarmConfig"))
		{	*type = SOAP_TYPE_adm__updateHfcAlarmConfig;
			return soap_in_adm__updateHfcAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateHfcAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__updateHfcAlarmConfigResponse;
			return soap_in_adm__updateHfcAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getHfcAlarmConfig"))
		{	*type = SOAP_TYPE_adm__getHfcAlarmConfig;
			return soap_in_adm__getHfcAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getHfcAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__getHfcAlarmConfigResponse;
			return soap_in_adm__getHfcAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateMtaAlarmConfig"))
		{	*type = SOAP_TYPE_adm__updateMtaAlarmConfig;
			return soap_in_adm__updateMtaAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateMtaAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__updateMtaAlarmConfigResponse;
			return soap_in_adm__updateMtaAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getMtaAlarmConfig"))
		{	*type = SOAP_TYPE_adm__getMtaAlarmConfig;
			return soap_in_adm__getMtaAlarmConfig(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getMtaAlarmConfigResponse"))
		{	*type = SOAP_TYPE_adm__getMtaAlarmConfigResponse;
			return soap_in_adm__getMtaAlarmConfigResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmsStatusThreshold"))
		{	*type = SOAP_TYPE_adm__updateCmsStatusThreshold;
			return soap_in_adm__updateCmsStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmsStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__updateCmsStatusThresholdResponse;
			return soap_in_adm__updateCmsStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmsStatusThreshold"))
		{	*type = SOAP_TYPE_adm__getCmsStatusThreshold;
			return soap_in_adm__getCmsStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmsStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__getCmsStatusThresholdResponse;
			return soap_in_adm__getCmsStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmtsStatusThreshold"))
		{	*type = SOAP_TYPE_adm__updateCmtsStatusThreshold;
			return soap_in_adm__updateCmtsStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmtsStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__updateCmtsStatusThresholdResponse;
			return soap_in_adm__updateCmtsStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmtsStatusThreshold"))
		{	*type = SOAP_TYPE_adm__getCmtsStatusThreshold;
			return soap_in_adm__getCmtsStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getCmtsStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__getCmtsStatusThresholdResponse;
			return soap_in_adm__getCmtsStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateChannelStatusThreshold"))
		{	*type = SOAP_TYPE_adm__updateChannelStatusThreshold;
			return soap_in_adm__updateChannelStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateChannelStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__updateChannelStatusThresholdResponse;
			return soap_in_adm__updateChannelStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getChannelStatusThreshold"))
		{	*type = SOAP_TYPE_adm__getChannelStatusThreshold;
			return soap_in_adm__getChannelStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getChannelStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__getChannelStatusThresholdResponse;
			return soap_in_adm__getChannelStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateHfcStatusThreshold"))
		{	*type = SOAP_TYPE_adm__updateHfcStatusThreshold;
			return soap_in_adm__updateHfcStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateHfcStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__updateHfcStatusThresholdResponse;
			return soap_in_adm__updateHfcStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getHfcStatusThreshold"))
		{	*type = SOAP_TYPE_adm__getHfcStatusThreshold;
			return soap_in_adm__getHfcStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getHfcStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__getHfcStatusThresholdResponse;
			return soap_in_adm__getHfcStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateMtaStatusThreshold"))
		{	*type = SOAP_TYPE_adm__updateMtaStatusThreshold;
			return soap_in_adm__updateMtaStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateMtaStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__updateMtaStatusThresholdResponse;
			return soap_in_adm__updateMtaStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getMtaStatusThreshold"))
		{	*type = SOAP_TYPE_adm__getMtaStatusThreshold;
			return soap_in_adm__getMtaStatusThreshold(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getMtaStatusThresholdResponse"))
		{	*type = SOAP_TYPE_adm__getMtaStatusThresholdResponse;
			return soap_in_adm__getMtaStatusThresholdResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updatePollingIntervals"))
		{	*type = SOAP_TYPE_adm__updatePollingIntervals;
			return soap_in_adm__updatePollingIntervals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updatePollingIntervalsResponse"))
		{	*type = SOAP_TYPE_adm__updatePollingIntervalsResponse;
			return soap_in_adm__updatePollingIntervalsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getPollingIntervals"))
		{	*type = SOAP_TYPE_adm__getPollingIntervals;
			return soap_in_adm__getPollingIntervals(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:getPollingIntervalsResponse"))
		{	*type = SOAP_TYPE_adm__getPollingIntervalsResponse;
			return soap_in_adm__getPollingIntervalsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:deleteCms"))
		{	*type = SOAP_TYPE_adm__deleteCms;
			return soap_in_adm__deleteCms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:deleteCmsResponse"))
		{	*type = SOAP_TYPE_adm__deleteCmsResponse;
			return soap_in_adm__deleteCmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addCms"))
		{	*type = SOAP_TYPE_adm__addCms;
			return soap_in_adm__addCms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addCmsResponse"))
		{	*type = SOAP_TYPE_adm__addCmsResponse;
			return soap_in_adm__addCmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCms"))
		{	*type = SOAP_TYPE_adm__updateCms;
			return soap_in_adm__updateCms(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmsResponse"))
		{	*type = SOAP_TYPE_adm__updateCmsResponse;
			return soap_in_adm__updateCmsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmtsAllSnmpV2CAttributes"))
		{	*type = SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes;
			return soap_in_adm__updateCmtsAllSnmpV2CAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmtsAllSnmpV2CAttributesResponse"))
		{	*type = SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse;
			return soap_in_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addCmtsAllSnmpV2CAttributes"))
		{	*type = SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes;
			return soap_in_adm__addCmtsAllSnmpV2CAttributes(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addCmtsAllSnmpV2CAttributesResponse"))
		{	*type = SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse;
			return soap_in_adm__addCmtsAllSnmpV2CAttributesResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:deleteCmts"))
		{	*type = SOAP_TYPE_adm__deleteCmts;
			return soap_in_adm__deleteCmts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:deleteCmtsResponse"))
		{	*type = SOAP_TYPE_adm__deleteCmtsResponse;
			return soap_in_adm__deleteCmtsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addCmts"))
		{	*type = SOAP_TYPE_adm__addCmts;
			return soap_in_adm__addCmts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:addCmtsResponse"))
		{	*type = SOAP_TYPE_adm__addCmtsResponse;
			return soap_in_adm__addCmtsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmts"))
		{	*type = SOAP_TYPE_adm__updateCmts;
			return soap_in_adm__updateCmts(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "adm:updateCmtsResponse"))
		{	*type = SOAP_TYPE_adm__updateCmtsResponse;
			return soap_in_adm__updateCmtsResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
		if (!soap_match_tag(soap, t, "SOAP-ENC:arrayType"))
		{	*type = SOAP_TYPE__SOAP_ENC__arrayType;
			return soap_in__SOAP_ENC__arrayType(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
	}
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		if (soap->mustUnderstand && !soap->other)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unknown element '%s' (level=%u, %d)\n", soap->tag, soap->level, soap->body));
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body)
			{	soap->level++;
				while (!soap_ignore_element(soap))
					;
				if (soap->error == SOAP_NO_TAG)
					soap->error = soap_element_end_in(soap, NULL);
			}
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, "id", pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_short:
		return soap_out_short(soap, tag, id, (const short *)ptr, "xsd:short");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns1__EventCategoryT:
		return soap_out_ns1__EventCategoryT(soap, tag, id, (const enum ns1__EventCategoryT *)ptr, "ns1:EventCategoryT");
	case SOAP_TYPE_ns1__EventTypeT:
		return soap_out_ns1__EventTypeT(soap, tag, id, (const enum ns1__EventTypeT *)ptr, "ns1:EventTypeT");
	case SOAP_TYPE_ns1__ApplicationDomainTypeT:
		return soap_out_ns1__ApplicationDomainTypeT(soap, tag, id, (const enum ns1__ApplicationDomainTypeT *)ptr, "ns1:ApplicationDomainTypeT");
	case SOAP_TYPE_ns1__UserAccessTypeT:
		return soap_out_ns1__UserAccessTypeT(soap, tag, id, (const enum ns1__UserAccessTypeT *)ptr, "ns1:UserAccessTypeT");
	case SOAP_TYPE_ns1__EndUserDeviceTypeT:
		return soap_out_ns1__EndUserDeviceTypeT(soap, tag, id, (const enum ns1__EndUserDeviceTypeT *)ptr, "ns1:EndUserDeviceTypeT");
	case SOAP_TYPE_ns1__ChannelTypeT:
		return soap_out_ns1__ChannelTypeT(soap, tag, id, (const enum ns1__ChannelTypeT *)ptr, "ns1:ChannelTypeT");
	case SOAP_TYPE_ns1__SnmpVersionT:
		return soap_out_ns1__SnmpVersionT(soap, tag, id, (const enum ns1__SnmpVersionT *)ptr, "ns1:SnmpVersionT");
	case SOAP_TYPE_ns1__StatusColorT:
		return soap_out_ns1__StatusColorT(soap, tag, id, (const enum ns1__StatusColorT *)ptr, "ns1:StatusColorT");
	case SOAP_TYPE_ns1__ResourceTypeT:
		return soap_out_ns1__ResourceTypeT(soap, tag, id, (const enum ns1__ResourceTypeT *)ptr, "ns1:ResourceTypeT");
	case SOAP_TYPE_ns1__SystemTypeT:
		return soap_out_ns1__SystemTypeT(soap, tag, id, (const enum ns1__SystemTypeT *)ptr, "ns1:SystemTypeT");
	case SOAP_TYPE_ns1__EventMessageT:
		return ((ns1__EventMessageT *)ptr)->soap_out(soap, tag, id, "ns1:EventMessageT");
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		return ((ns1__HistoricalAlarmsRespT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmsRespT");
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		return ((ns1__CurrentAlarmsRespT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmsRespT");
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		return ((ns1__CmStatusSummaryRespT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusSummaryRespT");
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		return ((ns1__HfcStatusSummaryRespT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusSummaryRespT");
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		return ((ns1__MtaStatusSummaryRespT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusSummaryRespT");
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		return ((ArrayOfCmStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		return ((ns1__CmStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		return ((ArrayOfMtaStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		return ((ns1__MtaStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		return ((ArrayOfHfcStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		return ((ns1__HfcStatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_ns1__StatusSummaryT:
		return ((ns1__StatusSummaryT *)ptr)->soap_out(soap, tag, id, "ns1:StatusSummaryT");
	case SOAP_TYPE_ns1__MtaDataT:
		return ((ns1__MtaDataT *)ptr)->soap_out(soap, tag, id, "ns1:MtaDataT");
	case SOAP_TYPE_ns1__CmDataT:
		return ((ns1__CmDataT *)ptr)->soap_out(soap, tag, id, "ns1:CmDataT");
	case SOAP_TYPE_ns1__CmtsCmDataT:
		return ((ns1__CmtsCmDataT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsCmDataT");
	case SOAP_TYPE_ns1__ConfigDownloadT:
		return ((ns1__ConfigDownloadT *)ptr)->soap_out(soap, tag, id, "ns1:ConfigDownloadT");
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		return ((ns1__CmPerformanceConfigT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceConfigT");
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		return ((ns1__CmsAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:CmsAlarmConfigT");
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		return ((ns1__CmtsAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsAlarmConfigT");
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		return ((ns1__MtaAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAlarmConfigT");
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		return ((ArrayOfAlarmTypeConfigT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		return ((ns1__AlarmTypeConfigT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		return ((ns1__HfcAlarmConfigT *)ptr)->soap_out(soap, tag, id, "ns1:HfcAlarmConfigT");
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		return ((ns1__HfcPowerTresholdT *)ptr)->soap_out(soap, tag, id, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		return ((ns1__AggregateMtaTresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		return ((ns1__AggregateCmOfflineTresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_ns1__SoakWindowT:
		return ((ns1__SoakWindowT *)ptr)->soap_out(soap, tag, id, "ns1:SoakWindowT");
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		return ((ns1__CmsStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:CmsStatusThresholdT");
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		return ((ns1__CmtsStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsStatusThresholdT");
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		return ((ns1__ChannelStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:ChannelStatusThresholdT");
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		return ((ns1__HfcStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:HfcStatusThresholdT");
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		return ((ns1__MtaStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:MtaStatusThresholdT");
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		return ((ArrayOfAggregateStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		return ((ns1__AggregateStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		return ((ArrayOfAlarmStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		return ((ns1__AlarmBasedStatusThresholdT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_ns1__PollingIntervalsT:
		return ((ns1__PollingIntervalsT *)ptr)->soap_out(soap, tag, id, "ns1:PollingIntervalsT");
	case SOAP_TYPE_ArrayOfUserT:
		return ((ArrayOfUserT *)ptr)->soap_out(soap, tag, id, "ns1:UserT");
	case SOAP_TYPE_ns1__UserT:
		return ((ns1__UserT *)ptr)->soap_out(soap, tag, id, "ns1:UserT");
	case SOAP_TYPE_ArrayOfRoleT:
		return ((ArrayOfRoleT *)ptr)->soap_out(soap, tag, id, "ns1:RoleT");
	case SOAP_TYPE_ns1__RoleT:
		return ((ns1__RoleT *)ptr)->soap_out(soap, tag, id, "ns1:RoleT");
	case SOAP_TYPE_ArrayOfApplicationDomainT:
		return ((ArrayOfApplicationDomainT *)ptr)->soap_out(soap, tag, id, "ns1:ApplicationDomainT");
	case SOAP_TYPE_ns1__ApplicationDomainT:
		return ((ns1__ApplicationDomainT *)ptr)->soap_out(soap, tag, id, "ns1:ApplicationDomainT");
	case SOAP_TYPE_ArrayOfUserAccessT:
		return ((ArrayOfUserAccessT *)ptr)->soap_out(soap, tag, id, "ns1:UserAccessT");
	case SOAP_TYPE_ns1__UserAccessT:
		return ((ns1__UserAccessT *)ptr)->soap_out(soap, tag, id, "ns1:UserAccessT");
	case SOAP_TYPE_ns1__CMSResultT:
		return ((ns1__CMSResultT *)ptr)->soap_out(soap, tag, id, "ns1:CMSResultT");
	case SOAP_TYPE_ArrayOfCMSLineT:
		return ((ArrayOfCMSLineT *)ptr)->soap_out(soap, tag, id, "ns1:CMSLineT");
	case SOAP_TYPE_ns1__CMSLineT:
		return ((ns1__CMSLineT *)ptr)->soap_out(soap, tag, id, "ns1:CMSLineT");
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		return ((ArrayOfCTEQueryInputT *)ptr)->soap_out(soap, tag, id, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ns1__CTEQueryInputT:
		return ((ns1__CTEQueryInputT *)ptr)->soap_out(soap, tag, id, "ns1:CTEQueryInputT");
	case SOAP_TYPE_ArrayOfCTEDataT:
		return ((ArrayOfCTEDataT *)ptr)->soap_out(soap, tag, id, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEDataT:
		return ((ns1__CTEDataT *)ptr)->soap_out(soap, tag, id, "ns1:CTEDataT");
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		return ((ns1__CTEAbstractNameT *)ptr)->soap_out(soap, tag, id, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		return ((ns1__CTEAbstractMacT *)ptr)->soap_out(soap, tag, id, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_ArrayOfCTECustomerT:
		return ((ArrayOfCTECustomerT *)ptr)->soap_out(soap, tag, id, "ns1:CTECustomerT");
	case SOAP_TYPE_ns1__CTECustomerT:
		return ((ns1__CTECustomerT *)ptr)->soap_out(soap, tag, id, "ns1:CTECustomerT");
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		return ((ArrayOfCmPerformanceHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		return ((ns1__CmCurrentPerformanceT *)ptr)->soap_out(soap, tag, id, "ns1:CmCurrentPerformanceT");
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		return ((ns1__CmPerformanceHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_ns1__CmPerformanceT:
		return ((ns1__CmPerformanceT *)ptr)->soap_out(soap, tag, id, "ns1:CmPerformanceT");
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		return ((ArrayOfMtaPingStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		return ((ns1__MtaPingStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_ns1__MtaPingStatusT:
		return ((ns1__MtaPingStatusT *)ptr)->soap_out(soap, tag, id, "ns1:MtaPingStatusT");
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		return ((ArrayOfMtaProvStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		return ((ns1__MtaProvStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_ns1__MtaProvStatusT:
		return ((ns1__MtaProvStatusT *)ptr)->soap_out(soap, tag, id, "ns1:MtaProvStatusT");
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		return ((ArrayOfMtaAvailabilityHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		return ((ns1__MtaAvailabilityHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		return ((ns1__MtaAvailabilityT *)ptr)->soap_out(soap, tag, id, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		return ((ArrayOfCmStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		return ((ns1__CmStatusHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_ns1__CmStatusT:
		return ((ns1__CmStatusT *)ptr)->soap_out(soap, tag, id, "ns1:CmStatusT");
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		return ((ArrayOfGenericCountsHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		return ((ns1__GenericCountsHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_ArrayOfQueryStateT:
		return ((ArrayOfQueryStateT *)ptr)->soap_out(soap, tag, id, "ns1:QueryStateT");
	case SOAP_TYPE_ns1__QueryStateT:
		return ((ns1__QueryStateT *)ptr)->soap_out(soap, tag, id, "ns1:QueryStateT");
	case SOAP_TYPE_ArrayOfScrollPageT:
		return ((ArrayOfScrollPageT *)ptr)->soap_out(soap, tag, id, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__ScrollPageT:
		return ((ns1__ScrollPageT *)ptr)->soap_out(soap, tag, id, "ns1:ScrollPageT");
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		return ((ns1__MappedEuDevicesT *)ptr)->soap_out(soap, tag, id, "ns1:MappedEuDevicesT");
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		return ((ArrayOfAlarmHistoriesT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		return ((ArrayOfHistoricalAlarmsT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		return ((ArrayOfCurrentAlarmsT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ArrayOfEmtasT:
		return ((ArrayOfEmtasT *)ptr)->soap_out(soap, tag, id, "ns1:EmtaT");
	case SOAP_TYPE_ArrayOfCableModemsT:
		return ((ArrayOfCableModemsT *)ptr)->soap_out(soap, tag, id, "ns1:CableModemT");
	case SOAP_TYPE_ArrayOfHfcsT:
		return ((ArrayOfHfcsT *)ptr)->soap_out(soap, tag, id, "ns1:HfcT");
	case SOAP_TYPE_ArrayOfChannelsT:
		return ((ArrayOfChannelsT *)ptr)->soap_out(soap, tag, id, "ns1:ChannelT");
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		return ((ArrayOfSnmpV2CAttributesT *)ptr)->soap_out(soap, tag, id, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_ArrayOfCmtsesT:
		return ((ArrayOfCmtsesT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsT");
	case SOAP_TYPE_ArrayOfCmsesT:
		return ((ArrayOfCmsesT *)ptr)->soap_out(soap, tag, id, "ns1:CmsT");
	case SOAP_TYPE_ArrayOfBladesT:
		return ((ArrayOfBladesT *)ptr)->soap_out(soap, tag, id, "ns1:BladeT");
	case SOAP_TYPE_ArrayOfMarketsT:
		return ((ArrayOfMarketsT *)ptr)->soap_out(soap, tag, id, "ns1:MarketT");
	case SOAP_TYPE_ArrayOfRegionsT:
		return ((ArrayOfRegionsT *)ptr)->soap_out(soap, tag, id, "ns1:RegionT");
	case SOAP_TYPE_ns1__AlarmHistoryT:
		return ((ns1__AlarmHistoryT *)ptr)->soap_out(soap, tag, id, "ns1:AlarmHistoryT");
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		return ((ns1__HistoricalAlarmDetailsT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmDetailsT");
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		return ((ns1__HistoricalAlarmT *)ptr)->soap_out(soap, tag, id, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		return ((ns1__CurrentAlarmDetailsT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmDetailsT");
	case SOAP_TYPE_ns1__CurrentAlarmT:
		return ((ns1__CurrentAlarmT *)ptr)->soap_out(soap, tag, id, "ns1:CurrentAlarmT");
	case SOAP_TYPE_ns1__AbstractAlarmT:
		return ((ns1__AbstractAlarmT *)ptr)->soap_out(soap, tag, id, "ns1:AbstractAlarmT");
	case SOAP_TYPE_ns1__EmtaSecondaryT:
		return ((ns1__EmtaSecondaryT *)ptr)->soap_out(soap, tag, id, "ns1:EmtaSecondaryT");
	case SOAP_TYPE_ns1__EmtaT:
		return ((ns1__EmtaT *)ptr)->soap_out(soap, tag, id, "ns1:EmtaT");
	case SOAP_TYPE_ns1__CableModemT:
		return ((ns1__CableModemT *)ptr)->soap_out(soap, tag, id, "ns1:CableModemT");
	case SOAP_TYPE_ns1__HfcT:
		return ((ns1__HfcT *)ptr)->soap_out(soap, tag, id, "ns1:HfcT");
	case SOAP_TYPE_ns1__ChannelT:
		return ((ns1__ChannelT *)ptr)->soap_out(soap, tag, id, "ns1:ChannelT");
	case SOAP_TYPE_ns1__CmtsT:
		return ((ns1__CmtsT *)ptr)->soap_out(soap, tag, id, "ns1:CmtsT");
	case SOAP_TYPE_ns1__CmsT:
		return ((ns1__CmsT *)ptr)->soap_out(soap, tag, id, "ns1:CmsT");
	case SOAP_TYPE_ns1__BladeT:
		return ((ns1__BladeT *)ptr)->soap_out(soap, tag, id, "ns1:BladeT");
	case SOAP_TYPE_ns1__MarketT:
		return ((ns1__MarketT *)ptr)->soap_out(soap, tag, id, "ns1:MarketT");
	case SOAP_TYPE_ns1__RegionT:
		return ((ns1__RegionT *)ptr)->soap_out(soap, tag, id, "ns1:RegionT");
	case SOAP_TYPE_ns1__LocalSystemT:
		return ((ns1__LocalSystemT *)ptr)->soap_out(soap, tag, id, "ns1:LocalSystemT");
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		return ((ns1__TopoHierarchyKeyT *)ptr)->soap_out(soap, tag, id, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_ns1__ResultBatchT:
		return ((ns1__ResultBatchT *)ptr)->soap_out(soap, tag, id, "ns1:ResultBatchT");
	case SOAP_TYPE_ns1__InputTimeT:
		return ((ns1__InputTimeT *)ptr)->soap_out(soap, tag, id, "ns1:InputTimeT");
	case SOAP_TYPE_ns1__GenericCountsT:
		return ((ns1__GenericCountsT *)ptr)->soap_out(soap, tag, id, "ns1:GenericCountsT");
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		return ((ns1__SnmpV2CAttributesT *)ptr)->soap_out(soap, tag, id, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE__SOAP_ENC__arrayType:
		return soap_out__SOAP_ENC__arrayType(soap, "SOAP-ENC:arrayType", id, (const std::string *)ptr, NULL);
	case SOAP_TYPE_xsd__integer:
		return soap_out_xsd__integer(soap, tag, id, (const std::string *)ptr, "xsd:integer");
	case SOAP_TYPE_std__string:
		return soap_out_std__string(soap, tag, id, (const std::string *)ptr, "xsd:string");
	case SOAP_TYPE_adm__getConfig:
		return soap_out_adm__getConfig(soap, tag, id, (const struct adm__getConfig *)ptr, "adm:getConfig");
	case SOAP_TYPE_adm__getConfigResponse:
		return soap_out_adm__getConfigResponse(soap, tag, id, (const struct adm__getConfigResponse *)ptr, "adm:getConfigResponse");
	case SOAP_TYPE_adm__downloadConfigFromParent:
		return soap_out_adm__downloadConfigFromParent(soap, tag, id, (const struct adm__downloadConfigFromParent *)ptr, "adm:downloadConfigFromParent");
	case SOAP_TYPE_adm__downloadConfigFromParentResponse:
		return soap_out_adm__downloadConfigFromParentResponse(soap, tag, id, (const struct adm__downloadConfigFromParentResponse *)ptr, "adm:downloadConfigFromParentResponse");
	case SOAP_TYPE_adm__updateRole:
		return soap_out_adm__updateRole(soap, tag, id, (const struct adm__updateRole *)ptr, "adm:updateRole");
	case SOAP_TYPE_adm__updateRoleResponse:
		return soap_out_adm__updateRoleResponse(soap, tag, id, (const struct adm__updateRoleResponse *)ptr, "adm:updateRoleResponse");
	case SOAP_TYPE_adm__getRole:
		return soap_out_adm__getRole(soap, tag, id, (const struct adm__getRole *)ptr, "adm:getRole");
	case SOAP_TYPE_adm__getRoleResponse:
		return soap_out_adm__getRoleResponse(soap, tag, id, (const struct adm__getRoleResponse *)ptr, "adm:getRoleResponse");
	case SOAP_TYPE_adm__getRoles:
		return soap_out_adm__getRoles(soap, tag, id, (const struct adm__getRoles *)ptr, "adm:getRoles");
	case SOAP_TYPE_adm__getRolesResponse:
		return soap_out_adm__getRolesResponse(soap, tag, id, (const struct adm__getRolesResponse *)ptr, "adm:getRolesResponse");
	case SOAP_TYPE_adm__updateUserPassword:
		return soap_out_adm__updateUserPassword(soap, tag, id, (const struct adm__updateUserPassword *)ptr, "adm:updateUserPassword");
	case SOAP_TYPE_adm__updateUserPasswordResponse:
		return soap_out_adm__updateUserPasswordResponse(soap, tag, id, (const struct adm__updateUserPasswordResponse *)ptr, "adm:updateUserPasswordResponse");
	case SOAP_TYPE_adm__updateUser:
		return soap_out_adm__updateUser(soap, tag, id, (const struct adm__updateUser *)ptr, "adm:updateUser");
	case SOAP_TYPE_adm__updateUserResponse:
		return soap_out_adm__updateUserResponse(soap, tag, id, (const struct adm__updateUserResponse *)ptr, "adm:updateUserResponse");
	case SOAP_TYPE_adm__getUser:
		return soap_out_adm__getUser(soap, tag, id, (const struct adm__getUser *)ptr, "adm:getUser");
	case SOAP_TYPE_adm__getUserResponse:
		return soap_out_adm__getUserResponse(soap, tag, id, (const struct adm__getUserResponse *)ptr, "adm:getUserResponse");
	case SOAP_TYPE_adm__getUsers:
		return soap_out_adm__getUsers(soap, tag, id, (const struct adm__getUsers *)ptr, "adm:getUsers");
	case SOAP_TYPE_adm__getUsersResponse:
		return soap_out_adm__getUsersResponse(soap, tag, id, (const struct adm__getUsersResponse *)ptr, "adm:getUsersResponse");
	case SOAP_TYPE_adm__addUser:
		return soap_out_adm__addUser(soap, tag, id, (const struct adm__addUser *)ptr, "adm:addUser");
	case SOAP_TYPE_adm__addUserResponse:
		return soap_out_adm__addUserResponse(soap, tag, id, (const struct adm__addUserResponse *)ptr, "adm:addUserResponse");
	case SOAP_TYPE_adm__updateCmPerfConfig:
		return soap_out_adm__updateCmPerfConfig(soap, tag, id, (const struct adm__updateCmPerfConfig *)ptr, "adm:updateCmPerfConfig");
	case SOAP_TYPE_adm__updateCmPerfConfigResponse:
		return soap_out_adm__updateCmPerfConfigResponse(soap, tag, id, (const struct adm__updateCmPerfConfigResponse *)ptr, "adm:updateCmPerfConfigResponse");
	case SOAP_TYPE_adm__getCmPerfConfig:
		return soap_out_adm__getCmPerfConfig(soap, tag, id, (const struct adm__getCmPerfConfig *)ptr, "adm:getCmPerfConfig");
	case SOAP_TYPE_adm__getCmPerfConfigResponse:
		return soap_out_adm__getCmPerfConfigResponse(soap, tag, id, (const struct adm__getCmPerfConfigResponse *)ptr, "adm:getCmPerfConfigResponse");
	case SOAP_TYPE_adm__deleteBlade:
		return soap_out_adm__deleteBlade(soap, tag, id, (const struct adm__deleteBlade *)ptr, "adm:deleteBlade");
	case SOAP_TYPE_adm__deleteBladeResponse:
		return soap_out_adm__deleteBladeResponse(soap, tag, id, (const struct adm__deleteBladeResponse *)ptr, "adm:deleteBladeResponse");
	case SOAP_TYPE_adm__addBlade:
		return soap_out_adm__addBlade(soap, tag, id, (const struct adm__addBlade *)ptr, "adm:addBlade");
	case SOAP_TYPE_adm__addBladeResponse:
		return soap_out_adm__addBladeResponse(soap, tag, id, (const struct adm__addBladeResponse *)ptr, "adm:addBladeResponse");
	case SOAP_TYPE_adm__updateBlade:
		return soap_out_adm__updateBlade(soap, tag, id, (const struct adm__updateBlade *)ptr, "adm:updateBlade");
	case SOAP_TYPE_adm__updateBladeResponse:
		return soap_out_adm__updateBladeResponse(soap, tag, id, (const struct adm__updateBladeResponse *)ptr, "adm:updateBladeResponse");
	case SOAP_TYPE_adm__addMarket:
		return soap_out_adm__addMarket(soap, tag, id, (const struct adm__addMarket *)ptr, "adm:addMarket");
	case SOAP_TYPE_adm__addMarketResponse:
		return soap_out_adm__addMarketResponse(soap, tag, id, (const struct adm__addMarketResponse *)ptr, "adm:addMarketResponse");
	case SOAP_TYPE_adm__updateMarket:
		return soap_out_adm__updateMarket(soap, tag, id, (const struct adm__updateMarket *)ptr, "adm:updateMarket");
	case SOAP_TYPE_adm__updateMarketResponse:
		return soap_out_adm__updateMarketResponse(soap, tag, id, (const struct adm__updateMarketResponse *)ptr, "adm:updateMarketResponse");
	case SOAP_TYPE_adm__addRegion:
		return soap_out_adm__addRegion(soap, tag, id, (const struct adm__addRegion *)ptr, "adm:addRegion");
	case SOAP_TYPE_adm__addRegionResponse:
		return soap_out_adm__addRegionResponse(soap, tag, id, (const struct adm__addRegionResponse *)ptr, "adm:addRegionResponse");
	case SOAP_TYPE_adm__updateRegion:
		return soap_out_adm__updateRegion(soap, tag, id, (const struct adm__updateRegion *)ptr, "adm:updateRegion");
	case SOAP_TYPE_adm__updateRegionResponse:
		return soap_out_adm__updateRegionResponse(soap, tag, id, (const struct adm__updateRegionResponse *)ptr, "adm:updateRegionResponse");
	case SOAP_TYPE_adm__updateLocalSystem:
		return soap_out_adm__updateLocalSystem(soap, tag, id, (const struct adm__updateLocalSystem *)ptr, "adm:updateLocalSystem");
	case SOAP_TYPE_adm__updateLocalSystemResponse:
		return soap_out_adm__updateLocalSystemResponse(soap, tag, id, (const struct adm__updateLocalSystemResponse *)ptr, "adm:updateLocalSystemResponse");
	case SOAP_TYPE_adm__updateCmsAlarmConfig:
		return soap_out_adm__updateCmsAlarmConfig(soap, tag, id, (const struct adm__updateCmsAlarmConfig *)ptr, "adm:updateCmsAlarmConfig");
	case SOAP_TYPE_adm__updateCmsAlarmConfigResponse:
		return soap_out_adm__updateCmsAlarmConfigResponse(soap, tag, id, (const struct adm__updateCmsAlarmConfigResponse *)ptr, "adm:updateCmsAlarmConfigResponse");
	case SOAP_TYPE_adm__getCmsAlarmConfig:
		return soap_out_adm__getCmsAlarmConfig(soap, tag, id, (const struct adm__getCmsAlarmConfig *)ptr, "adm:getCmsAlarmConfig");
	case SOAP_TYPE_adm__getCmsAlarmConfigResponse:
		return soap_out_adm__getCmsAlarmConfigResponse(soap, tag, id, (const struct adm__getCmsAlarmConfigResponse *)ptr, "adm:getCmsAlarmConfigResponse");
	case SOAP_TYPE_adm__updateCmtsAlarmConfig:
		return soap_out_adm__updateCmtsAlarmConfig(soap, tag, id, (const struct adm__updateCmtsAlarmConfig *)ptr, "adm:updateCmtsAlarmConfig");
	case SOAP_TYPE_adm__updateCmtsAlarmConfigResponse:
		return soap_out_adm__updateCmtsAlarmConfigResponse(soap, tag, id, (const struct adm__updateCmtsAlarmConfigResponse *)ptr, "adm:updateCmtsAlarmConfigResponse");
	case SOAP_TYPE_adm__getCmtsAlarmConfig:
		return soap_out_adm__getCmtsAlarmConfig(soap, tag, id, (const struct adm__getCmtsAlarmConfig *)ptr, "adm:getCmtsAlarmConfig");
	case SOAP_TYPE_adm__getCmtsAlarmConfigResponse:
		return soap_out_adm__getCmtsAlarmConfigResponse(soap, tag, id, (const struct adm__getCmtsAlarmConfigResponse *)ptr, "adm:getCmtsAlarmConfigResponse");
	case SOAP_TYPE_adm__updateHfcAlarmConfig:
		return soap_out_adm__updateHfcAlarmConfig(soap, tag, id, (const struct adm__updateHfcAlarmConfig *)ptr, "adm:updateHfcAlarmConfig");
	case SOAP_TYPE_adm__updateHfcAlarmConfigResponse:
		return soap_out_adm__updateHfcAlarmConfigResponse(soap, tag, id, (const struct adm__updateHfcAlarmConfigResponse *)ptr, "adm:updateHfcAlarmConfigResponse");
	case SOAP_TYPE_adm__getHfcAlarmConfig:
		return soap_out_adm__getHfcAlarmConfig(soap, tag, id, (const struct adm__getHfcAlarmConfig *)ptr, "adm:getHfcAlarmConfig");
	case SOAP_TYPE_adm__getHfcAlarmConfigResponse:
		return soap_out_adm__getHfcAlarmConfigResponse(soap, tag, id, (const struct adm__getHfcAlarmConfigResponse *)ptr, "adm:getHfcAlarmConfigResponse");
	case SOAP_TYPE_adm__updateMtaAlarmConfig:
		return soap_out_adm__updateMtaAlarmConfig(soap, tag, id, (const struct adm__updateMtaAlarmConfig *)ptr, "adm:updateMtaAlarmConfig");
	case SOAP_TYPE_adm__updateMtaAlarmConfigResponse:
		return soap_out_adm__updateMtaAlarmConfigResponse(soap, tag, id, (const struct adm__updateMtaAlarmConfigResponse *)ptr, "adm:updateMtaAlarmConfigResponse");
	case SOAP_TYPE_adm__getMtaAlarmConfig:
		return soap_out_adm__getMtaAlarmConfig(soap, tag, id, (const struct adm__getMtaAlarmConfig *)ptr, "adm:getMtaAlarmConfig");
	case SOAP_TYPE_adm__getMtaAlarmConfigResponse:
		return soap_out_adm__getMtaAlarmConfigResponse(soap, tag, id, (const struct adm__getMtaAlarmConfigResponse *)ptr, "adm:getMtaAlarmConfigResponse");
	case SOAP_TYPE_adm__updateCmsStatusThreshold:
		return soap_out_adm__updateCmsStatusThreshold(soap, tag, id, (const struct adm__updateCmsStatusThreshold *)ptr, "adm:updateCmsStatusThreshold");
	case SOAP_TYPE_adm__updateCmsStatusThresholdResponse:
		return soap_out_adm__updateCmsStatusThresholdResponse(soap, tag, id, (const struct adm__updateCmsStatusThresholdResponse *)ptr, "adm:updateCmsStatusThresholdResponse");
	case SOAP_TYPE_adm__getCmsStatusThreshold:
		return soap_out_adm__getCmsStatusThreshold(soap, tag, id, (const struct adm__getCmsStatusThreshold *)ptr, "adm:getCmsStatusThreshold");
	case SOAP_TYPE_adm__getCmsStatusThresholdResponse:
		return soap_out_adm__getCmsStatusThresholdResponse(soap, tag, id, (const struct adm__getCmsStatusThresholdResponse *)ptr, "adm:getCmsStatusThresholdResponse");
	case SOAP_TYPE_adm__updateCmtsStatusThreshold:
		return soap_out_adm__updateCmtsStatusThreshold(soap, tag, id, (const struct adm__updateCmtsStatusThreshold *)ptr, "adm:updateCmtsStatusThreshold");
	case SOAP_TYPE_adm__updateCmtsStatusThresholdResponse:
		return soap_out_adm__updateCmtsStatusThresholdResponse(soap, tag, id, (const struct adm__updateCmtsStatusThresholdResponse *)ptr, "adm:updateCmtsStatusThresholdResponse");
	case SOAP_TYPE_adm__getCmtsStatusThreshold:
		return soap_out_adm__getCmtsStatusThreshold(soap, tag, id, (const struct adm__getCmtsStatusThreshold *)ptr, "adm:getCmtsStatusThreshold");
	case SOAP_TYPE_adm__getCmtsStatusThresholdResponse:
		return soap_out_adm__getCmtsStatusThresholdResponse(soap, tag, id, (const struct adm__getCmtsStatusThresholdResponse *)ptr, "adm:getCmtsStatusThresholdResponse");
	case SOAP_TYPE_adm__updateChannelStatusThreshold:
		return soap_out_adm__updateChannelStatusThreshold(soap, tag, id, (const struct adm__updateChannelStatusThreshold *)ptr, "adm:updateChannelStatusThreshold");
	case SOAP_TYPE_adm__updateChannelStatusThresholdResponse:
		return soap_out_adm__updateChannelStatusThresholdResponse(soap, tag, id, (const struct adm__updateChannelStatusThresholdResponse *)ptr, "adm:updateChannelStatusThresholdResponse");
	case SOAP_TYPE_adm__getChannelStatusThreshold:
		return soap_out_adm__getChannelStatusThreshold(soap, tag, id, (const struct adm__getChannelStatusThreshold *)ptr, "adm:getChannelStatusThreshold");
	case SOAP_TYPE_adm__getChannelStatusThresholdResponse:
		return soap_out_adm__getChannelStatusThresholdResponse(soap, tag, id, (const struct adm__getChannelStatusThresholdResponse *)ptr, "adm:getChannelStatusThresholdResponse");
	case SOAP_TYPE_adm__updateHfcStatusThreshold:
		return soap_out_adm__updateHfcStatusThreshold(soap, tag, id, (const struct adm__updateHfcStatusThreshold *)ptr, "adm:updateHfcStatusThreshold");
	case SOAP_TYPE_adm__updateHfcStatusThresholdResponse:
		return soap_out_adm__updateHfcStatusThresholdResponse(soap, tag, id, (const struct adm__updateHfcStatusThresholdResponse *)ptr, "adm:updateHfcStatusThresholdResponse");
	case SOAP_TYPE_adm__getHfcStatusThreshold:
		return soap_out_adm__getHfcStatusThreshold(soap, tag, id, (const struct adm__getHfcStatusThreshold *)ptr, "adm:getHfcStatusThreshold");
	case SOAP_TYPE_adm__getHfcStatusThresholdResponse:
		return soap_out_adm__getHfcStatusThresholdResponse(soap, tag, id, (const struct adm__getHfcStatusThresholdResponse *)ptr, "adm:getHfcStatusThresholdResponse");
	case SOAP_TYPE_adm__updateMtaStatusThreshold:
		return soap_out_adm__updateMtaStatusThreshold(soap, tag, id, (const struct adm__updateMtaStatusThreshold *)ptr, "adm:updateMtaStatusThreshold");
	case SOAP_TYPE_adm__updateMtaStatusThresholdResponse:
		return soap_out_adm__updateMtaStatusThresholdResponse(soap, tag, id, (const struct adm__updateMtaStatusThresholdResponse *)ptr, "adm:updateMtaStatusThresholdResponse");
	case SOAP_TYPE_adm__getMtaStatusThreshold:
		return soap_out_adm__getMtaStatusThreshold(soap, tag, id, (const struct adm__getMtaStatusThreshold *)ptr, "adm:getMtaStatusThreshold");
	case SOAP_TYPE_adm__getMtaStatusThresholdResponse:
		return soap_out_adm__getMtaStatusThresholdResponse(soap, tag, id, (const struct adm__getMtaStatusThresholdResponse *)ptr, "adm:getMtaStatusThresholdResponse");
	case SOAP_TYPE_adm__updatePollingIntervals:
		return soap_out_adm__updatePollingIntervals(soap, tag, id, (const struct adm__updatePollingIntervals *)ptr, "adm:updatePollingIntervals");
	case SOAP_TYPE_adm__updatePollingIntervalsResponse:
		return soap_out_adm__updatePollingIntervalsResponse(soap, tag, id, (const struct adm__updatePollingIntervalsResponse *)ptr, "adm:updatePollingIntervalsResponse");
	case SOAP_TYPE_adm__getPollingIntervals:
		return soap_out_adm__getPollingIntervals(soap, tag, id, (const struct adm__getPollingIntervals *)ptr, "adm:getPollingIntervals");
	case SOAP_TYPE_adm__getPollingIntervalsResponse:
		return soap_out_adm__getPollingIntervalsResponse(soap, tag, id, (const struct adm__getPollingIntervalsResponse *)ptr, "adm:getPollingIntervalsResponse");
	case SOAP_TYPE_adm__deleteCms:
		return soap_out_adm__deleteCms(soap, tag, id, (const struct adm__deleteCms *)ptr, "adm:deleteCms");
	case SOAP_TYPE_adm__deleteCmsResponse:
		return soap_out_adm__deleteCmsResponse(soap, tag, id, (const struct adm__deleteCmsResponse *)ptr, "adm:deleteCmsResponse");
	case SOAP_TYPE_adm__addCms:
		return soap_out_adm__addCms(soap, tag, id, (const struct adm__addCms *)ptr, "adm:addCms");
	case SOAP_TYPE_adm__addCmsResponse:
		return soap_out_adm__addCmsResponse(soap, tag, id, (const struct adm__addCmsResponse *)ptr, "adm:addCmsResponse");
	case SOAP_TYPE_adm__updateCms:
		return soap_out_adm__updateCms(soap, tag, id, (const struct adm__updateCms *)ptr, "adm:updateCms");
	case SOAP_TYPE_adm__updateCmsResponse:
		return soap_out_adm__updateCmsResponse(soap, tag, id, (const struct adm__updateCmsResponse *)ptr, "adm:updateCmsResponse");
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes:
		return soap_out_adm__updateCmtsAllSnmpV2CAttributes(soap, tag, id, (const struct adm__updateCmtsAllSnmpV2CAttributes *)ptr, "adm:updateCmtsAllSnmpV2CAttributes");
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse:
		return soap_out_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, tag, id, (const struct adm__updateCmtsAllSnmpV2CAttributesResponse *)ptr, "adm:updateCmtsAllSnmpV2CAttributesResponse");
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes:
		return soap_out_adm__addCmtsAllSnmpV2CAttributes(soap, tag, id, (const struct adm__addCmtsAllSnmpV2CAttributes *)ptr, "adm:addCmtsAllSnmpV2CAttributes");
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse:
		return soap_out_adm__addCmtsAllSnmpV2CAttributesResponse(soap, tag, id, (const struct adm__addCmtsAllSnmpV2CAttributesResponse *)ptr, "adm:addCmtsAllSnmpV2CAttributesResponse");
	case SOAP_TYPE_adm__deleteCmts:
		return soap_out_adm__deleteCmts(soap, tag, id, (const struct adm__deleteCmts *)ptr, "adm:deleteCmts");
	case SOAP_TYPE_adm__deleteCmtsResponse:
		return soap_out_adm__deleteCmtsResponse(soap, tag, id, (const struct adm__deleteCmtsResponse *)ptr, "adm:deleteCmtsResponse");
	case SOAP_TYPE_adm__addCmts:
		return soap_out_adm__addCmts(soap, tag, id, (const struct adm__addCmts *)ptr, "adm:addCmts");
	case SOAP_TYPE_adm__addCmtsResponse:
		return soap_out_adm__addCmtsResponse(soap, tag, id, (const struct adm__addCmtsResponse *)ptr, "adm:addCmtsResponse");
	case SOAP_TYPE_adm__updateCmts:
		return soap_out_adm__updateCmts(soap, tag, id, (const struct adm__updateCmts *)ptr, "adm:updateCmts");
	case SOAP_TYPE_adm__updateCmtsResponse:
		return soap_out_adm__updateCmtsResponse(soap, tag, id, (const struct adm__updateCmtsResponse *)ptr, "adm:updateCmtsResponse");
	case SOAP_TYPE_PointerTons1__ConfigDownloadT:
		return soap_out_PointerTons1__ConfigDownloadT(soap, tag, id, (ns1__ConfigDownloadT *const*)ptr, "ns1:ConfigDownloadT");
	case SOAP_TYPE_PointerTons1__LocalSystemT:
		return soap_out_PointerTons1__LocalSystemT(soap, tag, id, (ns1__LocalSystemT *const*)ptr, "ns1:LocalSystemT");
	case SOAP_TYPE_PointerTons1__CmsStatusThresholdT:
		return soap_out_PointerTons1__CmsStatusThresholdT(soap, tag, id, (ns1__CmsStatusThresholdT *const*)ptr, "ns1:CmsStatusThresholdT");
	case SOAP_TYPE_PointerTons1__CmtsStatusThresholdT:
		return soap_out_PointerTons1__CmtsStatusThresholdT(soap, tag, id, (ns1__CmtsStatusThresholdT *const*)ptr, "ns1:CmtsStatusThresholdT");
	case SOAP_TYPE_PointerTons1__ChannelStatusThresholdT:
		return soap_out_PointerTons1__ChannelStatusThresholdT(soap, tag, id, (ns1__ChannelStatusThresholdT *const*)ptr, "ns1:ChannelStatusThresholdT");
	case SOAP_TYPE_PointerTons1__HfcStatusThresholdT:
		return soap_out_PointerTons1__HfcStatusThresholdT(soap, tag, id, (ns1__HfcStatusThresholdT *const*)ptr, "ns1:HfcStatusThresholdT");
	case SOAP_TYPE_PointerTons1__MtaStatusThresholdT:
		return soap_out_PointerTons1__MtaStatusThresholdT(soap, tag, id, (ns1__MtaStatusThresholdT *const*)ptr, "ns1:MtaStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfSnmpV2CAttributesT:
		return soap_out_PointerToArrayOfSnmpV2CAttributesT(soap, tag, id, (ArrayOfSnmpV2CAttributesT *const*)ptr, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT:
		return soap_out_PointerToPointerTons1__CmStatusSummaryT(soap, tag, id, (ns1__CmStatusSummaryT **const*)ptr, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerTons1__CmStatusSummaryT:
		return soap_out_PointerTons1__CmStatusSummaryT(soap, tag, id, (ns1__CmStatusSummaryT *const*)ptr, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT:
		return soap_out_PointerToPointerTons1__MtaStatusSummaryT(soap, tag, id, (ns1__MtaStatusSummaryT **const*)ptr, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__MtaStatusSummaryT:
		return soap_out_PointerTons1__MtaStatusSummaryT(soap, tag, id, (ns1__MtaStatusSummaryT *const*)ptr, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT:
		return soap_out_PointerToPointerTons1__HfcStatusSummaryT(soap, tag, id, (ns1__HfcStatusSummaryT **const*)ptr, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerTons1__HfcStatusSummaryT:
		return soap_out_PointerTons1__HfcStatusSummaryT(soap, tag, id, (ns1__HfcStatusSummaryT *const*)ptr, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT:
		return soap_out_PointerToPointerTons1__AlarmTypeConfigT(soap, tag, id, (ns1__AlarmTypeConfigT **const*)ptr, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT:
		return soap_out_PointerToPointerTons1__AggregateStatusThresholdT(soap, tag, id, (ns1__AggregateStatusThresholdT **const*)ptr, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AggregateStatusThresholdT:
		return soap_out_PointerTons1__AggregateStatusThresholdT(soap, tag, id, (ns1__AggregateStatusThresholdT *const*)ptr, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT:
		return soap_out_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, (ns1__AlarmBasedStatusThresholdT **const*)ptr, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT:
		return soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, (ns1__AlarmBasedStatusThresholdT *const*)ptr, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerToPointerTons1__UserT:
		return soap_out_PointerToPointerTons1__UserT(soap, tag, id, (ns1__UserT **const*)ptr, "ns1:UserT");
	case SOAP_TYPE_PointerTons1__UserT:
		return soap_out_PointerTons1__UserT(soap, tag, id, (ns1__UserT *const*)ptr, "ns1:UserT");
	case SOAP_TYPE_PointerToPointerTons1__RoleT:
		return soap_out_PointerToPointerTons1__RoleT(soap, tag, id, (ns1__RoleT **const*)ptr, "ns1:RoleT");
	case SOAP_TYPE_PointerTons1__RoleT:
		return soap_out_PointerTons1__RoleT(soap, tag, id, (ns1__RoleT *const*)ptr, "ns1:RoleT");
	case SOAP_TYPE_PointerToPointerTons1__ApplicationDomainT:
		return soap_out_PointerToPointerTons1__ApplicationDomainT(soap, tag, id, (ns1__ApplicationDomainT **const*)ptr, "ns1:ApplicationDomainT");
	case SOAP_TYPE_PointerTons1__ApplicationDomainT:
		return soap_out_PointerTons1__ApplicationDomainT(soap, tag, id, (ns1__ApplicationDomainT *const*)ptr, "ns1:ApplicationDomainT");
	case SOAP_TYPE_PointerToPointerTons1__UserAccessT:
		return soap_out_PointerToPointerTons1__UserAccessT(soap, tag, id, (ns1__UserAccessT **const*)ptr, "ns1:UserAccessT");
	case SOAP_TYPE_PointerTons1__UserAccessT:
		return soap_out_PointerTons1__UserAccessT(soap, tag, id, (ns1__UserAccessT *const*)ptr, "ns1:UserAccessT");
	case SOAP_TYPE_PointerToPointerTons1__CMSLineT:
		return soap_out_PointerToPointerTons1__CMSLineT(soap, tag, id, (ns1__CMSLineT **const*)ptr, "ns1:CMSLineT");
	case SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT:
		return soap_out_PointerToPointerTons1__CTEQueryInputT(soap, tag, id, (ns1__CTEQueryInputT **const*)ptr, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerTons1__CTEQueryInputT:
		return soap_out_PointerTons1__CTEQueryInputT(soap, tag, id, (ns1__CTEQueryInputT *const*)ptr, "ns1:CTEQueryInputT");
	case SOAP_TYPE_PointerToPointerTons1__CTEDataT:
		return soap_out_PointerToPointerTons1__CTEDataT(soap, tag, id, (ns1__CTEDataT **const*)ptr, "ns1:CTEDataT");
	case SOAP_TYPE_PointerTons1__CTEDataT:
		return soap_out_PointerTons1__CTEDataT(soap, tag, id, (ns1__CTEDataT *const*)ptr, "ns1:CTEDataT");
	case SOAP_TYPE_PointerToPointerTons1__CTECustomerT:
		return soap_out_PointerToPointerTons1__CTECustomerT(soap, tag, id, (ns1__CTECustomerT **const*)ptr, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT:
		return soap_out_PointerToPointerTons1__CmPerformanceHistoryT(soap, tag, id, (ns1__CmPerformanceHistoryT **const*)ptr, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerTons1__CmPerformanceHistoryT:
		return soap_out_PointerTons1__CmPerformanceHistoryT(soap, tag, id, (ns1__CmPerformanceHistoryT *const*)ptr, "ns1:CmPerformanceHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT:
		return soap_out_PointerToPointerTons1__MtaPingStatusHistoryT(soap, tag, id, (ns1__MtaPingStatusHistoryT **const*)ptr, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT:
		return soap_out_PointerTons1__MtaPingStatusHistoryT(soap, tag, id, (ns1__MtaPingStatusHistoryT *const*)ptr, "ns1:MtaPingStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT:
		return soap_out_PointerToPointerTons1__MtaProvStatusHistoryT(soap, tag, id, (ns1__MtaProvStatusHistoryT **const*)ptr, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT:
		return soap_out_PointerTons1__MtaProvStatusHistoryT(soap, tag, id, (ns1__MtaProvStatusHistoryT *const*)ptr, "ns1:MtaProvStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT:
		return soap_out_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, tag, id, (ns1__MtaAvailabilityHistoryT **const*)ptr, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT:
		return soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, tag, id, (ns1__MtaAvailabilityHistoryT *const*)ptr, "ns1:MtaAvailabilityHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT:
		return soap_out_PointerToPointerTons1__CmStatusHistoryT(soap, tag, id, (ns1__CmStatusHistoryT **const*)ptr, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerTons1__CmStatusHistoryT:
		return soap_out_PointerTons1__CmStatusHistoryT(soap, tag, id, (ns1__CmStatusHistoryT *const*)ptr, "ns1:CmStatusHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT:
		return soap_out_PointerToPointerTons1__GenericCountsHistoryT(soap, tag, id, (ns1__GenericCountsHistoryT **const*)ptr, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerTons1__GenericCountsHistoryT:
		return soap_out_PointerTons1__GenericCountsHistoryT(soap, tag, id, (ns1__GenericCountsHistoryT *const*)ptr, "ns1:GenericCountsHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__QueryStateT:
		return soap_out_PointerToPointerTons1__QueryStateT(soap, tag, id, (ns1__QueryStateT **const*)ptr, "ns1:QueryStateT");
	case SOAP_TYPE_PointerTons1__QueryStateT:
		return soap_out_PointerTons1__QueryStateT(soap, tag, id, (ns1__QueryStateT *const*)ptr, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToPointerTons1__ScrollPageT:
		return soap_out_PointerToPointerTons1__ScrollPageT(soap, tag, id, (ns1__ScrollPageT **const*)ptr, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ScrollPageT:
		return soap_out_PointerTons1__ScrollPageT(soap, tag, id, (ns1__ScrollPageT *const*)ptr, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT:
		return soap_out_PointerToPointerTons1__AlarmHistoryT(soap, tag, id, (ns1__AlarmHistoryT **const*)ptr, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerTons1__AlarmHistoryT:
		return soap_out_PointerTons1__AlarmHistoryT(soap, tag, id, (ns1__AlarmHistoryT *const*)ptr, "ns1:AlarmHistoryT");
	case SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT:
		return soap_out_PointerToPointerTons1__HistoricalAlarmT(soap, tag, id, (ns1__HistoricalAlarmT **const*)ptr, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT:
		return soap_out_PointerToPointerTons1__CurrentAlarmT(soap, tag, id, (ns1__CurrentAlarmT **const*)ptr, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToPointerTons1__EmtaT:
		return soap_out_PointerToPointerTons1__EmtaT(soap, tag, id, (ns1__EmtaT **const*)ptr, "ns1:EmtaT");
	case SOAP_TYPE_PointerToPointerTons1__CableModemT:
		return soap_out_PointerToPointerTons1__CableModemT(soap, tag, id, (ns1__CableModemT **const*)ptr, "ns1:CableModemT");
	case SOAP_TYPE_PointerToPointerTons1__HfcT:
		return soap_out_PointerToPointerTons1__HfcT(soap, tag, id, (ns1__HfcT **const*)ptr, "ns1:HfcT");
	case SOAP_TYPE_PointerTons1__HfcT:
		return soap_out_PointerTons1__HfcT(soap, tag, id, (ns1__HfcT *const*)ptr, "ns1:HfcT");
	case SOAP_TYPE_PointerToPointerTons1__ChannelT:
		return soap_out_PointerToPointerTons1__ChannelT(soap, tag, id, (ns1__ChannelT **const*)ptr, "ns1:ChannelT");
	case SOAP_TYPE_PointerTons1__ChannelT:
		return soap_out_PointerTons1__ChannelT(soap, tag, id, (ns1__ChannelT *const*)ptr, "ns1:ChannelT");
	case SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT:
		return soap_out_PointerToPointerTons1__SnmpV2CAttributesT(soap, tag, id, (ns1__SnmpV2CAttributesT **const*)ptr, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerTons1__SnmpV2CAttributesT:
		return soap_out_PointerTons1__SnmpV2CAttributesT(soap, tag, id, (ns1__SnmpV2CAttributesT *const*)ptr, "ns1:SnmpV2CAttributesT");
	case SOAP_TYPE_PointerToPointerTons1__CmtsT:
		return soap_out_PointerToPointerTons1__CmtsT(soap, tag, id, (ns1__CmtsT **const*)ptr, "ns1:CmtsT");
	case SOAP_TYPE_PointerTons1__CmtsT:
		return soap_out_PointerTons1__CmtsT(soap, tag, id, (ns1__CmtsT *const*)ptr, "ns1:CmtsT");
	case SOAP_TYPE_PointerToPointerTons1__CmsT:
		return soap_out_PointerToPointerTons1__CmsT(soap, tag, id, (ns1__CmsT **const*)ptr, "ns1:CmsT");
	case SOAP_TYPE_PointerTons1__CmsT:
		return soap_out_PointerTons1__CmsT(soap, tag, id, (ns1__CmsT *const*)ptr, "ns1:CmsT");
	case SOAP_TYPE_PointerToPointerTons1__BladeT:
		return soap_out_PointerToPointerTons1__BladeT(soap, tag, id, (ns1__BladeT **const*)ptr, "ns1:BladeT");
	case SOAP_TYPE_PointerTons1__BladeT:
		return soap_out_PointerTons1__BladeT(soap, tag, id, (ns1__BladeT *const*)ptr, "ns1:BladeT");
	case SOAP_TYPE_PointerToPointerTons1__MarketT:
		return soap_out_PointerToPointerTons1__MarketT(soap, tag, id, (ns1__MarketT **const*)ptr, "ns1:MarketT");
	case SOAP_TYPE_PointerTons1__MarketT:
		return soap_out_PointerTons1__MarketT(soap, tag, id, (ns1__MarketT *const*)ptr, "ns1:MarketT");
	case SOAP_TYPE_PointerToPointerTons1__RegionT:
		return soap_out_PointerToPointerTons1__RegionT(soap, tag, id, (ns1__RegionT **const*)ptr, "ns1:RegionT");
	case SOAP_TYPE_PointerTons1__RegionT:
		return soap_out_PointerTons1__RegionT(soap, tag, id, (ns1__RegionT *const*)ptr, "ns1:RegionT");
	case SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT:
		return soap_out_PointerToArrayOfHistoricalAlarmsT(soap, tag, id, (ArrayOfHistoricalAlarmsT *const*)ptr, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerToArrayOfCurrentAlarmsT:
		return soap_out_PointerToArrayOfCurrentAlarmsT(soap, tag, id, (ArrayOfCurrentAlarmsT *const*)ptr, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerToArrayOfCmStatusSummaryT:
		return soap_out_PointerToArrayOfCmStatusSummaryT(soap, tag, id, (ArrayOfCmStatusSummaryT *const*)ptr, "ns1:CmStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT:
		return soap_out_PointerToArrayOfHfcStatusSummaryT(soap, tag, id, (ArrayOfHfcStatusSummaryT *const*)ptr, "ns1:HfcStatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfQueryStateT:
		return soap_out_PointerToArrayOfQueryStateT(soap, tag, id, (ArrayOfQueryStateT *const*)ptr, "ns1:QueryStateT");
	case SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT:
		return soap_out_PointerToArrayOfMtaStatusSummaryT(soap, tag, id, (ArrayOfMtaStatusSummaryT *const*)ptr, "ns1:MtaStatusSummaryT");
	case SOAP_TYPE_PointerTons1__StatusSummaryT:
		return soap_out_PointerTons1__StatusSummaryT(soap, tag, id, (ns1__StatusSummaryT *const*)ptr, "ns1:StatusSummaryT");
	case SOAP_TYPE_PointerToArrayOfUserT:
		return soap_out_PointerToArrayOfUserT(soap, tag, id, (ArrayOfUserT *const*)ptr, "ns1:UserT");
	case SOAP_TYPE_PointerToArrayOfRoleT:
		return soap_out_PointerToArrayOfRoleT(soap, tag, id, (ArrayOfRoleT *const*)ptr, "ns1:RoleT");
	case SOAP_TYPE_PointerTons1__PollingIntervalsT:
		return soap_out_PointerTons1__PollingIntervalsT(soap, tag, id, (ns1__PollingIntervalsT *const*)ptr, "ns1:PollingIntervalsT");
	case SOAP_TYPE_PointerTons1__HfcAlarmConfigT:
		return soap_out_PointerTons1__HfcAlarmConfigT(soap, tag, id, (ns1__HfcAlarmConfigT *const*)ptr, "ns1:HfcAlarmConfigT");
	case SOAP_TYPE_PointerTons1__MtaAlarmConfigT:
		return soap_out_PointerTons1__MtaAlarmConfigT(soap, tag, id, (ns1__MtaAlarmConfigT *const*)ptr, "ns1:MtaAlarmConfigT");
	case SOAP_TYPE_PointerTons1__CmtsAlarmConfigT:
		return soap_out_PointerTons1__CmtsAlarmConfigT(soap, tag, id, (ns1__CmtsAlarmConfigT *const*)ptr, "ns1:CmtsAlarmConfigT");
	case SOAP_TYPE_PointerTons1__CmsAlarmConfigT:
		return soap_out_PointerTons1__CmsAlarmConfigT(soap, tag, id, (ns1__CmsAlarmConfigT *const*)ptr, "ns1:CmsAlarmConfigT");
	case SOAP_TYPE_PointerTons1__CmPerformanceConfigT:
		return soap_out_PointerTons1__CmPerformanceConfigT(soap, tag, id, (ns1__CmPerformanceConfigT *const*)ptr, "ns1:CmPerformanceConfigT");
	case SOAP_TYPE_PointerTons1__AlarmTypeConfigT:
		return soap_out_PointerTons1__AlarmTypeConfigT(soap, tag, id, (ns1__AlarmTypeConfigT *const*)ptr, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT:
		return soap_out_PointerToArrayOfAlarmTypeConfigT(soap, tag, id, (ArrayOfAlarmTypeConfigT *const*)ptr, "ns1:AlarmTypeConfigT");
	case SOAP_TYPE_PointerTons1__HfcPowerTresholdT:
		return soap_out_PointerTons1__HfcPowerTresholdT(soap, tag, id, (ns1__HfcPowerTresholdT *const*)ptr, "ns1:HfcPowerTresholdT");
	case SOAP_TYPE_PointerTons1__AggregateMtaTresholdT:
		return soap_out_PointerTons1__AggregateMtaTresholdT(soap, tag, id, (ns1__AggregateMtaTresholdT *const*)ptr, "ns1:AggregateMtaTresholdT");
	case SOAP_TYPE_PointerTons1__SoakWindowT:
		return soap_out_PointerTons1__SoakWindowT(soap, tag, id, (ns1__SoakWindowT *const*)ptr, "ns1:SoakWindowT");
	case SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT:
		return soap_out_PointerTons1__AggregateCmOfflineTresholdT(soap, tag, id, (ns1__AggregateCmOfflineTresholdT *const*)ptr, "ns1:AggregateCmOfflineTresholdT");
	case SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT:
		return soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, tag, id, (ArrayOfAggregateStatusThresholdT *const*)ptr, "ns1:AggregateStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT:
		return soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, tag, id, (ArrayOfAlarmStatusThresholdT *const*)ptr, "ns1:AlarmBasedStatusThresholdT");
	case SOAP_TYPE_PointerToArrayOfApplicationDomainT:
		return soap_out_PointerToArrayOfApplicationDomainT(soap, tag, id, (ArrayOfApplicationDomainT *const*)ptr, "ns1:ApplicationDomainT");
	case SOAP_TYPE_PointerToArrayOfUserAccessT:
		return soap_out_PointerToArrayOfUserAccessT(soap, tag, id, (ArrayOfUserAccessT *const*)ptr, "ns1:UserAccessT");
	case SOAP_TYPE_PointerTons1__CMSLineT:
		return soap_out_PointerTons1__CMSLineT(soap, tag, id, (ns1__CMSLineT *const*)ptr, "ns1:CMSLineT");
	case SOAP_TYPE_PointerTons1__CTEAbstractNameT:
		return soap_out_PointerTons1__CTEAbstractNameT(soap, tag, id, (ns1__CTEAbstractNameT *const*)ptr, "ns1:CTEAbstractNameT");
	case SOAP_TYPE_PointerTons1__CTEAbstractMacT:
		return soap_out_PointerTons1__CTEAbstractMacT(soap, tag, id, (ns1__CTEAbstractMacT *const*)ptr, "ns1:CTEAbstractMacT");
	case SOAP_TYPE_PointerTons1__CTECustomerT:
		return soap_out_PointerTons1__CTECustomerT(soap, tag, id, (ns1__CTECustomerT *const*)ptr, "ns1:CTECustomerT");
	case SOAP_TYPE_PointerToshort:
		return soap_out_PointerToshort(soap, tag, id, (short *const*)ptr, "xsd:short");
	case SOAP_TYPE_PointerTons1__CmPerformanceT:
		return soap_out_PointerTons1__CmPerformanceT(soap, tag, id, (ns1__CmPerformanceT *const*)ptr, "ns1:CmPerformanceT");
	case SOAP_TYPE_PointerTons1__MtaPingStatusT:
		return soap_out_PointerTons1__MtaPingStatusT(soap, tag, id, (ns1__MtaPingStatusT *const*)ptr, "ns1:MtaPingStatusT");
	case SOAP_TYPE_PointerTons1__MtaProvStatusT:
		return soap_out_PointerTons1__MtaProvStatusT(soap, tag, id, (ns1__MtaProvStatusT *const*)ptr, "ns1:MtaProvStatusT");
	case SOAP_TYPE_PointerTons1__MtaAvailabilityT:
		return soap_out_PointerTons1__MtaAvailabilityT(soap, tag, id, (ns1__MtaAvailabilityT *const*)ptr, "ns1:MtaAvailabilityT");
	case SOAP_TYPE_PointerTons1__CmStatusT:
		return soap_out_PointerTons1__CmStatusT(soap, tag, id, (ns1__CmStatusT *const*)ptr, "ns1:CmStatusT");
	case SOAP_TYPE_PointerToArrayOfScrollPageT:
		return soap_out_PointerToArrayOfScrollPageT(soap, tag, id, (ArrayOfScrollPageT *const*)ptr, "ns1:ScrollPageT");
	case SOAP_TYPE_PointerTons1__ResultBatchT:
		return soap_out_PointerTons1__ResultBatchT(soap, tag, id, (ns1__ResultBatchT *const*)ptr, "ns1:ResultBatchT");
	case SOAP_TYPE_PointerTons1__EmtaT:
		return soap_out_PointerTons1__EmtaT(soap, tag, id, (ns1__EmtaT *const*)ptr, "ns1:EmtaT");
	case SOAP_TYPE_PointerTons1__CableModemT:
		return soap_out_PointerTons1__CableModemT(soap, tag, id, (ns1__CableModemT *const*)ptr, "ns1:CableModemT");
	case SOAP_TYPE_PointerTons1__HistoricalAlarmT:
		return soap_out_PointerTons1__HistoricalAlarmT(soap, tag, id, (ns1__HistoricalAlarmT *const*)ptr, "ns1:HistoricalAlarmT");
	case SOAP_TYPE_PointerTons1__CurrentAlarmT:
		return soap_out_PointerTons1__CurrentAlarmT(soap, tag, id, (ns1__CurrentAlarmT *const*)ptr, "ns1:CurrentAlarmT");
	case SOAP_TYPE_PointerTons1__AbstractAlarmT:
		return soap_out_PointerTons1__AbstractAlarmT(soap, tag, id, (ns1__AbstractAlarmT *const*)ptr, "ns1:AbstractAlarmT");
	case SOAP_TYPE_PointerToxsd__integer:
		return soap_out_PointerToxsd__integer(soap, tag, id, (std::string *const*)ptr, "xsd:integer");
	case SOAP_TYPE_PointerTons1__GenericCountsT:
		return soap_out_PointerTons1__GenericCountsT(soap, tag, id, (ns1__GenericCountsT *const*)ptr, "ns1:GenericCountsT");
	case SOAP_TYPE_PointerTons1__TopoHierarchyKeyT:
		return soap_out_PointerTons1__TopoHierarchyKeyT(soap, tag, id, (ns1__TopoHierarchyKeyT *const*)ptr, "ns1:TopoHierarchyKeyT");
	case SOAP_TYPE_PointerTostd__string:
		return soap_out_PointerTostd__string(soap, tag, id, (std::string *const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, "xsd:QName", id, (char**)&ptr, NULL);
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char**)&ptr, "xsd:string");
	}
	return SOAP_OK;
}

#ifdef __cplusplus
}
#endif
#endif

#ifndef WITH_NOIDREF

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__EventMessageT:
		((ns1__EventMessageT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		((ns1__HistoricalAlarmsRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		((ns1__CurrentAlarmsRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		((ns1__CmStatusSummaryRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		((ns1__HfcStatusSummaryRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		((ns1__MtaStatusSummaryRespT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		((ArrayOfCmStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		((ns1__CmStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		((ArrayOfMtaStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		((ns1__MtaStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		((ArrayOfHfcStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		((ns1__HfcStatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__StatusSummaryT:
		((ns1__StatusSummaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaDataT:
		((ns1__MtaDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmDataT:
		((ns1__CmDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsCmDataT:
		((ns1__CmtsCmDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ConfigDownloadT:
		((ns1__ConfigDownloadT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		((ns1__CmPerformanceConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		((ns1__CmsAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		((ns1__CmtsAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		((ns1__MtaAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		((ArrayOfAlarmTypeConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		((ns1__AlarmTypeConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		((ns1__HfcAlarmConfigT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		((ns1__HfcPowerTresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		((ns1__AggregateMtaTresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		((ns1__AggregateCmOfflineTresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SoakWindowT:
		((ns1__SoakWindowT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		((ns1__CmsStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		((ns1__CmtsStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		((ns1__ChannelStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		((ns1__HfcStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		((ns1__MtaStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		((ArrayOfAggregateStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		((ns1__AggregateStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		((ArrayOfAlarmStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		((ns1__AlarmBasedStatusThresholdT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__PollingIntervalsT:
		((ns1__PollingIntervalsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfUserT:
		((ArrayOfUserT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserT:
		((ns1__UserT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfRoleT:
		((ArrayOfRoleT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RoleT:
		((ns1__RoleT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfApplicationDomainT:
		((ArrayOfApplicationDomainT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ApplicationDomainT:
		((ns1__ApplicationDomainT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfUserAccessT:
		((ArrayOfUserAccessT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__UserAccessT:
		((ns1__UserAccessT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CMSResultT:
		((ns1__CMSResultT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCMSLineT:
		((ArrayOfCMSLineT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CMSLineT:
		((ns1__CMSLineT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		((ArrayOfCTEQueryInputT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEQueryInputT:
		((ns1__CTEQueryInputT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTEDataT:
		((ArrayOfCTEDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEDataT:
		((ns1__CTEDataT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		((ns1__CTEAbstractNameT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		((ns1__CTEAbstractMacT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCTECustomerT:
		((ArrayOfCTECustomerT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CTECustomerT:
		((ns1__CTECustomerT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		((ArrayOfCmPerformanceHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		((ns1__CmCurrentPerformanceT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		((ns1__CmPerformanceHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmPerformanceT:
		((ns1__CmPerformanceT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		((ArrayOfMtaPingStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		((ns1__MtaPingStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaPingStatusT:
		((ns1__MtaPingStatusT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		((ArrayOfMtaProvStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		((ns1__MtaProvStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaProvStatusT:
		((ns1__MtaProvStatusT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		((ArrayOfMtaAvailabilityHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		((ns1__MtaAvailabilityHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		((ns1__MtaAvailabilityT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		((ArrayOfCmStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		((ns1__CmStatusHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmStatusT:
		((ns1__CmStatusT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		((ArrayOfGenericCountsHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		((ns1__GenericCountsHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfQueryStateT:
		((ArrayOfQueryStateT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__QueryStateT:
		((ns1__QueryStateT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfScrollPageT:
		((ArrayOfScrollPageT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ScrollPageT:
		((ns1__ScrollPageT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		((ns1__MappedEuDevicesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		((ArrayOfAlarmHistoriesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		((ArrayOfHistoricalAlarmsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		((ArrayOfCurrentAlarmsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfEmtasT:
		((ArrayOfEmtasT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCableModemsT:
		((ArrayOfCableModemsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfHfcsT:
		((ArrayOfHfcsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfChannelsT:
		((ArrayOfChannelsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		((ArrayOfSnmpV2CAttributesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmtsesT:
		((ArrayOfCmtsesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfCmsesT:
		((ArrayOfCmsesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfBladesT:
		((ArrayOfBladesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfMarketsT:
		((ArrayOfMarketsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ArrayOfRegionsT:
		((ArrayOfRegionsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AlarmHistoryT:
		((ns1__AlarmHistoryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		((ns1__HistoricalAlarmDetailsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		((ns1__HistoricalAlarmT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		((ns1__CurrentAlarmDetailsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CurrentAlarmT:
		((ns1__CurrentAlarmT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__AbstractAlarmT:
		((ns1__AbstractAlarmT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EmtaSecondaryT:
		((ns1__EmtaSecondaryT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__EmtaT:
		((ns1__EmtaT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CableModemT:
		((ns1__CableModemT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__HfcT:
		((ns1__HfcT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ChannelT:
		((ns1__ChannelT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmtsT:
		((ns1__CmtsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__CmsT:
		((ns1__CmsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__BladeT:
		((ns1__BladeT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__MarketT:
		((ns1__MarketT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__RegionT:
		((ns1__RegionT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__LocalSystemT:
		((ns1__LocalSystemT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		((ns1__TopoHierarchyKeyT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__ResultBatchT:
		((ns1__ResultBatchT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__InputTimeT:
		((ns1__InputTimeT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__GenericCountsT:
		((ns1__GenericCountsT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		((ns1__SnmpV2CAttributesT *)ptr)->soap_serialize(soap);
		break;
	case SOAP_TYPE__SOAP_ENC__arrayType:
		soap_serialize__SOAP_ENC__arrayType(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_xsd__integer:
		soap_serialize_xsd__integer(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_std__string:
		soap_serialize_std__string(soap, (const std::string *)ptr);
		break;
	case SOAP_TYPE_adm__getConfig:
		soap_serialize_adm__getConfig(soap, (const struct adm__getConfig *)ptr);
		break;
	case SOAP_TYPE_adm__getConfigResponse:
		soap_serialize_adm__getConfigResponse(soap, (const struct adm__getConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__downloadConfigFromParent:
		soap_serialize_adm__downloadConfigFromParent(soap, (const struct adm__downloadConfigFromParent *)ptr);
		break;
	case SOAP_TYPE_adm__downloadConfigFromParentResponse:
		soap_serialize_adm__downloadConfigFromParentResponse(soap, (const struct adm__downloadConfigFromParentResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateRole:
		soap_serialize_adm__updateRole(soap, (const struct adm__updateRole *)ptr);
		break;
	case SOAP_TYPE_adm__updateRoleResponse:
		soap_serialize_adm__updateRoleResponse(soap, (const struct adm__updateRoleResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getRole:
		soap_serialize_adm__getRole(soap, (const struct adm__getRole *)ptr);
		break;
	case SOAP_TYPE_adm__getRoleResponse:
		soap_serialize_adm__getRoleResponse(soap, (const struct adm__getRoleResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getRoles:
		soap_serialize_adm__getRoles(soap, (const struct adm__getRoles *)ptr);
		break;
	case SOAP_TYPE_adm__getRolesResponse:
		soap_serialize_adm__getRolesResponse(soap, (const struct adm__getRolesResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateUserPassword:
		soap_serialize_adm__updateUserPassword(soap, (const struct adm__updateUserPassword *)ptr);
		break;
	case SOAP_TYPE_adm__updateUserPasswordResponse:
		soap_serialize_adm__updateUserPasswordResponse(soap, (const struct adm__updateUserPasswordResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateUser:
		soap_serialize_adm__updateUser(soap, (const struct adm__updateUser *)ptr);
		break;
	case SOAP_TYPE_adm__updateUserResponse:
		soap_serialize_adm__updateUserResponse(soap, (const struct adm__updateUserResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getUser:
		soap_serialize_adm__getUser(soap, (const struct adm__getUser *)ptr);
		break;
	case SOAP_TYPE_adm__getUserResponse:
		soap_serialize_adm__getUserResponse(soap, (const struct adm__getUserResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getUsers:
		soap_serialize_adm__getUsers(soap, (const struct adm__getUsers *)ptr);
		break;
	case SOAP_TYPE_adm__getUsersResponse:
		soap_serialize_adm__getUsersResponse(soap, (const struct adm__getUsersResponse *)ptr);
		break;
	case SOAP_TYPE_adm__addUser:
		soap_serialize_adm__addUser(soap, (const struct adm__addUser *)ptr);
		break;
	case SOAP_TYPE_adm__addUserResponse:
		soap_serialize_adm__addUserResponse(soap, (const struct adm__addUserResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmPerfConfig:
		soap_serialize_adm__updateCmPerfConfig(soap, (const struct adm__updateCmPerfConfig *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmPerfConfigResponse:
		soap_serialize_adm__updateCmPerfConfigResponse(soap, (const struct adm__updateCmPerfConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getCmPerfConfig:
		soap_serialize_adm__getCmPerfConfig(soap, (const struct adm__getCmPerfConfig *)ptr);
		break;
	case SOAP_TYPE_adm__getCmPerfConfigResponse:
		soap_serialize_adm__getCmPerfConfigResponse(soap, (const struct adm__getCmPerfConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__deleteBlade:
		soap_serialize_adm__deleteBlade(soap, (const struct adm__deleteBlade *)ptr);
		break;
	case SOAP_TYPE_adm__deleteBladeResponse:
		soap_serialize_adm__deleteBladeResponse(soap, (const struct adm__deleteBladeResponse *)ptr);
		break;
	case SOAP_TYPE_adm__addBlade:
		soap_serialize_adm__addBlade(soap, (const struct adm__addBlade *)ptr);
		break;
	case SOAP_TYPE_adm__addBladeResponse:
		soap_serialize_adm__addBladeResponse(soap, (const struct adm__addBladeResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateBlade:
		soap_serialize_adm__updateBlade(soap, (const struct adm__updateBlade *)ptr);
		break;
	case SOAP_TYPE_adm__updateBladeResponse:
		soap_serialize_adm__updateBladeResponse(soap, (const struct adm__updateBladeResponse *)ptr);
		break;
	case SOAP_TYPE_adm__addMarket:
		soap_serialize_adm__addMarket(soap, (const struct adm__addMarket *)ptr);
		break;
	case SOAP_TYPE_adm__addMarketResponse:
		soap_serialize_adm__addMarketResponse(soap, (const struct adm__addMarketResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateMarket:
		soap_serialize_adm__updateMarket(soap, (const struct adm__updateMarket *)ptr);
		break;
	case SOAP_TYPE_adm__updateMarketResponse:
		soap_serialize_adm__updateMarketResponse(soap, (const struct adm__updateMarketResponse *)ptr);
		break;
	case SOAP_TYPE_adm__addRegion:
		soap_serialize_adm__addRegion(soap, (const struct adm__addRegion *)ptr);
		break;
	case SOAP_TYPE_adm__addRegionResponse:
		soap_serialize_adm__addRegionResponse(soap, (const struct adm__addRegionResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateRegion:
		soap_serialize_adm__updateRegion(soap, (const struct adm__updateRegion *)ptr);
		break;
	case SOAP_TYPE_adm__updateRegionResponse:
		soap_serialize_adm__updateRegionResponse(soap, (const struct adm__updateRegionResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateLocalSystem:
		soap_serialize_adm__updateLocalSystem(soap, (const struct adm__updateLocalSystem *)ptr);
		break;
	case SOAP_TYPE_adm__updateLocalSystemResponse:
		soap_serialize_adm__updateLocalSystemResponse(soap, (const struct adm__updateLocalSystemResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmsAlarmConfig:
		soap_serialize_adm__updateCmsAlarmConfig(soap, (const struct adm__updateCmsAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmsAlarmConfigResponse:
		soap_serialize_adm__updateCmsAlarmConfigResponse(soap, (const struct adm__updateCmsAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getCmsAlarmConfig:
		soap_serialize_adm__getCmsAlarmConfig(soap, (const struct adm__getCmsAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__getCmsAlarmConfigResponse:
		soap_serialize_adm__getCmsAlarmConfigResponse(soap, (const struct adm__getCmsAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmtsAlarmConfig:
		soap_serialize_adm__updateCmtsAlarmConfig(soap, (const struct adm__updateCmtsAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmtsAlarmConfigResponse:
		soap_serialize_adm__updateCmtsAlarmConfigResponse(soap, (const struct adm__updateCmtsAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getCmtsAlarmConfig:
		soap_serialize_adm__getCmtsAlarmConfig(soap, (const struct adm__getCmtsAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__getCmtsAlarmConfigResponse:
		soap_serialize_adm__getCmtsAlarmConfigResponse(soap, (const struct adm__getCmtsAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateHfcAlarmConfig:
		soap_serialize_adm__updateHfcAlarmConfig(soap, (const struct adm__updateHfcAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__updateHfcAlarmConfigResponse:
		soap_serialize_adm__updateHfcAlarmConfigResponse(soap, (const struct adm__updateHfcAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getHfcAlarmConfig:
		soap_serialize_adm__getHfcAlarmConfig(soap, (const struct adm__getHfcAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__getHfcAlarmConfigResponse:
		soap_serialize_adm__getHfcAlarmConfigResponse(soap, (const struct adm__getHfcAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateMtaAlarmConfig:
		soap_serialize_adm__updateMtaAlarmConfig(soap, (const struct adm__updateMtaAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__updateMtaAlarmConfigResponse:
		soap_serialize_adm__updateMtaAlarmConfigResponse(soap, (const struct adm__updateMtaAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getMtaAlarmConfig:
		soap_serialize_adm__getMtaAlarmConfig(soap, (const struct adm__getMtaAlarmConfig *)ptr);
		break;
	case SOAP_TYPE_adm__getMtaAlarmConfigResponse:
		soap_serialize_adm__getMtaAlarmConfigResponse(soap, (const struct adm__getMtaAlarmConfigResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmsStatusThreshold:
		soap_serialize_adm__updateCmsStatusThreshold(soap, (const struct adm__updateCmsStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmsStatusThresholdResponse:
		soap_serialize_adm__updateCmsStatusThresholdResponse(soap, (const struct adm__updateCmsStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getCmsStatusThreshold:
		soap_serialize_adm__getCmsStatusThreshold(soap, (const struct adm__getCmsStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__getCmsStatusThresholdResponse:
		soap_serialize_adm__getCmsStatusThresholdResponse(soap, (const struct adm__getCmsStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmtsStatusThreshold:
		soap_serialize_adm__updateCmtsStatusThreshold(soap, (const struct adm__updateCmtsStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmtsStatusThresholdResponse:
		soap_serialize_adm__updateCmtsStatusThresholdResponse(soap, (const struct adm__updateCmtsStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getCmtsStatusThreshold:
		soap_serialize_adm__getCmtsStatusThreshold(soap, (const struct adm__getCmtsStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__getCmtsStatusThresholdResponse:
		soap_serialize_adm__getCmtsStatusThresholdResponse(soap, (const struct adm__getCmtsStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateChannelStatusThreshold:
		soap_serialize_adm__updateChannelStatusThreshold(soap, (const struct adm__updateChannelStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__updateChannelStatusThresholdResponse:
		soap_serialize_adm__updateChannelStatusThresholdResponse(soap, (const struct adm__updateChannelStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getChannelStatusThreshold:
		soap_serialize_adm__getChannelStatusThreshold(soap, (const struct adm__getChannelStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__getChannelStatusThresholdResponse:
		soap_serialize_adm__getChannelStatusThresholdResponse(soap, (const struct adm__getChannelStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateHfcStatusThreshold:
		soap_serialize_adm__updateHfcStatusThreshold(soap, (const struct adm__updateHfcStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__updateHfcStatusThresholdResponse:
		soap_serialize_adm__updateHfcStatusThresholdResponse(soap, (const struct adm__updateHfcStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getHfcStatusThreshold:
		soap_serialize_adm__getHfcStatusThreshold(soap, (const struct adm__getHfcStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__getHfcStatusThresholdResponse:
		soap_serialize_adm__getHfcStatusThresholdResponse(soap, (const struct adm__getHfcStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateMtaStatusThreshold:
		soap_serialize_adm__updateMtaStatusThreshold(soap, (const struct adm__updateMtaStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__updateMtaStatusThresholdResponse:
		soap_serialize_adm__updateMtaStatusThresholdResponse(soap, (const struct adm__updateMtaStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getMtaStatusThreshold:
		soap_serialize_adm__getMtaStatusThreshold(soap, (const struct adm__getMtaStatusThreshold *)ptr);
		break;
	case SOAP_TYPE_adm__getMtaStatusThresholdResponse:
		soap_serialize_adm__getMtaStatusThresholdResponse(soap, (const struct adm__getMtaStatusThresholdResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updatePollingIntervals:
		soap_serialize_adm__updatePollingIntervals(soap, (const struct adm__updatePollingIntervals *)ptr);
		break;
	case SOAP_TYPE_adm__updatePollingIntervalsResponse:
		soap_serialize_adm__updatePollingIntervalsResponse(soap, (const struct adm__updatePollingIntervalsResponse *)ptr);
		break;
	case SOAP_TYPE_adm__getPollingIntervals:
		soap_serialize_adm__getPollingIntervals(soap, (const struct adm__getPollingIntervals *)ptr);
		break;
	case SOAP_TYPE_adm__getPollingIntervalsResponse:
		soap_serialize_adm__getPollingIntervalsResponse(soap, (const struct adm__getPollingIntervalsResponse *)ptr);
		break;
	case SOAP_TYPE_adm__deleteCms:
		soap_serialize_adm__deleteCms(soap, (const struct adm__deleteCms *)ptr);
		break;
	case SOAP_TYPE_adm__deleteCmsResponse:
		soap_serialize_adm__deleteCmsResponse(soap, (const struct adm__deleteCmsResponse *)ptr);
		break;
	case SOAP_TYPE_adm__addCms:
		soap_serialize_adm__addCms(soap, (const struct adm__addCms *)ptr);
		break;
	case SOAP_TYPE_adm__addCmsResponse:
		soap_serialize_adm__addCmsResponse(soap, (const struct adm__addCmsResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCms:
		soap_serialize_adm__updateCms(soap, (const struct adm__updateCms *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmsResponse:
		soap_serialize_adm__updateCmsResponse(soap, (const struct adm__updateCmsResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes:
		soap_serialize_adm__updateCmtsAllSnmpV2CAttributes(soap, (const struct adm__updateCmtsAllSnmpV2CAttributes *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse:
		soap_serialize_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, (const struct adm__updateCmtsAllSnmpV2CAttributesResponse *)ptr);
		break;
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes:
		soap_serialize_adm__addCmtsAllSnmpV2CAttributes(soap, (const struct adm__addCmtsAllSnmpV2CAttributes *)ptr);
		break;
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse:
		soap_serialize_adm__addCmtsAllSnmpV2CAttributesResponse(soap, (const struct adm__addCmtsAllSnmpV2CAttributesResponse *)ptr);
		break;
	case SOAP_TYPE_adm__deleteCmts:
		soap_serialize_adm__deleteCmts(soap, (const struct adm__deleteCmts *)ptr);
		break;
	case SOAP_TYPE_adm__deleteCmtsResponse:
		soap_serialize_adm__deleteCmtsResponse(soap, (const struct adm__deleteCmtsResponse *)ptr);
		break;
	case SOAP_TYPE_adm__addCmts:
		soap_serialize_adm__addCmts(soap, (const struct adm__addCmts *)ptr);
		break;
	case SOAP_TYPE_adm__addCmtsResponse:
		soap_serialize_adm__addCmtsResponse(soap, (const struct adm__addCmtsResponse *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmts:
		soap_serialize_adm__updateCmts(soap, (const struct adm__updateCmts *)ptr);
		break;
	case SOAP_TYPE_adm__updateCmtsResponse:
		soap_serialize_adm__updateCmtsResponse(soap, (const struct adm__updateCmtsResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ConfigDownloadT:
		soap_serialize_PointerTons1__ConfigDownloadT(soap, (ns1__ConfigDownloadT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__LocalSystemT:
		soap_serialize_PointerTons1__LocalSystemT(soap, (ns1__LocalSystemT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmsStatusThresholdT:
		soap_serialize_PointerTons1__CmsStatusThresholdT(soap, (ns1__CmsStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmtsStatusThresholdT:
		soap_serialize_PointerTons1__CmtsStatusThresholdT(soap, (ns1__CmtsStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChannelStatusThresholdT:
		soap_serialize_PointerTons1__ChannelStatusThresholdT(soap, (ns1__ChannelStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcStatusThresholdT:
		soap_serialize_PointerTons1__HfcStatusThresholdT(soap, (ns1__HfcStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaStatusThresholdT:
		soap_serialize_PointerTons1__MtaStatusThresholdT(soap, (ns1__MtaStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfSnmpV2CAttributesT:
		soap_serialize_PointerToArrayOfSnmpV2CAttributesT(soap, (ArrayOfSnmpV2CAttributesT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT:
		soap_serialize_PointerToPointerTons1__CmStatusSummaryT(soap, (ns1__CmStatusSummaryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmStatusSummaryT:
		soap_serialize_PointerTons1__CmStatusSummaryT(soap, (ns1__CmStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT:
		soap_serialize_PointerToPointerTons1__MtaStatusSummaryT(soap, (ns1__MtaStatusSummaryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaStatusSummaryT:
		soap_serialize_PointerTons1__MtaStatusSummaryT(soap, (ns1__MtaStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT:
		soap_serialize_PointerToPointerTons1__HfcStatusSummaryT(soap, (ns1__HfcStatusSummaryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcStatusSummaryT:
		soap_serialize_PointerTons1__HfcStatusSummaryT(soap, (ns1__HfcStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT:
		soap_serialize_PointerToPointerTons1__AlarmTypeConfigT(soap, (ns1__AlarmTypeConfigT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT:
		soap_serialize_PointerToPointerTons1__AggregateStatusThresholdT(soap, (ns1__AggregateStatusThresholdT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AggregateStatusThresholdT:
		soap_serialize_PointerTons1__AggregateStatusThresholdT(soap, (ns1__AggregateStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT:
		soap_serialize_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, (ns1__AlarmBasedStatusThresholdT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT:
		soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(soap, (ns1__AlarmBasedStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UserT:
		soap_serialize_PointerToPointerTons1__UserT(soap, (ns1__UserT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserT:
		soap_serialize_PointerTons1__UserT(soap, (ns1__UserT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__RoleT:
		soap_serialize_PointerToPointerTons1__RoleT(soap, (ns1__RoleT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RoleT:
		soap_serialize_PointerTons1__RoleT(soap, (ns1__RoleT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ApplicationDomainT:
		soap_serialize_PointerToPointerTons1__ApplicationDomainT(soap, (ns1__ApplicationDomainT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ApplicationDomainT:
		soap_serialize_PointerTons1__ApplicationDomainT(soap, (ns1__ApplicationDomainT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__UserAccessT:
		soap_serialize_PointerToPointerTons1__UserAccessT(soap, (ns1__UserAccessT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__UserAccessT:
		soap_serialize_PointerTons1__UserAccessT(soap, (ns1__UserAccessT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CMSLineT:
		soap_serialize_PointerToPointerTons1__CMSLineT(soap, (ns1__CMSLineT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT:
		soap_serialize_PointerToPointerTons1__CTEQueryInputT(soap, (ns1__CTEQueryInputT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEQueryInputT:
		soap_serialize_PointerTons1__CTEQueryInputT(soap, (ns1__CTEQueryInputT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTEDataT:
		soap_serialize_PointerToPointerTons1__CTEDataT(soap, (ns1__CTEDataT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEDataT:
		soap_serialize_PointerTons1__CTEDataT(soap, (ns1__CTEDataT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CTECustomerT:
		soap_serialize_PointerToPointerTons1__CTECustomerT(soap, (ns1__CTECustomerT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT:
		soap_serialize_PointerToPointerTons1__CmPerformanceHistoryT(soap, (ns1__CmPerformanceHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmPerformanceHistoryT:
		soap_serialize_PointerTons1__CmPerformanceHistoryT(soap, (ns1__CmPerformanceHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT:
		soap_serialize_PointerToPointerTons1__MtaPingStatusHistoryT(soap, (ns1__MtaPingStatusHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT:
		soap_serialize_PointerTons1__MtaPingStatusHistoryT(soap, (ns1__MtaPingStatusHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT:
		soap_serialize_PointerToPointerTons1__MtaProvStatusHistoryT(soap, (ns1__MtaProvStatusHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT:
		soap_serialize_PointerTons1__MtaProvStatusHistoryT(soap, (ns1__MtaProvStatusHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT:
		soap_serialize_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, (ns1__MtaAvailabilityHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT:
		soap_serialize_PointerTons1__MtaAvailabilityHistoryT(soap, (ns1__MtaAvailabilityHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT:
		soap_serialize_PointerToPointerTons1__CmStatusHistoryT(soap, (ns1__CmStatusHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmStatusHistoryT:
		soap_serialize_PointerTons1__CmStatusHistoryT(soap, (ns1__CmStatusHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT:
		soap_serialize_PointerToPointerTons1__GenericCountsHistoryT(soap, (ns1__GenericCountsHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericCountsHistoryT:
		soap_serialize_PointerTons1__GenericCountsHistoryT(soap, (ns1__GenericCountsHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__QueryStateT:
		soap_serialize_PointerToPointerTons1__QueryStateT(soap, (ns1__QueryStateT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__QueryStateT:
		soap_serialize_PointerTons1__QueryStateT(soap, (ns1__QueryStateT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ScrollPageT:
		soap_serialize_PointerToPointerTons1__ScrollPageT(soap, (ns1__ScrollPageT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ScrollPageT:
		soap_serialize_PointerTons1__ScrollPageT(soap, (ns1__ScrollPageT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT:
		soap_serialize_PointerToPointerTons1__AlarmHistoryT(soap, (ns1__AlarmHistoryT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AlarmHistoryT:
		soap_serialize_PointerTons1__AlarmHistoryT(soap, (ns1__AlarmHistoryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT:
		soap_serialize_PointerToPointerTons1__HistoricalAlarmT(soap, (ns1__HistoricalAlarmT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT:
		soap_serialize_PointerToPointerTons1__CurrentAlarmT(soap, (ns1__CurrentAlarmT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__EmtaT:
		soap_serialize_PointerToPointerTons1__EmtaT(soap, (ns1__EmtaT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CableModemT:
		soap_serialize_PointerToPointerTons1__CableModemT(soap, (ns1__CableModemT **const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__HfcT:
		soap_serialize_PointerToPointerTons1__HfcT(soap, (ns1__HfcT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcT:
		soap_serialize_PointerTons1__HfcT(soap, (ns1__HfcT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__ChannelT:
		soap_serialize_PointerToPointerTons1__ChannelT(soap, (ns1__ChannelT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ChannelT:
		soap_serialize_PointerTons1__ChannelT(soap, (ns1__ChannelT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT:
		soap_serialize_PointerToPointerTons1__SnmpV2CAttributesT(soap, (ns1__SnmpV2CAttributesT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SnmpV2CAttributesT:
		soap_serialize_PointerTons1__SnmpV2CAttributesT(soap, (ns1__SnmpV2CAttributesT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmtsT:
		soap_serialize_PointerToPointerTons1__CmtsT(soap, (ns1__CmtsT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmtsT:
		soap_serialize_PointerTons1__CmtsT(soap, (ns1__CmtsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__CmsT:
		soap_serialize_PointerToPointerTons1__CmsT(soap, (ns1__CmsT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmsT:
		soap_serialize_PointerTons1__CmsT(soap, (ns1__CmsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__BladeT:
		soap_serialize_PointerToPointerTons1__BladeT(soap, (ns1__BladeT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__BladeT:
		soap_serialize_PointerTons1__BladeT(soap, (ns1__BladeT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__MarketT:
		soap_serialize_PointerToPointerTons1__MarketT(soap, (ns1__MarketT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MarketT:
		soap_serialize_PointerTons1__MarketT(soap, (ns1__MarketT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToPointerTons1__RegionT:
		soap_serialize_PointerToPointerTons1__RegionT(soap, (ns1__RegionT **const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__RegionT:
		soap_serialize_PointerTons1__RegionT(soap, (ns1__RegionT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT:
		soap_serialize_PointerToArrayOfHistoricalAlarmsT(soap, (ArrayOfHistoricalAlarmsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCurrentAlarmsT:
		soap_serialize_PointerToArrayOfCurrentAlarmsT(soap, (ArrayOfCurrentAlarmsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfCmStatusSummaryT:
		soap_serialize_PointerToArrayOfCmStatusSummaryT(soap, (ArrayOfCmStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT:
		soap_serialize_PointerToArrayOfHfcStatusSummaryT(soap, (ArrayOfHfcStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfQueryStateT:
		soap_serialize_PointerToArrayOfQueryStateT(soap, (ArrayOfQueryStateT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT:
		soap_serialize_PointerToArrayOfMtaStatusSummaryT(soap, (ArrayOfMtaStatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__StatusSummaryT:
		soap_serialize_PointerTons1__StatusSummaryT(soap, (ns1__StatusSummaryT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfUserT:
		soap_serialize_PointerToArrayOfUserT(soap, (ArrayOfUserT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfRoleT:
		soap_serialize_PointerToArrayOfRoleT(soap, (ArrayOfRoleT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__PollingIntervalsT:
		soap_serialize_PointerTons1__PollingIntervalsT(soap, (ns1__PollingIntervalsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcAlarmConfigT:
		soap_serialize_PointerTons1__HfcAlarmConfigT(soap, (ns1__HfcAlarmConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaAlarmConfigT:
		soap_serialize_PointerTons1__MtaAlarmConfigT(soap, (ns1__MtaAlarmConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmtsAlarmConfigT:
		soap_serialize_PointerTons1__CmtsAlarmConfigT(soap, (ns1__CmtsAlarmConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmsAlarmConfigT:
		soap_serialize_PointerTons1__CmsAlarmConfigT(soap, (ns1__CmsAlarmConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmPerformanceConfigT:
		soap_serialize_PointerTons1__CmPerformanceConfigT(soap, (ns1__CmPerformanceConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AlarmTypeConfigT:
		soap_serialize_PointerTons1__AlarmTypeConfigT(soap, (ns1__AlarmTypeConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT:
		soap_serialize_PointerToArrayOfAlarmTypeConfigT(soap, (ArrayOfAlarmTypeConfigT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HfcPowerTresholdT:
		soap_serialize_PointerTons1__HfcPowerTresholdT(soap, (ns1__HfcPowerTresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AggregateMtaTresholdT:
		soap_serialize_PointerTons1__AggregateMtaTresholdT(soap, (ns1__AggregateMtaTresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__SoakWindowT:
		soap_serialize_PointerTons1__SoakWindowT(soap, (ns1__SoakWindowT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT:
		soap_serialize_PointerTons1__AggregateCmOfflineTresholdT(soap, (ns1__AggregateCmOfflineTresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT:
		soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, (ArrayOfAggregateStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT:
		soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, (ArrayOfAlarmStatusThresholdT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfApplicationDomainT:
		soap_serialize_PointerToArrayOfApplicationDomainT(soap, (ArrayOfApplicationDomainT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfUserAccessT:
		soap_serialize_PointerToArrayOfUserAccessT(soap, (ArrayOfUserAccessT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CMSLineT:
		soap_serialize_PointerTons1__CMSLineT(soap, (ns1__CMSLineT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEAbstractNameT:
		soap_serialize_PointerTons1__CTEAbstractNameT(soap, (ns1__CTEAbstractNameT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTEAbstractMacT:
		soap_serialize_PointerTons1__CTEAbstractMacT(soap, (ns1__CTEAbstractMacT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CTECustomerT:
		soap_serialize_PointerTons1__CTECustomerT(soap, (ns1__CTECustomerT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToshort:
		soap_serialize_PointerToshort(soap, (short *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmPerformanceT:
		soap_serialize_PointerTons1__CmPerformanceT(soap, (ns1__CmPerformanceT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaPingStatusT:
		soap_serialize_PointerTons1__MtaPingStatusT(soap, (ns1__MtaPingStatusT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaProvStatusT:
		soap_serialize_PointerTons1__MtaProvStatusT(soap, (ns1__MtaProvStatusT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__MtaAvailabilityT:
		soap_serialize_PointerTons1__MtaAvailabilityT(soap, (ns1__MtaAvailabilityT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CmStatusT:
		soap_serialize_PointerTons1__CmStatusT(soap, (ns1__CmStatusT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToArrayOfScrollPageT:
		soap_serialize_PointerToArrayOfScrollPageT(soap, (ArrayOfScrollPageT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__ResultBatchT:
		soap_serialize_PointerTons1__ResultBatchT(soap, (ns1__ResultBatchT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__EmtaT:
		soap_serialize_PointerTons1__EmtaT(soap, (ns1__EmtaT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CableModemT:
		soap_serialize_PointerTons1__CableModemT(soap, (ns1__CableModemT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__HistoricalAlarmT:
		soap_serialize_PointerTons1__HistoricalAlarmT(soap, (ns1__HistoricalAlarmT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__CurrentAlarmT:
		soap_serialize_PointerTons1__CurrentAlarmT(soap, (ns1__CurrentAlarmT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__AbstractAlarmT:
		soap_serialize_PointerTons1__AbstractAlarmT(soap, (ns1__AbstractAlarmT *const*)ptr);
		break;
	case SOAP_TYPE_PointerToxsd__integer:
		soap_serialize_PointerToxsd__integer(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__GenericCountsT:
		soap_serialize_PointerTons1__GenericCountsT(soap, (ns1__GenericCountsT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTons1__TopoHierarchyKeyT:
		soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, (ns1__TopoHierarchyKeyT *const*)ptr);
		break;
	case SOAP_TYPE_PointerTostd__string:
		soap_serialize_PointerTostd__string(soap, (std::string *const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char**)&ptr);
		break;
	}
}

#ifdef __cplusplus
}
#endif
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_instantiate(struct soap *soap, int t, const char *type, const char *arrayType, size_t *n)
{
	switch (t)
	{
	case SOAP_TYPE_std__string:
		return (void*)soap_instantiate_std__string(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		return (void*)soap_instantiate_ns1__SnmpV2CAttributesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericCountsT:
		return (void*)soap_instantiate_ns1__GenericCountsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__InputTimeT:
		return (void*)soap_instantiate_ns1__InputTimeT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ResultBatchT:
		return (void*)soap_instantiate_ns1__ResultBatchT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		return (void*)soap_instantiate_ns1__TopoHierarchyKeyT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__LocalSystemT:
		return (void*)soap_instantiate_ns1__LocalSystemT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RegionT:
		return (void*)soap_instantiate_ns1__RegionT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MarketT:
		return (void*)soap_instantiate_ns1__MarketT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__BladeT:
		return (void*)soap_instantiate_ns1__BladeT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmsT:
		return (void*)soap_instantiate_ns1__CmsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsT:
		return (void*)soap_instantiate_ns1__CmtsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ChannelT:
		return (void*)soap_instantiate_ns1__ChannelT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcT:
		return (void*)soap_instantiate_ns1__HfcT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CableModemT:
		return (void*)soap_instantiate_ns1__CableModemT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EmtaT:
		return (void*)soap_instantiate_ns1__EmtaT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EmtaSecondaryT:
		return (void*)soap_instantiate_ns1__EmtaSecondaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AbstractAlarmT:
		return (void*)soap_instantiate_ns1__AbstractAlarmT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CurrentAlarmT:
		return (void*)soap_instantiate_ns1__CurrentAlarmT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		return (void*)soap_instantiate_ns1__CurrentAlarmDetailsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		return (void*)soap_instantiate_ns1__HistoricalAlarmT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		return (void*)soap_instantiate_ns1__HistoricalAlarmDetailsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AlarmHistoryT:
		return (void*)soap_instantiate_ns1__AlarmHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		return (void*)soap_instantiate_ns1__MappedEuDevicesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ScrollPageT:
		return (void*)soap_instantiate_ns1__ScrollPageT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__QueryStateT:
		return (void*)soap_instantiate_ns1__QueryStateT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		return (void*)soap_instantiate_ns1__GenericCountsHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusT:
		return (void*)soap_instantiate_ns1__CmStatusT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		return (void*)soap_instantiate_ns1__CmStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		return (void*)soap_instantiate_ns1__MtaAvailabilityT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		return (void*)soap_instantiate_ns1__MtaAvailabilityHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaProvStatusT:
		return (void*)soap_instantiate_ns1__MtaProvStatusT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		return (void*)soap_instantiate_ns1__MtaProvStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaPingStatusT:
		return (void*)soap_instantiate_ns1__MtaPingStatusT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		return (void*)soap_instantiate_ns1__MtaPingStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmPerformanceT:
		return (void*)soap_instantiate_ns1__CmPerformanceT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		return (void*)soap_instantiate_ns1__CmPerformanceHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		return (void*)soap_instantiate_ns1__CmCurrentPerformanceT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTECustomerT:
		return (void*)soap_instantiate_ns1__CTECustomerT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		return (void*)soap_instantiate_ns1__CTEAbstractMacT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		return (void*)soap_instantiate_ns1__CTEAbstractNameT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEDataT:
		return (void*)soap_instantiate_ns1__CTEDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CTEQueryInputT:
		return (void*)soap_instantiate_ns1__CTEQueryInputT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CMSLineT:
		return (void*)soap_instantiate_ns1__CMSLineT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CMSResultT:
		return (void*)soap_instantiate_ns1__CMSResultT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserAccessT:
		return (void*)soap_instantiate_ns1__UserAccessT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ApplicationDomainT:
		return (void*)soap_instantiate_ns1__ApplicationDomainT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__RoleT:
		return (void*)soap_instantiate_ns1__RoleT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__UserT:
		return (void*)soap_instantiate_ns1__UserT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__PollingIntervalsT:
		return (void*)soap_instantiate_ns1__PollingIntervalsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		return (void*)soap_instantiate_ns1__AlarmBasedStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		return (void*)soap_instantiate_ns1__AggregateStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		return (void*)soap_instantiate_ns1__MtaStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		return (void*)soap_instantiate_ns1__HfcStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		return (void*)soap_instantiate_ns1__ChannelStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		return (void*)soap_instantiate_ns1__CmtsStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		return (void*)soap_instantiate_ns1__CmsStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__SoakWindowT:
		return (void*)soap_instantiate_ns1__SoakWindowT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		return (void*)soap_instantiate_ns1__AggregateCmOfflineTresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		return (void*)soap_instantiate_ns1__AggregateMtaTresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		return (void*)soap_instantiate_ns1__HfcPowerTresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		return (void*)soap_instantiate_ns1__HfcAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		return (void*)soap_instantiate_ns1__AlarmTypeConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		return (void*)soap_instantiate_ns1__MtaAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		return (void*)soap_instantiate_ns1__CmtsAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		return (void*)soap_instantiate_ns1__CmsAlarmConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		return (void*)soap_instantiate_ns1__CmPerformanceConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__ConfigDownloadT:
		return (void*)soap_instantiate_ns1__ConfigDownloadT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmtsCmDataT:
		return (void*)soap_instantiate_ns1__CmtsCmDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmDataT:
		return (void*)soap_instantiate_ns1__CmDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaDataT:
		return (void*)soap_instantiate_ns1__MtaDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__StatusSummaryT:
		return (void*)soap_instantiate_ns1__StatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		return (void*)soap_instantiate_ns1__HfcStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		return (void*)soap_instantiate_ns1__MtaStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		return (void*)soap_instantiate_ns1__CmStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		return (void*)soap_instantiate_ns1__MtaStatusSummaryRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		return (void*)soap_instantiate_ns1__HfcStatusSummaryRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		return (void*)soap_instantiate_ns1__CmStatusSummaryRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		return (void*)soap_instantiate_ns1__CurrentAlarmsRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		return (void*)soap_instantiate_ns1__HistoricalAlarmsRespT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ns1__EventMessageT:
		return (void*)soap_instantiate_ns1__EventMessageT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfRegionsT:
		return (void*)soap_instantiate_ArrayOfRegionsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMarketsT:
		return (void*)soap_instantiate_ArrayOfMarketsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfBladesT:
		return (void*)soap_instantiate_ArrayOfBladesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmsesT:
		return (void*)soap_instantiate_ArrayOfCmsesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmtsesT:
		return (void*)soap_instantiate_ArrayOfCmtsesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		return (void*)soap_instantiate_ArrayOfSnmpV2CAttributesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfChannelsT:
		return (void*)soap_instantiate_ArrayOfChannelsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfHfcsT:
		return (void*)soap_instantiate_ArrayOfHfcsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCableModemsT:
		return (void*)soap_instantiate_ArrayOfCableModemsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfEmtasT:
		return (void*)soap_instantiate_ArrayOfEmtasT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		return (void*)soap_instantiate_ArrayOfCurrentAlarmsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		return (void*)soap_instantiate_ArrayOfHistoricalAlarmsT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		return (void*)soap_instantiate_ArrayOfAlarmHistoriesT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfScrollPageT:
		return (void*)soap_instantiate_ArrayOfScrollPageT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfQueryStateT:
		return (void*)soap_instantiate_ArrayOfQueryStateT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		return (void*)soap_instantiate_ArrayOfGenericCountsHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		return (void*)soap_instantiate_ArrayOfCmStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		return (void*)soap_instantiate_ArrayOfMtaAvailabilityHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		return (void*)soap_instantiate_ArrayOfMtaProvStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		return (void*)soap_instantiate_ArrayOfMtaPingStatusHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		return (void*)soap_instantiate_ArrayOfCmPerformanceHistoryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTECustomerT:
		return (void*)soap_instantiate_ArrayOfCTECustomerT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTEDataT:
		return (void*)soap_instantiate_ArrayOfCTEDataT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		return (void*)soap_instantiate_ArrayOfCTEQueryInputT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCMSLineT:
		return (void*)soap_instantiate_ArrayOfCMSLineT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfUserAccessT:
		return (void*)soap_instantiate_ArrayOfUserAccessT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfApplicationDomainT:
		return (void*)soap_instantiate_ArrayOfApplicationDomainT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfRoleT:
		return (void*)soap_instantiate_ArrayOfRoleT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfUserT:
		return (void*)soap_instantiate_ArrayOfUserT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		return (void*)soap_instantiate_ArrayOfAlarmStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		return (void*)soap_instantiate_ArrayOfAggregateStatusThresholdT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		return (void*)soap_instantiate_ArrayOfAlarmTypeConfigT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		return (void*)soap_instantiate_ArrayOfHfcStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		return (void*)soap_instantiate_ArrayOfMtaStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		return (void*)soap_instantiate_ArrayOfCmStatusSummaryT(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmtsResponse:
		return (void*)soap_instantiate_adm__updateCmtsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmts:
		return (void*)soap_instantiate_adm__updateCmts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addCmtsResponse:
		return (void*)soap_instantiate_adm__addCmtsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addCmts:
		return (void*)soap_instantiate_adm__addCmts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__deleteCmtsResponse:
		return (void*)soap_instantiate_adm__deleteCmtsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__deleteCmts:
		return (void*)soap_instantiate_adm__deleteCmts(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse:
		return (void*)soap_instantiate_adm__addCmtsAllSnmpV2CAttributesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes:
		return (void*)soap_instantiate_adm__addCmtsAllSnmpV2CAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse:
		return (void*)soap_instantiate_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes:
		return (void*)soap_instantiate_adm__updateCmtsAllSnmpV2CAttributes(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmsResponse:
		return (void*)soap_instantiate_adm__updateCmsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCms:
		return (void*)soap_instantiate_adm__updateCms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addCmsResponse:
		return (void*)soap_instantiate_adm__addCmsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addCms:
		return (void*)soap_instantiate_adm__addCms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__deleteCmsResponse:
		return (void*)soap_instantiate_adm__deleteCmsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__deleteCms:
		return (void*)soap_instantiate_adm__deleteCms(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getPollingIntervalsResponse:
		return (void*)soap_instantiate_adm__getPollingIntervalsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getPollingIntervals:
		return (void*)soap_instantiate_adm__getPollingIntervals(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updatePollingIntervalsResponse:
		return (void*)soap_instantiate_adm__updatePollingIntervalsResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updatePollingIntervals:
		return (void*)soap_instantiate_adm__updatePollingIntervals(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getMtaStatusThresholdResponse:
		return (void*)soap_instantiate_adm__getMtaStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getMtaStatusThreshold:
		return (void*)soap_instantiate_adm__getMtaStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateMtaStatusThresholdResponse:
		return (void*)soap_instantiate_adm__updateMtaStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateMtaStatusThreshold:
		return (void*)soap_instantiate_adm__updateMtaStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getHfcStatusThresholdResponse:
		return (void*)soap_instantiate_adm__getHfcStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getHfcStatusThreshold:
		return (void*)soap_instantiate_adm__getHfcStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateHfcStatusThresholdResponse:
		return (void*)soap_instantiate_adm__updateHfcStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateHfcStatusThreshold:
		return (void*)soap_instantiate_adm__updateHfcStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getChannelStatusThresholdResponse:
		return (void*)soap_instantiate_adm__getChannelStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getChannelStatusThreshold:
		return (void*)soap_instantiate_adm__getChannelStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateChannelStatusThresholdResponse:
		return (void*)soap_instantiate_adm__updateChannelStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateChannelStatusThreshold:
		return (void*)soap_instantiate_adm__updateChannelStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmtsStatusThresholdResponse:
		return (void*)soap_instantiate_adm__getCmtsStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmtsStatusThreshold:
		return (void*)soap_instantiate_adm__getCmtsStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmtsStatusThresholdResponse:
		return (void*)soap_instantiate_adm__updateCmtsStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmtsStatusThreshold:
		return (void*)soap_instantiate_adm__updateCmtsStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmsStatusThresholdResponse:
		return (void*)soap_instantiate_adm__getCmsStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmsStatusThreshold:
		return (void*)soap_instantiate_adm__getCmsStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmsStatusThresholdResponse:
		return (void*)soap_instantiate_adm__updateCmsStatusThresholdResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmsStatusThreshold:
		return (void*)soap_instantiate_adm__updateCmsStatusThreshold(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getMtaAlarmConfigResponse:
		return (void*)soap_instantiate_adm__getMtaAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getMtaAlarmConfig:
		return (void*)soap_instantiate_adm__getMtaAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateMtaAlarmConfigResponse:
		return (void*)soap_instantiate_adm__updateMtaAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateMtaAlarmConfig:
		return (void*)soap_instantiate_adm__updateMtaAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getHfcAlarmConfigResponse:
		return (void*)soap_instantiate_adm__getHfcAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getHfcAlarmConfig:
		return (void*)soap_instantiate_adm__getHfcAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateHfcAlarmConfigResponse:
		return (void*)soap_instantiate_adm__updateHfcAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateHfcAlarmConfig:
		return (void*)soap_instantiate_adm__updateHfcAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmtsAlarmConfigResponse:
		return (void*)soap_instantiate_adm__getCmtsAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmtsAlarmConfig:
		return (void*)soap_instantiate_adm__getCmtsAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmtsAlarmConfigResponse:
		return (void*)soap_instantiate_adm__updateCmtsAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmtsAlarmConfig:
		return (void*)soap_instantiate_adm__updateCmtsAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmsAlarmConfigResponse:
		return (void*)soap_instantiate_adm__getCmsAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmsAlarmConfig:
		return (void*)soap_instantiate_adm__getCmsAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmsAlarmConfigResponse:
		return (void*)soap_instantiate_adm__updateCmsAlarmConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmsAlarmConfig:
		return (void*)soap_instantiate_adm__updateCmsAlarmConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateLocalSystemResponse:
		return (void*)soap_instantiate_adm__updateLocalSystemResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateLocalSystem:
		return (void*)soap_instantiate_adm__updateLocalSystem(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateRegionResponse:
		return (void*)soap_instantiate_adm__updateRegionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateRegion:
		return (void*)soap_instantiate_adm__updateRegion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addRegionResponse:
		return (void*)soap_instantiate_adm__addRegionResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addRegion:
		return (void*)soap_instantiate_adm__addRegion(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateMarketResponse:
		return (void*)soap_instantiate_adm__updateMarketResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateMarket:
		return (void*)soap_instantiate_adm__updateMarket(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addMarketResponse:
		return (void*)soap_instantiate_adm__addMarketResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addMarket:
		return (void*)soap_instantiate_adm__addMarket(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateBladeResponse:
		return (void*)soap_instantiate_adm__updateBladeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateBlade:
		return (void*)soap_instantiate_adm__updateBlade(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addBladeResponse:
		return (void*)soap_instantiate_adm__addBladeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addBlade:
		return (void*)soap_instantiate_adm__addBlade(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__deleteBladeResponse:
		return (void*)soap_instantiate_adm__deleteBladeResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__deleteBlade:
		return (void*)soap_instantiate_adm__deleteBlade(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmPerfConfigResponse:
		return (void*)soap_instantiate_adm__getCmPerfConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getCmPerfConfig:
		return (void*)soap_instantiate_adm__getCmPerfConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmPerfConfigResponse:
		return (void*)soap_instantiate_adm__updateCmPerfConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateCmPerfConfig:
		return (void*)soap_instantiate_adm__updateCmPerfConfig(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addUserResponse:
		return (void*)soap_instantiate_adm__addUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__addUser:
		return (void*)soap_instantiate_adm__addUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getUsersResponse:
		return (void*)soap_instantiate_adm__getUsersResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getUsers:
		return (void*)soap_instantiate_adm__getUsers(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getUserResponse:
		return (void*)soap_instantiate_adm__getUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getUser:
		return (void*)soap_instantiate_adm__getUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateUserResponse:
		return (void*)soap_instantiate_adm__updateUserResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateUser:
		return (void*)soap_instantiate_adm__updateUser(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateUserPasswordResponse:
		return (void*)soap_instantiate_adm__updateUserPasswordResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateUserPassword:
		return (void*)soap_instantiate_adm__updateUserPassword(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getRolesResponse:
		return (void*)soap_instantiate_adm__getRolesResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getRoles:
		return (void*)soap_instantiate_adm__getRoles(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getRoleResponse:
		return (void*)soap_instantiate_adm__getRoleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getRole:
		return (void*)soap_instantiate_adm__getRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateRoleResponse:
		return (void*)soap_instantiate_adm__updateRoleResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__updateRole:
		return (void*)soap_instantiate_adm__updateRole(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__downloadConfigFromParentResponse:
		return (void*)soap_instantiate_adm__downloadConfigFromParentResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__downloadConfigFromParent:
		return (void*)soap_instantiate_adm__downloadConfigFromParent(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getConfigResponse:
		return (void*)soap_instantiate_adm__getConfigResponse(soap, -1, type, arrayType, n);
	case SOAP_TYPE_adm__getConfig:
		return (void*)soap_instantiate_adm__getConfig(soap, -1, type, arrayType, n);
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Header:
		return (void*)soap_instantiate_SOAP_ENV__Header(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Code:
		return (void*)soap_instantiate_SOAP_ENV__Code(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Detail:
		return (void*)soap_instantiate_SOAP_ENV__Detail(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Reason:
		return (void*)soap_instantiate_SOAP_ENV__Reason(soap, -1, type, arrayType, n);
#endif
#ifndef WITH_NOGLOBAL
	case SOAP_TYPE_SOAP_ENV__Fault:
		return (void*)soap_instantiate_SOAP_ENV__Fault(soap, -1, type, arrayType, n);
#endif
	case SOAP_TYPE_xsd__integer:
		return (void*)soap_instantiate_xsd__integer(soap, -1, type, arrayType, n);
	case SOAP_TYPE__SOAP_ENC__arrayType:
		return (void*)soap_instantiate__SOAP_ENC__arrayType(soap, -1, type, arrayType, n);
	}
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_fdelete(struct soap_clist *p)
{	switch (p->type)
	{
	case SOAP_TYPE_std__string:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SnmpV2CAttributesT:
		if (p->size < 0)
			delete (ns1__SnmpV2CAttributesT*)p->ptr;
		else
			delete[] (ns1__SnmpV2CAttributesT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GenericCountsT:
		if (p->size < 0)
			delete (ns1__GenericCountsT*)p->ptr;
		else
			delete[] (ns1__GenericCountsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__InputTimeT:
		if (p->size < 0)
			delete (ns1__InputTimeT*)p->ptr;
		else
			delete[] (ns1__InputTimeT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ResultBatchT:
		if (p->size < 0)
			delete (ns1__ResultBatchT*)p->ptr;
		else
			delete[] (ns1__ResultBatchT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__TopoHierarchyKeyT:
		if (p->size < 0)
			delete (ns1__TopoHierarchyKeyT*)p->ptr;
		else
			delete[] (ns1__TopoHierarchyKeyT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__LocalSystemT:
		if (p->size < 0)
			delete (ns1__LocalSystemT*)p->ptr;
		else
			delete[] (ns1__LocalSystemT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RegionT:
		if (p->size < 0)
			delete (ns1__RegionT*)p->ptr;
		else
			delete[] (ns1__RegionT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MarketT:
		if (p->size < 0)
			delete (ns1__MarketT*)p->ptr;
		else
			delete[] (ns1__MarketT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__BladeT:
		if (p->size < 0)
			delete (ns1__BladeT*)p->ptr;
		else
			delete[] (ns1__BladeT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmsT:
		if (p->size < 0)
			delete (ns1__CmsT*)p->ptr;
		else
			delete[] (ns1__CmsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsT:
		if (p->size < 0)
			delete (ns1__CmtsT*)p->ptr;
		else
			delete[] (ns1__CmtsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ChannelT:
		if (p->size < 0)
			delete (ns1__ChannelT*)p->ptr;
		else
			delete[] (ns1__ChannelT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcT:
		if (p->size < 0)
			delete (ns1__HfcT*)p->ptr;
		else
			delete[] (ns1__HfcT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CableModemT:
		if (p->size < 0)
			delete (ns1__CableModemT*)p->ptr;
		else
			delete[] (ns1__CableModemT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__EmtaT:
		if (p->size < 0)
			delete (ns1__EmtaT*)p->ptr;
		else
			delete[] (ns1__EmtaT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__EmtaSecondaryT:
		if (p->size < 0)
			delete (ns1__EmtaSecondaryT*)p->ptr;
		else
			delete[] (ns1__EmtaSecondaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AbstractAlarmT:
		if (p->size < 0)
			delete (ns1__AbstractAlarmT*)p->ptr;
		else
			delete[] (ns1__AbstractAlarmT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CurrentAlarmT:
		if (p->size < 0)
			delete (ns1__CurrentAlarmT*)p->ptr;
		else
			delete[] (ns1__CurrentAlarmT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CurrentAlarmDetailsT:
		if (p->size < 0)
			delete (ns1__CurrentAlarmDetailsT*)p->ptr;
		else
			delete[] (ns1__CurrentAlarmDetailsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmT:
		if (p->size < 0)
			delete (ns1__HistoricalAlarmT*)p->ptr;
		else
			delete[] (ns1__HistoricalAlarmT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmDetailsT:
		if (p->size < 0)
			delete (ns1__HistoricalAlarmDetailsT*)p->ptr;
		else
			delete[] (ns1__HistoricalAlarmDetailsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AlarmHistoryT:
		if (p->size < 0)
			delete (ns1__AlarmHistoryT*)p->ptr;
		else
			delete[] (ns1__AlarmHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MappedEuDevicesT:
		if (p->size < 0)
			delete (ns1__MappedEuDevicesT*)p->ptr;
		else
			delete[] (ns1__MappedEuDevicesT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ScrollPageT:
		if (p->size < 0)
			delete (ns1__ScrollPageT*)p->ptr;
		else
			delete[] (ns1__ScrollPageT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__QueryStateT:
		if (p->size < 0)
			delete (ns1__QueryStateT*)p->ptr;
		else
			delete[] (ns1__QueryStateT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__GenericCountsHistoryT:
		if (p->size < 0)
			delete (ns1__GenericCountsHistoryT*)p->ptr;
		else
			delete[] (ns1__GenericCountsHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusT:
		if (p->size < 0)
			delete (ns1__CmStatusT*)p->ptr;
		else
			delete[] (ns1__CmStatusT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusHistoryT:
		if (p->size < 0)
			delete (ns1__CmStatusHistoryT*)p->ptr;
		else
			delete[] (ns1__CmStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityT:
		if (p->size < 0)
			delete (ns1__MtaAvailabilityT*)p->ptr;
		else
			delete[] (ns1__MtaAvailabilityT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaAvailabilityHistoryT:
		if (p->size < 0)
			delete (ns1__MtaAvailabilityHistoryT*)p->ptr;
		else
			delete[] (ns1__MtaAvailabilityHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaProvStatusT:
		if (p->size < 0)
			delete (ns1__MtaProvStatusT*)p->ptr;
		else
			delete[] (ns1__MtaProvStatusT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaProvStatusHistoryT:
		if (p->size < 0)
			delete (ns1__MtaProvStatusHistoryT*)p->ptr;
		else
			delete[] (ns1__MtaProvStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaPingStatusT:
		if (p->size < 0)
			delete (ns1__MtaPingStatusT*)p->ptr;
		else
			delete[] (ns1__MtaPingStatusT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaPingStatusHistoryT:
		if (p->size < 0)
			delete (ns1__MtaPingStatusHistoryT*)p->ptr;
		else
			delete[] (ns1__MtaPingStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmPerformanceT:
		if (p->size < 0)
			delete (ns1__CmPerformanceT*)p->ptr;
		else
			delete[] (ns1__CmPerformanceT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmPerformanceHistoryT:
		if (p->size < 0)
			delete (ns1__CmPerformanceHistoryT*)p->ptr;
		else
			delete[] (ns1__CmPerformanceHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmCurrentPerformanceT:
		if (p->size < 0)
			delete (ns1__CmCurrentPerformanceT*)p->ptr;
		else
			delete[] (ns1__CmCurrentPerformanceT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTECustomerT:
		if (p->size < 0)
			delete (ns1__CTECustomerT*)p->ptr;
		else
			delete[] (ns1__CTECustomerT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEAbstractMacT:
		if (p->size < 0)
			delete (ns1__CTEAbstractMacT*)p->ptr;
		else
			delete[] (ns1__CTEAbstractMacT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEAbstractNameT:
		if (p->size < 0)
			delete (ns1__CTEAbstractNameT*)p->ptr;
		else
			delete[] (ns1__CTEAbstractNameT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEDataT:
		if (p->size < 0)
			delete (ns1__CTEDataT*)p->ptr;
		else
			delete[] (ns1__CTEDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CTEQueryInputT:
		if (p->size < 0)
			delete (ns1__CTEQueryInputT*)p->ptr;
		else
			delete[] (ns1__CTEQueryInputT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CMSLineT:
		if (p->size < 0)
			delete (ns1__CMSLineT*)p->ptr;
		else
			delete[] (ns1__CMSLineT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CMSResultT:
		if (p->size < 0)
			delete (ns1__CMSResultT*)p->ptr;
		else
			delete[] (ns1__CMSResultT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UserAccessT:
		if (p->size < 0)
			delete (ns1__UserAccessT*)p->ptr;
		else
			delete[] (ns1__UserAccessT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ApplicationDomainT:
		if (p->size < 0)
			delete (ns1__ApplicationDomainT*)p->ptr;
		else
			delete[] (ns1__ApplicationDomainT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__RoleT:
		if (p->size < 0)
			delete (ns1__RoleT*)p->ptr;
		else
			delete[] (ns1__RoleT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__UserT:
		if (p->size < 0)
			delete (ns1__UserT*)p->ptr;
		else
			delete[] (ns1__UserT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__PollingIntervalsT:
		if (p->size < 0)
			delete (ns1__PollingIntervalsT*)p->ptr;
		else
			delete[] (ns1__PollingIntervalsT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AlarmBasedStatusThresholdT:
		if (p->size < 0)
			delete (ns1__AlarmBasedStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__AlarmBasedStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AggregateStatusThresholdT:
		if (p->size < 0)
			delete (ns1__AggregateStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__AggregateStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaStatusThresholdT:
		if (p->size < 0)
			delete (ns1__MtaStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__MtaStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcStatusThresholdT:
		if (p->size < 0)
			delete (ns1__HfcStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__HfcStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ChannelStatusThresholdT:
		if (p->size < 0)
			delete (ns1__ChannelStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__ChannelStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsStatusThresholdT:
		if (p->size < 0)
			delete (ns1__CmtsStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__CmtsStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmsStatusThresholdT:
		if (p->size < 0)
			delete (ns1__CmsStatusThresholdT*)p->ptr;
		else
			delete[] (ns1__CmsStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__SoakWindowT:
		if (p->size < 0)
			delete (ns1__SoakWindowT*)p->ptr;
		else
			delete[] (ns1__SoakWindowT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AggregateCmOfflineTresholdT:
		if (p->size < 0)
			delete (ns1__AggregateCmOfflineTresholdT*)p->ptr;
		else
			delete[] (ns1__AggregateCmOfflineTresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AggregateMtaTresholdT:
		if (p->size < 0)
			delete (ns1__AggregateMtaTresholdT*)p->ptr;
		else
			delete[] (ns1__AggregateMtaTresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcPowerTresholdT:
		if (p->size < 0)
			delete (ns1__HfcPowerTresholdT*)p->ptr;
		else
			delete[] (ns1__HfcPowerTresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcAlarmConfigT:
		if (p->size < 0)
			delete (ns1__HfcAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__HfcAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__AlarmTypeConfigT:
		if (p->size < 0)
			delete (ns1__AlarmTypeConfigT*)p->ptr;
		else
			delete[] (ns1__AlarmTypeConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaAlarmConfigT:
		if (p->size < 0)
			delete (ns1__MtaAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__MtaAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsAlarmConfigT:
		if (p->size < 0)
			delete (ns1__CmtsAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__CmtsAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmsAlarmConfigT:
		if (p->size < 0)
			delete (ns1__CmsAlarmConfigT*)p->ptr;
		else
			delete[] (ns1__CmsAlarmConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmPerformanceConfigT:
		if (p->size < 0)
			delete (ns1__CmPerformanceConfigT*)p->ptr;
		else
			delete[] (ns1__CmPerformanceConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__ConfigDownloadT:
		if (p->size < 0)
			delete (ns1__ConfigDownloadT*)p->ptr;
		else
			delete[] (ns1__ConfigDownloadT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmtsCmDataT:
		if (p->size < 0)
			delete (ns1__CmtsCmDataT*)p->ptr;
		else
			delete[] (ns1__CmtsCmDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmDataT:
		if (p->size < 0)
			delete (ns1__CmDataT*)p->ptr;
		else
			delete[] (ns1__CmDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaDataT:
		if (p->size < 0)
			delete (ns1__MtaDataT*)p->ptr;
		else
			delete[] (ns1__MtaDataT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__StatusSummaryT:
		if (p->size < 0)
			delete (ns1__StatusSummaryT*)p->ptr;
		else
			delete[] (ns1__StatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryT:
		if (p->size < 0)
			delete (ns1__HfcStatusSummaryT*)p->ptr;
		else
			delete[] (ns1__HfcStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryT:
		if (p->size < 0)
			delete (ns1__MtaStatusSummaryT*)p->ptr;
		else
			delete[] (ns1__MtaStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryT:
		if (p->size < 0)
			delete (ns1__CmStatusSummaryT*)p->ptr;
		else
			delete[] (ns1__CmStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__MtaStatusSummaryRespT:
		if (p->size < 0)
			delete (ns1__MtaStatusSummaryRespT*)p->ptr;
		else
			delete[] (ns1__MtaStatusSummaryRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HfcStatusSummaryRespT:
		if (p->size < 0)
			delete (ns1__HfcStatusSummaryRespT*)p->ptr;
		else
			delete[] (ns1__HfcStatusSummaryRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CmStatusSummaryRespT:
		if (p->size < 0)
			delete (ns1__CmStatusSummaryRespT*)p->ptr;
		else
			delete[] (ns1__CmStatusSummaryRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__CurrentAlarmsRespT:
		if (p->size < 0)
			delete (ns1__CurrentAlarmsRespT*)p->ptr;
		else
			delete[] (ns1__CurrentAlarmsRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__HistoricalAlarmsRespT:
		if (p->size < 0)
			delete (ns1__HistoricalAlarmsRespT*)p->ptr;
		else
			delete[] (ns1__HistoricalAlarmsRespT*)p->ptr;
		break;
	case SOAP_TYPE_ns1__EventMessageT:
		if (p->size < 0)
			delete (ns1__EventMessageT*)p->ptr;
		else
			delete[] (ns1__EventMessageT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfRegionsT:
		if (p->size < 0)
			delete (ArrayOfRegionsT*)p->ptr;
		else
			delete[] (ArrayOfRegionsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMarketsT:
		if (p->size < 0)
			delete (ArrayOfMarketsT*)p->ptr;
		else
			delete[] (ArrayOfMarketsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfBladesT:
		if (p->size < 0)
			delete (ArrayOfBladesT*)p->ptr;
		else
			delete[] (ArrayOfBladesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmsesT:
		if (p->size < 0)
			delete (ArrayOfCmsesT*)p->ptr;
		else
			delete[] (ArrayOfCmsesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmtsesT:
		if (p->size < 0)
			delete (ArrayOfCmtsesT*)p->ptr;
		else
			delete[] (ArrayOfCmtsesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfSnmpV2CAttributesT:
		if (p->size < 0)
			delete (ArrayOfSnmpV2CAttributesT*)p->ptr;
		else
			delete[] (ArrayOfSnmpV2CAttributesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfChannelsT:
		if (p->size < 0)
			delete (ArrayOfChannelsT*)p->ptr;
		else
			delete[] (ArrayOfChannelsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfHfcsT:
		if (p->size < 0)
			delete (ArrayOfHfcsT*)p->ptr;
		else
			delete[] (ArrayOfHfcsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCableModemsT:
		if (p->size < 0)
			delete (ArrayOfCableModemsT*)p->ptr;
		else
			delete[] (ArrayOfCableModemsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfEmtasT:
		if (p->size < 0)
			delete (ArrayOfEmtasT*)p->ptr;
		else
			delete[] (ArrayOfEmtasT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCurrentAlarmsT:
		if (p->size < 0)
			delete (ArrayOfCurrentAlarmsT*)p->ptr;
		else
			delete[] (ArrayOfCurrentAlarmsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfHistoricalAlarmsT:
		if (p->size < 0)
			delete (ArrayOfHistoricalAlarmsT*)p->ptr;
		else
			delete[] (ArrayOfHistoricalAlarmsT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAlarmHistoriesT:
		if (p->size < 0)
			delete (ArrayOfAlarmHistoriesT*)p->ptr;
		else
			delete[] (ArrayOfAlarmHistoriesT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfScrollPageT:
		if (p->size < 0)
			delete (ArrayOfScrollPageT*)p->ptr;
		else
			delete[] (ArrayOfScrollPageT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfQueryStateT:
		if (p->size < 0)
			delete (ArrayOfQueryStateT*)p->ptr;
		else
			delete[] (ArrayOfQueryStateT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfGenericCountsHistoryT:
		if (p->size < 0)
			delete (ArrayOfGenericCountsHistoryT*)p->ptr;
		else
			delete[] (ArrayOfGenericCountsHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmStatusHistoryT:
		if (p->size < 0)
			delete (ArrayOfCmStatusHistoryT*)p->ptr;
		else
			delete[] (ArrayOfCmStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT:
		if (p->size < 0)
			delete (ArrayOfMtaAvailabilityHistoryT*)p->ptr;
		else
			delete[] (ArrayOfMtaAvailabilityHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaProvStatusHistoryT:
		if (p->size < 0)
			delete (ArrayOfMtaProvStatusHistoryT*)p->ptr;
		else
			delete[] (ArrayOfMtaProvStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaPingStatusHistoryT:
		if (p->size < 0)
			delete (ArrayOfMtaPingStatusHistoryT*)p->ptr;
		else
			delete[] (ArrayOfMtaPingStatusHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmPerformanceHistoryT:
		if (p->size < 0)
			delete (ArrayOfCmPerformanceHistoryT*)p->ptr;
		else
			delete[] (ArrayOfCmPerformanceHistoryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCTECustomerT:
		if (p->size < 0)
			delete (ArrayOfCTECustomerT*)p->ptr;
		else
			delete[] (ArrayOfCTECustomerT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCTEDataT:
		if (p->size < 0)
			delete (ArrayOfCTEDataT*)p->ptr;
		else
			delete[] (ArrayOfCTEDataT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCTEQueryInputT:
		if (p->size < 0)
			delete (ArrayOfCTEQueryInputT*)p->ptr;
		else
			delete[] (ArrayOfCTEQueryInputT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCMSLineT:
		if (p->size < 0)
			delete (ArrayOfCMSLineT*)p->ptr;
		else
			delete[] (ArrayOfCMSLineT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfUserAccessT:
		if (p->size < 0)
			delete (ArrayOfUserAccessT*)p->ptr;
		else
			delete[] (ArrayOfUserAccessT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfApplicationDomainT:
		if (p->size < 0)
			delete (ArrayOfApplicationDomainT*)p->ptr;
		else
			delete[] (ArrayOfApplicationDomainT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfRoleT:
		if (p->size < 0)
			delete (ArrayOfRoleT*)p->ptr;
		else
			delete[] (ArrayOfRoleT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfUserT:
		if (p->size < 0)
			delete (ArrayOfUserT*)p->ptr;
		else
			delete[] (ArrayOfUserT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAlarmStatusThresholdT:
		if (p->size < 0)
			delete (ArrayOfAlarmStatusThresholdT*)p->ptr;
		else
			delete[] (ArrayOfAlarmStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAggregateStatusThresholdT:
		if (p->size < 0)
			delete (ArrayOfAggregateStatusThresholdT*)p->ptr;
		else
			delete[] (ArrayOfAggregateStatusThresholdT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfAlarmTypeConfigT:
		if (p->size < 0)
			delete (ArrayOfAlarmTypeConfigT*)p->ptr;
		else
			delete[] (ArrayOfAlarmTypeConfigT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfHfcStatusSummaryT:
		if (p->size < 0)
			delete (ArrayOfHfcStatusSummaryT*)p->ptr;
		else
			delete[] (ArrayOfHfcStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfMtaStatusSummaryT:
		if (p->size < 0)
			delete (ArrayOfMtaStatusSummaryT*)p->ptr;
		else
			delete[] (ArrayOfMtaStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_ArrayOfCmStatusSummaryT:
		if (p->size < 0)
			delete (ArrayOfCmStatusSummaryT*)p->ptr;
		else
			delete[] (ArrayOfCmStatusSummaryT*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmtsResponse:
		if (p->size < 0)
			delete (struct adm__updateCmtsResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmtsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmts:
		if (p->size < 0)
			delete (struct adm__updateCmts*)p->ptr;
		else
			delete[] (struct adm__updateCmts*)p->ptr;
		break;
	case SOAP_TYPE_adm__addCmtsResponse:
		if (p->size < 0)
			delete (struct adm__addCmtsResponse*)p->ptr;
		else
			delete[] (struct adm__addCmtsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__addCmts:
		if (p->size < 0)
			delete (struct adm__addCmts*)p->ptr;
		else
			delete[] (struct adm__addCmts*)p->ptr;
		break;
	case SOAP_TYPE_adm__deleteCmtsResponse:
		if (p->size < 0)
			delete (struct adm__deleteCmtsResponse*)p->ptr;
		else
			delete[] (struct adm__deleteCmtsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__deleteCmts:
		if (p->size < 0)
			delete (struct adm__deleteCmts*)p->ptr;
		else
			delete[] (struct adm__deleteCmts*)p->ptr;
		break;
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse:
		if (p->size < 0)
			delete (struct adm__addCmtsAllSnmpV2CAttributesResponse*)p->ptr;
		else
			delete[] (struct adm__addCmtsAllSnmpV2CAttributesResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes:
		if (p->size < 0)
			delete (struct adm__addCmtsAllSnmpV2CAttributes*)p->ptr;
		else
			delete[] (struct adm__addCmtsAllSnmpV2CAttributes*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse:
		if (p->size < 0)
			delete (struct adm__updateCmtsAllSnmpV2CAttributesResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmtsAllSnmpV2CAttributesResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes:
		if (p->size < 0)
			delete (struct adm__updateCmtsAllSnmpV2CAttributes*)p->ptr;
		else
			delete[] (struct adm__updateCmtsAllSnmpV2CAttributes*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmsResponse:
		if (p->size < 0)
			delete (struct adm__updateCmsResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCms:
		if (p->size < 0)
			delete (struct adm__updateCms*)p->ptr;
		else
			delete[] (struct adm__updateCms*)p->ptr;
		break;
	case SOAP_TYPE_adm__addCmsResponse:
		if (p->size < 0)
			delete (struct adm__addCmsResponse*)p->ptr;
		else
			delete[] (struct adm__addCmsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__addCms:
		if (p->size < 0)
			delete (struct adm__addCms*)p->ptr;
		else
			delete[] (struct adm__addCms*)p->ptr;
		break;
	case SOAP_TYPE_adm__deleteCmsResponse:
		if (p->size < 0)
			delete (struct adm__deleteCmsResponse*)p->ptr;
		else
			delete[] (struct adm__deleteCmsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__deleteCms:
		if (p->size < 0)
			delete (struct adm__deleteCms*)p->ptr;
		else
			delete[] (struct adm__deleteCms*)p->ptr;
		break;
	case SOAP_TYPE_adm__getPollingIntervalsResponse:
		if (p->size < 0)
			delete (struct adm__getPollingIntervalsResponse*)p->ptr;
		else
			delete[] (struct adm__getPollingIntervalsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getPollingIntervals:
		if (p->size < 0)
			delete (struct adm__getPollingIntervals*)p->ptr;
		else
			delete[] (struct adm__getPollingIntervals*)p->ptr;
		break;
	case SOAP_TYPE_adm__updatePollingIntervalsResponse:
		if (p->size < 0)
			delete (struct adm__updatePollingIntervalsResponse*)p->ptr;
		else
			delete[] (struct adm__updatePollingIntervalsResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updatePollingIntervals:
		if (p->size < 0)
			delete (struct adm__updatePollingIntervals*)p->ptr;
		else
			delete[] (struct adm__updatePollingIntervals*)p->ptr;
		break;
	case SOAP_TYPE_adm__getMtaStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__getMtaStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__getMtaStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getMtaStatusThreshold:
		if (p->size < 0)
			delete (struct adm__getMtaStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__getMtaStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateMtaStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__updateMtaStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__updateMtaStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateMtaStatusThreshold:
		if (p->size < 0)
			delete (struct adm__updateMtaStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__updateMtaStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__getHfcStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__getHfcStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__getHfcStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getHfcStatusThreshold:
		if (p->size < 0)
			delete (struct adm__getHfcStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__getHfcStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateHfcStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__updateHfcStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__updateHfcStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateHfcStatusThreshold:
		if (p->size < 0)
			delete (struct adm__updateHfcStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__updateHfcStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__getChannelStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__getChannelStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__getChannelStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getChannelStatusThreshold:
		if (p->size < 0)
			delete (struct adm__getChannelStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__getChannelStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateChannelStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__updateChannelStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__updateChannelStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateChannelStatusThreshold:
		if (p->size < 0)
			delete (struct adm__updateChannelStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__updateChannelStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmtsStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__getCmtsStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__getCmtsStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmtsStatusThreshold:
		if (p->size < 0)
			delete (struct adm__getCmtsStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__getCmtsStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmtsStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__updateCmtsStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmtsStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmtsStatusThreshold:
		if (p->size < 0)
			delete (struct adm__updateCmtsStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__updateCmtsStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmsStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__getCmsStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__getCmsStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmsStatusThreshold:
		if (p->size < 0)
			delete (struct adm__getCmsStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__getCmsStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmsStatusThresholdResponse:
		if (p->size < 0)
			delete (struct adm__updateCmsStatusThresholdResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmsStatusThresholdResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmsStatusThreshold:
		if (p->size < 0)
			delete (struct adm__updateCmsStatusThreshold*)p->ptr;
		else
			delete[] (struct adm__updateCmsStatusThreshold*)p->ptr;
		break;
	case SOAP_TYPE_adm__getMtaAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__getMtaAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__getMtaAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getMtaAlarmConfig:
		if (p->size < 0)
			delete (struct adm__getMtaAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__getMtaAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateMtaAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__updateMtaAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__updateMtaAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateMtaAlarmConfig:
		if (p->size < 0)
			delete (struct adm__updateMtaAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__updateMtaAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__getHfcAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__getHfcAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__getHfcAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getHfcAlarmConfig:
		if (p->size < 0)
			delete (struct adm__getHfcAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__getHfcAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateHfcAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__updateHfcAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__updateHfcAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateHfcAlarmConfig:
		if (p->size < 0)
			delete (struct adm__updateHfcAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__updateHfcAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmtsAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__getCmtsAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__getCmtsAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmtsAlarmConfig:
		if (p->size < 0)
			delete (struct adm__getCmtsAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__getCmtsAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmtsAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__updateCmtsAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmtsAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmtsAlarmConfig:
		if (p->size < 0)
			delete (struct adm__updateCmtsAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__updateCmtsAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmsAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__getCmsAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__getCmsAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmsAlarmConfig:
		if (p->size < 0)
			delete (struct adm__getCmsAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__getCmsAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmsAlarmConfigResponse:
		if (p->size < 0)
			delete (struct adm__updateCmsAlarmConfigResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmsAlarmConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmsAlarmConfig:
		if (p->size < 0)
			delete (struct adm__updateCmsAlarmConfig*)p->ptr;
		else
			delete[] (struct adm__updateCmsAlarmConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateLocalSystemResponse:
		if (p->size < 0)
			delete (struct adm__updateLocalSystemResponse*)p->ptr;
		else
			delete[] (struct adm__updateLocalSystemResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateLocalSystem:
		if (p->size < 0)
			delete (struct adm__updateLocalSystem*)p->ptr;
		else
			delete[] (struct adm__updateLocalSystem*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateRegionResponse:
		if (p->size < 0)
			delete (struct adm__updateRegionResponse*)p->ptr;
		else
			delete[] (struct adm__updateRegionResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateRegion:
		if (p->size < 0)
			delete (struct adm__updateRegion*)p->ptr;
		else
			delete[] (struct adm__updateRegion*)p->ptr;
		break;
	case SOAP_TYPE_adm__addRegionResponse:
		if (p->size < 0)
			delete (struct adm__addRegionResponse*)p->ptr;
		else
			delete[] (struct adm__addRegionResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__addRegion:
		if (p->size < 0)
			delete (struct adm__addRegion*)p->ptr;
		else
			delete[] (struct adm__addRegion*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateMarketResponse:
		if (p->size < 0)
			delete (struct adm__updateMarketResponse*)p->ptr;
		else
			delete[] (struct adm__updateMarketResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateMarket:
		if (p->size < 0)
			delete (struct adm__updateMarket*)p->ptr;
		else
			delete[] (struct adm__updateMarket*)p->ptr;
		break;
	case SOAP_TYPE_adm__addMarketResponse:
		if (p->size < 0)
			delete (struct adm__addMarketResponse*)p->ptr;
		else
			delete[] (struct adm__addMarketResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__addMarket:
		if (p->size < 0)
			delete (struct adm__addMarket*)p->ptr;
		else
			delete[] (struct adm__addMarket*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateBladeResponse:
		if (p->size < 0)
			delete (struct adm__updateBladeResponse*)p->ptr;
		else
			delete[] (struct adm__updateBladeResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateBlade:
		if (p->size < 0)
			delete (struct adm__updateBlade*)p->ptr;
		else
			delete[] (struct adm__updateBlade*)p->ptr;
		break;
	case SOAP_TYPE_adm__addBladeResponse:
		if (p->size < 0)
			delete (struct adm__addBladeResponse*)p->ptr;
		else
			delete[] (struct adm__addBladeResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__addBlade:
		if (p->size < 0)
			delete (struct adm__addBlade*)p->ptr;
		else
			delete[] (struct adm__addBlade*)p->ptr;
		break;
	case SOAP_TYPE_adm__deleteBladeResponse:
		if (p->size < 0)
			delete (struct adm__deleteBladeResponse*)p->ptr;
		else
			delete[] (struct adm__deleteBladeResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__deleteBlade:
		if (p->size < 0)
			delete (struct adm__deleteBlade*)p->ptr;
		else
			delete[] (struct adm__deleteBlade*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmPerfConfigResponse:
		if (p->size < 0)
			delete (struct adm__getCmPerfConfigResponse*)p->ptr;
		else
			delete[] (struct adm__getCmPerfConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getCmPerfConfig:
		if (p->size < 0)
			delete (struct adm__getCmPerfConfig*)p->ptr;
		else
			delete[] (struct adm__getCmPerfConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmPerfConfigResponse:
		if (p->size < 0)
			delete (struct adm__updateCmPerfConfigResponse*)p->ptr;
		else
			delete[] (struct adm__updateCmPerfConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateCmPerfConfig:
		if (p->size < 0)
			delete (struct adm__updateCmPerfConfig*)p->ptr;
		else
			delete[] (struct adm__updateCmPerfConfig*)p->ptr;
		break;
	case SOAP_TYPE_adm__addUserResponse:
		if (p->size < 0)
			delete (struct adm__addUserResponse*)p->ptr;
		else
			delete[] (struct adm__addUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__addUser:
		if (p->size < 0)
			delete (struct adm__addUser*)p->ptr;
		else
			delete[] (struct adm__addUser*)p->ptr;
		break;
	case SOAP_TYPE_adm__getUsersResponse:
		if (p->size < 0)
			delete (struct adm__getUsersResponse*)p->ptr;
		else
			delete[] (struct adm__getUsersResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getUsers:
		if (p->size < 0)
			delete (struct adm__getUsers*)p->ptr;
		else
			delete[] (struct adm__getUsers*)p->ptr;
		break;
	case SOAP_TYPE_adm__getUserResponse:
		if (p->size < 0)
			delete (struct adm__getUserResponse*)p->ptr;
		else
			delete[] (struct adm__getUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getUser:
		if (p->size < 0)
			delete (struct adm__getUser*)p->ptr;
		else
			delete[] (struct adm__getUser*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateUserResponse:
		if (p->size < 0)
			delete (struct adm__updateUserResponse*)p->ptr;
		else
			delete[] (struct adm__updateUserResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateUser:
		if (p->size < 0)
			delete (struct adm__updateUser*)p->ptr;
		else
			delete[] (struct adm__updateUser*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateUserPasswordResponse:
		if (p->size < 0)
			delete (struct adm__updateUserPasswordResponse*)p->ptr;
		else
			delete[] (struct adm__updateUserPasswordResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateUserPassword:
		if (p->size < 0)
			delete (struct adm__updateUserPassword*)p->ptr;
		else
			delete[] (struct adm__updateUserPassword*)p->ptr;
		break;
	case SOAP_TYPE_adm__getRolesResponse:
		if (p->size < 0)
			delete (struct adm__getRolesResponse*)p->ptr;
		else
			delete[] (struct adm__getRolesResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getRoles:
		if (p->size < 0)
			delete (struct adm__getRoles*)p->ptr;
		else
			delete[] (struct adm__getRoles*)p->ptr;
		break;
	case SOAP_TYPE_adm__getRoleResponse:
		if (p->size < 0)
			delete (struct adm__getRoleResponse*)p->ptr;
		else
			delete[] (struct adm__getRoleResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getRole:
		if (p->size < 0)
			delete (struct adm__getRole*)p->ptr;
		else
			delete[] (struct adm__getRole*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateRoleResponse:
		if (p->size < 0)
			delete (struct adm__updateRoleResponse*)p->ptr;
		else
			delete[] (struct adm__updateRoleResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__updateRole:
		if (p->size < 0)
			delete (struct adm__updateRole*)p->ptr;
		else
			delete[] (struct adm__updateRole*)p->ptr;
		break;
	case SOAP_TYPE_adm__downloadConfigFromParentResponse:
		if (p->size < 0)
			delete (struct adm__downloadConfigFromParentResponse*)p->ptr;
		else
			delete[] (struct adm__downloadConfigFromParentResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__downloadConfigFromParent:
		if (p->size < 0)
			delete (struct adm__downloadConfigFromParent*)p->ptr;
		else
			delete[] (struct adm__downloadConfigFromParent*)p->ptr;
		break;
	case SOAP_TYPE_adm__getConfigResponse:
		if (p->size < 0)
			delete (struct adm__getConfigResponse*)p->ptr;
		else
			delete[] (struct adm__getConfigResponse*)p->ptr;
		break;
	case SOAP_TYPE_adm__getConfig:
		if (p->size < 0)
			delete (struct adm__getConfig*)p->ptr;
		else
			delete[] (struct adm__getConfig*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Header:
		if (p->size < 0)
			delete (struct SOAP_ENV__Header*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Header*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Code:
		if (p->size < 0)
			delete (struct SOAP_ENV__Code*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Code*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Detail:
		if (p->size < 0)
			delete (struct SOAP_ENV__Detail*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Detail*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Reason:
		if (p->size < 0)
			delete (struct SOAP_ENV__Reason*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Reason*)p->ptr;
		break;
	case SOAP_TYPE_SOAP_ENV__Fault:
		if (p->size < 0)
			delete (struct SOAP_ENV__Fault*)p->ptr;
		else
			delete[] (struct SOAP_ENV__Fault*)p->ptr;
		break;
	case SOAP_TYPE_xsd__integer:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	case SOAP_TYPE__SOAP_ENC__arrayType:
		if (p->size < 0)
			delete (std::string*)p->ptr;
		else
			delete[] (std::string*)p->ptr;
		break;
	default:	return SOAP_ERR;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_class_id_enter(struct soap *soap, const char *id, void *p, int t, size_t n, const char *type, const char *arrayType)
{	return soap_id_enter(soap, id, p, t, n, 0, type, arrayType, soap_instantiate);
}

SOAP_FMAC3 void* SOAP_FMAC4 soap_container_id_forward(struct soap *soap, const char *href, void *p, size_t len, int st, int tt, size_t n, unsigned int k)
{	return soap_id_forward(soap, href, p, len, st, tt, n, k, soap_container_insert);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_container_insert(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{	switch (tt)
	{
	default:
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Could not insert type=%d in %d\n", st, tt));
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_byte(struct soap *soap, char *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_byte
	*a = SOAP_DEFAULT_byte;
#else
	*a = (char)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_byte);
	if (soap_out_byte(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	return soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_short(struct soap *soap, short *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_short
	*a = SOAP_DEFAULT_short;
#else
	*a = (short)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_short(struct soap *soap, const short *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_short);
	if (soap_out_short(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_short(struct soap *soap, const char *tag, int id, const short *a, const char *type)
{
	return soap_outshort(soap, tag, id, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_get_short(struct soap *soap, short *p, const char *tag, const char *type)
{
	if ((p = soap_in_short(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short * SOAP_FMAC4 soap_in_short(struct soap *soap, const char *tag, short *a, const char *type)
{
	return soap_inshort(soap, tag, a, type, SOAP_TYPE_short);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_int(struct soap *soap, int *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_int
	*a = SOAP_DEFAULT_int;
#else
	*a = (int)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_int);
	if (soap_out_int(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	return soap_inint(soap, tag, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EventCategoryT(struct soap *soap, enum ns1__EventCategoryT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EventCategoryT
	*a = SOAP_DEFAULT_ns1__EventCategoryT;
#else
	*a = (enum ns1__EventCategoryT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EventCategoryT(struct soap *soap, const enum ns1__EventCategoryT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__EventCategoryT);
	if (soap_out_ns1__EventCategoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__EventCategoryT[] =
{	{ (long)ns1__EventCategoryT__Resource, "Resource" },
	{ (long)ns1__EventCategoryT__Configuration, "Configuration" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__EventCategoryT2s(struct soap *soap, enum ns1__EventCategoryT n)
{	const char *s = soap_code_str(soap_codes_ns1__EventCategoryT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EventCategoryT(struct soap *soap, const char *tag, int id, const enum ns1__EventCategoryT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EventCategoryT), type);
	soap_send(soap, soap_ns1__EventCategoryT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__EventCategoryT * SOAP_FMAC4 soap_get_ns1__EventCategoryT(struct soap *soap, enum ns1__EventCategoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EventCategoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__EventCategoryT(struct soap *soap, const char *s, enum ns1__EventCategoryT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__EventCategoryT, s);
	if (map)
		*a = (enum ns1__EventCategoryT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__EventCategoryT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__EventCategoryT * SOAP_FMAC4 soap_in_ns1__EventCategoryT(struct soap *soap, const char *tag, enum ns1__EventCategoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__EventCategoryT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EventCategoryT, sizeof(enum ns1__EventCategoryT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__EventCategoryT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__EventCategoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EventCategoryT, 0, sizeof(enum ns1__EventCategoryT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EventTypeT(struct soap *soap, enum ns1__EventTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EventTypeT
	*a = SOAP_DEFAULT_ns1__EventTypeT;
#else
	*a = (enum ns1__EventTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EventTypeT(struct soap *soap, const enum ns1__EventTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__EventTypeT);
	if (soap_out_ns1__EventTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__EventTypeT[] =
{	{ (long)ns1__EventTypeT__Add, "Add" },
	{ (long)ns1__EventTypeT__Delete, "Delete" },
	{ (long)ns1__EventTypeT__Update, "Update" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__EventTypeT2s(struct soap *soap, enum ns1__EventTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__EventTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EventTypeT(struct soap *soap, const char *tag, int id, const enum ns1__EventTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EventTypeT), type);
	soap_send(soap, soap_ns1__EventTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__EventTypeT * SOAP_FMAC4 soap_get_ns1__EventTypeT(struct soap *soap, enum ns1__EventTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EventTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__EventTypeT(struct soap *soap, const char *s, enum ns1__EventTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__EventTypeT, s);
	if (map)
		*a = (enum ns1__EventTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__EventTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__EventTypeT * SOAP_FMAC4 soap_in_ns1__EventTypeT(struct soap *soap, const char *tag, enum ns1__EventTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__EventTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EventTypeT, sizeof(enum ns1__EventTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__EventTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__EventTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EventTypeT, 0, sizeof(enum ns1__EventTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ApplicationDomainTypeT(struct soap *soap, enum ns1__ApplicationDomainTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ApplicationDomainTypeT
	*a = SOAP_DEFAULT_ns1__ApplicationDomainTypeT;
#else
	*a = (enum ns1__ApplicationDomainTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ApplicationDomainTypeT(struct soap *soap, const enum ns1__ApplicationDomainTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ApplicationDomainTypeT);
	if (soap_out_ns1__ApplicationDomainTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ApplicationDomainTypeT[] =
{	{ (long)ns1__ApplicationDomainTypeT__Alarm, "Alarm" },
	{ (long)ns1__ApplicationDomainTypeT__CSR_x0020Portal, "CSR Portal" },
	{ (long)ns1__ApplicationDomainTypeT__System_x0020Administration, "System Administration" },
	{ (long)ns1__ApplicationDomainTypeT__User_x0020Administration, "User Administration" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ApplicationDomainTypeT2s(struct soap *soap, enum ns1__ApplicationDomainTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__ApplicationDomainTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApplicationDomainTypeT(struct soap *soap, const char *tag, int id, const enum ns1__ApplicationDomainTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApplicationDomainTypeT), type);
	soap_send(soap, soap_ns1__ApplicationDomainTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ApplicationDomainTypeT * SOAP_FMAC4 soap_get_ns1__ApplicationDomainTypeT(struct soap *soap, enum ns1__ApplicationDomainTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApplicationDomainTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ApplicationDomainTypeT(struct soap *soap, const char *s, enum ns1__ApplicationDomainTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ApplicationDomainTypeT, s);
	if (map)
		*a = (enum ns1__ApplicationDomainTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ApplicationDomainTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ApplicationDomainTypeT * SOAP_FMAC4 soap_in_ns1__ApplicationDomainTypeT(struct soap *soap, const char *tag, enum ns1__ApplicationDomainTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ApplicationDomainTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApplicationDomainTypeT, sizeof(enum ns1__ApplicationDomainTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ApplicationDomainTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ApplicationDomainTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApplicationDomainTypeT, 0, sizeof(enum ns1__ApplicationDomainTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__UserAccessTypeT(struct soap *soap, enum ns1__UserAccessTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__UserAccessTypeT
	*a = SOAP_DEFAULT_ns1__UserAccessTypeT;
#else
	*a = (enum ns1__UserAccessTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__UserAccessTypeT(struct soap *soap, const enum ns1__UserAccessTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__UserAccessTypeT);
	if (soap_out_ns1__UserAccessTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__UserAccessTypeT[] =
{	{ (long)ns1__UserAccessTypeT__None, "None" },
	{ (long)ns1__UserAccessTypeT__Read, "Read" },
	{ (long)ns1__UserAccessTypeT__Write, "Write" },
	{ (long)ns1__UserAccessTypeT__Execute, "Execute" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__UserAccessTypeT2s(struct soap *soap, enum ns1__UserAccessTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__UserAccessTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserAccessTypeT(struct soap *soap, const char *tag, int id, const enum ns1__UserAccessTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserAccessTypeT), type);
	soap_send(soap, soap_ns1__UserAccessTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__UserAccessTypeT * SOAP_FMAC4 soap_get_ns1__UserAccessTypeT(struct soap *soap, enum ns1__UserAccessTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserAccessTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__UserAccessTypeT(struct soap *soap, const char *s, enum ns1__UserAccessTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__UserAccessTypeT, s);
	if (map)
		*a = (enum ns1__UserAccessTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__UserAccessTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__UserAccessTypeT * SOAP_FMAC4 soap_in_ns1__UserAccessTypeT(struct soap *soap, const char *tag, enum ns1__UserAccessTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__UserAccessTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserAccessTypeT, sizeof(enum ns1__UserAccessTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__UserAccessTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__UserAccessTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserAccessTypeT, 0, sizeof(enum ns1__UserAccessTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__EndUserDeviceTypeT(struct soap *soap, enum ns1__EndUserDeviceTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__EndUserDeviceTypeT
	*a = SOAP_DEFAULT_ns1__EndUserDeviceTypeT;
#else
	*a = (enum ns1__EndUserDeviceTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__EndUserDeviceTypeT(struct soap *soap, const enum ns1__EndUserDeviceTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__EndUserDeviceTypeT);
	if (soap_out_ns1__EndUserDeviceTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__EndUserDeviceTypeT[] =
{	{ (long)ns1__EndUserDeviceTypeT__CM, "CM" },
	{ (long)ns1__EndUserDeviceTypeT__eMTA, "eMTA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__EndUserDeviceTypeT2s(struct soap *soap, enum ns1__EndUserDeviceTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__EndUserDeviceTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EndUserDeviceTypeT(struct soap *soap, const char *tag, int id, const enum ns1__EndUserDeviceTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EndUserDeviceTypeT), type);
	soap_send(soap, soap_ns1__EndUserDeviceTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__EndUserDeviceTypeT * SOAP_FMAC4 soap_get_ns1__EndUserDeviceTypeT(struct soap *soap, enum ns1__EndUserDeviceTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EndUserDeviceTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__EndUserDeviceTypeT(struct soap *soap, const char *s, enum ns1__EndUserDeviceTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__EndUserDeviceTypeT, s);
	if (map)
		*a = (enum ns1__EndUserDeviceTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__EndUserDeviceTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__EndUserDeviceTypeT * SOAP_FMAC4 soap_in_ns1__EndUserDeviceTypeT(struct soap *soap, const char *tag, enum ns1__EndUserDeviceTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__EndUserDeviceTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EndUserDeviceTypeT, sizeof(enum ns1__EndUserDeviceTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__EndUserDeviceTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__EndUserDeviceTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EndUserDeviceTypeT, 0, sizeof(enum ns1__EndUserDeviceTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChannelTypeT(struct soap *soap, enum ns1__ChannelTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ChannelTypeT
	*a = SOAP_DEFAULT_ns1__ChannelTypeT;
#else
	*a = (enum ns1__ChannelTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChannelTypeT(struct soap *soap, const enum ns1__ChannelTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ChannelTypeT);
	if (soap_out_ns1__ChannelTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ChannelTypeT[] =
{	{ (long)ns1__ChannelTypeT__Upstream, "Upstream" },
	{ (long)ns1__ChannelTypeT__Downstream, "Downstream" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ChannelTypeT2s(struct soap *soap, enum ns1__ChannelTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__ChannelTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChannelTypeT(struct soap *soap, const char *tag, int id, const enum ns1__ChannelTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChannelTypeT), type);
	soap_send(soap, soap_ns1__ChannelTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ChannelTypeT * SOAP_FMAC4 soap_get_ns1__ChannelTypeT(struct soap *soap, enum ns1__ChannelTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChannelTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ChannelTypeT(struct soap *soap, const char *s, enum ns1__ChannelTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ChannelTypeT, s);
	if (map)
		*a = (enum ns1__ChannelTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 1)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ChannelTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ChannelTypeT * SOAP_FMAC4 soap_in_ns1__ChannelTypeT(struct soap *soap, const char *tag, enum ns1__ChannelTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ChannelTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChannelTypeT, sizeof(enum ns1__ChannelTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ChannelTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ChannelTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChannelTypeT, 0, sizeof(enum ns1__ChannelTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SnmpVersionT(struct soap *soap, enum ns1__SnmpVersionT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__SnmpVersionT
	*a = SOAP_DEFAULT_ns1__SnmpVersionT;
#else
	*a = (enum ns1__SnmpVersionT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SnmpVersionT(struct soap *soap, const enum ns1__SnmpVersionT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SnmpVersionT);
	if (soap_out_ns1__SnmpVersionT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__SnmpVersionT[] =
{	{ (long)ns1__SnmpVersionT__v1, "v1" },
	{ (long)ns1__SnmpVersionT__v2c, "v2c" },
	{ (long)ns1__SnmpVersionT__v3, "v3" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SnmpVersionT2s(struct soap *soap, enum ns1__SnmpVersionT n)
{	const char *s = soap_code_str(soap_codes_ns1__SnmpVersionT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnmpVersionT(struct soap *soap, const char *tag, int id, const enum ns1__SnmpVersionT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnmpVersionT), type);
	soap_send(soap, soap_ns1__SnmpVersionT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__SnmpVersionT * SOAP_FMAC4 soap_get_ns1__SnmpVersionT(struct soap *soap, enum ns1__SnmpVersionT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnmpVersionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SnmpVersionT(struct soap *soap, const char *s, enum ns1__SnmpVersionT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__SnmpVersionT, s);
	if (map)
		*a = (enum ns1__SnmpVersionT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 2)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__SnmpVersionT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SnmpVersionT * SOAP_FMAC4 soap_in_ns1__SnmpVersionT(struct soap *soap, const char *tag, enum ns1__SnmpVersionT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__SnmpVersionT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnmpVersionT, sizeof(enum ns1__SnmpVersionT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__SnmpVersionT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__SnmpVersionT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnmpVersionT, 0, sizeof(enum ns1__SnmpVersionT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__StatusColorT(struct soap *soap, enum ns1__StatusColorT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__StatusColorT
	*a = SOAP_DEFAULT_ns1__StatusColorT;
#else
	*a = (enum ns1__StatusColorT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__StatusColorT(struct soap *soap, const enum ns1__StatusColorT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__StatusColorT);
	if (soap_out_ns1__StatusColorT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__StatusColorT[] =
{	{ (long)ns1__StatusColorT__Gray, "Gray" },
	{ (long)ns1__StatusColorT__Green, "Green" },
	{ (long)ns1__StatusColorT__Yellow, "Yellow" },
	{ (long)ns1__StatusColorT__Orange, "Orange" },
	{ (long)ns1__StatusColorT__Red, "Red" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__StatusColorT2s(struct soap *soap, enum ns1__StatusColorT n)
{	const char *s = soap_code_str(soap_codes_ns1__StatusColorT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatusColorT(struct soap *soap, const char *tag, int id, const enum ns1__StatusColorT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatusColorT), type);
	soap_send(soap, soap_ns1__StatusColorT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__StatusColorT * SOAP_FMAC4 soap_get_ns1__StatusColorT(struct soap *soap, enum ns1__StatusColorT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatusColorT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__StatusColorT(struct soap *soap, const char *s, enum ns1__StatusColorT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__StatusColorT, s);
	if (map)
		*a = (enum ns1__StatusColorT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 4)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__StatusColorT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__StatusColorT * SOAP_FMAC4 soap_in_ns1__StatusColorT(struct soap *soap, const char *tag, enum ns1__StatusColorT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__StatusColorT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatusColorT, sizeof(enum ns1__StatusColorT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__StatusColorT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__StatusColorT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StatusColorT, 0, sizeof(enum ns1__StatusColorT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ResourceTypeT(struct soap *soap, enum ns1__ResourceTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__ResourceTypeT
	*a = SOAP_DEFAULT_ns1__ResourceTypeT;
#else
	*a = (enum ns1__ResourceTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ResourceTypeT(struct soap *soap, const enum ns1__ResourceTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__ResourceTypeT);
	if (soap_out_ns1__ResourceTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__ResourceTypeT[] =
{	{ (long)ns1__ResourceTypeT__CMTS, "CMTS" },
	{ (long)ns1__ResourceTypeT__CMS, "CMS" },
	{ (long)ns1__ResourceTypeT__Channel, "Channel" },
	{ (long)ns1__ResourceTypeT__HFC, "HFC" },
	{ (long)ns1__ResourceTypeT__CM, "CM" },
	{ (long)ns1__ResourceTypeT__MTA, "MTA" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__ResourceTypeT2s(struct soap *soap, enum ns1__ResourceTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__ResourceTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResourceTypeT(struct soap *soap, const char *tag, int id, const enum ns1__ResourceTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResourceTypeT), type);
	soap_send(soap, soap_ns1__ResourceTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__ResourceTypeT * SOAP_FMAC4 soap_get_ns1__ResourceTypeT(struct soap *soap, enum ns1__ResourceTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResourceTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__ResourceTypeT(struct soap *soap, const char *s, enum ns1__ResourceTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__ResourceTypeT, s);
	if (map)
		*a = (enum ns1__ResourceTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 5)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__ResourceTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__ResourceTypeT * SOAP_FMAC4 soap_in_ns1__ResourceTypeT(struct soap *soap, const char *tag, enum ns1__ResourceTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__ResourceTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResourceTypeT, sizeof(enum ns1__ResourceTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__ResourceTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__ResourceTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResourceTypeT, 0, sizeof(enum ns1__ResourceTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SystemTypeT(struct soap *soap, enum ns1__SystemTypeT *a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_ns1__SystemTypeT
	*a = SOAP_DEFAULT_ns1__SystemTypeT;
#else
	*a = (enum ns1__SystemTypeT)0;
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SystemTypeT(struct soap *soap, const enum ns1__SystemTypeT *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_ns1__SystemTypeT);
	if (soap_out_ns1__SystemTypeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

static const struct soap_code_map soap_codes_ns1__SystemTypeT[] =
{	{ (long)ns1__SystemTypeT__EnterpriseServer, "EnterpriseServer" },
	{ (long)ns1__SystemTypeT__RegionServer, "RegionServer" },
	{ (long)ns1__SystemTypeT__MarketServer, "MarketServer" },
	{ (long)ns1__SystemTypeT__BladeServer, "BladeServer" },
	{ 0, NULL }
};

SOAP_FMAC3S const char* SOAP_FMAC4S soap_ns1__SystemTypeT2s(struct soap *soap, enum ns1__SystemTypeT n)
{	const char *s = soap_code_str(soap_codes_ns1__SystemTypeT, (long)n);
	if (s)
		return s;
	return soap_long2s(soap, (long)n);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SystemTypeT(struct soap *soap, const char *tag, int id, const enum ns1__SystemTypeT *a, const char *type)
{	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SystemTypeT), type);
	soap_send(soap, soap_ns1__SystemTypeT2s(soap, *a));
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 enum ns1__SystemTypeT * SOAP_FMAC4 soap_get_ns1__SystemTypeT(struct soap *soap, enum ns1__SystemTypeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SystemTypeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3S int SOAP_FMAC4S soap_s2ns1__SystemTypeT(struct soap *soap, const char *s, enum ns1__SystemTypeT *a)
{
	const struct soap_code_map *map;
	if (!s)
		return SOAP_OK;
	map = soap_code(soap_codes_ns1__SystemTypeT, s);
	if (map)
		*a = (enum ns1__SystemTypeT)map->code;
	else
	{	long n;
		if (soap_s2long(soap, s, &n) || ((soap->mode & SOAP_XML_STRICT) && (n < 0 || n > 3)))
			return soap->error = SOAP_TYPE;
		*a = (enum ns1__SystemTypeT)n;
	}
	return SOAP_OK;
}

SOAP_FMAC3 enum ns1__SystemTypeT * SOAP_FMAC4 soap_in_ns1__SystemTypeT(struct soap *soap, const char *tag, enum ns1__SystemTypeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (enum ns1__SystemTypeT *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SystemTypeT, sizeof(enum ns1__SystemTypeT), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	if (soap->body && !*soap->href)
	{	if (!a || soap_s2ns1__SystemTypeT(soap, soap_value(soap), a) || soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (enum ns1__SystemTypeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SystemTypeT, 0, sizeof(enum ns1__SystemTypeT), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

void ns1__EventMessageT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__EventTypeT(soap, &((ns1__EventMessageT*)this)->eventType);
	soap_default_ns1__EventCategoryT(soap, &((ns1__EventMessageT*)this)->eventCategory);
	soap_default_std__string(soap, &((ns1__EventMessageT*)this)->eventSubCategory);
	((ns1__EventMessageT*)this)->objectId = NULL;
	/* transient soap skipped */
}

void ns1__EventMessageT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__EventMessageT*)this)->eventSubCategory, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__EventMessageT*)this)->eventSubCategory);
	soap_serialize_PointerTostd__string(soap, &((ns1__EventMessageT*)this)->objectId);
	/* transient soap skipped */
}

int ns1__EventMessageT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EventMessageT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__EventMessageT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EventMessageT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EventMessageT(struct soap *soap, const char *tag, int id, const ns1__EventMessageT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EventMessageT), type);
	soap_out_ns1__EventTypeT(soap, "eventType", -1, &(((ns1__EventMessageT*)a)->eventType), "");
	soap_out_ns1__EventCategoryT(soap, "eventCategory", -1, &(((ns1__EventMessageT*)a)->eventCategory), "");
	soap_out_std__string(soap, "eventSubCategory", -1, &(((ns1__EventMessageT*)a)->eventSubCategory), "");
	soap_out_PointerTostd__string(soap, "objectId", -1, &(((ns1__EventMessageT*)a)->objectId), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__EventMessageT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EventMessageT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EventMessageT * SOAP_FMAC4 soap_get_ns1__EventMessageT(struct soap *soap, ns1__EventMessageT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EventMessageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__EventMessageT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EventMessageT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EventMessageT * SOAP_FMAC4 soap_in_ns1__EventMessageT(struct soap *soap, const char *tag, ns1__EventMessageT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EventMessageT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EventMessageT, sizeof(ns1__EventMessageT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EventMessageT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EventMessageT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_eventType1 = 1, soap_flag_eventCategory1 = 1, soap_flag_eventSubCategory1 = 1, soap_flag_objectId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_eventType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__EventTypeT(soap, "eventType", &(((ns1__EventMessageT*)a)->eventType), "ns1:EventTypeT"))
				{	soap_flag_eventType1--;
					continue;
				}
			if (soap_flag_eventCategory1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__EventCategoryT(soap, "eventCategory", &(((ns1__EventMessageT*)a)->eventCategory), "ns1:EventCategoryT"))
				{	soap_flag_eventCategory1--;
					continue;
				}
			if (soap_flag_eventSubCategory1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "eventSubCategory", &(((ns1__EventMessageT*)a)->eventSubCategory), "xsd:string"))
				{	soap_flag_eventSubCategory1--;
					continue;
				}
			if (soap_flag_objectId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "objectId", &(((ns1__EventMessageT*)a)->objectId), "xsd:string"))
				{	soap_flag_objectId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_eventType1 > 0 || soap_flag_eventCategory1 > 0 || soap_flag_eventSubCategory1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EventMessageT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EventMessageT, 0, sizeof(ns1__EventMessageT), 0, soap_copy_ns1__EventMessageT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__EventMessageT * SOAP_FMAC6 soap_new_ns1__EventMessageT(struct soap *soap, int n)
{	return soap_instantiate_ns1__EventMessageT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__EventMessageT(struct soap *soap, ns1__EventMessageT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__EventMessageT * SOAP_FMAC4 soap_instantiate_ns1__EventMessageT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EventMessageT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EventMessageT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__EventMessageT;
		if (size)
			*size = sizeof(ns1__EventMessageT);
		((ns1__EventMessageT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__EventMessageT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EventMessageT);
		for (int i = 0; i < n; i++)
			((ns1__EventMessageT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EventMessageT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EventMessageT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EventMessageT %p -> %p\n", q, p));
	*(ns1__EventMessageT*)p = *(ns1__EventMessageT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HistoricalAlarmsRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HistoricalAlarmsRespT*)this)->alarms = NULL;
	((ns1__HistoricalAlarmsRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__HistoricalAlarmsRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfHistoricalAlarmsT(soap, &((ns1__HistoricalAlarmsRespT*)this)->alarms);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__HistoricalAlarmsRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__HistoricalAlarmsRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HistoricalAlarmsRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HistoricalAlarmsRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistoricalAlarmsRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistoricalAlarmsRespT(struct soap *soap, const char *tag, int id, const ns1__HistoricalAlarmsRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistoricalAlarmsRespT), type);
	soap_out_PointerToArrayOfHistoricalAlarmsT(soap, "alarms", -1, &(((ns1__HistoricalAlarmsRespT*)a)->alarms), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__HistoricalAlarmsRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HistoricalAlarmsRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistoricalAlarmsRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmsRespT * SOAP_FMAC4 soap_get_ns1__HistoricalAlarmsRespT(struct soap *soap, ns1__HistoricalAlarmsRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistoricalAlarmsRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HistoricalAlarmsRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HistoricalAlarmsRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmsRespT * SOAP_FMAC4 soap_in_ns1__HistoricalAlarmsRespT(struct soap *soap, const char *tag, ns1__HistoricalAlarmsRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistoricalAlarmsRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistoricalAlarmsRespT, sizeof(ns1__HistoricalAlarmsRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HistoricalAlarmsRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HistoricalAlarmsRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarms1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfHistoricalAlarmsT(soap, "alarms", &(((ns1__HistoricalAlarmsRespT*)a)->alarms), "ns1:HistoricalAlarmT"))
				{	soap_flag_alarms1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__HistoricalAlarmsRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarms1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmsRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistoricalAlarmsRespT, 0, sizeof(ns1__HistoricalAlarmsRespT), 0, soap_copy_ns1__HistoricalAlarmsRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HistoricalAlarmsRespT * SOAP_FMAC6 soap_new_ns1__HistoricalAlarmsRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HistoricalAlarmsRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HistoricalAlarmsRespT(struct soap *soap, ns1__HistoricalAlarmsRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HistoricalAlarmsRespT * SOAP_FMAC4 soap_instantiate_ns1__HistoricalAlarmsRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistoricalAlarmsRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HistoricalAlarmsRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HistoricalAlarmsRespT;
		if (size)
			*size = sizeof(ns1__HistoricalAlarmsRespT);
		((ns1__HistoricalAlarmsRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HistoricalAlarmsRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HistoricalAlarmsRespT);
		for (int i = 0; i < n; i++)
			((ns1__HistoricalAlarmsRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HistoricalAlarmsRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HistoricalAlarmsRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HistoricalAlarmsRespT %p -> %p\n", q, p));
	*(ns1__HistoricalAlarmsRespT*)p = *(ns1__HistoricalAlarmsRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CurrentAlarmsRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CurrentAlarmsRespT*)this)->alarms = NULL;
	((ns1__CurrentAlarmsRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__CurrentAlarmsRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCurrentAlarmsT(soap, &((ns1__CurrentAlarmsRespT*)this)->alarms);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__CurrentAlarmsRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__CurrentAlarmsRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CurrentAlarmsRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CurrentAlarmsRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CurrentAlarmsRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CurrentAlarmsRespT(struct soap *soap, const char *tag, int id, const ns1__CurrentAlarmsRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CurrentAlarmsRespT), type);
	soap_out_PointerToArrayOfCurrentAlarmsT(soap, "alarms", -1, &(((ns1__CurrentAlarmsRespT*)a)->alarms), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__CurrentAlarmsRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CurrentAlarmsRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CurrentAlarmsRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CurrentAlarmsRespT * SOAP_FMAC4 soap_get_ns1__CurrentAlarmsRespT(struct soap *soap, ns1__CurrentAlarmsRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CurrentAlarmsRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CurrentAlarmsRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CurrentAlarmsRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CurrentAlarmsRespT * SOAP_FMAC4 soap_in_ns1__CurrentAlarmsRespT(struct soap *soap, const char *tag, ns1__CurrentAlarmsRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CurrentAlarmsRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CurrentAlarmsRespT, sizeof(ns1__CurrentAlarmsRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CurrentAlarmsRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CurrentAlarmsRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarms1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCurrentAlarmsT(soap, "alarms", &(((ns1__CurrentAlarmsRespT*)a)->alarms), "ns1:CurrentAlarmT"))
				{	soap_flag_alarms1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__CurrentAlarmsRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarms1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmsRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CurrentAlarmsRespT, 0, sizeof(ns1__CurrentAlarmsRespT), 0, soap_copy_ns1__CurrentAlarmsRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CurrentAlarmsRespT * SOAP_FMAC6 soap_new_ns1__CurrentAlarmsRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CurrentAlarmsRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CurrentAlarmsRespT(struct soap *soap, ns1__CurrentAlarmsRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CurrentAlarmsRespT * SOAP_FMAC4 soap_instantiate_ns1__CurrentAlarmsRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CurrentAlarmsRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CurrentAlarmsRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CurrentAlarmsRespT;
		if (size)
			*size = sizeof(ns1__CurrentAlarmsRespT);
		((ns1__CurrentAlarmsRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CurrentAlarmsRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CurrentAlarmsRespT);
		for (int i = 0; i < n; i++)
			((ns1__CurrentAlarmsRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CurrentAlarmsRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CurrentAlarmsRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CurrentAlarmsRespT %p -> %p\n", q, p));
	*(ns1__CurrentAlarmsRespT*)p = *(ns1__CurrentAlarmsRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusSummaryRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmStatusSummaryRespT*)this)->cmData = NULL;
	((ns1__CmStatusSummaryRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__CmStatusSummaryRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfCmStatusSummaryT(soap, &((ns1__CmStatusSummaryRespT*)this)->cmData);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__CmStatusSummaryRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__CmStatusSummaryRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusSummaryRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusSummaryRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusSummaryRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusSummaryRespT(struct soap *soap, const char *tag, int id, const ns1__CmStatusSummaryRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusSummaryRespT), type);
	soap_out_PointerToArrayOfCmStatusSummaryT(soap, "cmData", -1, &(((ns1__CmStatusSummaryRespT*)a)->cmData), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__CmStatusSummaryRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusSummaryRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusSummaryRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryRespT * SOAP_FMAC4 soap_get_ns1__CmStatusSummaryRespT(struct soap *soap, ns1__CmStatusSummaryRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusSummaryRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusSummaryRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusSummaryRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryRespT * SOAP_FMAC4 soap_in_ns1__CmStatusSummaryRespT(struct soap *soap, const char *tag, ns1__CmStatusSummaryRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusSummaryRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusSummaryRespT, sizeof(ns1__CmStatusSummaryRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusSummaryRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusSummaryRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmData1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfCmStatusSummaryT(soap, "cmData", &(((ns1__CmStatusSummaryRespT*)a)->cmData), "ns1:CmStatusSummaryT"))
				{	soap_flag_cmData1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__CmStatusSummaryRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmData1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusSummaryRespT, 0, sizeof(ns1__CmStatusSummaryRespT), 0, soap_copy_ns1__CmStatusSummaryRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusSummaryRespT * SOAP_FMAC6 soap_new_ns1__CmStatusSummaryRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusSummaryRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusSummaryRespT(struct soap *soap, ns1__CmStatusSummaryRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusSummaryRespT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusSummaryRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusSummaryRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusSummaryRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusSummaryRespT;
		if (size)
			*size = sizeof(ns1__CmStatusSummaryRespT);
		((ns1__CmStatusSummaryRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusSummaryRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusSummaryRespT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusSummaryRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusSummaryRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusSummaryRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusSummaryRespT %p -> %p\n", q, p));
	*(ns1__CmStatusSummaryRespT*)p = *(ns1__CmStatusSummaryRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcStatusSummaryRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcStatusSummaryRespT*)this)->hfcData = NULL;
	((ns1__HfcStatusSummaryRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__HfcStatusSummaryRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfHfcStatusSummaryT(soap, &((ns1__HfcStatusSummaryRespT*)this)->hfcData);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__HfcStatusSummaryRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__HfcStatusSummaryRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcStatusSummaryRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcStatusSummaryRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcStatusSummaryRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcStatusSummaryRespT(struct soap *soap, const char *tag, int id, const ns1__HfcStatusSummaryRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcStatusSummaryRespT), type);
	soap_out_PointerToArrayOfHfcStatusSummaryT(soap, "hfcData", -1, &(((ns1__HfcStatusSummaryRespT*)a)->hfcData), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__HfcStatusSummaryRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcStatusSummaryRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcStatusSummaryRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryRespT * SOAP_FMAC4 soap_get_ns1__HfcStatusSummaryRespT(struct soap *soap, ns1__HfcStatusSummaryRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcStatusSummaryRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcStatusSummaryRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcStatusSummaryRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryRespT * SOAP_FMAC4 soap_in_ns1__HfcStatusSummaryRespT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcStatusSummaryRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcStatusSummaryRespT, sizeof(ns1__HfcStatusSummaryRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcStatusSummaryRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcStatusSummaryRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_hfcData1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_hfcData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfHfcStatusSummaryT(soap, "hfcData", &(((ns1__HfcStatusSummaryRespT*)a)->hfcData), "ns1:HfcStatusSummaryT"))
				{	soap_flag_hfcData1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__HfcStatusSummaryRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_hfcData1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcStatusSummaryRespT, 0, sizeof(ns1__HfcStatusSummaryRespT), 0, soap_copy_ns1__HfcStatusSummaryRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcStatusSummaryRespT * SOAP_FMAC6 soap_new_ns1__HfcStatusSummaryRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcStatusSummaryRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcStatusSummaryRespT(struct soap *soap, ns1__HfcStatusSummaryRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcStatusSummaryRespT * SOAP_FMAC4 soap_instantiate_ns1__HfcStatusSummaryRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcStatusSummaryRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcStatusSummaryRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryRespT;
		if (size)
			*size = sizeof(ns1__HfcStatusSummaryRespT);
		((ns1__HfcStatusSummaryRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcStatusSummaryRespT);
		for (int i = 0; i < n; i++)
			((ns1__HfcStatusSummaryRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcStatusSummaryRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcStatusSummaryRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcStatusSummaryRespT %p -> %p\n", q, p));
	*(ns1__HfcStatusSummaryRespT*)p = *(ns1__HfcStatusSummaryRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaStatusSummaryRespT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaStatusSummaryRespT*)this)->mtaData = NULL;
	((ns1__MtaStatusSummaryRespT*)this)->queryState = NULL;
	/* transient soap skipped */
}

void ns1__MtaStatusSummaryRespT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfMtaStatusSummaryT(soap, &((ns1__MtaStatusSummaryRespT*)this)->mtaData);
	soap_serialize_PointerToArrayOfQueryStateT(soap, &((ns1__MtaStatusSummaryRespT*)this)->queryState);
	/* transient soap skipped */
}

int ns1__MtaStatusSummaryRespT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaStatusSummaryRespT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaStatusSummaryRespT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaStatusSummaryRespT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaStatusSummaryRespT(struct soap *soap, const char *tag, int id, const ns1__MtaStatusSummaryRespT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaStatusSummaryRespT), type);
	soap_out_PointerToArrayOfMtaStatusSummaryT(soap, "mtaData", -1, &(((ns1__MtaStatusSummaryRespT*)a)->mtaData), "");
	soap_out_PointerToArrayOfQueryStateT(soap, "queryState", -1, &(((ns1__MtaStatusSummaryRespT*)a)->queryState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaStatusSummaryRespT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaStatusSummaryRespT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryRespT * SOAP_FMAC4 soap_get_ns1__MtaStatusSummaryRespT(struct soap *soap, ns1__MtaStatusSummaryRespT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaStatusSummaryRespT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaStatusSummaryRespT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaStatusSummaryRespT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryRespT * SOAP_FMAC4 soap_in_ns1__MtaStatusSummaryRespT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryRespT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaStatusSummaryRespT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaStatusSummaryRespT, sizeof(ns1__MtaStatusSummaryRespT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaStatusSummaryRespT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaStatusSummaryRespT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mtaData1 = 1, soap_flag_queryState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtaData1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfMtaStatusSummaryT(soap, "mtaData", &(((ns1__MtaStatusSummaryRespT*)a)->mtaData), "ns1:MtaStatusSummaryT"))
				{	soap_flag_mtaData1--;
					continue;
				}
			if (soap_flag_queryState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfQueryStateT(soap, "queryState", &(((ns1__MtaStatusSummaryRespT*)a)->queryState), "ns1:QueryStateT"))
				{	soap_flag_queryState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mtaData1 > 0 || soap_flag_queryState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryRespT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaStatusSummaryRespT, 0, sizeof(ns1__MtaStatusSummaryRespT), 0, soap_copy_ns1__MtaStatusSummaryRespT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaStatusSummaryRespT * SOAP_FMAC6 soap_new_ns1__MtaStatusSummaryRespT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaStatusSummaryRespT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaStatusSummaryRespT(struct soap *soap, ns1__MtaStatusSummaryRespT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaStatusSummaryRespT * SOAP_FMAC4 soap_instantiate_ns1__MtaStatusSummaryRespT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaStatusSummaryRespT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaStatusSummaryRespT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryRespT;
		if (size)
			*size = sizeof(ns1__MtaStatusSummaryRespT);
		((ns1__MtaStatusSummaryRespT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryRespT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaStatusSummaryRespT);
		for (int i = 0; i < n; i++)
			((ns1__MtaStatusSummaryRespT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaStatusSummaryRespT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaStatusSummaryRespT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaStatusSummaryRespT %p -> %p\n", q, p));
	*(ns1__MtaStatusSummaryRespT*)p = *(ns1__MtaStatusSummaryRespT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmStatusSummaryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmStatusSummaryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmStatusSummaryT(soap, this->__ptr + i);
		}
}

int ArrayOfCmStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, int id, const ArrayOfCmStatusSummaryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmStatusSummaryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmStatusSummaryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmStatusSummaryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT * SOAP_FMAC4 soap_get_ArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT * SOAP_FMAC4 soap_in_ArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, ArrayOfCmStatusSummaryT *a, const char *type)
{	int i, j;
	ns1__CmStatusSummaryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmStatusSummaryT, sizeof(ArrayOfCmStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmStatusSummaryT **)soap_malloc(soap, sizeof(ns1__CmStatusSummaryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmStatusSummaryT(soap, NULL, a->__ptr + i, "ns1:CmStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmStatusSummaryT **)soap_push_block(soap, sizeof(ns1__CmStatusSummaryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmStatusSummaryT(soap, NULL, p, "ns1:CmStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmStatusSummaryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmStatusSummaryT, 0, sizeof(ArrayOfCmStatusSummaryT), 0, soap_copy_ArrayOfCmStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmStatusSummaryT * SOAP_FMAC6 soap_new_ArrayOfCmStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT * SOAP_FMAC4 soap_instantiate_ArrayOfCmStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmStatusSummaryT;
		if (size)
			*size = sizeof(ArrayOfCmStatusSummaryT);
		((ArrayOfCmStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmStatusSummaryT %p -> %p\n", q, p));
	*(ArrayOfCmStatusSummaryT*)p = *(ArrayOfCmStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmStatusSummaryT*)this)->statusSummary = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__CmStatusSummaryT*)this)->cmtsName);
	soap_default_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->hfcResId);
	soap_default_std__string(soap, &((ns1__CmStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

void ns1__CmStatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StatusSummaryT(soap, &((ns1__CmStatusSummaryT*)this)->statusSummary);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmStatusSummaryT*)this)->cmtsName);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmStatusSummaryT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__CmStatusSummaryT*)this)->hfcName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

int ns1__CmStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__CmStatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusSummaryT), type);
	soap_out_PointerTons1__StatusSummaryT(soap, "statusSummary", -1, &(((ns1__CmStatusSummaryT*)a)->statusSummary), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__CmStatusSummaryT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__CmStatusSummaryT*)a)->cmtsName), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__CmStatusSummaryT*)a)->hfcResId), "");
	soap_out_std__string(soap, "hfcName", -1, &(((ns1__CmStatusSummaryT*)a)->hfcName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT * SOAP_FMAC4 soap_get_ns1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT * SOAP_FMAC4 soap_in_ns1__CmStatusSummaryT(struct soap *soap, const char *tag, ns1__CmStatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusSummaryT, sizeof(ns1__CmStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_statusSummary1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1, soap_flag_hfcResId1 = 1, soap_flag_hfcName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusSummary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StatusSummaryT(soap, "statusSummary", &(((ns1__CmStatusSummaryT*)a)->statusSummary), "ns1:StatusSummaryT"))
				{	soap_flag_statusSummary1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__CmStatusSummaryT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__CmStatusSummaryT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__CmStatusSummaryT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "hfcName", &(((ns1__CmStatusSummaryT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusSummary1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_hfcName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusSummaryT, 0, sizeof(ns1__CmStatusSummaryT), 0, soap_copy_ns1__CmStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusSummaryT * SOAP_FMAC6 soap_new_ns1__CmStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusSummaryT;
		if (size)
			*size = sizeof(ns1__CmStatusSummaryT);
		((ns1__CmStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusSummaryT %p -> %p\n", q, p));
	*(ns1__CmStatusSummaryT*)p = *(ns1__CmStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaStatusSummaryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaStatusSummaryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaStatusSummaryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaStatusSummaryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaStatusSummaryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaStatusSummaryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT * SOAP_FMAC4 soap_get_ArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT * SOAP_FMAC4 soap_in_ArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, ArrayOfMtaStatusSummaryT *a, const char *type)
{	int i, j;
	ns1__MtaStatusSummaryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaStatusSummaryT, sizeof(ArrayOfMtaStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaStatusSummaryT **)soap_malloc(soap, sizeof(ns1__MtaStatusSummaryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaStatusSummaryT(soap, NULL, a->__ptr + i, "ns1:MtaStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaStatusSummaryT **)soap_push_block(soap, sizeof(ns1__MtaStatusSummaryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaStatusSummaryT(soap, NULL, p, "ns1:MtaStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaStatusSummaryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaStatusSummaryT, 0, sizeof(ArrayOfMtaStatusSummaryT), 0, soap_copy_ArrayOfMtaStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaStatusSummaryT * SOAP_FMAC6 soap_new_ArrayOfMtaStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaStatusSummaryT;
		if (size)
			*size = sizeof(ArrayOfMtaStatusSummaryT);
		((ArrayOfMtaStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaStatusSummaryT %p -> %p\n", q, p));
	*(ArrayOfMtaStatusSummaryT*)p = *(ArrayOfMtaStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaStatusSummaryT*)this)->statusSummary = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsName);
	soap_default_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->hfcResId);
	soap_default_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

void ns1__MtaStatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StatusSummaryT(soap, &((ns1__MtaStatusSummaryT*)this)->statusSummary);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->cmtsName);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaStatusSummaryT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__MtaStatusSummaryT*)this)->hfcName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MtaStatusSummaryT*)this)->hfcName);
	/* transient soap skipped */
}

int ns1__MtaStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaStatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__MtaStatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaStatusSummaryT), type);
	soap_out_PointerTons1__StatusSummaryT(soap, "statusSummary", -1, &(((ns1__MtaStatusSummaryT*)a)->statusSummary), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__MtaStatusSummaryT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__MtaStatusSummaryT*)a)->cmtsName), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__MtaStatusSummaryT*)a)->hfcResId), "");
	soap_out_std__string(soap, "hfcName", -1, &(((ns1__MtaStatusSummaryT*)a)->hfcName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT * SOAP_FMAC4 soap_get_ns1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT * SOAP_FMAC4 soap_in_ns1__MtaStatusSummaryT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaStatusSummaryT, sizeof(ns1__MtaStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaStatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaStatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_statusSummary1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1, soap_flag_hfcResId1 = 1, soap_flag_hfcName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusSummary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StatusSummaryT(soap, "statusSummary", &(((ns1__MtaStatusSummaryT*)a)->statusSummary), "ns1:StatusSummaryT"))
				{	soap_flag_statusSummary1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__MtaStatusSummaryT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__MtaStatusSummaryT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__MtaStatusSummaryT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "hfcName", &(((ns1__MtaStatusSummaryT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusSummary1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_hfcName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaStatusSummaryT, 0, sizeof(ns1__MtaStatusSummaryT), 0, soap_copy_ns1__MtaStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaStatusSummaryT * SOAP_FMAC6 soap_new_ns1__MtaStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__MtaStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryT;
		if (size)
			*size = sizeof(ns1__MtaStatusSummaryT);
		((ns1__MtaStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaStatusSummaryT %p -> %p\n", q, p));
	*(ns1__MtaStatusSummaryT*)p = *(ns1__MtaStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfHfcStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfHfcStatusSummaryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfHfcStatusSummaryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__HfcStatusSummaryT(soap, this->__ptr + i);
		}
}

int ArrayOfHfcStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfHfcStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfHfcStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfHfcStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, int id, const ArrayOfHfcStatusSummaryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:HfcStatusSummaryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfHfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__HfcStatusSummaryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfHfcStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfHfcStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT * SOAP_FMAC4 soap_get_ArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfHfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfHfcStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfHfcStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT * SOAP_FMAC4 soap_in_ArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, ArrayOfHfcStatusSummaryT *a, const char *type)
{	int i, j;
	ns1__HfcStatusSummaryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfHfcStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfHfcStatusSummaryT, sizeof(ArrayOfHfcStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__HfcStatusSummaryT **)soap_malloc(soap, sizeof(ns1__HfcStatusSummaryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__HfcStatusSummaryT(soap, NULL, a->__ptr + i, "ns1:HfcStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__HfcStatusSummaryT **)soap_push_block(soap, sizeof(ns1__HfcStatusSummaryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__HfcStatusSummaryT(soap, NULL, p, "ns1:HfcStatusSummaryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__HfcStatusSummaryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfHfcStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfHfcStatusSummaryT, 0, sizeof(ArrayOfHfcStatusSummaryT), 0, soap_copy_ArrayOfHfcStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfHfcStatusSummaryT * SOAP_FMAC6 soap_new_ArrayOfHfcStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfHfcStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT * SOAP_FMAC4 soap_instantiate_ArrayOfHfcStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfHfcStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfHfcStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfHfcStatusSummaryT;
		if (size)
			*size = sizeof(ArrayOfHfcStatusSummaryT);
		((ArrayOfHfcStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfHfcStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfHfcStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ArrayOfHfcStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfHfcStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfHfcStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfHfcStatusSummaryT %p -> %p\n", q, p));
	*(ArrayOfHfcStatusSummaryT*)p = *(ArrayOfHfcStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcStatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcStatusSummaryT*)this)->statusSummary = NULL;
	soap_default_xsd__integer(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsName);
	/* transient soap skipped */
}

void ns1__HfcStatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__StatusSummaryT(soap, &((ns1__HfcStatusSummaryT*)this)->statusSummary);
	soap_embedded(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcStatusSummaryT*)this)->cmtsName);
	/* transient soap skipped */
}

int ns1__HfcStatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcStatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcStatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcStatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcStatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__HfcStatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcStatusSummaryT), type);
	soap_out_PointerTons1__StatusSummaryT(soap, "statusSummary", -1, &(((ns1__HfcStatusSummaryT*)a)->statusSummary), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__HfcStatusSummaryT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__HfcStatusSummaryT*)a)->cmtsName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcStatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcStatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT * SOAP_FMAC4 soap_get_ns1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcStatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcStatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT * SOAP_FMAC4 soap_in_ns1__HfcStatusSummaryT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcStatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcStatusSummaryT, sizeof(ns1__HfcStatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcStatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcStatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_statusSummary1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_statusSummary1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__StatusSummaryT(soap, "statusSummary", &(((ns1__HfcStatusSummaryT*)a)->statusSummary), "ns1:StatusSummaryT"))
				{	soap_flag_statusSummary1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__HfcStatusSummaryT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__HfcStatusSummaryT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_statusSummary1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcStatusSummaryT, 0, sizeof(ns1__HfcStatusSummaryT), 0, soap_copy_ns1__HfcStatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcStatusSummaryT * SOAP_FMAC6 soap_new_ns1__HfcStatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcStatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__HfcStatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcStatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcStatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryT;
		if (size)
			*size = sizeof(ns1__HfcStatusSummaryT);
		((ns1__HfcStatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcStatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcStatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__HfcStatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcStatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcStatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcStatusSummaryT %p -> %p\n", q, p));
	*(ns1__HfcStatusSummaryT*)p = *(ns1__HfcStatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__StatusSummaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__StatusSummaryT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->resId);
	soap_default_std__string(soap, &((ns1__StatusSummaryT*)this)->name);
	soap_default_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumRedStatusTime);
	soap_default_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumGreenStatusTime);
	soap_default_short(soap, &((ns1__StatusSummaryT*)this)->sumStateChanges);
	/* transient soap skipped */
}

void ns1__StatusSummaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__StatusSummaryT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->resId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->resId);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__StatusSummaryT*)this)->name);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->sumRedStatusTime, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumRedStatusTime);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->sumGreenStatusTime, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__StatusSummaryT*)this)->sumGreenStatusTime);
	soap_embedded(soap, &((ns1__StatusSummaryT*)this)->sumStateChanges, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__StatusSummaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__StatusSummaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__StatusSummaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__StatusSummaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__StatusSummaryT(struct soap *soap, const char *tag, int id, const ns1__StatusSummaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__StatusSummaryT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__StatusSummaryT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "resId", -1, &(((ns1__StatusSummaryT*)a)->resId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__StatusSummaryT*)a)->name), "");
	soap_out_xsd__integer(soap, "sumRedStatusTime", -1, &(((ns1__StatusSummaryT*)a)->sumRedStatusTime), "");
	soap_out_xsd__integer(soap, "sumGreenStatusTime", -1, &(((ns1__StatusSummaryT*)a)->sumGreenStatusTime), "");
	soap_out_short(soap, "sumStateChanges", -1, &(((ns1__StatusSummaryT*)a)->sumStateChanges), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__StatusSummaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__StatusSummaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__StatusSummaryT * SOAP_FMAC4 soap_get_ns1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__StatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__StatusSummaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__StatusSummaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__StatusSummaryT * SOAP_FMAC4 soap_in_ns1__StatusSummaryT(struct soap *soap, const char *tag, ns1__StatusSummaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__StatusSummaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__StatusSummaryT, sizeof(ns1__StatusSummaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__StatusSummaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__StatusSummaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_resId1 = 1, soap_flag_name1 = 1, soap_flag_sumRedStatusTime1 = 1, soap_flag_sumGreenStatusTime1 = 1, soap_flag_sumStateChanges1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__StatusSummaryT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_resId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "resId", &(((ns1__StatusSummaryT*)a)->resId), "xsd:integer"))
				{	soap_flag_resId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__StatusSummaryT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_sumRedStatusTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "sumRedStatusTime", &(((ns1__StatusSummaryT*)a)->sumRedStatusTime), "xsd:integer"))
				{	soap_flag_sumRedStatusTime1--;
					continue;
				}
			if (soap_flag_sumGreenStatusTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "sumGreenStatusTime", &(((ns1__StatusSummaryT*)a)->sumGreenStatusTime), "xsd:integer"))
				{	soap_flag_sumGreenStatusTime1--;
					continue;
				}
			if (soap_flag_sumStateChanges1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "sumStateChanges", &(((ns1__StatusSummaryT*)a)->sumStateChanges), "xsd:short"))
				{	soap_flag_sumStateChanges1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_resId1 > 0 || soap_flag_name1 > 0 || soap_flag_sumRedStatusTime1 > 0 || soap_flag_sumGreenStatusTime1 > 0 || soap_flag_sumStateChanges1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__StatusSummaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__StatusSummaryT, 0, sizeof(ns1__StatusSummaryT), 0, soap_copy_ns1__StatusSummaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__StatusSummaryT * SOAP_FMAC6 soap_new_ns1__StatusSummaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__StatusSummaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__StatusSummaryT * SOAP_FMAC4 soap_instantiate_ns1__StatusSummaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__StatusSummaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__StatusSummaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__StatusSummaryT;
		if (size)
			*size = sizeof(ns1__StatusSummaryT);
		((ns1__StatusSummaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__StatusSummaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__StatusSummaryT);
		for (int i = 0; i < n; i++)
			((ns1__StatusSummaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__StatusSummaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__StatusSummaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__StatusSummaryT %p -> %p\n", q, p));
	*(ns1__StatusSummaryT*)p = *(ns1__StatusSummaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__MtaDataT*)this)->provStatus);
	soap_default_std__string(soap, &((ns1__MtaDataT*)this)->provCounter);
	((ns1__MtaDataT*)this)->pingStatus = NULL;
	((ns1__MtaDataT*)this)->batteryStatus1 = NULL;
	((ns1__MtaDataT*)this)->batteryStatus2 = NULL;
	((ns1__MtaDataT*)this)->field1 = NULL;
	((ns1__MtaDataT*)this)->field2 = NULL;
	/* transient soap skipped */
}

void ns1__MtaDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaDataT*)this)->provStatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MtaDataT*)this)->provStatus);
	soap_embedded(soap, &((ns1__MtaDataT*)this)->provCounter, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MtaDataT*)this)->provCounter);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->pingStatus);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->batteryStatus1);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->batteryStatus2);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->field1);
	soap_serialize_PointerTostd__string(soap, &((ns1__MtaDataT*)this)->field2);
	/* transient soap skipped */
}

int ns1__MtaDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaDataT(struct soap *soap, const char *tag, int id, const ns1__MtaDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaDataT), type);
	soap_out_std__string(soap, "provStatus", -1, &(((ns1__MtaDataT*)a)->provStatus), "");
	soap_out_std__string(soap, "provCounter", -1, &(((ns1__MtaDataT*)a)->provCounter), "");
	soap_out_PointerTostd__string(soap, "pingStatus", -1, &(((ns1__MtaDataT*)a)->pingStatus), "");
	soap_out_PointerTostd__string(soap, "batteryStatus1", -1, &(((ns1__MtaDataT*)a)->batteryStatus1), "");
	soap_out_PointerTostd__string(soap, "batteryStatus2", -1, &(((ns1__MtaDataT*)a)->batteryStatus2), "");
	soap_out_PointerTostd__string(soap, "field1", -1, &(((ns1__MtaDataT*)a)->field1), "");
	soap_out_PointerTostd__string(soap, "field2", -1, &(((ns1__MtaDataT*)a)->field2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaDataT * SOAP_FMAC4 soap_get_ns1__MtaDataT(struct soap *soap, ns1__MtaDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaDataT * SOAP_FMAC4 soap_in_ns1__MtaDataT(struct soap *soap, const char *tag, ns1__MtaDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaDataT, sizeof(ns1__MtaDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_provStatus1 = 1, soap_flag_provCounter1 = 1, soap_flag_pingStatus1 = 1, soap_flag_batteryStatus11 = 1, soap_flag_batteryStatus21 = 1, soap_flag_field11 = 1, soap_flag_field21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_provStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "provStatus", &(((ns1__MtaDataT*)a)->provStatus), "xsd:string"))
				{	soap_flag_provStatus1--;
					continue;
				}
			if (soap_flag_provCounter1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "provCounter", &(((ns1__MtaDataT*)a)->provCounter), "xsd:string"))
				{	soap_flag_provCounter1--;
					continue;
				}
			if (soap_flag_pingStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "pingStatus", &(((ns1__MtaDataT*)a)->pingStatus), "xsd:string"))
				{	soap_flag_pingStatus1--;
					continue;
				}
			if (soap_flag_batteryStatus11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "batteryStatus1", &(((ns1__MtaDataT*)a)->batteryStatus1), "xsd:string"))
				{	soap_flag_batteryStatus11--;
					continue;
				}
			if (soap_flag_batteryStatus21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "batteryStatus2", &(((ns1__MtaDataT*)a)->batteryStatus2), "xsd:string"))
				{	soap_flag_batteryStatus21--;
					continue;
				}
			if (soap_flag_field11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field1", &(((ns1__MtaDataT*)a)->field1), "xsd:string"))
				{	soap_flag_field11--;
					continue;
				}
			if (soap_flag_field21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field2", &(((ns1__MtaDataT*)a)->field2), "xsd:string"))
				{	soap_flag_field21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_provStatus1 > 0 || soap_flag_provCounter1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaDataT, 0, sizeof(ns1__MtaDataT), 0, soap_copy_ns1__MtaDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaDataT * SOAP_FMAC6 soap_new_ns1__MtaDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaDataT(struct soap *soap, ns1__MtaDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaDataT * SOAP_FMAC4 soap_instantiate_ns1__MtaDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaDataT;
		if (size)
			*size = sizeof(ns1__MtaDataT);
		((ns1__MtaDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaDataT);
		for (int i = 0; i < n; i++)
			((ns1__MtaDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaDataT %p -> %p\n", q, p));
	*(ns1__MtaDataT*)p = *(ns1__MtaDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->mac);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->host);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->cmIndex);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->downstreamSNR);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->downstreamPower);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->upstreamPower);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t1Count);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t2Count);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t3Count);
	soap_default_std__string(soap, &((ns1__CmDataT*)this)->t4Count);
	((ns1__CmDataT*)this)->field1 = NULL;
	((ns1__CmDataT*)this)->field2 = NULL;
	/* transient soap skipped */
}

void ns1__CmDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmDataT*)this)->mac, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->mac);
	soap_embedded(soap, &((ns1__CmDataT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->host);
	soap_embedded(soap, &((ns1__CmDataT*)this)->cmIndex, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->cmIndex);
	soap_embedded(soap, &((ns1__CmDataT*)this)->downstreamSNR, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->downstreamSNR);
	soap_embedded(soap, &((ns1__CmDataT*)this)->downstreamPower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->downstreamPower);
	soap_embedded(soap, &((ns1__CmDataT*)this)->upstreamPower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->upstreamPower);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t1Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t1Count);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t2Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t2Count);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t3Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t3Count);
	soap_embedded(soap, &((ns1__CmDataT*)this)->t4Count, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmDataT*)this)->t4Count);
	soap_serialize_PointerTostd__string(soap, &((ns1__CmDataT*)this)->field1);
	soap_serialize_PointerTostd__string(soap, &((ns1__CmDataT*)this)->field2);
	/* transient soap skipped */
}

int ns1__CmDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmDataT(struct soap *soap, const char *tag, int id, const ns1__CmDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmDataT), type);
	soap_out_std__string(soap, "mac", -1, &(((ns1__CmDataT*)a)->mac), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__CmDataT*)a)->host), "");
	soap_out_std__string(soap, "cmIndex", -1, &(((ns1__CmDataT*)a)->cmIndex), "");
	soap_out_std__string(soap, "downstreamSNR", -1, &(((ns1__CmDataT*)a)->downstreamSNR), "");
	soap_out_std__string(soap, "downstreamPower", -1, &(((ns1__CmDataT*)a)->downstreamPower), "");
	soap_out_std__string(soap, "upstreamPower", -1, &(((ns1__CmDataT*)a)->upstreamPower), "");
	soap_out_std__string(soap, "t1Count", -1, &(((ns1__CmDataT*)a)->t1Count), "");
	soap_out_std__string(soap, "t2Count", -1, &(((ns1__CmDataT*)a)->t2Count), "");
	soap_out_std__string(soap, "t3Count", -1, &(((ns1__CmDataT*)a)->t3Count), "");
	soap_out_std__string(soap, "t4Count", -1, &(((ns1__CmDataT*)a)->t4Count), "");
	soap_out_PointerTostd__string(soap, "field1", -1, &(((ns1__CmDataT*)a)->field1), "");
	soap_out_PointerTostd__string(soap, "field2", -1, &(((ns1__CmDataT*)a)->field2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmDataT * SOAP_FMAC4 soap_get_ns1__CmDataT(struct soap *soap, ns1__CmDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmDataT * SOAP_FMAC4 soap_in_ns1__CmDataT(struct soap *soap, const char *tag, ns1__CmDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmDataT, sizeof(ns1__CmDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mac1 = 1, soap_flag_host1 = 1, soap_flag_cmIndex1 = 1, soap_flag_downstreamSNR1 = 1, soap_flag_downstreamPower1 = 1, soap_flag_upstreamPower1 = 1, soap_flag_t1Count1 = 1, soap_flag_t2Count1 = 1, soap_flag_t3Count1 = 1, soap_flag_t4Count1 = 1, soap_flag_field11 = 1, soap_flag_field21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mac", &(((ns1__CmDataT*)a)->mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__CmDataT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			if (soap_flag_cmIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmIndex", &(((ns1__CmDataT*)a)->cmIndex), "xsd:string"))
				{	soap_flag_cmIndex1--;
					continue;
				}
			if (soap_flag_downstreamSNR1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamSNR", &(((ns1__CmDataT*)a)->downstreamSNR), "xsd:string"))
				{	soap_flag_downstreamSNR1--;
					continue;
				}
			if (soap_flag_downstreamPower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamPower", &(((ns1__CmDataT*)a)->downstreamPower), "xsd:string"))
				{	soap_flag_downstreamPower1--;
					continue;
				}
			if (soap_flag_upstreamPower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamPower", &(((ns1__CmDataT*)a)->upstreamPower), "xsd:string"))
				{	soap_flag_upstreamPower1--;
					continue;
				}
			if (soap_flag_t1Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t1Count", &(((ns1__CmDataT*)a)->t1Count), "xsd:string"))
				{	soap_flag_t1Count1--;
					continue;
				}
			if (soap_flag_t2Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t2Count", &(((ns1__CmDataT*)a)->t2Count), "xsd:string"))
				{	soap_flag_t2Count1--;
					continue;
				}
			if (soap_flag_t3Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t3Count", &(((ns1__CmDataT*)a)->t3Count), "xsd:string"))
				{	soap_flag_t3Count1--;
					continue;
				}
			if (soap_flag_t4Count1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "t4Count", &(((ns1__CmDataT*)a)->t4Count), "xsd:string"))
				{	soap_flag_t4Count1--;
					continue;
				}
			if (soap_flag_field11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field1", &(((ns1__CmDataT*)a)->field1), "xsd:string"))
				{	soap_flag_field11--;
					continue;
				}
			if (soap_flag_field21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "field2", &(((ns1__CmDataT*)a)->field2), "xsd:string"))
				{	soap_flag_field21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mac1 > 0 || soap_flag_host1 > 0 || soap_flag_cmIndex1 > 0 || soap_flag_downstreamSNR1 > 0 || soap_flag_downstreamPower1 > 0 || soap_flag_upstreamPower1 > 0 || soap_flag_t1Count1 > 0 || soap_flag_t2Count1 > 0 || soap_flag_t3Count1 > 0 || soap_flag_t4Count1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmDataT, 0, sizeof(ns1__CmDataT), 0, soap_copy_ns1__CmDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmDataT * SOAP_FMAC6 soap_new_ns1__CmDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmDataT(struct soap *soap, ns1__CmDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmDataT * SOAP_FMAC4 soap_instantiate_ns1__CmDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmDataT;
		if (size)
			*size = sizeof(ns1__CmDataT);
		((ns1__CmDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmDataT);
		for (int i = 0; i < n; i++)
			((ns1__CmDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmDataT %p -> %p\n", q, p));
	*(ns1__CmDataT*)p = *(ns1__CmDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsCmDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmIpAddress);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmMac);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelIndex);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->downstreamChannelIndex);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmIndex);
	soap_default_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmStatus);
	/* transient soap skipped */
}

void ns1__CmtsCmDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->cmIpAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmIpAddress);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->cmMac, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmMac);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelIndex, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->upstreamChannelIndex);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->downstreamChannelIndex, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->downstreamChannelIndex);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->cmIndex, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmIndex);
	soap_embedded(soap, &((ns1__CmtsCmDataT*)this)->cmStatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsCmDataT*)this)->cmStatus);
	/* transient soap skipped */
}

int ns1__CmtsCmDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsCmDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsCmDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsCmDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsCmDataT(struct soap *soap, const char *tag, int id, const ns1__CmtsCmDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsCmDataT), type);
	soap_out_std__string(soap, "cmIpAddress", -1, &(((ns1__CmtsCmDataT*)a)->cmIpAddress), "");
	soap_out_std__string(soap, "cmMac", -1, &(((ns1__CmtsCmDataT*)a)->cmMac), "");
	soap_out_std__string(soap, "upstreamChannelIndex", -1, &(((ns1__CmtsCmDataT*)a)->upstreamChannelIndex), "");
	soap_out_std__string(soap, "downstreamChannelIndex", -1, &(((ns1__CmtsCmDataT*)a)->downstreamChannelIndex), "");
	soap_out_std__string(soap, "cmIndex", -1, &(((ns1__CmtsCmDataT*)a)->cmIndex), "");
	soap_out_std__string(soap, "cmStatus", -1, &(((ns1__CmtsCmDataT*)a)->cmStatus), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsCmDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsCmDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsCmDataT * SOAP_FMAC4 soap_get_ns1__CmtsCmDataT(struct soap *soap, ns1__CmtsCmDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsCmDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsCmDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsCmDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsCmDataT * SOAP_FMAC4 soap_in_ns1__CmtsCmDataT(struct soap *soap, const char *tag, ns1__CmtsCmDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsCmDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsCmDataT, sizeof(ns1__CmtsCmDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsCmDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsCmDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmIpAddress1 = 1, soap_flag_cmMac1 = 1, soap_flag_upstreamChannelIndex1 = 1, soap_flag_downstreamChannelIndex1 = 1, soap_flag_cmIndex1 = 1, soap_flag_cmStatus1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmIpAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmIpAddress", &(((ns1__CmtsCmDataT*)a)->cmIpAddress), "xsd:string"))
				{	soap_flag_cmIpAddress1--;
					continue;
				}
			if (soap_flag_cmMac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmMac", &(((ns1__CmtsCmDataT*)a)->cmMac), "xsd:string"))
				{	soap_flag_cmMac1--;
					continue;
				}
			if (soap_flag_upstreamChannelIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamChannelIndex", &(((ns1__CmtsCmDataT*)a)->upstreamChannelIndex), "xsd:string"))
				{	soap_flag_upstreamChannelIndex1--;
					continue;
				}
			if (soap_flag_downstreamChannelIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamChannelIndex", &(((ns1__CmtsCmDataT*)a)->downstreamChannelIndex), "xsd:string"))
				{	soap_flag_downstreamChannelIndex1--;
					continue;
				}
			if (soap_flag_cmIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmIndex", &(((ns1__CmtsCmDataT*)a)->cmIndex), "xsd:string"))
				{	soap_flag_cmIndex1--;
					continue;
				}
			if (soap_flag_cmStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmStatus", &(((ns1__CmtsCmDataT*)a)->cmStatus), "xsd:string"))
				{	soap_flag_cmStatus1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmIpAddress1 > 0 || soap_flag_cmMac1 > 0 || soap_flag_upstreamChannelIndex1 > 0 || soap_flag_downstreamChannelIndex1 > 0 || soap_flag_cmIndex1 > 0 || soap_flag_cmStatus1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsCmDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsCmDataT, 0, sizeof(ns1__CmtsCmDataT), 0, soap_copy_ns1__CmtsCmDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsCmDataT * SOAP_FMAC6 soap_new_ns1__CmtsCmDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsCmDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsCmDataT(struct soap *soap, ns1__CmtsCmDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsCmDataT * SOAP_FMAC4 soap_instantiate_ns1__CmtsCmDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsCmDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsCmDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsCmDataT;
		if (size)
			*size = sizeof(ns1__CmtsCmDataT);
		((ns1__CmtsCmDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsCmDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsCmDataT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsCmDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsCmDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsCmDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsCmDataT %p -> %p\n", q, p));
	*(ns1__CmtsCmDataT*)p = *(ns1__CmtsCmDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ConfigDownloadT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ConfigDownloadT*)this)->cmPerfCfg = NULL;
	((ns1__ConfigDownloadT*)this)->cmsAlarmCfg = NULL;
	((ns1__ConfigDownloadT*)this)->cmtsAlarmCfg = NULL;
	((ns1__ConfigDownloadT*)this)->mtaAlarmCfg = NULL;
	((ns1__ConfigDownloadT*)this)->hfcAlarmCfg = NULL;
	((ns1__ConfigDownloadT*)this)->pollingIntervals = NULL;
	((ns1__ConfigDownloadT*)this)->userAccessRights = NULL;
	((ns1__ConfigDownloadT*)this)->applicationDomains = NULL;
	((ns1__ConfigDownloadT*)this)->roles = NULL;
	((ns1__ConfigDownloadT*)this)->users = NULL;
	/* transient soap skipped */
}

void ns1__ConfigDownloadT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmPerformanceConfigT(soap, &((ns1__ConfigDownloadT*)this)->cmPerfCfg);
	soap_serialize_PointerTons1__CmsAlarmConfigT(soap, &((ns1__ConfigDownloadT*)this)->cmsAlarmCfg);
	soap_serialize_PointerTons1__CmtsAlarmConfigT(soap, &((ns1__ConfigDownloadT*)this)->cmtsAlarmCfg);
	soap_serialize_PointerTons1__MtaAlarmConfigT(soap, &((ns1__ConfigDownloadT*)this)->mtaAlarmCfg);
	soap_serialize_PointerTons1__HfcAlarmConfigT(soap, &((ns1__ConfigDownloadT*)this)->hfcAlarmCfg);
	soap_serialize_PointerTons1__PollingIntervalsT(soap, &((ns1__ConfigDownloadT*)this)->pollingIntervals);
	soap_serialize_PointerToArrayOfUserAccessT(soap, &((ns1__ConfigDownloadT*)this)->userAccessRights);
	soap_serialize_PointerToArrayOfApplicationDomainT(soap, &((ns1__ConfigDownloadT*)this)->applicationDomains);
	soap_serialize_PointerToArrayOfRoleT(soap, &((ns1__ConfigDownloadT*)this)->roles);
	soap_serialize_PointerToArrayOfUserT(soap, &((ns1__ConfigDownloadT*)this)->users);
	/* transient soap skipped */
}

int ns1__ConfigDownloadT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ConfigDownloadT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ConfigDownloadT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ConfigDownloadT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ConfigDownloadT(struct soap *soap, const char *tag, int id, const ns1__ConfigDownloadT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ConfigDownloadT), type);
	soap_out_PointerTons1__CmPerformanceConfigT(soap, "cmPerfCfg", -1, &(((ns1__ConfigDownloadT*)a)->cmPerfCfg), "");
	soap_out_PointerTons1__CmsAlarmConfigT(soap, "cmsAlarmCfg", -1, &(((ns1__ConfigDownloadT*)a)->cmsAlarmCfg), "");
	soap_out_PointerTons1__CmtsAlarmConfigT(soap, "cmtsAlarmCfg", -1, &(((ns1__ConfigDownloadT*)a)->cmtsAlarmCfg), "");
	soap_out_PointerTons1__MtaAlarmConfigT(soap, "mtaAlarmCfg", -1, &(((ns1__ConfigDownloadT*)a)->mtaAlarmCfg), "");
	soap_out_PointerTons1__HfcAlarmConfigT(soap, "hfcAlarmCfg", -1, &(((ns1__ConfigDownloadT*)a)->hfcAlarmCfg), "");
	soap_out_PointerTons1__PollingIntervalsT(soap, "pollingIntervals", -1, &(((ns1__ConfigDownloadT*)a)->pollingIntervals), "");
	soap_out_PointerToArrayOfUserAccessT(soap, "userAccessRights", -1, &(((ns1__ConfigDownloadT*)a)->userAccessRights), "");
	soap_out_PointerToArrayOfApplicationDomainT(soap, "applicationDomains", -1, &(((ns1__ConfigDownloadT*)a)->applicationDomains), "");
	soap_out_PointerToArrayOfRoleT(soap, "roles", -1, &(((ns1__ConfigDownloadT*)a)->roles), "");
	soap_out_PointerToArrayOfUserT(soap, "users", -1, &(((ns1__ConfigDownloadT*)a)->users), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ConfigDownloadT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ConfigDownloadT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ConfigDownloadT * SOAP_FMAC4 soap_get_ns1__ConfigDownloadT(struct soap *soap, ns1__ConfigDownloadT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ConfigDownloadT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ConfigDownloadT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ConfigDownloadT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ConfigDownloadT * SOAP_FMAC4 soap_in_ns1__ConfigDownloadT(struct soap *soap, const char *tag, ns1__ConfigDownloadT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ConfigDownloadT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ConfigDownloadT, sizeof(ns1__ConfigDownloadT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ConfigDownloadT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ConfigDownloadT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmPerfCfg1 = 1, soap_flag_cmsAlarmCfg1 = 1, soap_flag_cmtsAlarmCfg1 = 1, soap_flag_mtaAlarmCfg1 = 1, soap_flag_hfcAlarmCfg1 = 1, soap_flag_pollingIntervals1 = 1, soap_flag_userAccessRights1 = 1, soap_flag_applicationDomains1 = 1, soap_flag_roles1 = 1, soap_flag_users1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmPerfCfg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmPerformanceConfigT(soap, "cmPerfCfg", &(((ns1__ConfigDownloadT*)a)->cmPerfCfg), "ns1:CmPerformanceConfigT"))
				{	soap_flag_cmPerfCfg1--;
					continue;
				}
			if (soap_flag_cmsAlarmCfg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsAlarmConfigT(soap, "cmsAlarmCfg", &(((ns1__ConfigDownloadT*)a)->cmsAlarmCfg), "ns1:CmsAlarmConfigT"))
				{	soap_flag_cmsAlarmCfg1--;
					continue;
				}
			if (soap_flag_cmtsAlarmCfg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsAlarmConfigT(soap, "cmtsAlarmCfg", &(((ns1__ConfigDownloadT*)a)->cmtsAlarmCfg), "ns1:CmtsAlarmConfigT"))
				{	soap_flag_cmtsAlarmCfg1--;
					continue;
				}
			if (soap_flag_mtaAlarmCfg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaAlarmConfigT(soap, "mtaAlarmCfg", &(((ns1__ConfigDownloadT*)a)->mtaAlarmCfg), "ns1:MtaAlarmConfigT"))
				{	soap_flag_mtaAlarmCfg1--;
					continue;
				}
			if (soap_flag_hfcAlarmCfg1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HfcAlarmConfigT(soap, "hfcAlarmCfg", &(((ns1__ConfigDownloadT*)a)->hfcAlarmCfg), "ns1:HfcAlarmConfigT"))
				{	soap_flag_hfcAlarmCfg1--;
					continue;
				}
			if (soap_flag_pollingIntervals1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PollingIntervalsT(soap, "pollingIntervals", &(((ns1__ConfigDownloadT*)a)->pollingIntervals), "ns1:PollingIntervalsT"))
				{	soap_flag_pollingIntervals1--;
					continue;
				}
			if (soap_flag_userAccessRights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfUserAccessT(soap, "userAccessRights", &(((ns1__ConfigDownloadT*)a)->userAccessRights), "ns1:UserAccessT"))
				{	soap_flag_userAccessRights1--;
					continue;
				}
			if (soap_flag_applicationDomains1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfApplicationDomainT(soap, "applicationDomains", &(((ns1__ConfigDownloadT*)a)->applicationDomains), "ns1:ApplicationDomainT"))
				{	soap_flag_applicationDomains1--;
					continue;
				}
			if (soap_flag_roles1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRoleT(soap, "roles", &(((ns1__ConfigDownloadT*)a)->roles), "ns1:RoleT"))
				{	soap_flag_roles1--;
					continue;
				}
			if (soap_flag_users1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfUserT(soap, "users", &(((ns1__ConfigDownloadT*)a)->users), "ns1:UserT"))
				{	soap_flag_users1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ConfigDownloadT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ConfigDownloadT, 0, sizeof(ns1__ConfigDownloadT), 0, soap_copy_ns1__ConfigDownloadT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ConfigDownloadT * SOAP_FMAC6 soap_new_ns1__ConfigDownloadT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ConfigDownloadT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ConfigDownloadT(struct soap *soap, ns1__ConfigDownloadT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ConfigDownloadT * SOAP_FMAC4 soap_instantiate_ns1__ConfigDownloadT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ConfigDownloadT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ConfigDownloadT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ConfigDownloadT;
		if (size)
			*size = sizeof(ns1__ConfigDownloadT);
		((ns1__ConfigDownloadT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ConfigDownloadT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ConfigDownloadT);
		for (int i = 0; i < n; i++)
			((ns1__ConfigDownloadT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ConfigDownloadT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ConfigDownloadT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ConfigDownloadT %p -> %p\n", q, p));
	*(ns1__ConfigDownloadT*)p = *(ns1__ConfigDownloadT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmPerformanceConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamSnrLower);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerLower);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerUpper);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerLower);
	soap_default_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerUpper);
	/* transient soap skipped */
}

void ns1__CmPerformanceConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamSnrLower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamSnrLower);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerLower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerLower);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerUpper, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->downstreamPowerUpper);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerLower, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerLower);
	soap_embedded(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerUpper, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmPerformanceConfigT*)this)->upstreamPowerUpper);
	/* transient soap skipped */
}

int ns1__CmPerformanceConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmPerformanceConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmPerformanceConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmPerformanceConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmPerformanceConfigT(struct soap *soap, const char *tag, int id, const ns1__CmPerformanceConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmPerformanceConfigT), type);
	soap_out_std__string(soap, "downstreamSnrLower", -1, &(((ns1__CmPerformanceConfigT*)a)->downstreamSnrLower), "");
	soap_out_std__string(soap, "downstreamPowerLower", -1, &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerLower), "");
	soap_out_std__string(soap, "downstreamPowerUpper", -1, &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerUpper), "");
	soap_out_std__string(soap, "upstreamPowerLower", -1, &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerLower), "");
	soap_out_std__string(soap, "upstreamPowerUpper", -1, &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerUpper), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmPerformanceConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmPerformanceConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmPerformanceConfigT * SOAP_FMAC4 soap_get_ns1__CmPerformanceConfigT(struct soap *soap, ns1__CmPerformanceConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmPerformanceConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmPerformanceConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmPerformanceConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmPerformanceConfigT * SOAP_FMAC4 soap_in_ns1__CmPerformanceConfigT(struct soap *soap, const char *tag, ns1__CmPerformanceConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmPerformanceConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmPerformanceConfigT, sizeof(ns1__CmPerformanceConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmPerformanceConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmPerformanceConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_downstreamSnrLower1 = 1, soap_flag_downstreamPowerLower1 = 1, soap_flag_downstreamPowerUpper1 = 1, soap_flag_upstreamPowerLower1 = 1, soap_flag_upstreamPowerUpper1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_downstreamSnrLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamSnrLower", &(((ns1__CmPerformanceConfigT*)a)->downstreamSnrLower), "xsd:string"))
				{	soap_flag_downstreamSnrLower1--;
					continue;
				}
			if (soap_flag_downstreamPowerLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamPowerLower", &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerLower), "xsd:string"))
				{	soap_flag_downstreamPowerLower1--;
					continue;
				}
			if (soap_flag_downstreamPowerUpper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "downstreamPowerUpper", &(((ns1__CmPerformanceConfigT*)a)->downstreamPowerUpper), "xsd:string"))
				{	soap_flag_downstreamPowerUpper1--;
					continue;
				}
			if (soap_flag_upstreamPowerLower1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamPowerLower", &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerLower), "xsd:string"))
				{	soap_flag_upstreamPowerLower1--;
					continue;
				}
			if (soap_flag_upstreamPowerUpper1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "upstreamPowerUpper", &(((ns1__CmPerformanceConfigT*)a)->upstreamPowerUpper), "xsd:string"))
				{	soap_flag_upstreamPowerUpper1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_downstreamSnrLower1 > 0 || soap_flag_downstreamPowerLower1 > 0 || soap_flag_downstreamPowerUpper1 > 0 || soap_flag_upstreamPowerLower1 > 0 || soap_flag_upstreamPowerUpper1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmPerformanceConfigT, 0, sizeof(ns1__CmPerformanceConfigT), 0, soap_copy_ns1__CmPerformanceConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmPerformanceConfigT * SOAP_FMAC6 soap_new_ns1__CmPerformanceConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmPerformanceConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmPerformanceConfigT(struct soap *soap, ns1__CmPerformanceConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmPerformanceConfigT * SOAP_FMAC4 soap_instantiate_ns1__CmPerformanceConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmPerformanceConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmPerformanceConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmPerformanceConfigT;
		if (size)
			*size = sizeof(ns1__CmPerformanceConfigT);
		((ns1__CmPerformanceConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmPerformanceConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmPerformanceConfigT);
		for (int i = 0; i < n; i++)
			((ns1__CmPerformanceConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmPerformanceConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmPerformanceConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmPerformanceConfigT %p -> %p\n", q, p));
	*(ns1__CmPerformanceConfigT*)p = *(ns1__CmPerformanceConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmsAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmsAlarmConfigT*)this)->cmsLossOfComm = NULL;
	/* transient soap skipped */
}

void ns1__CmsAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AlarmTypeConfigT(soap, &((ns1__CmsAlarmConfigT*)this)->cmsLossOfComm);
	/* transient soap skipped */
}

int ns1__CmsAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmsAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmsAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmsAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmsAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__CmsAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmsAlarmConfigT), type);
	soap_out_PointerTons1__AlarmTypeConfigT(soap, "cmsLossOfComm", -1, &(((ns1__CmsAlarmConfigT*)a)->cmsLossOfComm), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmsAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmsAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmsAlarmConfigT * SOAP_FMAC4 soap_get_ns1__CmsAlarmConfigT(struct soap *soap, ns1__CmsAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmsAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmsAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmsAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmsAlarmConfigT * SOAP_FMAC4 soap_in_ns1__CmsAlarmConfigT(struct soap *soap, const char *tag, ns1__CmsAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmsAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmsAlarmConfigT, sizeof(ns1__CmsAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmsAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmsAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmsLossOfComm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmsLossOfComm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AlarmTypeConfigT(soap, "cmsLossOfComm", &(((ns1__CmsAlarmConfigT*)a)->cmsLossOfComm), "ns1:AlarmTypeConfigT"))
				{	soap_flag_cmsLossOfComm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmsLossOfComm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmsAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmsAlarmConfigT, 0, sizeof(ns1__CmsAlarmConfigT), 0, soap_copy_ns1__CmsAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmsAlarmConfigT * SOAP_FMAC6 soap_new_ns1__CmsAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmsAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmsAlarmConfigT(struct soap *soap, ns1__CmsAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmsAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__CmsAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmsAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmsAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmsAlarmConfigT;
		if (size)
			*size = sizeof(ns1__CmsAlarmConfigT);
		((ns1__CmsAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmsAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmsAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__CmsAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmsAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmsAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmsAlarmConfigT %p -> %p\n", q, p));
	*(ns1__CmsAlarmConfigT*)p = *(ns1__CmsAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmtsAlarmConfigT*)this)->cmtsDown = NULL;
	/* transient soap skipped */
}

void ns1__CmtsAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AlarmTypeConfigT(soap, &((ns1__CmtsAlarmConfigT*)this)->cmtsDown);
	/* transient soap skipped */
}

int ns1__CmtsAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__CmtsAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsAlarmConfigT), type);
	soap_out_PointerTons1__AlarmTypeConfigT(soap, "cmtsDown", -1, &(((ns1__CmtsAlarmConfigT*)a)->cmtsDown), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT * SOAP_FMAC4 soap_get_ns1__CmtsAlarmConfigT(struct soap *soap, ns1__CmtsAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT * SOAP_FMAC4 soap_in_ns1__CmtsAlarmConfigT(struct soap *soap, const char *tag, ns1__CmtsAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsAlarmConfigT, sizeof(ns1__CmtsAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmtsDown1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmtsDown1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AlarmTypeConfigT(soap, "cmtsDown", &(((ns1__CmtsAlarmConfigT*)a)->cmtsDown), "ns1:AlarmTypeConfigT"))
				{	soap_flag_cmtsDown1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmtsDown1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsAlarmConfigT, 0, sizeof(ns1__CmtsAlarmConfigT), 0, soap_copy_ns1__CmtsAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsAlarmConfigT * SOAP_FMAC6 soap_new_ns1__CmtsAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsAlarmConfigT(struct soap *soap, ns1__CmtsAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__CmtsAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsAlarmConfigT;
		if (size)
			*size = sizeof(ns1__CmtsAlarmConfigT);
		((ns1__CmtsAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsAlarmConfigT %p -> %p\n", q, p));
	*(ns1__CmtsAlarmConfigT*)p = *(ns1__CmtsAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaAlarmConfigT*)this)->alarmTypes = NULL;
	/* transient soap skipped */
}

void ns1__MtaAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmTypeConfigT(soap, &((ns1__MtaAlarmConfigT*)this)->alarmTypes);
	/* transient soap skipped */
}

int ns1__MtaAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__MtaAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaAlarmConfigT), type);
	soap_out_PointerToArrayOfAlarmTypeConfigT(soap, "alarmTypes", -1, &(((ns1__MtaAlarmConfigT*)a)->alarmTypes), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaAlarmConfigT * SOAP_FMAC4 soap_get_ns1__MtaAlarmConfigT(struct soap *soap, ns1__MtaAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaAlarmConfigT * SOAP_FMAC4 soap_in_ns1__MtaAlarmConfigT(struct soap *soap, const char *tag, ns1__MtaAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaAlarmConfigT, sizeof(ns1__MtaAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmTypes1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmTypes1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmTypeConfigT(soap, "alarmTypes", &(((ns1__MtaAlarmConfigT*)a)->alarmTypes), "ns1:AlarmTypeConfigT"))
				{	soap_flag_alarmTypes1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmTypes1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaAlarmConfigT, 0, sizeof(ns1__MtaAlarmConfigT), 0, soap_copy_ns1__MtaAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaAlarmConfigT * SOAP_FMAC6 soap_new_ns1__MtaAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaAlarmConfigT(struct soap *soap, ns1__MtaAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__MtaAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaAlarmConfigT;
		if (size)
			*size = sizeof(ns1__MtaAlarmConfigT);
		((ns1__MtaAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__MtaAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaAlarmConfigT %p -> %p\n", q, p));
	*(ns1__MtaAlarmConfigT*)p = *(ns1__MtaAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAlarmTypeConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAlarmTypeConfigT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAlarmTypeConfigT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AlarmTypeConfigT(soap, this->__ptr + i);
		}
}

int ArrayOfAlarmTypeConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAlarmTypeConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAlarmTypeConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAlarmTypeConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, int id, const ArrayOfAlarmTypeConfigT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AlarmTypeConfigT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AlarmTypeConfigT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAlarmTypeConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAlarmTypeConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT * SOAP_FMAC4 soap_get_ArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAlarmTypeConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAlarmTypeConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT * SOAP_FMAC4 soap_in_ArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, ArrayOfAlarmTypeConfigT *a, const char *type)
{	int i, j;
	ns1__AlarmTypeConfigT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAlarmTypeConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAlarmTypeConfigT, sizeof(ArrayOfAlarmTypeConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AlarmTypeConfigT **)soap_malloc(soap, sizeof(ns1__AlarmTypeConfigT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AlarmTypeConfigT(soap, NULL, a->__ptr + i, "ns1:AlarmTypeConfigT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AlarmTypeConfigT **)soap_push_block(soap, sizeof(ns1__AlarmTypeConfigT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AlarmTypeConfigT(soap, NULL, p, "ns1:AlarmTypeConfigT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AlarmTypeConfigT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmTypeConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAlarmTypeConfigT, 0, sizeof(ArrayOfAlarmTypeConfigT), 0, soap_copy_ArrayOfAlarmTypeConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAlarmTypeConfigT * SOAP_FMAC6 soap_new_ArrayOfAlarmTypeConfigT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAlarmTypeConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT * SOAP_FMAC4 soap_instantiate_ArrayOfAlarmTypeConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAlarmTypeConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAlarmTypeConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAlarmTypeConfigT;
		if (size)
			*size = sizeof(ArrayOfAlarmTypeConfigT);
		((ArrayOfAlarmTypeConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAlarmTypeConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAlarmTypeConfigT);
		for (int i = 0; i < n; i++)
			((ArrayOfAlarmTypeConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAlarmTypeConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAlarmTypeConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAlarmTypeConfigT %p -> %p\n", q, p));
	*(ArrayOfAlarmTypeConfigT*)p = *(ArrayOfAlarmTypeConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AlarmTypeConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__AlarmTypeConfigT*)this)->alarmType);
	((ns1__AlarmTypeConfigT*)this)->soakWindow = NULL;
	/* transient soap skipped */
}

void ns1__AlarmTypeConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AlarmTypeConfigT*)this)->alarmType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmTypeConfigT*)this)->alarmType);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__AlarmTypeConfigT*)this)->soakWindow);
	/* transient soap skipped */
}

int ns1__AlarmTypeConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AlarmTypeConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AlarmTypeConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AlarmTypeConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AlarmTypeConfigT(struct soap *soap, const char *tag, int id, const ns1__AlarmTypeConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AlarmTypeConfigT), type);
	soap_out_std__string(soap, "alarmType", -1, &(((ns1__AlarmTypeConfigT*)a)->alarmType), "");
	soap_out_PointerTons1__SoakWindowT(soap, "soakWindow", -1, &(((ns1__AlarmTypeConfigT*)a)->soakWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AlarmTypeConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AlarmTypeConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT * SOAP_FMAC4 soap_get_ns1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AlarmTypeConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AlarmTypeConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT * SOAP_FMAC4 soap_in_ns1__AlarmTypeConfigT(struct soap *soap, const char *tag, ns1__AlarmTypeConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AlarmTypeConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AlarmTypeConfigT, sizeof(ns1__AlarmTypeConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AlarmTypeConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AlarmTypeConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmType1 = 1, soap_flag_soakWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmType", &(((ns1__AlarmTypeConfigT*)a)->alarmType), "xsd:string"))
				{	soap_flag_alarmType1--;
					continue;
				}
			if (soap_flag_soakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "soakWindow", &(((ns1__AlarmTypeConfigT*)a)->soakWindow), "ns1:SoakWindowT"))
				{	soap_flag_soakWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmType1 > 0 || soap_flag_soakWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AlarmTypeConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AlarmTypeConfigT, 0, sizeof(ns1__AlarmTypeConfigT), 0, soap_copy_ns1__AlarmTypeConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AlarmTypeConfigT * SOAP_FMAC6 soap_new_ns1__AlarmTypeConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AlarmTypeConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT * SOAP_FMAC4 soap_instantiate_ns1__AlarmTypeConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AlarmTypeConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AlarmTypeConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AlarmTypeConfigT;
		if (size)
			*size = sizeof(ns1__AlarmTypeConfigT);
		((ns1__AlarmTypeConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AlarmTypeConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AlarmTypeConfigT);
		for (int i = 0; i < n; i++)
			((ns1__AlarmTypeConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AlarmTypeConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AlarmTypeConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AlarmTypeConfigT %p -> %p\n", q, p));
	*(ns1__AlarmTypeConfigT*)p = *(ns1__AlarmTypeConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcAlarmConfigT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcAlarmConfigT*)this)->cmThresold = NULL;
	((ns1__HfcAlarmConfigT*)this)->cmSoakWindow = NULL;
	((ns1__HfcAlarmConfigT*)this)->mtaThresold = NULL;
	((ns1__HfcAlarmConfigT*)this)->mtaSoakWindow = NULL;
	((ns1__HfcAlarmConfigT*)this)->powerThresold = NULL;
	((ns1__HfcAlarmConfigT*)this)->powerSoakWindow = NULL;
	/* transient soap skipped */
}

void ns1__HfcAlarmConfigT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AggregateCmOfflineTresholdT(soap, &((ns1__HfcAlarmConfigT*)this)->cmThresold);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__HfcAlarmConfigT*)this)->cmSoakWindow);
	soap_serialize_PointerTons1__AggregateMtaTresholdT(soap, &((ns1__HfcAlarmConfigT*)this)->mtaThresold);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__HfcAlarmConfigT*)this)->mtaSoakWindow);
	soap_serialize_PointerTons1__HfcPowerTresholdT(soap, &((ns1__HfcAlarmConfigT*)this)->powerThresold);
	soap_serialize_PointerTons1__SoakWindowT(soap, &((ns1__HfcAlarmConfigT*)this)->powerSoakWindow);
	/* transient soap skipped */
}

int ns1__HfcAlarmConfigT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcAlarmConfigT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcAlarmConfigT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcAlarmConfigT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcAlarmConfigT(struct soap *soap, const char *tag, int id, const ns1__HfcAlarmConfigT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcAlarmConfigT), type);
	soap_out_PointerTons1__AggregateCmOfflineTresholdT(soap, "cmThresold", -1, &(((ns1__HfcAlarmConfigT*)a)->cmThresold), "");
	soap_out_PointerTons1__SoakWindowT(soap, "cmSoakWindow", -1, &(((ns1__HfcAlarmConfigT*)a)->cmSoakWindow), "");
	soap_out_PointerTons1__AggregateMtaTresholdT(soap, "mtaThresold", -1, &(((ns1__HfcAlarmConfigT*)a)->mtaThresold), "");
	soap_out_PointerTons1__SoakWindowT(soap, "mtaSoakWindow", -1, &(((ns1__HfcAlarmConfigT*)a)->mtaSoakWindow), "");
	soap_out_PointerTons1__HfcPowerTresholdT(soap, "powerThresold", -1, &(((ns1__HfcAlarmConfigT*)a)->powerThresold), "");
	soap_out_PointerTons1__SoakWindowT(soap, "powerSoakWindow", -1, &(((ns1__HfcAlarmConfigT*)a)->powerSoakWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcAlarmConfigT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcAlarmConfigT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcAlarmConfigT * SOAP_FMAC4 soap_get_ns1__HfcAlarmConfigT(struct soap *soap, ns1__HfcAlarmConfigT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcAlarmConfigT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcAlarmConfigT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcAlarmConfigT * SOAP_FMAC4 soap_in_ns1__HfcAlarmConfigT(struct soap *soap, const char *tag, ns1__HfcAlarmConfigT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcAlarmConfigT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcAlarmConfigT, sizeof(ns1__HfcAlarmConfigT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcAlarmConfigT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcAlarmConfigT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmThresold1 = 1, soap_flag_cmSoakWindow1 = 1, soap_flag_mtaThresold1 = 1, soap_flag_mtaSoakWindow1 = 1, soap_flag_powerThresold1 = 1, soap_flag_powerSoakWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmThresold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AggregateCmOfflineTresholdT(soap, "cmThresold", &(((ns1__HfcAlarmConfigT*)a)->cmThresold), "ns1:AggregateCmOfflineTresholdT"))
				{	soap_flag_cmThresold1--;
					continue;
				}
			if (soap_flag_cmSoakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "cmSoakWindow", &(((ns1__HfcAlarmConfigT*)a)->cmSoakWindow), "ns1:SoakWindowT"))
				{	soap_flag_cmSoakWindow1--;
					continue;
				}
			if (soap_flag_mtaThresold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AggregateMtaTresholdT(soap, "mtaThresold", &(((ns1__HfcAlarmConfigT*)a)->mtaThresold), "ns1:AggregateMtaTresholdT"))
				{	soap_flag_mtaThresold1--;
					continue;
				}
			if (soap_flag_mtaSoakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "mtaSoakWindow", &(((ns1__HfcAlarmConfigT*)a)->mtaSoakWindow), "ns1:SoakWindowT"))
				{	soap_flag_mtaSoakWindow1--;
					continue;
				}
			if (soap_flag_powerThresold1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HfcPowerTresholdT(soap, "powerThresold", &(((ns1__HfcAlarmConfigT*)a)->powerThresold), "ns1:HfcPowerTresholdT"))
				{	soap_flag_powerThresold1--;
					continue;
				}
			if (soap_flag_powerSoakWindow1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__SoakWindowT(soap, "powerSoakWindow", &(((ns1__HfcAlarmConfigT*)a)->powerSoakWindow), "ns1:SoakWindowT"))
				{	soap_flag_powerSoakWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmThresold1 > 0 || soap_flag_cmSoakWindow1 > 0 || soap_flag_mtaThresold1 > 0 || soap_flag_mtaSoakWindow1 > 0 || soap_flag_powerThresold1 > 0 || soap_flag_powerSoakWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcAlarmConfigT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcAlarmConfigT, 0, sizeof(ns1__HfcAlarmConfigT), 0, soap_copy_ns1__HfcAlarmConfigT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcAlarmConfigT * SOAP_FMAC6 soap_new_ns1__HfcAlarmConfigT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcAlarmConfigT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcAlarmConfigT(struct soap *soap, ns1__HfcAlarmConfigT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcAlarmConfigT * SOAP_FMAC4 soap_instantiate_ns1__HfcAlarmConfigT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcAlarmConfigT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcAlarmConfigT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcAlarmConfigT;
		if (size)
			*size = sizeof(ns1__HfcAlarmConfigT);
		((ns1__HfcAlarmConfigT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcAlarmConfigT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcAlarmConfigT);
		for (int i = 0; i < n; i++)
			((ns1__HfcAlarmConfigT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcAlarmConfigT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcAlarmConfigT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcAlarmConfigT %p -> %p\n", q, p));
	*(ns1__HfcAlarmConfigT*)p = *(ns1__HfcAlarmConfigT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcPowerTresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->thresholdCount);
	soap_default_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

void ns1__HfcPowerTresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__HfcPowerTresholdT*)this)->thresholdCount, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->thresholdCount);
	soap_embedded(soap, &((ns1__HfcPowerTresholdT*)this)->detectionWindow, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcPowerTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

int ns1__HfcPowerTresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcPowerTresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcPowerTresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcPowerTresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcPowerTresholdT(struct soap *soap, const char *tag, int id, const ns1__HfcPowerTresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcPowerTresholdT), type);
	soap_out_std__string(soap, "thresholdCount", -1, &(((ns1__HfcPowerTresholdT*)a)->thresholdCount), "");
	soap_out_std__string(soap, "detectionWindow", -1, &(((ns1__HfcPowerTresholdT*)a)->detectionWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcPowerTresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcPowerTresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT * SOAP_FMAC4 soap_get_ns1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcPowerTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcPowerTresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcPowerTresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT * SOAP_FMAC4 soap_in_ns1__HfcPowerTresholdT(struct soap *soap, const char *tag, ns1__HfcPowerTresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcPowerTresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcPowerTresholdT, sizeof(ns1__HfcPowerTresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcPowerTresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcPowerTresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_thresholdCount1 = 1, soap_flag_detectionWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_thresholdCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "thresholdCount", &(((ns1__HfcPowerTresholdT*)a)->thresholdCount), "xsd:string"))
				{	soap_flag_thresholdCount1--;
					continue;
				}
			if (soap_flag_detectionWindow1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "detectionWindow", &(((ns1__HfcPowerTresholdT*)a)->detectionWindow), "xsd:string"))
				{	soap_flag_detectionWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_thresholdCount1 > 0 || soap_flag_detectionWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcPowerTresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcPowerTresholdT, 0, sizeof(ns1__HfcPowerTresholdT), 0, soap_copy_ns1__HfcPowerTresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcPowerTresholdT * SOAP_FMAC6 soap_new_ns1__HfcPowerTresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcPowerTresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT * SOAP_FMAC4 soap_instantiate_ns1__HfcPowerTresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcPowerTresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcPowerTresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcPowerTresholdT;
		if (size)
			*size = sizeof(ns1__HfcPowerTresholdT);
		((ns1__HfcPowerTresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcPowerTresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcPowerTresholdT);
		for (int i = 0; i < n; i++)
			((ns1__HfcPowerTresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcPowerTresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcPowerTresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcPowerTresholdT %p -> %p\n", q, p));
	*(ns1__HfcPowerTresholdT*)p = *(ns1__HfcPowerTresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AggregateMtaTresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->mtaThresholdCount);
	soap_default_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

void ns1__AggregateMtaTresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AggregateMtaTresholdT*)this)->mtaThresholdCount, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->mtaThresholdCount);
	soap_embedded(soap, &((ns1__AggregateMtaTresholdT*)this)->detectionWindow, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateMtaTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

int ns1__AggregateMtaTresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AggregateMtaTresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AggregateMtaTresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AggregateMtaTresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AggregateMtaTresholdT(struct soap *soap, const char *tag, int id, const ns1__AggregateMtaTresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AggregateMtaTresholdT), type);
	soap_out_std__string(soap, "mtaThresholdCount", -1, &(((ns1__AggregateMtaTresholdT*)a)->mtaThresholdCount), "");
	soap_out_std__string(soap, "detectionWindow", -1, &(((ns1__AggregateMtaTresholdT*)a)->detectionWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AggregateMtaTresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AggregateMtaTresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT * SOAP_FMAC4 soap_get_ns1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AggregateMtaTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AggregateMtaTresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AggregateMtaTresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT * SOAP_FMAC4 soap_in_ns1__AggregateMtaTresholdT(struct soap *soap, const char *tag, ns1__AggregateMtaTresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AggregateMtaTresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AggregateMtaTresholdT, sizeof(ns1__AggregateMtaTresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AggregateMtaTresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AggregateMtaTresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mtaThresholdCount1 = 1, soap_flag_detectionWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mtaThresholdCount1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mtaThresholdCount", &(((ns1__AggregateMtaTresholdT*)a)->mtaThresholdCount), "xsd:string"))
				{	soap_flag_mtaThresholdCount1--;
					continue;
				}
			if (soap_flag_detectionWindow1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "detectionWindow", &(((ns1__AggregateMtaTresholdT*)a)->detectionWindow), "xsd:string"))
				{	soap_flag_detectionWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mtaThresholdCount1 > 0 || soap_flag_detectionWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AggregateMtaTresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AggregateMtaTresholdT, 0, sizeof(ns1__AggregateMtaTresholdT), 0, soap_copy_ns1__AggregateMtaTresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AggregateMtaTresholdT * SOAP_FMAC6 soap_new_ns1__AggregateMtaTresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AggregateMtaTresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT * SOAP_FMAC4 soap_instantiate_ns1__AggregateMtaTresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AggregateMtaTresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AggregateMtaTresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AggregateMtaTresholdT;
		if (size)
			*size = sizeof(ns1__AggregateMtaTresholdT);
		((ns1__AggregateMtaTresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AggregateMtaTresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AggregateMtaTresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AggregateMtaTresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AggregateMtaTresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AggregateMtaTresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AggregateMtaTresholdT %p -> %p\n", q, p));
	*(ns1__AggregateMtaTresholdT*)p = *(ns1__AggregateMtaTresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AggregateCmOfflineTresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE1);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE1);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE2);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE2);
	soap_default_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

void ns1__AggregateCmOfflineTresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE1);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE1);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->percentCmOffline_USCORE2);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->maxCm_USCORE2);
	soap_embedded(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->detectionWindow, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateCmOfflineTresholdT*)this)->detectionWindow);
	/* transient soap skipped */
}

int ns1__AggregateCmOfflineTresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AggregateCmOfflineTresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AggregateCmOfflineTresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, int id, const ns1__AggregateCmOfflineTresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT), type);
	soap_out_std__string(soap, "percentCmOffline_1", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE1), "");
	soap_out_std__string(soap, "maxCm_1", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE1), "");
	soap_out_std__string(soap, "percentCmOffline_2", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE2), "");
	soap_out_std__string(soap, "maxCm_2", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE2), "");
	soap_out_std__string(soap, "detectionWindow", -1, &(((ns1__AggregateCmOfflineTresholdT*)a)->detectionWindow), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AggregateCmOfflineTresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AggregateCmOfflineTresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC4 soap_get_ns1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AggregateCmOfflineTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AggregateCmOfflineTresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AggregateCmOfflineTresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC4 soap_in_ns1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, ns1__AggregateCmOfflineTresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AggregateCmOfflineTresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, sizeof(ns1__AggregateCmOfflineTresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AggregateCmOfflineTresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AggregateCmOfflineTresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_percentCmOffline_USCORE11 = 1, soap_flag_maxCm_USCORE11 = 1, soap_flag_percentCmOffline_USCORE21 = 1, soap_flag_maxCm_USCORE21 = 1, soap_flag_detectionWindow1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_percentCmOffline_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "percentCmOffline_1", &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE1), "xsd:string"))
				{	soap_flag_percentCmOffline_USCORE11--;
					continue;
				}
			if (soap_flag_maxCm_USCORE11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "maxCm_1", &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE1), "xsd:string"))
				{	soap_flag_maxCm_USCORE11--;
					continue;
				}
			if (soap_flag_percentCmOffline_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "percentCmOffline_2", &(((ns1__AggregateCmOfflineTresholdT*)a)->percentCmOffline_USCORE2), "xsd:string"))
				{	soap_flag_percentCmOffline_USCORE21--;
					continue;
				}
			if (soap_flag_maxCm_USCORE21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "maxCm_2", &(((ns1__AggregateCmOfflineTresholdT*)a)->maxCm_USCORE2), "xsd:string"))
				{	soap_flag_maxCm_USCORE21--;
					continue;
				}
			if (soap_flag_detectionWindow1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "detectionWindow", &(((ns1__AggregateCmOfflineTresholdT*)a)->detectionWindow), "xsd:string"))
				{	soap_flag_detectionWindow1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_percentCmOffline_USCORE11 > 0 || soap_flag_maxCm_USCORE11 > 0 || soap_flag_percentCmOffline_USCORE21 > 0 || soap_flag_maxCm_USCORE21 > 0 || soap_flag_detectionWindow1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AggregateCmOfflineTresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, 0, sizeof(ns1__AggregateCmOfflineTresholdT), 0, soap_copy_ns1__AggregateCmOfflineTresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC6 soap_new_ns1__AggregateCmOfflineTresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AggregateCmOfflineTresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT * SOAP_FMAC4 soap_instantiate_ns1__AggregateCmOfflineTresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AggregateCmOfflineTresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AggregateCmOfflineTresholdT;
		if (size)
			*size = sizeof(ns1__AggregateCmOfflineTresholdT);
		((ns1__AggregateCmOfflineTresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AggregateCmOfflineTresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AggregateCmOfflineTresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AggregateCmOfflineTresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AggregateCmOfflineTresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AggregateCmOfflineTresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AggregateCmOfflineTresholdT %p -> %p\n", q, p));
	*(ns1__AggregateCmOfflineTresholdT*)p = *(ns1__AggregateCmOfflineTresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SoakWindowT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREStartTime);
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREDuration);
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREStartTime);
	soap_default_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREDuration);
	/* transient soap skipped */
}

void ns1__SoakWindowT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREStartTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREStartTime);
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREDuration, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE1_USCOREDuration);
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREStartTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREStartTime);
	soap_embedded(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREDuration, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SoakWindowT*)this)->soakWindow_USCORE2_USCOREDuration);
	/* transient soap skipped */
}

int ns1__SoakWindowT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SoakWindowT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SoakWindowT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SoakWindowT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoakWindowT(struct soap *soap, const char *tag, int id, const ns1__SoakWindowT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoakWindowT), type);
	soap_out_std__string(soap, "soakWindow_1_StartTime", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREStartTime), "");
	soap_out_std__string(soap, "soakWindow_1_Duration", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREDuration), "");
	soap_out_std__string(soap, "soakWindow_2_StartTime", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREStartTime), "");
	soap_out_std__string(soap, "soakWindow_2_Duration", -1, &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREDuration), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SoakWindowT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SoakWindowT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SoakWindowT * SOAP_FMAC4 soap_get_ns1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoakWindowT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SoakWindowT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SoakWindowT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SoakWindowT * SOAP_FMAC4 soap_in_ns1__SoakWindowT(struct soap *soap, const char *tag, ns1__SoakWindowT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SoakWindowT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoakWindowT, sizeof(ns1__SoakWindowT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SoakWindowT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SoakWindowT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_soakWindow_USCORE1_USCOREStartTime1 = 1, soap_flag_soakWindow_USCORE1_USCOREDuration1 = 1, soap_flag_soakWindow_USCORE2_USCOREStartTime1 = 1, soap_flag_soakWindow_USCORE2_USCOREDuration1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_soakWindow_USCORE1_USCOREStartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_1_StartTime", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREStartTime), "xsd:string"))
				{	soap_flag_soakWindow_USCORE1_USCOREStartTime1--;
					continue;
				}
			if (soap_flag_soakWindow_USCORE1_USCOREDuration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_1_Duration", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE1_USCOREDuration), "xsd:string"))
				{	soap_flag_soakWindow_USCORE1_USCOREDuration1--;
					continue;
				}
			if (soap_flag_soakWindow_USCORE2_USCOREStartTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_2_StartTime", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREStartTime), "xsd:string"))
				{	soap_flag_soakWindow_USCORE2_USCOREStartTime1--;
					continue;
				}
			if (soap_flag_soakWindow_USCORE2_USCOREDuration1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "soakWindow_2_Duration", &(((ns1__SoakWindowT*)a)->soakWindow_USCORE2_USCOREDuration), "xsd:string"))
				{	soap_flag_soakWindow_USCORE2_USCOREDuration1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_soakWindow_USCORE1_USCOREStartTime1 > 0 || soap_flag_soakWindow_USCORE1_USCOREDuration1 > 0 || soap_flag_soakWindow_USCORE2_USCOREStartTime1 > 0 || soap_flag_soakWindow_USCORE2_USCOREDuration1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SoakWindowT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoakWindowT, 0, sizeof(ns1__SoakWindowT), 0, soap_copy_ns1__SoakWindowT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SoakWindowT * SOAP_FMAC6 soap_new_ns1__SoakWindowT(struct soap *soap, int n)
{	return soap_instantiate_ns1__SoakWindowT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SoakWindowT * SOAP_FMAC4 soap_instantiate_ns1__SoakWindowT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SoakWindowT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SoakWindowT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SoakWindowT;
		if (size)
			*size = sizeof(ns1__SoakWindowT);
		((ns1__SoakWindowT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SoakWindowT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SoakWindowT);
		for (int i = 0; i < n; i++)
			((ns1__SoakWindowT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SoakWindowT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SoakWindowT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SoakWindowT %p -> %p\n", q, p));
	*(ns1__SoakWindowT*)p = *(ns1__SoakWindowT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmsStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmsStatusThresholdT*)this)->alarmThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__CmsStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__CmsStatusThresholdT*)this)->alarmThreshArray);
	/* transient soap skipped */
}

int ns1__CmsStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmsStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmsStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmsStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmsStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__CmsStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmsStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__CmsStatusThresholdT*)a)->alarmThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmsStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmsStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmsStatusThresholdT * SOAP_FMAC4 soap_get_ns1__CmsStatusThresholdT(struct soap *soap, ns1__CmsStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmsStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmsStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmsStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmsStatusThresholdT * SOAP_FMAC4 soap_in_ns1__CmsStatusThresholdT(struct soap *soap, const char *tag, ns1__CmsStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmsStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmsStatusThresholdT, sizeof(ns1__CmsStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmsStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmsStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__CmsStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmsStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmsStatusThresholdT, 0, sizeof(ns1__CmsStatusThresholdT), 0, soap_copy_ns1__CmsStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmsStatusThresholdT * SOAP_FMAC6 soap_new_ns1__CmsStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmsStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmsStatusThresholdT(struct soap *soap, ns1__CmsStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmsStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__CmsStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmsStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmsStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmsStatusThresholdT;
		if (size)
			*size = sizeof(ns1__CmsStatusThresholdT);
		((ns1__CmsStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmsStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmsStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__CmsStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmsStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmsStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmsStatusThresholdT %p -> %p\n", q, p));
	*(ns1__CmsStatusThresholdT*)p = *(ns1__CmsStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmtsStatusThresholdT*)this)->alarmThreshArray = NULL;
	((ns1__CmtsStatusThresholdT*)this)->aggThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__CmtsStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__CmtsStatusThresholdT*)this)->alarmThreshArray);
	soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, &((ns1__CmtsStatusThresholdT*)this)->aggThreshArray);
	/* transient soap skipped */
}

int ns1__CmtsStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__CmtsStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__CmtsStatusThresholdT*)a)->alarmThreshArray), "");
	soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", -1, &(((ns1__CmtsStatusThresholdT*)a)->aggThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT * SOAP_FMAC4 soap_get_ns1__CmtsStatusThresholdT(struct soap *soap, ns1__CmtsStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT * SOAP_FMAC4 soap_in_ns1__CmtsStatusThresholdT(struct soap *soap, const char *tag, ns1__CmtsStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsStatusThresholdT, sizeof(ns1__CmtsStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1, soap_flag_aggThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__CmtsStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			if (soap_flag_aggThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", &(((ns1__CmtsStatusThresholdT*)a)->aggThreshArray), "ns1:AggregateStatusThresholdT"))
				{	soap_flag_aggThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0 || soap_flag_aggThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsStatusThresholdT, 0, sizeof(ns1__CmtsStatusThresholdT), 0, soap_copy_ns1__CmtsStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsStatusThresholdT * SOAP_FMAC6 soap_new_ns1__CmtsStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsStatusThresholdT(struct soap *soap, ns1__CmtsStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__CmtsStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsStatusThresholdT;
		if (size)
			*size = sizeof(ns1__CmtsStatusThresholdT);
		((ns1__CmtsStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsStatusThresholdT %p -> %p\n", q, p));
	*(ns1__CmtsStatusThresholdT*)p = *(ns1__CmtsStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ChannelStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ChannelStatusThresholdT*)this)->alarmThreshArray = NULL;
	((ns1__ChannelStatusThresholdT*)this)->aggThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__ChannelStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__ChannelStatusThresholdT*)this)->alarmThreshArray);
	soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, &((ns1__ChannelStatusThresholdT*)this)->aggThreshArray);
	/* transient soap skipped */
}

int ns1__ChannelStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ChannelStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ChannelStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChannelStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChannelStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__ChannelStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChannelStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__ChannelStatusThresholdT*)a)->alarmThreshArray), "");
	soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", -1, &(((ns1__ChannelStatusThresholdT*)a)->aggThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ChannelStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChannelStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT * SOAP_FMAC4 soap_get_ns1__ChannelStatusThresholdT(struct soap *soap, ns1__ChannelStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChannelStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ChannelStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ChannelStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT * SOAP_FMAC4 soap_in_ns1__ChannelStatusThresholdT(struct soap *soap, const char *tag, ns1__ChannelStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChannelStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChannelStatusThresholdT, sizeof(ns1__ChannelStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ChannelStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ChannelStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1, soap_flag_aggThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__ChannelStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			if (soap_flag_aggThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", &(((ns1__ChannelStatusThresholdT*)a)->aggThreshArray), "ns1:AggregateStatusThresholdT"))
				{	soap_flag_aggThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0 || soap_flag_aggThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ChannelStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChannelStatusThresholdT, 0, sizeof(ns1__ChannelStatusThresholdT), 0, soap_copy_ns1__ChannelStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ChannelStatusThresholdT * SOAP_FMAC6 soap_new_ns1__ChannelStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ChannelStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ChannelStatusThresholdT(struct soap *soap, ns1__ChannelStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__ChannelStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChannelStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ChannelStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ChannelStatusThresholdT;
		if (size)
			*size = sizeof(ns1__ChannelStatusThresholdT);
		((ns1__ChannelStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ChannelStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ChannelStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__ChannelStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ChannelStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ChannelStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ChannelStatusThresholdT %p -> %p\n", q, p));
	*(ns1__ChannelStatusThresholdT*)p = *(ns1__ChannelStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcStatusThresholdT*)this)->alarmThreshArray = NULL;
	((ns1__HfcStatusThresholdT*)this)->aggThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__HfcStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__HfcStatusThresholdT*)this)->alarmThreshArray);
	soap_serialize_PointerToArrayOfAggregateStatusThresholdT(soap, &((ns1__HfcStatusThresholdT*)this)->aggThreshArray);
	/* transient soap skipped */
}

int ns1__HfcStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__HfcStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__HfcStatusThresholdT*)a)->alarmThreshArray), "");
	soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", -1, &(((ns1__HfcStatusThresholdT*)a)->aggThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcStatusThresholdT * SOAP_FMAC4 soap_get_ns1__HfcStatusThresholdT(struct soap *soap, ns1__HfcStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcStatusThresholdT * SOAP_FMAC4 soap_in_ns1__HfcStatusThresholdT(struct soap *soap, const char *tag, ns1__HfcStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcStatusThresholdT, sizeof(ns1__HfcStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1, soap_flag_aggThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__HfcStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			if (soap_flag_aggThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, "aggThreshArray", &(((ns1__HfcStatusThresholdT*)a)->aggThreshArray), "ns1:AggregateStatusThresholdT"))
				{	soap_flag_aggThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0 || soap_flag_aggThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcStatusThresholdT, 0, sizeof(ns1__HfcStatusThresholdT), 0, soap_copy_ns1__HfcStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcStatusThresholdT * SOAP_FMAC6 soap_new_ns1__HfcStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcStatusThresholdT(struct soap *soap, ns1__HfcStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__HfcStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcStatusThresholdT;
		if (size)
			*size = sizeof(ns1__HfcStatusThresholdT);
		((ns1__HfcStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__HfcStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcStatusThresholdT %p -> %p\n", q, p));
	*(ns1__HfcStatusThresholdT*)p = *(ns1__HfcStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaStatusThresholdT*)this)->alarmThreshArray = NULL;
	/* transient soap skipped */
}

void ns1__MtaStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfAlarmStatusThresholdT(soap, &((ns1__MtaStatusThresholdT*)this)->alarmThreshArray);
	/* transient soap skipped */
}

int ns1__MtaStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__MtaStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaStatusThresholdT), type);
	soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", -1, &(((ns1__MtaStatusThresholdT*)a)->alarmThreshArray), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaStatusThresholdT * SOAP_FMAC4 soap_get_ns1__MtaStatusThresholdT(struct soap *soap, ns1__MtaStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaStatusThresholdT * SOAP_FMAC4 soap_in_ns1__MtaStatusThresholdT(struct soap *soap, const char *tag, ns1__MtaStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaStatusThresholdT, sizeof(ns1__MtaStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_alarmThreshArray1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmThreshArray1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, "alarmThreshArray", &(((ns1__MtaStatusThresholdT*)a)->alarmThreshArray), "ns1:AlarmBasedStatusThresholdT"))
				{	soap_flag_alarmThreshArray1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_alarmThreshArray1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaStatusThresholdT, 0, sizeof(ns1__MtaStatusThresholdT), 0, soap_copy_ns1__MtaStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaStatusThresholdT * SOAP_FMAC6 soap_new_ns1__MtaStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaStatusThresholdT(struct soap *soap, ns1__MtaStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__MtaStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaStatusThresholdT;
		if (size)
			*size = sizeof(ns1__MtaStatusThresholdT);
		((ns1__MtaStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__MtaStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaStatusThresholdT %p -> %p\n", q, p));
	*(ns1__MtaStatusThresholdT*)p = *(ns1__MtaStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAggregateStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAggregateStatusThresholdT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAggregateStatusThresholdT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AggregateStatusThresholdT(soap, this->__ptr + i);
		}
}

int ArrayOfAggregateStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAggregateStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAggregateStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAggregateStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, int id, const ArrayOfAggregateStatusThresholdT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AggregateStatusThresholdT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AggregateStatusThresholdT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAggregateStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAggregateStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT * SOAP_FMAC4 soap_get_ArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAggregateStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAggregateStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT * SOAP_FMAC4 soap_in_ArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAggregateStatusThresholdT *a, const char *type)
{	int i, j;
	ns1__AggregateStatusThresholdT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAggregateStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, sizeof(ArrayOfAggregateStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AggregateStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AggregateStatusThresholdT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AggregateStatusThresholdT(soap, NULL, a->__ptr + i, "ns1:AggregateStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AggregateStatusThresholdT **)soap_push_block(soap, sizeof(ns1__AggregateStatusThresholdT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AggregateStatusThresholdT(soap, NULL, p, "ns1:AggregateStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AggregateStatusThresholdT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAggregateStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, 0, sizeof(ArrayOfAggregateStatusThresholdT), 0, soap_copy_ArrayOfAggregateStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAggregateStatusThresholdT * SOAP_FMAC6 soap_new_ArrayOfAggregateStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAggregateStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT * SOAP_FMAC4 soap_instantiate_ArrayOfAggregateStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAggregateStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAggregateStatusThresholdT;
		if (size)
			*size = sizeof(ArrayOfAggregateStatusThresholdT);
		((ArrayOfAggregateStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAggregateStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAggregateStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ArrayOfAggregateStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAggregateStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAggregateStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAggregateStatusThresholdT %p -> %p\n", q, p));
	*(ArrayOfAggregateStatusThresholdT*)p = *(ArrayOfAggregateStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AggregateStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__StatusColorT(soap, &((ns1__AggregateStatusThresholdT*)this)->color);
	soap_default_ns1__StatusColorT(soap, &((ns1__AggregateStatusThresholdT*)this)->childColor);
	soap_default_std__string(soap, &((ns1__AggregateStatusThresholdT*)this)->thresholdPercent);
	/* transient soap skipped */
}

void ns1__AggregateStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AggregateStatusThresholdT*)this)->thresholdPercent, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AggregateStatusThresholdT*)this)->thresholdPercent);
	/* transient soap skipped */
}

int ns1__AggregateStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AggregateStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AggregateStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AggregateStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AggregateStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__AggregateStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AggregateStatusThresholdT), type);
	soap_out_ns1__StatusColorT(soap, "color", -1, &(((ns1__AggregateStatusThresholdT*)a)->color), "");
	soap_out_ns1__StatusColorT(soap, "childColor", -1, &(((ns1__AggregateStatusThresholdT*)a)->childColor), "");
	soap_out_std__string(soap, "thresholdPercent", -1, &(((ns1__AggregateStatusThresholdT*)a)->thresholdPercent), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AggregateStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AggregateStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT * SOAP_FMAC4 soap_get_ns1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AggregateStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AggregateStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT * SOAP_FMAC4 soap_in_ns1__AggregateStatusThresholdT(struct soap *soap, const char *tag, ns1__AggregateStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AggregateStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AggregateStatusThresholdT, sizeof(ns1__AggregateStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AggregateStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AggregateStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_color1 = 1, soap_flag_childColor1 = 1, soap_flag_thresholdPercent1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "color", &(((ns1__AggregateStatusThresholdT*)a)->color), "ns1:StatusColorT"))
				{	soap_flag_color1--;
					continue;
				}
			if (soap_flag_childColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "childColor", &(((ns1__AggregateStatusThresholdT*)a)->childColor), "ns1:StatusColorT"))
				{	soap_flag_childColor1--;
					continue;
				}
			if (soap_flag_thresholdPercent1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "thresholdPercent", &(((ns1__AggregateStatusThresholdT*)a)->thresholdPercent), "xsd:string"))
				{	soap_flag_thresholdPercent1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_color1 > 0 || soap_flag_childColor1 > 0 || soap_flag_thresholdPercent1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AggregateStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AggregateStatusThresholdT, 0, sizeof(ns1__AggregateStatusThresholdT), 0, soap_copy_ns1__AggregateStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AggregateStatusThresholdT * SOAP_FMAC6 soap_new_ns1__AggregateStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AggregateStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__AggregateStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AggregateStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AggregateStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AggregateStatusThresholdT;
		if (size)
			*size = sizeof(ns1__AggregateStatusThresholdT);
		((ns1__AggregateStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AggregateStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AggregateStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AggregateStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AggregateStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AggregateStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AggregateStatusThresholdT %p -> %p\n", q, p));
	*(ns1__AggregateStatusThresholdT*)p = *(ns1__AggregateStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAlarmStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAlarmStatusThresholdT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAlarmStatusThresholdT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(soap, this->__ptr + i);
		}
}

int ArrayOfAlarmStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAlarmStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAlarmStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAlarmStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, int id, const ArrayOfAlarmStatusThresholdT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AlarmBasedStatusThresholdT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmStatusThresholdT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAlarmStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAlarmStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT * SOAP_FMAC4 soap_get_ArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAlarmStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAlarmStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAlarmStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT * SOAP_FMAC4 soap_in_ArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAlarmStatusThresholdT *a, const char *type)
{	int i, j;
	ns1__AlarmBasedStatusThresholdT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAlarmStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, sizeof(ArrayOfAlarmStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AlarmBasedStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AlarmBasedStatusThresholdT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, NULL, a->__ptr + i, "ns1:AlarmBasedStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AlarmBasedStatusThresholdT **)soap_push_block(soap, sizeof(ns1__AlarmBasedStatusThresholdT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, NULL, p, "ns1:AlarmBasedStatusThresholdT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AlarmBasedStatusThresholdT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, 0, sizeof(ArrayOfAlarmStatusThresholdT), 0, soap_copy_ArrayOfAlarmStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAlarmStatusThresholdT * SOAP_FMAC6 soap_new_ArrayOfAlarmStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAlarmStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT * SOAP_FMAC4 soap_instantiate_ArrayOfAlarmStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAlarmStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAlarmStatusThresholdT;
		if (size)
			*size = sizeof(ArrayOfAlarmStatusThresholdT);
		((ArrayOfAlarmStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAlarmStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAlarmStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ArrayOfAlarmStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAlarmStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAlarmStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAlarmStatusThresholdT %p -> %p\n", q, p));
	*(ArrayOfAlarmStatusThresholdT*)p = *(ArrayOfAlarmStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AlarmBasedStatusThresholdT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__StatusColorT(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->color);
	soap_default_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmType);
	soap_default_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmState);
	/* transient soap skipped */
}

void ns1__AlarmBasedStatusThresholdT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmType);
	soap_embedded(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmState, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmBasedStatusThresholdT*)this)->alarmState);
	/* transient soap skipped */
}

int ns1__AlarmBasedStatusThresholdT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AlarmBasedStatusThresholdT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AlarmBasedStatusThresholdT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, int id, const ns1__AlarmBasedStatusThresholdT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT), type);
	soap_out_ns1__StatusColorT(soap, "color", -1, &(((ns1__AlarmBasedStatusThresholdT*)a)->color), "");
	soap_out_std__string(soap, "alarmType", -1, &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmType), "");
	soap_out_std__string(soap, "alarmState", -1, &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AlarmBasedStatusThresholdT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AlarmBasedStatusThresholdT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC4 soap_get_ns1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AlarmBasedStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AlarmBasedStatusThresholdT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AlarmBasedStatusThresholdT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC4 soap_in_ns1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, ns1__AlarmBasedStatusThresholdT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AlarmBasedStatusThresholdT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, sizeof(ns1__AlarmBasedStatusThresholdT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AlarmBasedStatusThresholdT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AlarmBasedStatusThresholdT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_color1 = 1, soap_flag_alarmType1 = 1, soap_flag_alarmState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_color1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "color", &(((ns1__AlarmBasedStatusThresholdT*)a)->color), "ns1:StatusColorT"))
				{	soap_flag_color1--;
					continue;
				}
			if (soap_flag_alarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmType", &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmType), "xsd:string"))
				{	soap_flag_alarmType1--;
					continue;
				}
			if (soap_flag_alarmState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmState", &(((ns1__AlarmBasedStatusThresholdT*)a)->alarmState), "xsd:string"))
				{	soap_flag_alarmState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_color1 > 0 || soap_flag_alarmType1 > 0 || soap_flag_alarmState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AlarmBasedStatusThresholdT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, 0, sizeof(ns1__AlarmBasedStatusThresholdT), 0, soap_copy_ns1__AlarmBasedStatusThresholdT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC6 soap_new_ns1__AlarmBasedStatusThresholdT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AlarmBasedStatusThresholdT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT * SOAP_FMAC4 soap_instantiate_ns1__AlarmBasedStatusThresholdT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AlarmBasedStatusThresholdT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AlarmBasedStatusThresholdT;
		if (size)
			*size = sizeof(ns1__AlarmBasedStatusThresholdT);
		((ns1__AlarmBasedStatusThresholdT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AlarmBasedStatusThresholdT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AlarmBasedStatusThresholdT);
		for (int i = 0; i < n; i++)
			((ns1__AlarmBasedStatusThresholdT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AlarmBasedStatusThresholdT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AlarmBasedStatusThresholdT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AlarmBasedStatusThresholdT %p -> %p\n", q, p));
	*(ns1__AlarmBasedStatusThresholdT*)p = *(ns1__AlarmBasedStatusThresholdT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__PollingIntervalsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmtsPollInterval);
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmPollInterval);
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPollInterval);
	soap_default_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPingInterval);
	/* transient soap skipped */
}

void ns1__PollingIntervalsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->cmtsPollInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmtsPollInterval);
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->cmPollInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->cmPollInterval);
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->mtaPollInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPollInterval);
	soap_embedded(soap, &((ns1__PollingIntervalsT*)this)->mtaPingInterval, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__PollingIntervalsT*)this)->mtaPingInterval);
	/* transient soap skipped */
}

int ns1__PollingIntervalsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__PollingIntervalsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__PollingIntervalsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__PollingIntervalsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__PollingIntervalsT(struct soap *soap, const char *tag, int id, const ns1__PollingIntervalsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__PollingIntervalsT), type);
	soap_out_std__string(soap, "cmtsPollInterval", -1, &(((ns1__PollingIntervalsT*)a)->cmtsPollInterval), "");
	soap_out_std__string(soap, "cmPollInterval", -1, &(((ns1__PollingIntervalsT*)a)->cmPollInterval), "");
	soap_out_std__string(soap, "mtaPollInterval", -1, &(((ns1__PollingIntervalsT*)a)->mtaPollInterval), "");
	soap_out_std__string(soap, "mtaPingInterval", -1, &(((ns1__PollingIntervalsT*)a)->mtaPingInterval), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__PollingIntervalsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__PollingIntervalsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__PollingIntervalsT * SOAP_FMAC4 soap_get_ns1__PollingIntervalsT(struct soap *soap, ns1__PollingIntervalsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__PollingIntervalsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__PollingIntervalsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__PollingIntervalsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__PollingIntervalsT * SOAP_FMAC4 soap_in_ns1__PollingIntervalsT(struct soap *soap, const char *tag, ns1__PollingIntervalsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__PollingIntervalsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__PollingIntervalsT, sizeof(ns1__PollingIntervalsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__PollingIntervalsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__PollingIntervalsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmtsPollInterval1 = 1, soap_flag_cmPollInterval1 = 1, soap_flag_mtaPollInterval1 = 1, soap_flag_mtaPingInterval1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmtsPollInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsPollInterval", &(((ns1__PollingIntervalsT*)a)->cmtsPollInterval), "xsd:string"))
				{	soap_flag_cmtsPollInterval1--;
					continue;
				}
			if (soap_flag_cmPollInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmPollInterval", &(((ns1__PollingIntervalsT*)a)->cmPollInterval), "xsd:string"))
				{	soap_flag_cmPollInterval1--;
					continue;
				}
			if (soap_flag_mtaPollInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mtaPollInterval", &(((ns1__PollingIntervalsT*)a)->mtaPollInterval), "xsd:string"))
				{	soap_flag_mtaPollInterval1--;
					continue;
				}
			if (soap_flag_mtaPingInterval1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mtaPingInterval", &(((ns1__PollingIntervalsT*)a)->mtaPingInterval), "xsd:string"))
				{	soap_flag_mtaPingInterval1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmtsPollInterval1 > 0 || soap_flag_cmPollInterval1 > 0 || soap_flag_mtaPollInterval1 > 0 || soap_flag_mtaPingInterval1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__PollingIntervalsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__PollingIntervalsT, 0, sizeof(ns1__PollingIntervalsT), 0, soap_copy_ns1__PollingIntervalsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__PollingIntervalsT * SOAP_FMAC6 soap_new_ns1__PollingIntervalsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__PollingIntervalsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__PollingIntervalsT(struct soap *soap, ns1__PollingIntervalsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__PollingIntervalsT * SOAP_FMAC4 soap_instantiate_ns1__PollingIntervalsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__PollingIntervalsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__PollingIntervalsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__PollingIntervalsT;
		if (size)
			*size = sizeof(ns1__PollingIntervalsT);
		((ns1__PollingIntervalsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__PollingIntervalsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__PollingIntervalsT);
		for (int i = 0; i < n; i++)
			((ns1__PollingIntervalsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__PollingIntervalsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__PollingIntervalsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__PollingIntervalsT %p -> %p\n", q, p));
	*(ns1__PollingIntervalsT*)p = *(ns1__PollingIntervalsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfUserT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfUserT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfUserT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__UserT(soap, this->__ptr + i);
		}
}

int ArrayOfUserT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfUserT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfUserT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfUserT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfUserT(struct soap *soap, const char *tag, int id, const ArrayOfUserT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:UserT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfUserT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__UserT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfUserT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfUserT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfUserT * SOAP_FMAC4 soap_get_ArrayOfUserT(struct soap *soap, ArrayOfUserT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfUserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfUserT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfUserT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfUserT * SOAP_FMAC4 soap_in_ArrayOfUserT(struct soap *soap, const char *tag, ArrayOfUserT *a, const char *type)
{	int i, j;
	ns1__UserT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfUserT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfUserT, sizeof(ArrayOfUserT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__UserT **)soap_malloc(soap, sizeof(ns1__UserT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__UserT(soap, NULL, a->__ptr + i, "ns1:UserT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__UserT **)soap_push_block(soap, sizeof(ns1__UserT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__UserT(soap, NULL, p, "ns1:UserT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__UserT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfUserT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfUserT, 0, sizeof(ArrayOfUserT), 0, soap_copy_ArrayOfUserT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfUserT * SOAP_FMAC6 soap_new_ArrayOfUserT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfUserT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfUserT(struct soap *soap, ArrayOfUserT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfUserT * SOAP_FMAC4 soap_instantiate_ArrayOfUserT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfUserT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfUserT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfUserT;
		if (size)
			*size = sizeof(ArrayOfUserT);
		((ArrayOfUserT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfUserT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfUserT);
		for (int i = 0; i < n; i++)
			((ArrayOfUserT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfUserT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfUserT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfUserT %p -> %p\n", q, p));
	*(ArrayOfUserT*)p = *(ArrayOfUserT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__UserT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__UserT*)this)->userId);
	soap_default_std__string(soap, &((ns1__UserT*)this)->firstName);
	soap_default_std__string(soap, &((ns1__UserT*)this)->lastName);
	((ns1__UserT*)this)->middleInitial = NULL;
	soap_default_std__string(soap, &((ns1__UserT*)this)->location);
	soap_default_std__string(soap, &((ns1__UserT*)this)->loginName);
	((ns1__UserT*)this)->loginPassword = NULL;
	((ns1__UserT*)this)->isActive = NULL;
	((ns1__UserT*)this)->roleName = NULL;
	/* transient soap skipped */
}

void ns1__UserT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__UserT*)this)->userId, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->userId);
	soap_embedded(soap, &((ns1__UserT*)this)->firstName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->firstName);
	soap_embedded(soap, &((ns1__UserT*)this)->lastName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->lastName);
	soap_serialize_PointerTostd__string(soap, &((ns1__UserT*)this)->middleInitial);
	soap_embedded(soap, &((ns1__UserT*)this)->location, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->location);
	soap_embedded(soap, &((ns1__UserT*)this)->loginName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__UserT*)this)->loginName);
	soap_serialize_PointerTostd__string(soap, &((ns1__UserT*)this)->loginPassword);
	soap_serialize_PointerToshort(soap, &((ns1__UserT*)this)->isActive);
	soap_serialize_PointerTostd__string(soap, &((ns1__UserT*)this)->roleName);
	/* transient soap skipped */
}

int ns1__UserT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UserT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__UserT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserT(struct soap *soap, const char *tag, int id, const ns1__UserT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserT), type);
	soap_out_std__string(soap, "userId", -1, &(((ns1__UserT*)a)->userId), "");
	soap_out_std__string(soap, "firstName", -1, &(((ns1__UserT*)a)->firstName), "");
	soap_out_std__string(soap, "lastName", -1, &(((ns1__UserT*)a)->lastName), "");
	soap_out_PointerTostd__string(soap, "middleInitial", -1, &(((ns1__UserT*)a)->middleInitial), "");
	soap_out_std__string(soap, "location", -1, &(((ns1__UserT*)a)->location), "");
	soap_out_std__string(soap, "loginName", -1, &(((ns1__UserT*)a)->loginName), "");
	soap_out_PointerTostd__string(soap, "loginPassword", -1, &(((ns1__UserT*)a)->loginPassword), "");
	soap_out_PointerToshort(soap, "isActive", -1, &(((ns1__UserT*)a)->isActive), "");
	soap_out_PointerTostd__string(soap, "roleName", -1, &(((ns1__UserT*)a)->roleName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__UserT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserT * SOAP_FMAC4 soap_get_ns1__UserT(struct soap *soap, ns1__UserT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__UserT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserT * SOAP_FMAC4 soap_in_ns1__UserT(struct soap *soap, const char *tag, ns1__UserT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserT, sizeof(ns1__UserT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UserT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UserT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_userId1 = 1, soap_flag_firstName1 = 1, soap_flag_lastName1 = 1, soap_flag_middleInitial1 = 1, soap_flag_location1 = 1, soap_flag_loginName1 = 1, soap_flag_loginPassword1 = 1, soap_flag_isActive1 = 1, soap_flag_roleName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_userId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "userId", &(((ns1__UserT*)a)->userId), "xsd:string"))
				{	soap_flag_userId1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "firstName", &(((ns1__UserT*)a)->firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "lastName", &(((ns1__UserT*)a)->lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_middleInitial1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "middleInitial", &(((ns1__UserT*)a)->middleInitial), "xsd:string"))
				{	soap_flag_middleInitial1--;
					continue;
				}
			if (soap_flag_location1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "location", &(((ns1__UserT*)a)->location), "xsd:string"))
				{	soap_flag_location1--;
					continue;
				}
			if (soap_flag_loginName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginName", &(((ns1__UserT*)a)->loginName), "xsd:string"))
				{	soap_flag_loginName1--;
					continue;
				}
			if (soap_flag_loginPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "loginPassword", &(((ns1__UserT*)a)->loginPassword), "xsd:string"))
				{	soap_flag_loginPassword1--;
					continue;
				}
			if (soap_flag_isActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToshort(soap, "isActive", &(((ns1__UserT*)a)->isActive), "xsd:short"))
				{	soap_flag_isActive1--;
					continue;
				}
			if (soap_flag_roleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "roleName", &(((ns1__UserT*)a)->roleName), "xsd:string"))
				{	soap_flag_roleName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_userId1 > 0 || soap_flag_firstName1 > 0 || soap_flag_lastName1 > 0 || soap_flag_location1 > 0 || soap_flag_loginName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UserT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserT, 0, sizeof(ns1__UserT), 0, soap_copy_ns1__UserT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__UserT * SOAP_FMAC6 soap_new_ns1__UserT(struct soap *soap, int n)
{	return soap_instantiate_ns1__UserT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UserT(struct soap *soap, ns1__UserT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__UserT * SOAP_FMAC4 soap_instantiate_ns1__UserT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UserT;
		if (size)
			*size = sizeof(ns1__UserT);
		((ns1__UserT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UserT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UserT);
		for (int i = 0; i < n; i++)
			((ns1__UserT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UserT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UserT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UserT %p -> %p\n", q, p));
	*(ns1__UserT*)p = *(ns1__UserT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfRoleT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfRoleT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfRoleT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__RoleT(soap, this->__ptr + i);
		}
}

int ArrayOfRoleT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfRoleT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfRoleT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfRoleT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfRoleT(struct soap *soap, const char *tag, int id, const ArrayOfRoleT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:RoleT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfRoleT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__RoleT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfRoleT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfRoleT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfRoleT * SOAP_FMAC4 soap_get_ArrayOfRoleT(struct soap *soap, ArrayOfRoleT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfRoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfRoleT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfRoleT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfRoleT * SOAP_FMAC4 soap_in_ArrayOfRoleT(struct soap *soap, const char *tag, ArrayOfRoleT *a, const char *type)
{	int i, j;
	ns1__RoleT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfRoleT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRoleT, sizeof(ArrayOfRoleT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__RoleT **)soap_malloc(soap, sizeof(ns1__RoleT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__RoleT(soap, NULL, a->__ptr + i, "ns1:RoleT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__RoleT **)soap_push_block(soap, sizeof(ns1__RoleT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__RoleT(soap, NULL, p, "ns1:RoleT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__RoleT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfRoleT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfRoleT, 0, sizeof(ArrayOfRoleT), 0, soap_copy_ArrayOfRoleT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfRoleT * SOAP_FMAC6 soap_new_ArrayOfRoleT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfRoleT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfRoleT(struct soap *soap, ArrayOfRoleT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfRoleT * SOAP_FMAC4 soap_instantiate_ArrayOfRoleT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfRoleT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfRoleT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfRoleT;
		if (size)
			*size = sizeof(ArrayOfRoleT);
		((ArrayOfRoleT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfRoleT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfRoleT);
		for (int i = 0; i < n; i++)
			((ArrayOfRoleT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfRoleT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfRoleT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfRoleT %p -> %p\n", q, p));
	*(ArrayOfRoleT*)p = *(ArrayOfRoleT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__RoleT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__RoleT*)this)->roleName);
	((ns1__RoleT*)this)->domains = NULL;
	/* transient soap skipped */
}

void ns1__RoleT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__RoleT*)this)->roleName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__RoleT*)this)->roleName);
	soap_serialize_PointerToArrayOfApplicationDomainT(soap, &((ns1__RoleT*)this)->domains);
	/* transient soap skipped */
}

int ns1__RoleT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RoleT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__RoleT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RoleT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RoleT(struct soap *soap, const char *tag, int id, const ns1__RoleT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RoleT), type);
	soap_out_std__string(soap, "roleName", -1, &(((ns1__RoleT*)a)->roleName), "");
	soap_out_PointerToArrayOfApplicationDomainT(soap, "domains", -1, &(((ns1__RoleT*)a)->domains), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RoleT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RoleT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RoleT * SOAP_FMAC4 soap_get_ns1__RoleT(struct soap *soap, ns1__RoleT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RoleT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RoleT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RoleT * SOAP_FMAC4 soap_in_ns1__RoleT(struct soap *soap, const char *tag, ns1__RoleT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RoleT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RoleT, sizeof(ns1__RoleT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RoleT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RoleT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_roleName1 = 1, soap_flag_domains1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roleName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "roleName", &(((ns1__RoleT*)a)->roleName), "xsd:string"))
				{	soap_flag_roleName1--;
					continue;
				}
			if (soap_flag_domains1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfApplicationDomainT(soap, "domains", &(((ns1__RoleT*)a)->domains), "ns1:ApplicationDomainT"))
				{	soap_flag_domains1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roleName1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RoleT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RoleT, 0, sizeof(ns1__RoleT), 0, soap_copy_ns1__RoleT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RoleT * SOAP_FMAC6 soap_new_ns1__RoleT(struct soap *soap, int n)
{	return soap_instantiate_ns1__RoleT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RoleT(struct soap *soap, ns1__RoleT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__RoleT * SOAP_FMAC4 soap_instantiate_ns1__RoleT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RoleT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RoleT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RoleT;
		if (size)
			*size = sizeof(ns1__RoleT);
		((ns1__RoleT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RoleT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RoleT);
		for (int i = 0; i < n; i++)
			((ns1__RoleT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RoleT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RoleT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RoleT %p -> %p\n", q, p));
	*(ns1__RoleT*)p = *(ns1__RoleT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfApplicationDomainT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfApplicationDomainT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfApplicationDomainT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ApplicationDomainT(soap, this->__ptr + i);
		}
}

int ArrayOfApplicationDomainT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfApplicationDomainT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfApplicationDomainT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfApplicationDomainT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfApplicationDomainT(struct soap *soap, const char *tag, int id, const ArrayOfApplicationDomainT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ApplicationDomainT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfApplicationDomainT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ApplicationDomainT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfApplicationDomainT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfApplicationDomainT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfApplicationDomainT * SOAP_FMAC4 soap_get_ArrayOfApplicationDomainT(struct soap *soap, ArrayOfApplicationDomainT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfApplicationDomainT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfApplicationDomainT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfApplicationDomainT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfApplicationDomainT * SOAP_FMAC4 soap_in_ArrayOfApplicationDomainT(struct soap *soap, const char *tag, ArrayOfApplicationDomainT *a, const char *type)
{	int i, j;
	ns1__ApplicationDomainT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfApplicationDomainT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfApplicationDomainT, sizeof(ArrayOfApplicationDomainT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ApplicationDomainT **)soap_malloc(soap, sizeof(ns1__ApplicationDomainT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ApplicationDomainT(soap, NULL, a->__ptr + i, "ns1:ApplicationDomainT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ApplicationDomainT **)soap_push_block(soap, sizeof(ns1__ApplicationDomainT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ApplicationDomainT(soap, NULL, p, "ns1:ApplicationDomainT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__ApplicationDomainT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfApplicationDomainT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfApplicationDomainT, 0, sizeof(ArrayOfApplicationDomainT), 0, soap_copy_ArrayOfApplicationDomainT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfApplicationDomainT * SOAP_FMAC6 soap_new_ArrayOfApplicationDomainT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfApplicationDomainT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfApplicationDomainT(struct soap *soap, ArrayOfApplicationDomainT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfApplicationDomainT * SOAP_FMAC4 soap_instantiate_ArrayOfApplicationDomainT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfApplicationDomainT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfApplicationDomainT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfApplicationDomainT;
		if (size)
			*size = sizeof(ArrayOfApplicationDomainT);
		((ArrayOfApplicationDomainT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfApplicationDomainT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfApplicationDomainT);
		for (int i = 0; i < n; i++)
			((ArrayOfApplicationDomainT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfApplicationDomainT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfApplicationDomainT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfApplicationDomainT %p -> %p\n", q, p));
	*(ArrayOfApplicationDomainT*)p = *(ArrayOfApplicationDomainT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ApplicationDomainT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__ApplicationDomainTypeT(soap, &((ns1__ApplicationDomainT*)this)->type);
	((ns1__ApplicationDomainT*)this)->accessRights = NULL;
	/* transient soap skipped */
}

void ns1__ApplicationDomainT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfUserAccessT(soap, &((ns1__ApplicationDomainT*)this)->accessRights);
	/* transient soap skipped */
}

int ns1__ApplicationDomainT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ApplicationDomainT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ApplicationDomainT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ApplicationDomainT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ApplicationDomainT(struct soap *soap, const char *tag, int id, const ns1__ApplicationDomainT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ApplicationDomainT), type);
	soap_out_ns1__ApplicationDomainTypeT(soap, "type", -1, &(((ns1__ApplicationDomainT*)a)->type), "");
	soap_out_PointerToArrayOfUserAccessT(soap, "accessRights", -1, &(((ns1__ApplicationDomainT*)a)->accessRights), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ApplicationDomainT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ApplicationDomainT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ApplicationDomainT * SOAP_FMAC4 soap_get_ns1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ApplicationDomainT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ApplicationDomainT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ApplicationDomainT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ApplicationDomainT * SOAP_FMAC4 soap_in_ns1__ApplicationDomainT(struct soap *soap, const char *tag, ns1__ApplicationDomainT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ApplicationDomainT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ApplicationDomainT, sizeof(ns1__ApplicationDomainT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ApplicationDomainT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ApplicationDomainT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_type1 = 1, soap_flag_accessRights1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ApplicationDomainTypeT(soap, "type", &(((ns1__ApplicationDomainT*)a)->type), "ns1:ApplicationDomainTypeT"))
				{	soap_flag_type1--;
					continue;
				}
			if (soap_flag_accessRights1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfUserAccessT(soap, "accessRights", &(((ns1__ApplicationDomainT*)a)->accessRights), "ns1:UserAccessT"))
				{	soap_flag_accessRights1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ApplicationDomainT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ApplicationDomainT, 0, sizeof(ns1__ApplicationDomainT), 0, soap_copy_ns1__ApplicationDomainT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ApplicationDomainT * SOAP_FMAC6 soap_new_ns1__ApplicationDomainT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ApplicationDomainT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ApplicationDomainT * SOAP_FMAC4 soap_instantiate_ns1__ApplicationDomainT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ApplicationDomainT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ApplicationDomainT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ApplicationDomainT;
		if (size)
			*size = sizeof(ns1__ApplicationDomainT);
		((ns1__ApplicationDomainT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ApplicationDomainT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ApplicationDomainT);
		for (int i = 0; i < n; i++)
			((ns1__ApplicationDomainT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ApplicationDomainT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ApplicationDomainT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ApplicationDomainT %p -> %p\n", q, p));
	*(ns1__ApplicationDomainT*)p = *(ns1__ApplicationDomainT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfUserAccessT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfUserAccessT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfUserAccessT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__UserAccessT(soap, this->__ptr + i);
		}
}

int ArrayOfUserAccessT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfUserAccessT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfUserAccessT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfUserAccessT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfUserAccessT(struct soap *soap, const char *tag, int id, const ArrayOfUserAccessT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:UserAccessT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfUserAccessT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__UserAccessT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfUserAccessT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfUserAccessT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfUserAccessT * SOAP_FMAC4 soap_get_ArrayOfUserAccessT(struct soap *soap, ArrayOfUserAccessT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfUserAccessT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfUserAccessT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfUserAccessT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfUserAccessT * SOAP_FMAC4 soap_in_ArrayOfUserAccessT(struct soap *soap, const char *tag, ArrayOfUserAccessT *a, const char *type)
{	int i, j;
	ns1__UserAccessT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfUserAccessT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfUserAccessT, sizeof(ArrayOfUserAccessT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__UserAccessT **)soap_malloc(soap, sizeof(ns1__UserAccessT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__UserAccessT(soap, NULL, a->__ptr + i, "ns1:UserAccessT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__UserAccessT **)soap_push_block(soap, sizeof(ns1__UserAccessT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__UserAccessT(soap, NULL, p, "ns1:UserAccessT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__UserAccessT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfUserAccessT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfUserAccessT, 0, sizeof(ArrayOfUserAccessT), 0, soap_copy_ArrayOfUserAccessT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfUserAccessT * SOAP_FMAC6 soap_new_ArrayOfUserAccessT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfUserAccessT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfUserAccessT(struct soap *soap, ArrayOfUserAccessT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfUserAccessT * SOAP_FMAC4 soap_instantiate_ArrayOfUserAccessT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfUserAccessT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfUserAccessT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfUserAccessT;
		if (size)
			*size = sizeof(ArrayOfUserAccessT);
		((ArrayOfUserAccessT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfUserAccessT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfUserAccessT);
		for (int i = 0; i < n; i++)
			((ArrayOfUserAccessT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfUserAccessT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfUserAccessT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfUserAccessT %p -> %p\n", q, p));
	*(ArrayOfUserAccessT*)p = *(ArrayOfUserAccessT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__UserAccessT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__UserAccessTypeT(soap, &((ns1__UserAccessT*)this)->type);
	/* transient soap skipped */
}

void ns1__UserAccessT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	/* transient soap skipped */
}

int ns1__UserAccessT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__UserAccessT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__UserAccessT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__UserAccessT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__UserAccessT(struct soap *soap, const char *tag, int id, const ns1__UserAccessT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__UserAccessT), type);
	soap_out_ns1__UserAccessTypeT(soap, "type", -1, &(((ns1__UserAccessT*)a)->type), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__UserAccessT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__UserAccessT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__UserAccessT * SOAP_FMAC4 soap_get_ns1__UserAccessT(struct soap *soap, ns1__UserAccessT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__UserAccessT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__UserAccessT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__UserAccessT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__UserAccessT * SOAP_FMAC4 soap_in_ns1__UserAccessT(struct soap *soap, const char *tag, ns1__UserAccessT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__UserAccessT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__UserAccessT, sizeof(ns1__UserAccessT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__UserAccessT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__UserAccessT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_type1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_type1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__UserAccessTypeT(soap, "type", &(((ns1__UserAccessT*)a)->type), "ns1:UserAccessTypeT"))
				{	soap_flag_type1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_type1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__UserAccessT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__UserAccessT, 0, sizeof(ns1__UserAccessT), 0, soap_copy_ns1__UserAccessT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__UserAccessT * SOAP_FMAC6 soap_new_ns1__UserAccessT(struct soap *soap, int n)
{	return soap_instantiate_ns1__UserAccessT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__UserAccessT(struct soap *soap, ns1__UserAccessT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__UserAccessT * SOAP_FMAC4 soap_instantiate_ns1__UserAccessT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__UserAccessT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__UserAccessT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__UserAccessT;
		if (size)
			*size = sizeof(ns1__UserAccessT);
		((ns1__UserAccessT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__UserAccessT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__UserAccessT);
		for (int i = 0; i < n; i++)
			((ns1__UserAccessT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__UserAccessT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__UserAccessT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__UserAccessT %p -> %p\n", q, p));
	*(ns1__UserAccessT*)p = *(ns1__UserAccessT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CMSResultT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CMSResultT*)this)->line1 = NULL;
	((ns1__CMSResultT*)this)->line2 = NULL;
	/* transient soap skipped */
}

void ns1__CMSResultT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CMSLineT(soap, &((ns1__CMSResultT*)this)->line1);
	soap_serialize_PointerTons1__CMSLineT(soap, &((ns1__CMSResultT*)this)->line2);
	/* transient soap skipped */
}

int ns1__CMSResultT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CMSResultT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CMSResultT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CMSResultT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CMSResultT(struct soap *soap, const char *tag, int id, const ns1__CMSResultT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CMSResultT), type);
	soap_out_PointerTons1__CMSLineT(soap, "line1", -1, &(((ns1__CMSResultT*)a)->line1), "");
	soap_out_PointerTons1__CMSLineT(soap, "line2", -1, &(((ns1__CMSResultT*)a)->line2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CMSResultT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CMSResultT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CMSResultT * SOAP_FMAC4 soap_get_ns1__CMSResultT(struct soap *soap, ns1__CMSResultT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CMSResultT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CMSResultT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CMSResultT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CMSResultT * SOAP_FMAC4 soap_in_ns1__CMSResultT(struct soap *soap, const char *tag, ns1__CMSResultT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CMSResultT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CMSResultT, sizeof(ns1__CMSResultT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CMSResultT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CMSResultT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_line11 = 1, soap_flag_line21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_line11 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CMSLineT(soap, "line1", &(((ns1__CMSResultT*)a)->line1), "ns1:CMSLineT"))
				{	soap_flag_line11--;
					continue;
				}
			if (soap_flag_line21 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CMSLineT(soap, "line2", &(((ns1__CMSResultT*)a)->line2), "ns1:CMSLineT"))
				{	soap_flag_line21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_line11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CMSResultT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CMSResultT, 0, sizeof(ns1__CMSResultT), 0, soap_copy_ns1__CMSResultT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CMSResultT * SOAP_FMAC6 soap_new_ns1__CMSResultT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CMSResultT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CMSResultT(struct soap *soap, ns1__CMSResultT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CMSResultT * SOAP_FMAC4 soap_instantiate_ns1__CMSResultT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CMSResultT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CMSResultT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CMSResultT;
		if (size)
			*size = sizeof(ns1__CMSResultT);
		((ns1__CMSResultT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CMSResultT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CMSResultT);
		for (int i = 0; i < n; i++)
			((ns1__CMSResultT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CMSResultT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CMSResultT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CMSResultT %p -> %p\n", q, p));
	*(ns1__CMSResultT*)p = *(ns1__CMSResultT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCMSLineT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCMSLineT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCMSLineT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CMSLineT(soap, this->__ptr + i);
		}
}

int ArrayOfCMSLineT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCMSLineT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCMSLineT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCMSLineT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCMSLineT(struct soap *soap, const char *tag, int id, const ArrayOfCMSLineT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CMSLineT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCMSLineT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CMSLineT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCMSLineT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCMSLineT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCMSLineT * SOAP_FMAC4 soap_get_ArrayOfCMSLineT(struct soap *soap, ArrayOfCMSLineT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCMSLineT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCMSLineT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCMSLineT * SOAP_FMAC4 soap_in_ArrayOfCMSLineT(struct soap *soap, const char *tag, ArrayOfCMSLineT *a, const char *type)
{	int i, j;
	ns1__CMSLineT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCMSLineT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCMSLineT, sizeof(ArrayOfCMSLineT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CMSLineT **)soap_malloc(soap, sizeof(ns1__CMSLineT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CMSLineT(soap, NULL, a->__ptr + i, "ns1:CMSLineT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CMSLineT **)soap_push_block(soap, sizeof(ns1__CMSLineT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CMSLineT(soap, NULL, p, "ns1:CMSLineT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CMSLineT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCMSLineT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCMSLineT, 0, sizeof(ArrayOfCMSLineT), 0, soap_copy_ArrayOfCMSLineT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCMSLineT * SOAP_FMAC6 soap_new_ArrayOfCMSLineT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCMSLineT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCMSLineT(struct soap *soap, ArrayOfCMSLineT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCMSLineT * SOAP_FMAC4 soap_instantiate_ArrayOfCMSLineT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCMSLineT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCMSLineT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCMSLineT;
		if (size)
			*size = sizeof(ArrayOfCMSLineT);
		((ArrayOfCMSLineT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCMSLineT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCMSLineT);
		for (int i = 0; i < n; i++)
			((ArrayOfCMSLineT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCMSLineT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCMSLineT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCMSLineT %p -> %p\n", q, p));
	*(ArrayOfCMSLineT*)p = *(ArrayOfCMSLineT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CMSLineT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CMSLineT*)this)->number);
	soap_default_std__string(soap, &((ns1__CMSLineT*)this)->status);
	/* transient soap skipped */
}

void ns1__CMSLineT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CMSLineT*)this)->number, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CMSLineT*)this)->number);
	soap_embedded(soap, &((ns1__CMSLineT*)this)->status, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CMSLineT*)this)->status);
	/* transient soap skipped */
}

int ns1__CMSLineT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CMSLineT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CMSLineT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CMSLineT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CMSLineT(struct soap *soap, const char *tag, int id, const ns1__CMSLineT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CMSLineT), type);
	soap_out_std__string(soap, "number", -1, &(((ns1__CMSLineT*)a)->number), "");
	soap_out_std__string(soap, "status", -1, &(((ns1__CMSLineT*)a)->status), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CMSLineT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CMSLineT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CMSLineT * SOAP_FMAC4 soap_get_ns1__CMSLineT(struct soap *soap, ns1__CMSLineT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CMSLineT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CMSLineT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CMSLineT * SOAP_FMAC4 soap_in_ns1__CMSLineT(struct soap *soap, const char *tag, ns1__CMSLineT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CMSLineT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CMSLineT, sizeof(ns1__CMSLineT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CMSLineT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CMSLineT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_number1 = 1, soap_flag_status1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_number1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "number", &(((ns1__CMSLineT*)a)->number), "xsd:string"))
				{	soap_flag_number1--;
					continue;
				}
			if (soap_flag_status1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "status", &(((ns1__CMSLineT*)a)->status), "xsd:string"))
				{	soap_flag_status1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_number1 > 0 || soap_flag_status1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CMSLineT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CMSLineT, 0, sizeof(ns1__CMSLineT), 0, soap_copy_ns1__CMSLineT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CMSLineT * SOAP_FMAC6 soap_new_ns1__CMSLineT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CMSLineT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CMSLineT(struct soap *soap, ns1__CMSLineT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CMSLineT * SOAP_FMAC4 soap_instantiate_ns1__CMSLineT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CMSLineT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CMSLineT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CMSLineT;
		if (size)
			*size = sizeof(ns1__CMSLineT);
		((ns1__CMSLineT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CMSLineT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CMSLineT);
		for (int i = 0; i < n; i++)
			((ns1__CMSLineT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CMSLineT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CMSLineT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CMSLineT %p -> %p\n", q, p));
	*(ns1__CMSLineT*)p = *(ns1__CMSLineT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCTEQueryInputT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCTEQueryInputT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCTEQueryInputT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTEQueryInputT(soap, this->__ptr + i);
		}
}

int ArrayOfCTEQueryInputT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCTEQueryInputT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCTEQueryInputT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTEQueryInputT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTEQueryInputT(struct soap *soap, const char *tag, int id, const ArrayOfCTEQueryInputT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CTEQueryInputT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCTEQueryInputT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTEQueryInputT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCTEQueryInputT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTEQueryInputT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTEQueryInputT * SOAP_FMAC4 soap_get_ArrayOfCTEQueryInputT(struct soap *soap, ArrayOfCTEQueryInputT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCTEQueryInputT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTEQueryInputT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTEQueryInputT * SOAP_FMAC4 soap_in_ArrayOfCTEQueryInputT(struct soap *soap, const char *tag, ArrayOfCTEQueryInputT *a, const char *type)
{	int i, j;
	ns1__CTEQueryInputT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTEQueryInputT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTEQueryInputT, sizeof(ArrayOfCTEQueryInputT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CTEQueryInputT **)soap_malloc(soap, sizeof(ns1__CTEQueryInputT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTEQueryInputT(soap, NULL, a->__ptr + i, "ns1:CTEQueryInputT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTEQueryInputT **)soap_push_block(soap, sizeof(ns1__CTEQueryInputT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTEQueryInputT(soap, NULL, p, "ns1:CTEQueryInputT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CTEQueryInputT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTEQueryInputT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTEQueryInputT, 0, sizeof(ArrayOfCTEQueryInputT), 0, soap_copy_ArrayOfCTEQueryInputT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCTEQueryInputT * SOAP_FMAC6 soap_new_ArrayOfCTEQueryInputT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCTEQueryInputT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCTEQueryInputT(struct soap *soap, ArrayOfCTEQueryInputT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCTEQueryInputT * SOAP_FMAC4 soap_instantiate_ArrayOfCTEQueryInputT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTEQueryInputT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTEQueryInputT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCTEQueryInputT;
		if (size)
			*size = sizeof(ArrayOfCTEQueryInputT);
		((ArrayOfCTEQueryInputT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCTEQueryInputT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCTEQueryInputT);
		for (int i = 0; i < n; i++)
			((ArrayOfCTEQueryInputT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCTEQueryInputT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTEQueryInputT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTEQueryInputT %p -> %p\n", q, p));
	*(ArrayOfCTEQueryInputT*)p = *(ArrayOfCTEQueryInputT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEQueryInputT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CTEQueryInputT*)this)->accountNumber = NULL;
	((ns1__CTEQueryInputT*)this)->firstName = NULL;
	((ns1__CTEQueryInputT*)this)->lastName = NULL;
	((ns1__CTEQueryInputT*)this)->primaryPhone = NULL;
	((ns1__CTEQueryInputT*)this)->cmMac = NULL;
	/* transient soap skipped */
}

void ns1__CTEQueryInputT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->accountNumber);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->firstName);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->lastName);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->primaryPhone);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEQueryInputT*)this)->cmMac);
	/* transient soap skipped */
}

int ns1__CTEQueryInputT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEQueryInputT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEQueryInputT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEQueryInputT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEQueryInputT(struct soap *soap, const char *tag, int id, const ns1__CTEQueryInputT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEQueryInputT), type);
	soap_out_PointerTostd__string(soap, "accountNumber", -1, &(((ns1__CTEQueryInputT*)a)->accountNumber), "");
	soap_out_PointerTostd__string(soap, "firstName", -1, &(((ns1__CTEQueryInputT*)a)->firstName), "");
	soap_out_PointerTostd__string(soap, "lastName", -1, &(((ns1__CTEQueryInputT*)a)->lastName), "");
	soap_out_PointerTostd__string(soap, "primaryPhone", -1, &(((ns1__CTEQueryInputT*)a)->primaryPhone), "");
	soap_out_PointerTostd__string(soap, "cmMac", -1, &(((ns1__CTEQueryInputT*)a)->cmMac), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEQueryInputT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEQueryInputT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT * SOAP_FMAC4 soap_get_ns1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEQueryInputT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEQueryInputT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT * SOAP_FMAC4 soap_in_ns1__CTEQueryInputT(struct soap *soap, const char *tag, ns1__CTEQueryInputT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEQueryInputT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEQueryInputT, sizeof(ns1__CTEQueryInputT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEQueryInputT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEQueryInputT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accountNumber1 = 1, soap_flag_firstName1 = 1, soap_flag_lastName1 = 1, soap_flag_primaryPhone1 = 1, soap_flag_cmMac1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "accountNumber", &(((ns1__CTEQueryInputT*)a)->accountNumber), "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "firstName", &(((ns1__CTEQueryInputT*)a)->firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "lastName", &(((ns1__CTEQueryInputT*)a)->lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_primaryPhone1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "primaryPhone", &(((ns1__CTEQueryInputT*)a)->primaryPhone), "xsd:string"))
				{	soap_flag_primaryPhone1--;
					continue;
				}
			if (soap_flag_cmMac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "cmMac", &(((ns1__CTEQueryInputT*)a)->cmMac), "xsd:string"))
				{	soap_flag_cmMac1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEQueryInputT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEQueryInputT, 0, sizeof(ns1__CTEQueryInputT), 0, soap_copy_ns1__CTEQueryInputT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEQueryInputT * SOAP_FMAC6 soap_new_ns1__CTEQueryInputT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEQueryInputT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEQueryInputT * SOAP_FMAC4 soap_instantiate_ns1__CTEQueryInputT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEQueryInputT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEQueryInputT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEQueryInputT;
		if (size)
			*size = sizeof(ns1__CTEQueryInputT);
		((ns1__CTEQueryInputT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEQueryInputT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEQueryInputT);
		for (int i = 0; i < n; i++)
			((ns1__CTEQueryInputT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEQueryInputT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEQueryInputT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEQueryInputT %p -> %p\n", q, p));
	*(ns1__CTEQueryInputT*)p = *(ns1__CTEQueryInputT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCTEDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCTEDataT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCTEDataT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTEDataT(soap, this->__ptr + i);
		}
}

int ArrayOfCTEDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCTEDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCTEDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTEDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTEDataT(struct soap *soap, const char *tag, int id, const ArrayOfCTEDataT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CTEDataT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCTEDataT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTEDataT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCTEDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTEDataT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTEDataT * SOAP_FMAC4 soap_get_ArrayOfCTEDataT(struct soap *soap, ArrayOfCTEDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCTEDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTEDataT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTEDataT * SOAP_FMAC4 soap_in_ArrayOfCTEDataT(struct soap *soap, const char *tag, ArrayOfCTEDataT *a, const char *type)
{	int i, j;
	ns1__CTEDataT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTEDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTEDataT, sizeof(ArrayOfCTEDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CTEDataT **)soap_malloc(soap, sizeof(ns1__CTEDataT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTEDataT(soap, NULL, a->__ptr + i, "ns1:CTEDataT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTEDataT **)soap_push_block(soap, sizeof(ns1__CTEDataT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTEDataT(soap, NULL, p, "ns1:CTEDataT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CTEDataT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTEDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTEDataT, 0, sizeof(ArrayOfCTEDataT), 0, soap_copy_ArrayOfCTEDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCTEDataT * SOAP_FMAC6 soap_new_ArrayOfCTEDataT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCTEDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCTEDataT(struct soap *soap, ArrayOfCTEDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCTEDataT * SOAP_FMAC4 soap_instantiate_ArrayOfCTEDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTEDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTEDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCTEDataT;
		if (size)
			*size = sizeof(ArrayOfCTEDataT);
		((ArrayOfCTEDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCTEDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCTEDataT);
		for (int i = 0; i < n; i++)
			((ArrayOfCTEDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCTEDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTEDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTEDataT %p -> %p\n", q, p));
	*(ArrayOfCTEDataT*)p = *(ArrayOfCTEDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEDataT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CTEDataT*)this)->customer = NULL;
	((ns1__CTEDataT*)this)->cm = NULL;
	((ns1__CTEDataT*)this)->mta = NULL;
	((ns1__CTEDataT*)this)->cmts = NULL;
	((ns1__CTEDataT*)this)->cms = NULL;
	((ns1__CTEDataT*)this)->hfcName = NULL;
	/* transient soap skipped */
}

void ns1__CTEDataT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CTECustomerT(soap, &((ns1__CTEDataT*)this)->customer);
	soap_serialize_PointerTons1__CTEAbstractMacT(soap, &((ns1__CTEDataT*)this)->cm);
	soap_serialize_PointerTons1__CTEAbstractMacT(soap, &((ns1__CTEDataT*)this)->mta);
	soap_serialize_PointerTons1__CTEAbstractNameT(soap, &((ns1__CTEDataT*)this)->cmts);
	soap_serialize_PointerTons1__CTEAbstractNameT(soap, &((ns1__CTEDataT*)this)->cms);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEDataT*)this)->hfcName);
	/* transient soap skipped */
}

int ns1__CTEDataT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEDataT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEDataT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEDataT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEDataT(struct soap *soap, const char *tag, int id, const ns1__CTEDataT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEDataT), type);
	soap_out_PointerTons1__CTECustomerT(soap, "customer", -1, &(((ns1__CTEDataT*)a)->customer), "");
	soap_out_PointerTons1__CTEAbstractMacT(soap, "cm", -1, &(((ns1__CTEDataT*)a)->cm), "");
	soap_out_PointerTons1__CTEAbstractMacT(soap, "mta", -1, &(((ns1__CTEDataT*)a)->mta), "");
	soap_out_PointerTons1__CTEAbstractNameT(soap, "cmts", -1, &(((ns1__CTEDataT*)a)->cmts), "");
	soap_out_PointerTons1__CTEAbstractNameT(soap, "cms", -1, &(((ns1__CTEDataT*)a)->cms), "");
	soap_out_PointerTostd__string(soap, "hfcName", -1, &(((ns1__CTEDataT*)a)->hfcName), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEDataT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEDataT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEDataT * SOAP_FMAC4 soap_get_ns1__CTEDataT(struct soap *soap, ns1__CTEDataT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEDataT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEDataT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEDataT * SOAP_FMAC4 soap_in_ns1__CTEDataT(struct soap *soap, const char *tag, ns1__CTEDataT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEDataT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEDataT, sizeof(ns1__CTEDataT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEDataT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEDataT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_customer1 = 1, soap_flag_cm1 = 1, soap_flag_mta1 = 1, soap_flag_cmts1 = 1, soap_flag_cms1 = 1, soap_flag_hfcName1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_customer1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTECustomerT(soap, "customer", &(((ns1__CTEDataT*)a)->customer), "ns1:CTECustomerT"))
				{	soap_flag_customer1--;
					continue;
				}
			if (soap_flag_cm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractMacT(soap, "cm", &(((ns1__CTEDataT*)a)->cm), "ns1:CTEAbstractMacT"))
				{	soap_flag_cm1--;
					continue;
				}
			if (soap_flag_mta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractMacT(soap, "mta", &(((ns1__CTEDataT*)a)->mta), "ns1:CTEAbstractMacT"))
				{	soap_flag_mta1--;
					continue;
				}
			if (soap_flag_cmts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractNameT(soap, "cmts", &(((ns1__CTEDataT*)a)->cmts), "ns1:CTEAbstractNameT"))
				{	soap_flag_cmts1--;
					continue;
				}
			if (soap_flag_cms1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CTEAbstractNameT(soap, "cms", &(((ns1__CTEDataT*)a)->cms), "ns1:CTEAbstractNameT"))
				{	soap_flag_cms1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "hfcName", &(((ns1__CTEDataT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_customer1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEDataT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEDataT, 0, sizeof(ns1__CTEDataT), 0, soap_copy_ns1__CTEDataT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEDataT * SOAP_FMAC6 soap_new_ns1__CTEDataT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEDataT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEDataT(struct soap *soap, ns1__CTEDataT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEDataT * SOAP_FMAC4 soap_instantiate_ns1__CTEDataT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEDataT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEDataT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEDataT;
		if (size)
			*size = sizeof(ns1__CTEDataT);
		((ns1__CTEDataT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEDataT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEDataT);
		for (int i = 0; i < n; i++)
			((ns1__CTEDataT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEDataT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEDataT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEDataT %p -> %p\n", q, p));
	*(ns1__CTEDataT*)p = *(ns1__CTEDataT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEAbstractNameT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CTEAbstractNameT*)this)->name);
	((ns1__CTEAbstractNameT*)this)->fqdn = NULL;
	((ns1__CTEAbstractNameT*)this)->host = NULL;
	/* transient soap skipped */
}

void ns1__CTEAbstractNameT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CTEAbstractNameT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTEAbstractNameT*)this)->name);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEAbstractNameT*)this)->fqdn);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEAbstractNameT*)this)->host);
	/* transient soap skipped */
}

int ns1__CTEAbstractNameT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEAbstractNameT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEAbstractNameT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEAbstractNameT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEAbstractNameT(struct soap *soap, const char *tag, int id, const ns1__CTEAbstractNameT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEAbstractNameT), type);
	soap_out_std__string(soap, "name", -1, &(((ns1__CTEAbstractNameT*)a)->name), "");
	soap_out_PointerTostd__string(soap, "fqdn", -1, &(((ns1__CTEAbstractNameT*)a)->fqdn), "");
	soap_out_PointerTostd__string(soap, "host", -1, &(((ns1__CTEAbstractNameT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEAbstractNameT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEAbstractNameT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEAbstractNameT * SOAP_FMAC4 soap_get_ns1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEAbstractNameT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEAbstractNameT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEAbstractNameT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEAbstractNameT * SOAP_FMAC4 soap_in_ns1__CTEAbstractNameT(struct soap *soap, const char *tag, ns1__CTEAbstractNameT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEAbstractNameT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEAbstractNameT, sizeof(ns1__CTEAbstractNameT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEAbstractNameT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEAbstractNameT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_name1 = 1, soap_flag_fqdn1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__CTEAbstractNameT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_fqdn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "fqdn", &(((ns1__CTEAbstractNameT*)a)->fqdn), "xsd:string"))
				{	soap_flag_fqdn1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "host", &(((ns1__CTEAbstractNameT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_name1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractNameT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEAbstractNameT, 0, sizeof(ns1__CTEAbstractNameT), 0, soap_copy_ns1__CTEAbstractNameT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEAbstractNameT * SOAP_FMAC6 soap_new_ns1__CTEAbstractNameT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEAbstractNameT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEAbstractNameT * SOAP_FMAC4 soap_instantiate_ns1__CTEAbstractNameT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEAbstractNameT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEAbstractNameT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEAbstractNameT;
		if (size)
			*size = sizeof(ns1__CTEAbstractNameT);
		((ns1__CTEAbstractNameT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEAbstractNameT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEAbstractNameT);
		for (int i = 0; i < n; i++)
			((ns1__CTEAbstractNameT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEAbstractNameT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEAbstractNameT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEAbstractNameT %p -> %p\n", q, p));
	*(ns1__CTEAbstractNameT*)p = *(ns1__CTEAbstractNameT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTEAbstractMacT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__CTEAbstractMacT*)this)->mac);
	((ns1__CTEAbstractMacT*)this)->fqdn = NULL;
	((ns1__CTEAbstractMacT*)this)->host = NULL;
	/* transient soap skipped */
}

void ns1__CTEAbstractMacT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CTEAbstractMacT*)this)->mac, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTEAbstractMacT*)this)->mac);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEAbstractMacT*)this)->fqdn);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTEAbstractMacT*)this)->host);
	/* transient soap skipped */
}

int ns1__CTEAbstractMacT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTEAbstractMacT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTEAbstractMacT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTEAbstractMacT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTEAbstractMacT(struct soap *soap, const char *tag, int id, const ns1__CTEAbstractMacT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTEAbstractMacT), type);
	soap_out_std__string(soap, "mac", -1, &(((ns1__CTEAbstractMacT*)a)->mac), "");
	soap_out_PointerTostd__string(soap, "fqdn", -1, &(((ns1__CTEAbstractMacT*)a)->fqdn), "");
	soap_out_PointerTostd__string(soap, "host", -1, &(((ns1__CTEAbstractMacT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTEAbstractMacT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTEAbstractMacT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTEAbstractMacT * SOAP_FMAC4 soap_get_ns1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTEAbstractMacT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTEAbstractMacT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTEAbstractMacT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTEAbstractMacT * SOAP_FMAC4 soap_in_ns1__CTEAbstractMacT(struct soap *soap, const char *tag, ns1__CTEAbstractMacT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTEAbstractMacT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTEAbstractMacT, sizeof(ns1__CTEAbstractMacT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTEAbstractMacT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTEAbstractMacT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_mac1 = 1, soap_flag_fqdn1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_mac1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "mac", &(((ns1__CTEAbstractMacT*)a)->mac), "xsd:string"))
				{	soap_flag_mac1--;
					continue;
				}
			if (soap_flag_fqdn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "fqdn", &(((ns1__CTEAbstractMacT*)a)->fqdn), "xsd:string"))
				{	soap_flag_fqdn1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "host", &(((ns1__CTEAbstractMacT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_mac1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractMacT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTEAbstractMacT, 0, sizeof(ns1__CTEAbstractMacT), 0, soap_copy_ns1__CTEAbstractMacT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTEAbstractMacT * SOAP_FMAC6 soap_new_ns1__CTEAbstractMacT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTEAbstractMacT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTEAbstractMacT * SOAP_FMAC4 soap_instantiate_ns1__CTEAbstractMacT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTEAbstractMacT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTEAbstractMacT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTEAbstractMacT;
		if (size)
			*size = sizeof(ns1__CTEAbstractMacT);
		((ns1__CTEAbstractMacT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTEAbstractMacT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTEAbstractMacT);
		for (int i = 0; i < n; i++)
			((ns1__CTEAbstractMacT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTEAbstractMacT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTEAbstractMacT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTEAbstractMacT %p -> %p\n", q, p));
	*(ns1__CTEAbstractMacT*)p = *(ns1__CTEAbstractMacT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCTECustomerT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCTECustomerT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCTECustomerT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CTECustomerT(soap, this->__ptr + i);
		}
}

int ArrayOfCTECustomerT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCTECustomerT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCTECustomerT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCTECustomerT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCTECustomerT(struct soap *soap, const char *tag, int id, const ArrayOfCTECustomerT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CTECustomerT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCTECustomerT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CTECustomerT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCTECustomerT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCTECustomerT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCTECustomerT * SOAP_FMAC4 soap_get_ArrayOfCTECustomerT(struct soap *soap, ArrayOfCTECustomerT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCTECustomerT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCTECustomerT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCTECustomerT * SOAP_FMAC4 soap_in_ArrayOfCTECustomerT(struct soap *soap, const char *tag, ArrayOfCTECustomerT *a, const char *type)
{	int i, j;
	ns1__CTECustomerT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCTECustomerT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCTECustomerT, sizeof(ArrayOfCTECustomerT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CTECustomerT **)soap_malloc(soap, sizeof(ns1__CTECustomerT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CTECustomerT(soap, NULL, a->__ptr + i, "ns1:CTECustomerT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CTECustomerT **)soap_push_block(soap, sizeof(ns1__CTECustomerT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CTECustomerT(soap, NULL, p, "ns1:CTECustomerT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CTECustomerT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCTECustomerT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCTECustomerT, 0, sizeof(ArrayOfCTECustomerT), 0, soap_copy_ArrayOfCTECustomerT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCTECustomerT * SOAP_FMAC6 soap_new_ArrayOfCTECustomerT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCTECustomerT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCTECustomerT(struct soap *soap, ArrayOfCTECustomerT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCTECustomerT * SOAP_FMAC4 soap_instantiate_ArrayOfCTECustomerT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCTECustomerT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCTECustomerT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCTECustomerT;
		if (size)
			*size = sizeof(ArrayOfCTECustomerT);
		((ArrayOfCTECustomerT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCTECustomerT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCTECustomerT);
		for (int i = 0; i < n; i++)
			((ArrayOfCTECustomerT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCTECustomerT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCTECustomerT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCTECustomerT %p -> %p\n", q, p));
	*(ArrayOfCTECustomerT*)p = *(ArrayOfCTECustomerT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CTECustomerT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CTECustomerT*)this)->accountNumber = NULL;
	((ns1__CTECustomerT*)this)->accountActive = NULL;
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->firstName);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->lastName);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->street1);
	((ns1__CTECustomerT*)this)->street2 = NULL;
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->city);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->state);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->zip);
	soap_default_std__string(soap, &((ns1__CTECustomerT*)this)->phone1);
	((ns1__CTECustomerT*)this)->phone2 = NULL;
	/* transient soap skipped */
}

void ns1__CTECustomerT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTostd__string(soap, &((ns1__CTECustomerT*)this)->accountNumber);
	soap_serialize_PointerToshort(soap, &((ns1__CTECustomerT*)this)->accountActive);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->firstName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->firstName);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->lastName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->lastName);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->street1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->street1);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTECustomerT*)this)->street2);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->city, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->city);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->state, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->state);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->zip, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->zip);
	soap_embedded(soap, &((ns1__CTECustomerT*)this)->phone1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CTECustomerT*)this)->phone1);
	soap_serialize_PointerTostd__string(soap, &((ns1__CTECustomerT*)this)->phone2);
	/* transient soap skipped */
}

int ns1__CTECustomerT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CTECustomerT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CTECustomerT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CTECustomerT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CTECustomerT(struct soap *soap, const char *tag, int id, const ns1__CTECustomerT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CTECustomerT), type);
	soap_out_PointerTostd__string(soap, "accountNumber", -1, &(((ns1__CTECustomerT*)a)->accountNumber), "");
	soap_out_PointerToshort(soap, "accountActive", -1, &(((ns1__CTECustomerT*)a)->accountActive), "");
	soap_out_std__string(soap, "firstName", -1, &(((ns1__CTECustomerT*)a)->firstName), "");
	soap_out_std__string(soap, "lastName", -1, &(((ns1__CTECustomerT*)a)->lastName), "");
	soap_out_std__string(soap, "street1", -1, &(((ns1__CTECustomerT*)a)->street1), "");
	soap_out_PointerTostd__string(soap, "street2", -1, &(((ns1__CTECustomerT*)a)->street2), "");
	soap_out_std__string(soap, "city", -1, &(((ns1__CTECustomerT*)a)->city), "");
	soap_out_std__string(soap, "state", -1, &(((ns1__CTECustomerT*)a)->state), "");
	soap_out_std__string(soap, "zip", -1, &(((ns1__CTECustomerT*)a)->zip), "");
	soap_out_std__string(soap, "phone1", -1, &(((ns1__CTECustomerT*)a)->phone1), "");
	soap_out_PointerTostd__string(soap, "phone2", -1, &(((ns1__CTECustomerT*)a)->phone2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CTECustomerT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CTECustomerT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CTECustomerT * SOAP_FMAC4 soap_get_ns1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CTECustomerT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CTECustomerT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CTECustomerT * SOAP_FMAC4 soap_in_ns1__CTECustomerT(struct soap *soap, const char *tag, ns1__CTECustomerT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CTECustomerT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CTECustomerT, sizeof(ns1__CTECustomerT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CTECustomerT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CTECustomerT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_accountNumber1 = 1, soap_flag_accountActive1 = 1, soap_flag_firstName1 = 1, soap_flag_lastName1 = 1, soap_flag_street11 = 1, soap_flag_street21 = 1, soap_flag_city1 = 1, soap_flag_state1 = 1, soap_flag_zip1 = 1, soap_flag_phone11 = 1, soap_flag_phone21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_accountNumber1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "accountNumber", &(((ns1__CTECustomerT*)a)->accountNumber), "xsd:string"))
				{	soap_flag_accountNumber1--;
					continue;
				}
			if (soap_flag_accountActive1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToshort(soap, "accountActive", &(((ns1__CTECustomerT*)a)->accountActive), "xsd:short"))
				{	soap_flag_accountActive1--;
					continue;
				}
			if (soap_flag_firstName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "firstName", &(((ns1__CTECustomerT*)a)->firstName), "xsd:string"))
				{	soap_flag_firstName1--;
					continue;
				}
			if (soap_flag_lastName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "lastName", &(((ns1__CTECustomerT*)a)->lastName), "xsd:string"))
				{	soap_flag_lastName1--;
					continue;
				}
			if (soap_flag_street11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "street1", &(((ns1__CTECustomerT*)a)->street1), "xsd:string"))
				{	soap_flag_street11--;
					continue;
				}
			if (soap_flag_street21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "street2", &(((ns1__CTECustomerT*)a)->street2), "xsd:string"))
				{	soap_flag_street21--;
					continue;
				}
			if (soap_flag_city1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "city", &(((ns1__CTECustomerT*)a)->city), "xsd:string"))
				{	soap_flag_city1--;
					continue;
				}
			if (soap_flag_state1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "state", &(((ns1__CTECustomerT*)a)->state), "xsd:string"))
				{	soap_flag_state1--;
					continue;
				}
			if (soap_flag_zip1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "zip", &(((ns1__CTECustomerT*)a)->zip), "xsd:string"))
				{	soap_flag_zip1--;
					continue;
				}
			if (soap_flag_phone11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "phone1", &(((ns1__CTECustomerT*)a)->phone1), "xsd:string"))
				{	soap_flag_phone11--;
					continue;
				}
			if (soap_flag_phone21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "phone2", &(((ns1__CTECustomerT*)a)->phone2), "xsd:string"))
				{	soap_flag_phone21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_firstName1 > 0 || soap_flag_lastName1 > 0 || soap_flag_street11 > 0 || soap_flag_city1 > 0 || soap_flag_state1 > 0 || soap_flag_zip1 > 0 || soap_flag_phone11 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CTECustomerT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CTECustomerT, 0, sizeof(ns1__CTECustomerT), 0, soap_copy_ns1__CTECustomerT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CTECustomerT * SOAP_FMAC6 soap_new_ns1__CTECustomerT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CTECustomerT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CTECustomerT * SOAP_FMAC4 soap_instantiate_ns1__CTECustomerT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CTECustomerT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CTECustomerT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CTECustomerT;
		if (size)
			*size = sizeof(ns1__CTECustomerT);
		((ns1__CTECustomerT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CTECustomerT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CTECustomerT);
		for (int i = 0; i < n; i++)
			((ns1__CTECustomerT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CTECustomerT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CTECustomerT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CTECustomerT %p -> %p\n", q, p));
	*(ns1__CTECustomerT*)p = *(ns1__CTECustomerT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmPerformanceHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmPerformanceHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmPerformanceHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmPerformanceHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfCmPerformanceHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmPerformanceHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmPerformanceHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmPerformanceHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmPerformanceHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfCmPerformanceHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmPerformanceHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmPerformanceHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmPerformanceHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmPerformanceHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmPerformanceHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmPerformanceHistoryT * SOAP_FMAC4 soap_get_ArrayOfCmPerformanceHistoryT(struct soap *soap, ArrayOfCmPerformanceHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmPerformanceHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmPerformanceHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmPerformanceHistoryT * SOAP_FMAC4 soap_in_ArrayOfCmPerformanceHistoryT(struct soap *soap, const char *tag, ArrayOfCmPerformanceHistoryT *a, const char *type)
{	int i, j;
	ns1__CmPerformanceHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmPerformanceHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmPerformanceHistoryT, sizeof(ArrayOfCmPerformanceHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmPerformanceHistoryT **)soap_malloc(soap, sizeof(ns1__CmPerformanceHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmPerformanceHistoryT(soap, NULL, a->__ptr + i, "ns1:CmPerformanceHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmPerformanceHistoryT **)soap_push_block(soap, sizeof(ns1__CmPerformanceHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmPerformanceHistoryT(soap, NULL, p, "ns1:CmPerformanceHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmPerformanceHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmPerformanceHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmPerformanceHistoryT, 0, sizeof(ArrayOfCmPerformanceHistoryT), 0, soap_copy_ArrayOfCmPerformanceHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmPerformanceHistoryT * SOAP_FMAC6 soap_new_ArrayOfCmPerformanceHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmPerformanceHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmPerformanceHistoryT(struct soap *soap, ArrayOfCmPerformanceHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmPerformanceHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfCmPerformanceHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmPerformanceHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmPerformanceHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmPerformanceHistoryT;
		if (size)
			*size = sizeof(ArrayOfCmPerformanceHistoryT);
		((ArrayOfCmPerformanceHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmPerformanceHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmPerformanceHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmPerformanceHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmPerformanceHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmPerformanceHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmPerformanceHistoryT %p -> %p\n", q, p));
	*(ArrayOfCmPerformanceHistoryT*)p = *(ArrayOfCmPerformanceHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmCurrentPerformanceT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmCurrentPerformanceT*)this)->cmPerformance = NULL;
	soap_default_std__string(soap, &((ns1__CmCurrentPerformanceT*)this)->recordedTime);
	/* transient soap skipped */
}

void ns1__CmCurrentPerformanceT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmPerformanceT(soap, &((ns1__CmCurrentPerformanceT*)this)->cmPerformance);
	soap_embedded(soap, &((ns1__CmCurrentPerformanceT*)this)->recordedTime, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmCurrentPerformanceT*)this)->recordedTime);
	/* transient soap skipped */
}

int ns1__CmCurrentPerformanceT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmCurrentPerformanceT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmCurrentPerformanceT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmCurrentPerformanceT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmCurrentPerformanceT(struct soap *soap, const char *tag, int id, const ns1__CmCurrentPerformanceT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmCurrentPerformanceT), type);
	soap_out_PointerTons1__CmPerformanceT(soap, "cmPerformance", -1, &(((ns1__CmCurrentPerformanceT*)a)->cmPerformance), "");
	soap_out_std__string(soap, "recordedTime", -1, &(((ns1__CmCurrentPerformanceT*)a)->recordedTime), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmCurrentPerformanceT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmCurrentPerformanceT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmCurrentPerformanceT * SOAP_FMAC4 soap_get_ns1__CmCurrentPerformanceT(struct soap *soap, ns1__CmCurrentPerformanceT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmCurrentPerformanceT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmCurrentPerformanceT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmCurrentPerformanceT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmCurrentPerformanceT * SOAP_FMAC4 soap_in_ns1__CmCurrentPerformanceT(struct soap *soap, const char *tag, ns1__CmCurrentPerformanceT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmCurrentPerformanceT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmCurrentPerformanceT, sizeof(ns1__CmCurrentPerformanceT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmCurrentPerformanceT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmCurrentPerformanceT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmPerformance1 = 1, soap_flag_recordedTime1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmPerformance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmPerformanceT(soap, "cmPerformance", &(((ns1__CmCurrentPerformanceT*)a)->cmPerformance), "ns1:CmPerformanceT"))
				{	soap_flag_cmPerformance1--;
					continue;
				}
			if (soap_flag_recordedTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "recordedTime", &(((ns1__CmCurrentPerformanceT*)a)->recordedTime), "xsd:string"))
				{	soap_flag_recordedTime1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmPerformance1 > 0 || soap_flag_recordedTime1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmCurrentPerformanceT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmCurrentPerformanceT, 0, sizeof(ns1__CmCurrentPerformanceT), 0, soap_copy_ns1__CmCurrentPerformanceT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmCurrentPerformanceT * SOAP_FMAC6 soap_new_ns1__CmCurrentPerformanceT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmCurrentPerformanceT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmCurrentPerformanceT(struct soap *soap, ns1__CmCurrentPerformanceT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmCurrentPerformanceT * SOAP_FMAC4 soap_instantiate_ns1__CmCurrentPerformanceT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmCurrentPerformanceT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmCurrentPerformanceT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmCurrentPerformanceT;
		if (size)
			*size = sizeof(ns1__CmCurrentPerformanceT);
		((ns1__CmCurrentPerformanceT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmCurrentPerformanceT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmCurrentPerformanceT);
		for (int i = 0; i < n; i++)
			((ns1__CmCurrentPerformanceT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmCurrentPerformanceT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmCurrentPerformanceT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmCurrentPerformanceT %p -> %p\n", q, p));
	*(ns1__CmCurrentPerformanceT*)p = *(ns1__CmCurrentPerformanceT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmPerformanceHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmPerformanceHistoryT*)this)->cmPerformance = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmPerformanceHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__CmPerformanceHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmPerformanceT(soap, &((ns1__CmPerformanceHistoryT*)this)->cmPerformance);
	soap_embedded(soap, &((ns1__CmPerformanceHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmPerformanceHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__CmPerformanceHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmPerformanceHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmPerformanceHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmPerformanceHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmPerformanceHistoryT(struct soap *soap, const char *tag, int id, const ns1__CmPerformanceHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmPerformanceHistoryT), type);
	soap_out_PointerTons1__CmPerformanceT(soap, "cmPerformance", -1, &(((ns1__CmPerformanceHistoryT*)a)->cmPerformance), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__CmPerformanceHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmPerformanceHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmPerformanceHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT * SOAP_FMAC4 soap_get_ns1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmPerformanceHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmPerformanceHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT * SOAP_FMAC4 soap_in_ns1__CmPerformanceHistoryT(struct soap *soap, const char *tag, ns1__CmPerformanceHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmPerformanceHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmPerformanceHistoryT, sizeof(ns1__CmPerformanceHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmPerformanceHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmPerformanceHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmPerformance1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmPerformance1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmPerformanceT(soap, "cmPerformance", &(((ns1__CmPerformanceHistoryT*)a)->cmPerformance), "ns1:CmPerformanceT"))
				{	soap_flag_cmPerformance1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__CmPerformanceHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmPerformance1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmPerformanceHistoryT, 0, sizeof(ns1__CmPerformanceHistoryT), 0, soap_copy_ns1__CmPerformanceHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmPerformanceHistoryT * SOAP_FMAC6 soap_new_ns1__CmPerformanceHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmPerformanceHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT * SOAP_FMAC4 soap_instantiate_ns1__CmPerformanceHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmPerformanceHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmPerformanceHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmPerformanceHistoryT;
		if (size)
			*size = sizeof(ns1__CmPerformanceHistoryT);
		((ns1__CmPerformanceHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmPerformanceHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmPerformanceHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__CmPerformanceHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmPerformanceHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmPerformanceHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmPerformanceHistoryT %p -> %p\n", q, p));
	*(ns1__CmPerformanceHistoryT*)p = *(ns1__CmPerformanceHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmPerformanceT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->downstreamSNR);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->downstreamPower);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->upstreamPower);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t1Timeouts);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t2Timeouts);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t3Timeouts);
	soap_default_short(soap, &((ns1__CmPerformanceT*)this)->t4Timeouts);
	/* transient soap skipped */
}

void ns1__CmPerformanceT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->downstreamSNR, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->downstreamPower, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->upstreamPower, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t1Timeouts, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t2Timeouts, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t3Timeouts, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__CmPerformanceT*)this)->t4Timeouts, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__CmPerformanceT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmPerformanceT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmPerformanceT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmPerformanceT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmPerformanceT(struct soap *soap, const char *tag, int id, const ns1__CmPerformanceT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmPerformanceT), type);
	soap_out_short(soap, "downstreamSNR", -1, &(((ns1__CmPerformanceT*)a)->downstreamSNR), "");
	soap_out_short(soap, "downstreamPower", -1, &(((ns1__CmPerformanceT*)a)->downstreamPower), "");
	soap_out_short(soap, "upstreamPower", -1, &(((ns1__CmPerformanceT*)a)->upstreamPower), "");
	soap_out_short(soap, "t1Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t1Timeouts), "");
	soap_out_short(soap, "t2Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t2Timeouts), "");
	soap_out_short(soap, "t3Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t3Timeouts), "");
	soap_out_short(soap, "t4Timeouts", -1, &(((ns1__CmPerformanceT*)a)->t4Timeouts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmPerformanceT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmPerformanceT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmPerformanceT * SOAP_FMAC4 soap_get_ns1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmPerformanceT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmPerformanceT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmPerformanceT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmPerformanceT * SOAP_FMAC4 soap_in_ns1__CmPerformanceT(struct soap *soap, const char *tag, ns1__CmPerformanceT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmPerformanceT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmPerformanceT, sizeof(ns1__CmPerformanceT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmPerformanceT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmPerformanceT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_downstreamSNR1 = 1, soap_flag_downstreamPower1 = 1, soap_flag_upstreamPower1 = 1, soap_flag_t1Timeouts1 = 1, soap_flag_t2Timeouts1 = 1, soap_flag_t3Timeouts1 = 1, soap_flag_t4Timeouts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_downstreamSNR1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "downstreamSNR", &(((ns1__CmPerformanceT*)a)->downstreamSNR), "xsd:short"))
				{	soap_flag_downstreamSNR1--;
					continue;
				}
			if (soap_flag_downstreamPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "downstreamPower", &(((ns1__CmPerformanceT*)a)->downstreamPower), "xsd:short"))
				{	soap_flag_downstreamPower1--;
					continue;
				}
			if (soap_flag_upstreamPower1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "upstreamPower", &(((ns1__CmPerformanceT*)a)->upstreamPower), "xsd:short"))
				{	soap_flag_upstreamPower1--;
					continue;
				}
			if (soap_flag_t1Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t1Timeouts", &(((ns1__CmPerformanceT*)a)->t1Timeouts), "xsd:short"))
				{	soap_flag_t1Timeouts1--;
					continue;
				}
			if (soap_flag_t2Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t2Timeouts", &(((ns1__CmPerformanceT*)a)->t2Timeouts), "xsd:short"))
				{	soap_flag_t2Timeouts1--;
					continue;
				}
			if (soap_flag_t3Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t3Timeouts", &(((ns1__CmPerformanceT*)a)->t3Timeouts), "xsd:short"))
				{	soap_flag_t3Timeouts1--;
					continue;
				}
			if (soap_flag_t4Timeouts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "t4Timeouts", &(((ns1__CmPerformanceT*)a)->t4Timeouts), "xsd:short"))
				{	soap_flag_t4Timeouts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_downstreamSNR1 > 0 || soap_flag_downstreamPower1 > 0 || soap_flag_upstreamPower1 > 0 || soap_flag_t1Timeouts1 > 0 || soap_flag_t2Timeouts1 > 0 || soap_flag_t3Timeouts1 > 0 || soap_flag_t4Timeouts1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmPerformanceT, 0, sizeof(ns1__CmPerformanceT), 0, soap_copy_ns1__CmPerformanceT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmPerformanceT * SOAP_FMAC6 soap_new_ns1__CmPerformanceT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmPerformanceT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmPerformanceT * SOAP_FMAC4 soap_instantiate_ns1__CmPerformanceT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmPerformanceT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmPerformanceT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmPerformanceT;
		if (size)
			*size = sizeof(ns1__CmPerformanceT);
		((ns1__CmPerformanceT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmPerformanceT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmPerformanceT);
		for (int i = 0; i < n; i++)
			((ns1__CmPerformanceT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmPerformanceT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmPerformanceT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmPerformanceT %p -> %p\n", q, p));
	*(ns1__CmPerformanceT*)p = *(ns1__CmPerformanceT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaPingStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaPingStatusHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaPingStatusHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaPingStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaPingStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaPingStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaPingStatusHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaPingStatusHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaPingStatusHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaPingStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaPingStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC4 soap_get_ArrayOfMtaPingStatusHistoryT(struct soap *soap, ArrayOfMtaPingStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaPingStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaPingStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC4 soap_in_ArrayOfMtaPingStatusHistoryT(struct soap *soap, const char *tag, ArrayOfMtaPingStatusHistoryT *a, const char *type)
{	int i, j;
	ns1__MtaPingStatusHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaPingStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT, sizeof(ArrayOfMtaPingStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaPingStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaPingStatusHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaPingStatusHistoryT(soap, NULL, a->__ptr + i, "ns1:MtaPingStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaPingStatusHistoryT **)soap_push_block(soap, sizeof(ns1__MtaPingStatusHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaPingStatusHistoryT(soap, NULL, p, "ns1:MtaPingStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaPingStatusHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaPingStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT, 0, sizeof(ArrayOfMtaPingStatusHistoryT), 0, soap_copy_ArrayOfMtaPingStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC6 soap_new_ArrayOfMtaPingStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaPingStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaPingStatusHistoryT(struct soap *soap, ArrayOfMtaPingStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaPingStatusHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaPingStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaPingStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaPingStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaPingStatusHistoryT;
		if (size)
			*size = sizeof(ArrayOfMtaPingStatusHistoryT);
		((ArrayOfMtaPingStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaPingStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaPingStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaPingStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaPingStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaPingStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaPingStatusHistoryT %p -> %p\n", q, p));
	*(ArrayOfMtaPingStatusHistoryT*)p = *(ArrayOfMtaPingStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaPingStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaPingStatusHistoryT*)this)->pingStatus = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaPingStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__MtaPingStatusHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaPingStatusT(soap, &((ns1__MtaPingStatusHistoryT*)this)->pingStatus);
	soap_embedded(soap, &((ns1__MtaPingStatusHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaPingStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__MtaPingStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaPingStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaPingStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaPingStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, const ns1__MtaPingStatusHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaPingStatusHistoryT), type);
	soap_out_PointerTons1__MtaPingStatusT(soap, "pingStatus", -1, &(((ns1__MtaPingStatusHistoryT*)a)->pingStatus), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__MtaPingStatusHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaPingStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaPingStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT * SOAP_FMAC4 soap_get_ns1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaPingStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaPingStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT * SOAP_FMAC4 soap_in_ns1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaPingStatusHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaPingStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaPingStatusHistoryT, sizeof(ns1__MtaPingStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaPingStatusHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaPingStatusHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_pingStatus1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pingStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaPingStatusT(soap, "pingStatus", &(((ns1__MtaPingStatusHistoryT*)a)->pingStatus), "ns1:MtaPingStatusT"))
				{	soap_flag_pingStatus1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__MtaPingStatusHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pingStatus1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaPingStatusHistoryT, 0, sizeof(ns1__MtaPingStatusHistoryT), 0, soap_copy_ns1__MtaPingStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaPingStatusHistoryT * SOAP_FMAC6 soap_new_ns1__MtaPingStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaPingStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT * SOAP_FMAC4 soap_instantiate_ns1__MtaPingStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaPingStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaPingStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaPingStatusHistoryT;
		if (size)
			*size = sizeof(ns1__MtaPingStatusHistoryT);
		((ns1__MtaPingStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaPingStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaPingStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaPingStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaPingStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaPingStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaPingStatusHistoryT %p -> %p\n", q, p));
	*(ns1__MtaPingStatusHistoryT*)p = *(ns1__MtaPingStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaPingStatusT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__MtaPingStatusT*)this)->pingState);
	/* transient soap skipped */
}

void ns1__MtaPingStatusT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaPingStatusT*)this)->pingState, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__MtaPingStatusT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaPingStatusT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaPingStatusT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaPingStatusT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaPingStatusT(struct soap *soap, const char *tag, int id, const ns1__MtaPingStatusT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaPingStatusT), type);
	soap_out_short(soap, "pingState", -1, &(((ns1__MtaPingStatusT*)a)->pingState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaPingStatusT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaPingStatusT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaPingStatusT * SOAP_FMAC4 soap_get_ns1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaPingStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaPingStatusT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaPingStatusT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaPingStatusT * SOAP_FMAC4 soap_in_ns1__MtaPingStatusT(struct soap *soap, const char *tag, ns1__MtaPingStatusT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaPingStatusT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaPingStatusT, sizeof(ns1__MtaPingStatusT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaPingStatusT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaPingStatusT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_pingState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pingState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "pingState", &(((ns1__MtaPingStatusT*)a)->pingState), "xsd:short"))
				{	soap_flag_pingState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pingState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaPingStatusT, 0, sizeof(ns1__MtaPingStatusT), 0, soap_copy_ns1__MtaPingStatusT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaPingStatusT * SOAP_FMAC6 soap_new_ns1__MtaPingStatusT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaPingStatusT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaPingStatusT * SOAP_FMAC4 soap_instantiate_ns1__MtaPingStatusT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaPingStatusT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaPingStatusT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaPingStatusT;
		if (size)
			*size = sizeof(ns1__MtaPingStatusT);
		((ns1__MtaPingStatusT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaPingStatusT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaPingStatusT);
		for (int i = 0; i < n; i++)
			((ns1__MtaPingStatusT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaPingStatusT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaPingStatusT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaPingStatusT %p -> %p\n", q, p));
	*(ns1__MtaPingStatusT*)p = *(ns1__MtaPingStatusT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaProvStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaProvStatusHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaProvStatusHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaProvStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaProvStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaProvStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaProvStatusHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaProvStatusHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaProvStatusHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaProvStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaProvStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC4 soap_get_ArrayOfMtaProvStatusHistoryT(struct soap *soap, ArrayOfMtaProvStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaProvStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaProvStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC4 soap_in_ArrayOfMtaProvStatusHistoryT(struct soap *soap, const char *tag, ArrayOfMtaProvStatusHistoryT *a, const char *type)
{	int i, j;
	ns1__MtaProvStatusHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaProvStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT, sizeof(ArrayOfMtaProvStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaProvStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaProvStatusHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaProvStatusHistoryT(soap, NULL, a->__ptr + i, "ns1:MtaProvStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaProvStatusHistoryT **)soap_push_block(soap, sizeof(ns1__MtaProvStatusHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaProvStatusHistoryT(soap, NULL, p, "ns1:MtaProvStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaProvStatusHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaProvStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT, 0, sizeof(ArrayOfMtaProvStatusHistoryT), 0, soap_copy_ArrayOfMtaProvStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC6 soap_new_ArrayOfMtaProvStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaProvStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaProvStatusHistoryT(struct soap *soap, ArrayOfMtaProvStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaProvStatusHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaProvStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaProvStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaProvStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaProvStatusHistoryT;
		if (size)
			*size = sizeof(ArrayOfMtaProvStatusHistoryT);
		((ArrayOfMtaProvStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaProvStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaProvStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaProvStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaProvStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaProvStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaProvStatusHistoryT %p -> %p\n", q, p));
	*(ArrayOfMtaProvStatusHistoryT*)p = *(ArrayOfMtaProvStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaProvStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaProvStatusHistoryT*)this)->provStatus = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaProvStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__MtaProvStatusHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaProvStatusT(soap, &((ns1__MtaProvStatusHistoryT*)this)->provStatus);
	soap_embedded(soap, &((ns1__MtaProvStatusHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaProvStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__MtaProvStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaProvStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaProvStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaProvStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, const ns1__MtaProvStatusHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaProvStatusHistoryT), type);
	soap_out_PointerTons1__MtaProvStatusT(soap, "provStatus", -1, &(((ns1__MtaProvStatusHistoryT*)a)->provStatus), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__MtaProvStatusHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaProvStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaProvStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT * SOAP_FMAC4 soap_get_ns1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaProvStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaProvStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT * SOAP_FMAC4 soap_in_ns1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaProvStatusHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaProvStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaProvStatusHistoryT, sizeof(ns1__MtaProvStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaProvStatusHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaProvStatusHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_provStatus1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_provStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaProvStatusT(soap, "provStatus", &(((ns1__MtaProvStatusHistoryT*)a)->provStatus), "ns1:MtaProvStatusT"))
				{	soap_flag_provStatus1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__MtaProvStatusHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_provStatus1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaProvStatusHistoryT, 0, sizeof(ns1__MtaProvStatusHistoryT), 0, soap_copy_ns1__MtaProvStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaProvStatusHistoryT * SOAP_FMAC6 soap_new_ns1__MtaProvStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaProvStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT * SOAP_FMAC4 soap_instantiate_ns1__MtaProvStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaProvStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaProvStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaProvStatusHistoryT;
		if (size)
			*size = sizeof(ns1__MtaProvStatusHistoryT);
		((ns1__MtaProvStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaProvStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaProvStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaProvStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaProvStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaProvStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaProvStatusHistoryT %p -> %p\n", q, p));
	*(ns1__MtaProvStatusHistoryT*)p = *(ns1__MtaProvStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaProvStatusT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__MtaProvStatusT*)this)->provState);
	/* transient soap skipped */
}

void ns1__MtaProvStatusT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaProvStatusT*)this)->provState, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__MtaProvStatusT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaProvStatusT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaProvStatusT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaProvStatusT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaProvStatusT(struct soap *soap, const char *tag, int id, const ns1__MtaProvStatusT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaProvStatusT), type);
	soap_out_short(soap, "provState", -1, &(((ns1__MtaProvStatusT*)a)->provState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaProvStatusT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaProvStatusT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaProvStatusT * SOAP_FMAC4 soap_get_ns1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaProvStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaProvStatusT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaProvStatusT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaProvStatusT * SOAP_FMAC4 soap_in_ns1__MtaProvStatusT(struct soap *soap, const char *tag, ns1__MtaProvStatusT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaProvStatusT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaProvStatusT, sizeof(ns1__MtaProvStatusT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaProvStatusT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaProvStatusT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_provState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_provState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "provState", &(((ns1__MtaProvStatusT*)a)->provState), "xsd:short"))
				{	soap_flag_provState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_provState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaProvStatusT, 0, sizeof(ns1__MtaProvStatusT), 0, soap_copy_ns1__MtaProvStatusT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaProvStatusT * SOAP_FMAC6 soap_new_ns1__MtaProvStatusT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaProvStatusT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaProvStatusT * SOAP_FMAC4 soap_instantiate_ns1__MtaProvStatusT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaProvStatusT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaProvStatusT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaProvStatusT;
		if (size)
			*size = sizeof(ns1__MtaProvStatusT);
		((ns1__MtaProvStatusT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaProvStatusT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaProvStatusT);
		for (int i = 0; i < n; i++)
			((ns1__MtaProvStatusT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaProvStatusT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaProvStatusT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaProvStatusT %p -> %p\n", q, p));
	*(ns1__MtaProvStatusT*)p = *(ns1__MtaProvStatusT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMtaAvailabilityHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMtaAvailabilityHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MtaAvailabilityHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfMtaAvailabilityHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMtaAvailabilityHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMtaAvailabilityHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfMtaAvailabilityHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MtaAvailabilityHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMtaAvailabilityHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMtaAvailabilityHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC4 soap_get_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, ArrayOfMtaAvailabilityHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMtaAvailabilityHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMtaAvailabilityHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC4 soap_in_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, const char *tag, ArrayOfMtaAvailabilityHistoryT *a, const char *type)
{	int i, j;
	ns1__MtaAvailabilityHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMtaAvailabilityHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT, sizeof(ArrayOfMtaAvailabilityHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MtaAvailabilityHistoryT **)soap_malloc(soap, sizeof(ns1__MtaAvailabilityHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, NULL, a->__ptr + i, "ns1:MtaAvailabilityHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MtaAvailabilityHistoryT **)soap_push_block(soap, sizeof(ns1__MtaAvailabilityHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, NULL, p, "ns1:MtaAvailabilityHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MtaAvailabilityHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaAvailabilityHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT, 0, sizeof(ArrayOfMtaAvailabilityHistoryT), 0, soap_copy_ArrayOfMtaAvailabilityHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC6 soap_new_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMtaAvailabilityHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, ArrayOfMtaAvailabilityHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMtaAvailabilityHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMtaAvailabilityHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMtaAvailabilityHistoryT;
		if (size)
			*size = sizeof(ArrayOfMtaAvailabilityHistoryT);
		((ArrayOfMtaAvailabilityHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMtaAvailabilityHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMtaAvailabilityHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfMtaAvailabilityHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMtaAvailabilityHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMtaAvailabilityHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMtaAvailabilityHistoryT %p -> %p\n", q, p));
	*(ArrayOfMtaAvailabilityHistoryT*)p = *(ArrayOfMtaAvailabilityHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaAvailabilityHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MtaAvailabilityHistoryT*)this)->available = NULL;
	soap_default_xsd__integer(soap, &((ns1__MtaAvailabilityHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__MtaAvailabilityHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaAvailabilityT(soap, &((ns1__MtaAvailabilityHistoryT*)this)->available);
	soap_embedded(soap, &((ns1__MtaAvailabilityHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MtaAvailabilityHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__MtaAvailabilityHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaAvailabilityHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaAvailabilityHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaAvailabilityHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, const ns1__MtaAvailabilityHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT), type);
	soap_out_PointerTons1__MtaAvailabilityT(soap, "available", -1, &(((ns1__MtaAvailabilityHistoryT*)a)->available), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__MtaAvailabilityHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaAvailabilityHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaAvailabilityHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT * SOAP_FMAC4 soap_get_ns1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaAvailabilityHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaAvailabilityHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT * SOAP_FMAC4 soap_in_ns1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, ns1__MtaAvailabilityHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaAvailabilityHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, sizeof(ns1__MtaAvailabilityHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaAvailabilityHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaAvailabilityHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_available1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_available1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaAvailabilityT(soap, "available", &(((ns1__MtaAvailabilityHistoryT*)a)->available), "ns1:MtaAvailabilityT"))
				{	soap_flag_available1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__MtaAvailabilityHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_available1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, 0, sizeof(ns1__MtaAvailabilityHistoryT), 0, soap_copy_ns1__MtaAvailabilityHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaAvailabilityHistoryT * SOAP_FMAC6 soap_new_ns1__MtaAvailabilityHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaAvailabilityHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT * SOAP_FMAC4 soap_instantiate_ns1__MtaAvailabilityHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaAvailabilityHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaAvailabilityHistoryT;
		if (size)
			*size = sizeof(ns1__MtaAvailabilityHistoryT);
		((ns1__MtaAvailabilityHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaAvailabilityHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaAvailabilityHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__MtaAvailabilityHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaAvailabilityHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaAvailabilityHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaAvailabilityHistoryT %p -> %p\n", q, p));
	*(ns1__MtaAvailabilityHistoryT*)p = *(ns1__MtaAvailabilityHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MtaAvailabilityT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__MtaAvailabilityT*)this)->available);
	/* transient soap skipped */
}

void ns1__MtaAvailabilityT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MtaAvailabilityT*)this)->available, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__MtaAvailabilityT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MtaAvailabilityT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MtaAvailabilityT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MtaAvailabilityT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MtaAvailabilityT(struct soap *soap, const char *tag, int id, const ns1__MtaAvailabilityT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MtaAvailabilityT), type);
	soap_out_short(soap, "available", -1, &(((ns1__MtaAvailabilityT*)a)->available), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MtaAvailabilityT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MtaAvailabilityT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityT * SOAP_FMAC4 soap_get_ns1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MtaAvailabilityT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MtaAvailabilityT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MtaAvailabilityT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityT * SOAP_FMAC4 soap_in_ns1__MtaAvailabilityT(struct soap *soap, const char *tag, ns1__MtaAvailabilityT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MtaAvailabilityT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MtaAvailabilityT, sizeof(ns1__MtaAvailabilityT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MtaAvailabilityT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MtaAvailabilityT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_available1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_available1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "available", &(((ns1__MtaAvailabilityT*)a)->available), "xsd:short"))
				{	soap_flag_available1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_available1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MtaAvailabilityT, 0, sizeof(ns1__MtaAvailabilityT), 0, soap_copy_ns1__MtaAvailabilityT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MtaAvailabilityT * SOAP_FMAC6 soap_new_ns1__MtaAvailabilityT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MtaAvailabilityT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MtaAvailabilityT * SOAP_FMAC4 soap_instantiate_ns1__MtaAvailabilityT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MtaAvailabilityT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MtaAvailabilityT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MtaAvailabilityT;
		if (size)
			*size = sizeof(ns1__MtaAvailabilityT);
		((ns1__MtaAvailabilityT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MtaAvailabilityT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MtaAvailabilityT);
		for (int i = 0; i < n; i++)
			((ns1__MtaAvailabilityT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MtaAvailabilityT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MtaAvailabilityT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MtaAvailabilityT %p -> %p\n", q, p));
	*(ns1__MtaAvailabilityT*)p = *(ns1__MtaAvailabilityT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmStatusHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmStatusHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmStatusHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfCmStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmStatusHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfCmStatusHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmStatusHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmStatusHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmStatusHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmStatusHistoryT * SOAP_FMAC4 soap_get_ArrayOfCmStatusHistoryT(struct soap *soap, ArrayOfCmStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmStatusHistoryT * SOAP_FMAC4 soap_in_ArrayOfCmStatusHistoryT(struct soap *soap, const char *tag, ArrayOfCmStatusHistoryT *a, const char *type)
{	int i, j;
	ns1__CmStatusHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmStatusHistoryT, sizeof(ArrayOfCmStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmStatusHistoryT **)soap_malloc(soap, sizeof(ns1__CmStatusHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmStatusHistoryT(soap, NULL, a->__ptr + i, "ns1:CmStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmStatusHistoryT **)soap_push_block(soap, sizeof(ns1__CmStatusHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmStatusHistoryT(soap, NULL, p, "ns1:CmStatusHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmStatusHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmStatusHistoryT, 0, sizeof(ArrayOfCmStatusHistoryT), 0, soap_copy_ArrayOfCmStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmStatusHistoryT * SOAP_FMAC6 soap_new_ArrayOfCmStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmStatusHistoryT(struct soap *soap, ArrayOfCmStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmStatusHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfCmStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmStatusHistoryT;
		if (size)
			*size = sizeof(ArrayOfCmStatusHistoryT);
		((ArrayOfCmStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmStatusHistoryT %p -> %p\n", q, p));
	*(ArrayOfCmStatusHistoryT*)p = *(ArrayOfCmStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmStatusHistoryT*)this)->cmStatus = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__CmStatusHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmStatusT(soap, &((ns1__CmStatusHistoryT*)this)->cmStatus);
	soap_embedded(soap, &((ns1__CmStatusHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmStatusHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__CmStatusHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusHistoryT(struct soap *soap, const char *tag, int id, const ns1__CmStatusHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusHistoryT), type);
	soap_out_PointerTons1__CmStatusT(soap, "cmStatus", -1, &(((ns1__CmStatusHistoryT*)a)->cmStatus), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__CmStatusHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT * SOAP_FMAC4 soap_get_ns1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT * SOAP_FMAC4 soap_in_ns1__CmStatusHistoryT(struct soap *soap, const char *tag, ns1__CmStatusHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusHistoryT, sizeof(ns1__CmStatusHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cmStatus1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmStatus1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmStatusT(soap, "cmStatus", &(((ns1__CmStatusHistoryT*)a)->cmStatus), "ns1:CmStatusT"))
				{	soap_flag_cmStatus1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__CmStatusHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmStatus1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusHistoryT, 0, sizeof(ns1__CmStatusHistoryT), 0, soap_copy_ns1__CmStatusHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusHistoryT * SOAP_FMAC6 soap_new_ns1__CmStatusHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusHistoryT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusHistoryT;
		if (size)
			*size = sizeof(ns1__CmStatusHistoryT);
		((ns1__CmStatusHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusHistoryT %p -> %p\n", q, p));
	*(ns1__CmStatusHistoryT*)p = *(ns1__CmStatusHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmStatusT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__CmStatusT*)this)->docsisState);
	/* transient soap skipped */
}

void ns1__CmStatusT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__CmStatusT*)this)->docsisState, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__CmStatusT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmStatusT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmStatusT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmStatusT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmStatusT(struct soap *soap, const char *tag, int id, const ns1__CmStatusT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmStatusT), type);
	soap_out_short(soap, "docsisState", -1, &(((ns1__CmStatusT*)a)->docsisState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmStatusT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmStatusT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmStatusT * SOAP_FMAC4 soap_get_ns1__CmStatusT(struct soap *soap, ns1__CmStatusT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmStatusT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmStatusT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmStatusT * SOAP_FMAC4 soap_in_ns1__CmStatusT(struct soap *soap, const char *tag, ns1__CmStatusT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmStatusT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmStatusT, sizeof(ns1__CmStatusT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmStatusT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmStatusT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_docsisState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_docsisState1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "docsisState", &(((ns1__CmStatusT*)a)->docsisState), "xsd:short"))
				{	soap_flag_docsisState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_docsisState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmStatusT, 0, sizeof(ns1__CmStatusT), 0, soap_copy_ns1__CmStatusT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmStatusT * SOAP_FMAC6 soap_new_ns1__CmStatusT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmStatusT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmStatusT(struct soap *soap, ns1__CmStatusT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmStatusT * SOAP_FMAC4 soap_instantiate_ns1__CmStatusT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmStatusT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmStatusT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmStatusT;
		if (size)
			*size = sizeof(ns1__CmStatusT);
		((ns1__CmStatusT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmStatusT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmStatusT);
		for (int i = 0; i < n; i++)
			((ns1__CmStatusT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmStatusT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmStatusT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmStatusT %p -> %p\n", q, p));
	*(ns1__CmStatusT*)p = *(ns1__CmStatusT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfGenericCountsHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfGenericCountsHistoryT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfGenericCountsHistoryT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__GenericCountsHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfGenericCountsHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfGenericCountsHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfGenericCountsHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfGenericCountsHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfGenericCountsHistoryT(struct soap *soap, const char *tag, int id, const ArrayOfGenericCountsHistoryT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:GenericCountsHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfGenericCountsHistoryT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__GenericCountsHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfGenericCountsHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfGenericCountsHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfGenericCountsHistoryT * SOAP_FMAC4 soap_get_ArrayOfGenericCountsHistoryT(struct soap *soap, ArrayOfGenericCountsHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfGenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfGenericCountsHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfGenericCountsHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfGenericCountsHistoryT * SOAP_FMAC4 soap_in_ArrayOfGenericCountsHistoryT(struct soap *soap, const char *tag, ArrayOfGenericCountsHistoryT *a, const char *type)
{	int i, j;
	ns1__GenericCountsHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfGenericCountsHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfGenericCountsHistoryT, sizeof(ArrayOfGenericCountsHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__GenericCountsHistoryT **)soap_malloc(soap, sizeof(ns1__GenericCountsHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__GenericCountsHistoryT(soap, NULL, a->__ptr + i, "ns1:GenericCountsHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__GenericCountsHistoryT **)soap_push_block(soap, sizeof(ns1__GenericCountsHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__GenericCountsHistoryT(soap, NULL, p, "ns1:GenericCountsHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__GenericCountsHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfGenericCountsHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfGenericCountsHistoryT, 0, sizeof(ArrayOfGenericCountsHistoryT), 0, soap_copy_ArrayOfGenericCountsHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfGenericCountsHistoryT * SOAP_FMAC6 soap_new_ArrayOfGenericCountsHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfGenericCountsHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfGenericCountsHistoryT(struct soap *soap, ArrayOfGenericCountsHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfGenericCountsHistoryT * SOAP_FMAC4 soap_instantiate_ArrayOfGenericCountsHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfGenericCountsHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfGenericCountsHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfGenericCountsHistoryT;
		if (size)
			*size = sizeof(ArrayOfGenericCountsHistoryT);
		((ArrayOfGenericCountsHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfGenericCountsHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfGenericCountsHistoryT);
		for (int i = 0; i < n; i++)
			((ArrayOfGenericCountsHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfGenericCountsHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfGenericCountsHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfGenericCountsHistoryT %p -> %p\n", q, p));
	*(ArrayOfGenericCountsHistoryT*)p = *(ArrayOfGenericCountsHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__GenericCountsHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__GenericCountsHistoryT*)this)->counts = NULL;
	soap_default_xsd__integer(soap, &((ns1__GenericCountsHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

void ns1__GenericCountsHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__GenericCountsHistoryT*)this)->counts);
	soap_embedded(soap, &((ns1__GenericCountsHistoryT*)this)->timeSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__GenericCountsHistoryT*)this)->timeSec);
	/* transient soap skipped */
}

int ns1__GenericCountsHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GenericCountsHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__GenericCountsHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericCountsHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericCountsHistoryT(struct soap *soap, const char *tag, int id, const ns1__GenericCountsHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericCountsHistoryT), type);
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__GenericCountsHistoryT*)a)->counts), "");
	soap_out_xsd__integer(soap, "timeSec", -1, &(((ns1__GenericCountsHistoryT*)a)->timeSec), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__GenericCountsHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericCountsHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT * SOAP_FMAC4 soap_get_ns1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__GenericCountsHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GenericCountsHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT * SOAP_FMAC4 soap_in_ns1__GenericCountsHistoryT(struct soap *soap, const char *tag, ns1__GenericCountsHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericCountsHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericCountsHistoryT, sizeof(ns1__GenericCountsHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GenericCountsHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GenericCountsHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_counts1 = 1, soap_flag_timeSec1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__GenericCountsHistoryT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			if (soap_flag_timeSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "timeSec", &(((ns1__GenericCountsHistoryT*)a)->timeSec), "xsd:integer"))
				{	soap_flag_timeSec1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_counts1 > 0 || soap_flag_timeSec1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericCountsHistoryT, 0, sizeof(ns1__GenericCountsHistoryT), 0, soap_copy_ns1__GenericCountsHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__GenericCountsHistoryT * SOAP_FMAC6 soap_new_ns1__GenericCountsHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__GenericCountsHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT * SOAP_FMAC4 soap_instantiate_ns1__GenericCountsHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericCountsHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GenericCountsHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__GenericCountsHistoryT;
		if (size)
			*size = sizeof(ns1__GenericCountsHistoryT);
		((ns1__GenericCountsHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__GenericCountsHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GenericCountsHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__GenericCountsHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GenericCountsHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GenericCountsHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GenericCountsHistoryT %p -> %p\n", q, p));
	*(ns1__GenericCountsHistoryT*)p = *(ns1__GenericCountsHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfQueryStateT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfQueryStateT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfQueryStateT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__QueryStateT(soap, this->__ptr + i);
		}
}

int ArrayOfQueryStateT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfQueryStateT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfQueryStateT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfQueryStateT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfQueryStateT(struct soap *soap, const char *tag, int id, const ArrayOfQueryStateT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:QueryStateT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfQueryStateT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__QueryStateT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfQueryStateT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfQueryStateT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfQueryStateT * SOAP_FMAC4 soap_get_ArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfQueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfQueryStateT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfQueryStateT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfQueryStateT * SOAP_FMAC4 soap_in_ArrayOfQueryStateT(struct soap *soap, const char *tag, ArrayOfQueryStateT *a, const char *type)
{	int i, j;
	ns1__QueryStateT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfQueryStateT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfQueryStateT, sizeof(ArrayOfQueryStateT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__QueryStateT **)soap_malloc(soap, sizeof(ns1__QueryStateT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__QueryStateT(soap, NULL, a->__ptr + i, "ns1:QueryStateT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__QueryStateT **)soap_push_block(soap, sizeof(ns1__QueryStateT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__QueryStateT(soap, NULL, p, "ns1:QueryStateT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__QueryStateT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfQueryStateT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfQueryStateT, 0, sizeof(ArrayOfQueryStateT), 0, soap_copy_ArrayOfQueryStateT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfQueryStateT * SOAP_FMAC6 soap_new_ArrayOfQueryStateT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfQueryStateT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfQueryStateT * SOAP_FMAC4 soap_instantiate_ArrayOfQueryStateT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfQueryStateT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfQueryStateT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfQueryStateT;
		if (size)
			*size = sizeof(ArrayOfQueryStateT);
		((ArrayOfQueryStateT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfQueryStateT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfQueryStateT);
		for (int i = 0; i < n; i++)
			((ArrayOfQueryStateT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfQueryStateT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfQueryStateT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfQueryStateT %p -> %p\n", q, p));
	*(ArrayOfQueryStateT*)p = *(ArrayOfQueryStateT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__QueryStateT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__QueryStateT*)this)->topologyKey = NULL;
	((ns1__QueryStateT*)this)->pages = NULL;
	/* transient soap skipped */
}

void ns1__QueryStateT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__QueryStateT*)this)->topologyKey);
	soap_serialize_PointerToArrayOfScrollPageT(soap, &((ns1__QueryStateT*)this)->pages);
	/* transient soap skipped */
}

int ns1__QueryStateT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__QueryStateT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__QueryStateT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__QueryStateT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__QueryStateT(struct soap *soap, const char *tag, int id, const ns1__QueryStateT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__QueryStateT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__QueryStateT*)a)->topologyKey), "");
	soap_out_PointerToArrayOfScrollPageT(soap, "pages", -1, &(((ns1__QueryStateT*)a)->pages), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__QueryStateT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__QueryStateT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__QueryStateT * SOAP_FMAC4 soap_get_ns1__QueryStateT(struct soap *soap, ns1__QueryStateT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__QueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__QueryStateT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__QueryStateT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__QueryStateT * SOAP_FMAC4 soap_in_ns1__QueryStateT(struct soap *soap, const char *tag, ns1__QueryStateT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__QueryStateT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__QueryStateT, sizeof(ns1__QueryStateT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__QueryStateT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__QueryStateT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_pages1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__QueryStateT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_pages1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfScrollPageT(soap, "pages", &(((ns1__QueryStateT*)a)->pages), "ns1:ScrollPageT"))
				{	soap_flag_pages1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_pages1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__QueryStateT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__QueryStateT, 0, sizeof(ns1__QueryStateT), 0, soap_copy_ns1__QueryStateT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__QueryStateT * SOAP_FMAC6 soap_new_ns1__QueryStateT(struct soap *soap, int n)
{	return soap_instantiate_ns1__QueryStateT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__QueryStateT(struct soap *soap, ns1__QueryStateT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__QueryStateT * SOAP_FMAC4 soap_instantiate_ns1__QueryStateT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__QueryStateT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__QueryStateT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__QueryStateT;
		if (size)
			*size = sizeof(ns1__QueryStateT);
		((ns1__QueryStateT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__QueryStateT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__QueryStateT);
		for (int i = 0; i < n; i++)
			((ns1__QueryStateT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__QueryStateT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__QueryStateT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__QueryStateT %p -> %p\n", q, p));
	*(ns1__QueryStateT*)p = *(ns1__QueryStateT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfScrollPageT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfScrollPageT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfScrollPageT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ScrollPageT(soap, this->__ptr + i);
		}
}

int ArrayOfScrollPageT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfScrollPageT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfScrollPageT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfScrollPageT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfScrollPageT(struct soap *soap, const char *tag, int id, const ArrayOfScrollPageT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ScrollPageT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfScrollPageT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ScrollPageT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfScrollPageT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfScrollPageT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfScrollPageT * SOAP_FMAC4 soap_get_ArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfScrollPageT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfScrollPageT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfScrollPageT * SOAP_FMAC4 soap_in_ArrayOfScrollPageT(struct soap *soap, const char *tag, ArrayOfScrollPageT *a, const char *type)
{	int i, j;
	ns1__ScrollPageT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfScrollPageT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfScrollPageT, sizeof(ArrayOfScrollPageT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ScrollPageT **)soap_malloc(soap, sizeof(ns1__ScrollPageT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ScrollPageT(soap, NULL, a->__ptr + i, "ns1:ScrollPageT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ScrollPageT **)soap_push_block(soap, sizeof(ns1__ScrollPageT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ScrollPageT(soap, NULL, p, "ns1:ScrollPageT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__ScrollPageT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfScrollPageT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfScrollPageT, 0, sizeof(ArrayOfScrollPageT), 0, soap_copy_ArrayOfScrollPageT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfScrollPageT * SOAP_FMAC6 soap_new_ArrayOfScrollPageT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfScrollPageT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfScrollPageT * SOAP_FMAC4 soap_instantiate_ArrayOfScrollPageT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfScrollPageT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfScrollPageT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfScrollPageT;
		if (size)
			*size = sizeof(ArrayOfScrollPageT);
		((ArrayOfScrollPageT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfScrollPageT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfScrollPageT);
		for (int i = 0; i < n; i++)
			((ArrayOfScrollPageT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfScrollPageT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfScrollPageT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfScrollPageT %p -> %p\n", q, p));
	*(ArrayOfScrollPageT*)p = *(ArrayOfScrollPageT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ScrollPageT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ScrollPageT*)this)->batch = NULL;
	soap_default_std__string(soap, &((ns1__ScrollPageT*)this)->start);
	/* transient soap skipped */
}

void ns1__ScrollPageT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ResultBatchT(soap, &((ns1__ScrollPageT*)this)->batch);
	soap_embedded(soap, &((ns1__ScrollPageT*)this)->start, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__ScrollPageT*)this)->start);
	/* transient soap skipped */
}

int ns1__ScrollPageT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ScrollPageT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ScrollPageT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ScrollPageT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ScrollPageT(struct soap *soap, const char *tag, int id, const ns1__ScrollPageT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ScrollPageT), type);
	soap_out_PointerTons1__ResultBatchT(soap, "batch", -1, &(((ns1__ScrollPageT*)a)->batch), "");
	soap_out_std__string(soap, "start", -1, &(((ns1__ScrollPageT*)a)->start), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ScrollPageT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ScrollPageT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ScrollPageT * SOAP_FMAC4 soap_get_ns1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ScrollPageT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ScrollPageT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ScrollPageT * SOAP_FMAC4 soap_in_ns1__ScrollPageT(struct soap *soap, const char *tag, ns1__ScrollPageT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ScrollPageT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ScrollPageT, sizeof(ns1__ScrollPageT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ScrollPageT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ScrollPageT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_batch1 = 1, soap_flag_start1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_batch1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ResultBatchT(soap, "batch", &(((ns1__ScrollPageT*)a)->batch), "ns1:ResultBatchT"))
				{	soap_flag_batch1--;
					continue;
				}
			if (soap_flag_start1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "start", &(((ns1__ScrollPageT*)a)->start), "xsd:string"))
				{	soap_flag_start1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_batch1 > 0 || soap_flag_start1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ScrollPageT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ScrollPageT, 0, sizeof(ns1__ScrollPageT), 0, soap_copy_ns1__ScrollPageT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ScrollPageT * SOAP_FMAC6 soap_new_ns1__ScrollPageT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ScrollPageT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ScrollPageT * SOAP_FMAC4 soap_instantiate_ns1__ScrollPageT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ScrollPageT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ScrollPageT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ScrollPageT;
		if (size)
			*size = sizeof(ns1__ScrollPageT);
		((ns1__ScrollPageT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ScrollPageT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ScrollPageT);
		for (int i = 0; i < n; i++)
			((ns1__ScrollPageT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ScrollPageT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ScrollPageT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ScrollPageT %p -> %p\n", q, p));
	*(ns1__ScrollPageT*)p = *(ns1__ScrollPageT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MappedEuDevicesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__MappedEuDevicesT*)this)->cm = NULL;
	((ns1__MappedEuDevicesT*)this)->mta = NULL;
	/* transient soap skipped */
}

void ns1__MappedEuDevicesT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CableModemT(soap, &((ns1__MappedEuDevicesT*)this)->cm);
	soap_serialize_PointerTons1__EmtaT(soap, &((ns1__MappedEuDevicesT*)this)->mta);
	/* transient soap skipped */
}

int ns1__MappedEuDevicesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MappedEuDevicesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MappedEuDevicesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MappedEuDevicesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MappedEuDevicesT(struct soap *soap, const char *tag, int id, const ns1__MappedEuDevicesT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MappedEuDevicesT), type);
	soap_out_PointerTons1__CableModemT(soap, "cm", -1, &(((ns1__MappedEuDevicesT*)a)->cm), "");
	soap_out_PointerTons1__EmtaT(soap, "mta", -1, &(((ns1__MappedEuDevicesT*)a)->mta), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MappedEuDevicesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MappedEuDevicesT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MappedEuDevicesT * SOAP_FMAC4 soap_get_ns1__MappedEuDevicesT(struct soap *soap, ns1__MappedEuDevicesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MappedEuDevicesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MappedEuDevicesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MappedEuDevicesT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MappedEuDevicesT * SOAP_FMAC4 soap_in_ns1__MappedEuDevicesT(struct soap *soap, const char *tag, ns1__MappedEuDevicesT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MappedEuDevicesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MappedEuDevicesT, sizeof(ns1__MappedEuDevicesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MappedEuDevicesT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MappedEuDevicesT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_cm1 = 1, soap_flag_mta1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CableModemT(soap, "cm", &(((ns1__MappedEuDevicesT*)a)->cm), "ns1:CableModemT"))
				{	soap_flag_cm1--;
					continue;
				}
			if (soap_flag_mta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__EmtaT(soap, "mta", &(((ns1__MappedEuDevicesT*)a)->mta), "ns1:EmtaT"))
				{	soap_flag_mta1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MappedEuDevicesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MappedEuDevicesT, 0, sizeof(ns1__MappedEuDevicesT), 0, soap_copy_ns1__MappedEuDevicesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MappedEuDevicesT * SOAP_FMAC6 soap_new_ns1__MappedEuDevicesT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MappedEuDevicesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MappedEuDevicesT(struct soap *soap, ns1__MappedEuDevicesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MappedEuDevicesT * SOAP_FMAC4 soap_instantiate_ns1__MappedEuDevicesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MappedEuDevicesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MappedEuDevicesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MappedEuDevicesT;
		if (size)
			*size = sizeof(ns1__MappedEuDevicesT);
		((ns1__MappedEuDevicesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MappedEuDevicesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MappedEuDevicesT);
		for (int i = 0; i < n; i++)
			((ns1__MappedEuDevicesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MappedEuDevicesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MappedEuDevicesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MappedEuDevicesT %p -> %p\n", q, p));
	*(ns1__MappedEuDevicesT*)p = *(ns1__MappedEuDevicesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfAlarmHistoriesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfAlarmHistoriesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfAlarmHistoriesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__AlarmHistoryT(soap, this->__ptr + i);
		}
}

int ArrayOfAlarmHistoriesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfAlarmHistoriesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfAlarmHistoriesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfAlarmHistoriesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfAlarmHistoriesT(struct soap *soap, const char *tag, int id, const ArrayOfAlarmHistoriesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:AlarmHistoryT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmHistoriesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__AlarmHistoryT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfAlarmHistoriesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfAlarmHistoriesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfAlarmHistoriesT * SOAP_FMAC4 soap_get_ArrayOfAlarmHistoriesT(struct soap *soap, ArrayOfAlarmHistoriesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfAlarmHistoriesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfAlarmHistoriesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfAlarmHistoriesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfAlarmHistoriesT * SOAP_FMAC4 soap_in_ArrayOfAlarmHistoriesT(struct soap *soap, const char *tag, ArrayOfAlarmHistoriesT *a, const char *type)
{	int i, j;
	ns1__AlarmHistoryT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfAlarmHistoriesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfAlarmHistoriesT, sizeof(ArrayOfAlarmHistoriesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__AlarmHistoryT **)soap_malloc(soap, sizeof(ns1__AlarmHistoryT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__AlarmHistoryT(soap, NULL, a->__ptr + i, "ns1:AlarmHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__AlarmHistoryT **)soap_push_block(soap, sizeof(ns1__AlarmHistoryT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__AlarmHistoryT(soap, NULL, p, "ns1:AlarmHistoryT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__AlarmHistoryT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmHistoriesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfAlarmHistoriesT, 0, sizeof(ArrayOfAlarmHistoriesT), 0, soap_copy_ArrayOfAlarmHistoriesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfAlarmHistoriesT * SOAP_FMAC6 soap_new_ArrayOfAlarmHistoriesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfAlarmHistoriesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfAlarmHistoriesT(struct soap *soap, ArrayOfAlarmHistoriesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfAlarmHistoriesT * SOAP_FMAC4 soap_instantiate_ArrayOfAlarmHistoriesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfAlarmHistoriesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfAlarmHistoriesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfAlarmHistoriesT;
		if (size)
			*size = sizeof(ArrayOfAlarmHistoriesT);
		((ArrayOfAlarmHistoriesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfAlarmHistoriesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfAlarmHistoriesT);
		for (int i = 0; i < n; i++)
			((ArrayOfAlarmHistoriesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfAlarmHistoriesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfAlarmHistoriesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfAlarmHistoriesT %p -> %p\n", q, p));
	*(ArrayOfAlarmHistoriesT*)p = *(ArrayOfAlarmHistoriesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfHistoricalAlarmsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfHistoricalAlarmsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfHistoricalAlarmsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__HistoricalAlarmT(soap, this->__ptr + i);
		}
}

int ArrayOfHistoricalAlarmsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfHistoricalAlarmsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfHistoricalAlarmsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfHistoricalAlarmsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, int id, const ArrayOfHistoricalAlarmsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:HistoricalAlarmT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfHistoricalAlarmsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__HistoricalAlarmT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfHistoricalAlarmsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfHistoricalAlarmsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT * SOAP_FMAC4 soap_get_ArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfHistoricalAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfHistoricalAlarmsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfHistoricalAlarmsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT * SOAP_FMAC4 soap_in_ArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, ArrayOfHistoricalAlarmsT *a, const char *type)
{	int i, j;
	ns1__HistoricalAlarmT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfHistoricalAlarmsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfHistoricalAlarmsT, sizeof(ArrayOfHistoricalAlarmsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__HistoricalAlarmT **)soap_malloc(soap, sizeof(ns1__HistoricalAlarmT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__HistoricalAlarmT(soap, NULL, a->__ptr + i, "ns1:HistoricalAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__HistoricalAlarmT **)soap_push_block(soap, sizeof(ns1__HistoricalAlarmT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__HistoricalAlarmT(soap, NULL, p, "ns1:HistoricalAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__HistoricalAlarmT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfHistoricalAlarmsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfHistoricalAlarmsT, 0, sizeof(ArrayOfHistoricalAlarmsT), 0, soap_copy_ArrayOfHistoricalAlarmsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfHistoricalAlarmsT * SOAP_FMAC6 soap_new_ArrayOfHistoricalAlarmsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfHistoricalAlarmsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT * SOAP_FMAC4 soap_instantiate_ArrayOfHistoricalAlarmsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfHistoricalAlarmsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfHistoricalAlarmsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfHistoricalAlarmsT;
		if (size)
			*size = sizeof(ArrayOfHistoricalAlarmsT);
		((ArrayOfHistoricalAlarmsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfHistoricalAlarmsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfHistoricalAlarmsT);
		for (int i = 0; i < n; i++)
			((ArrayOfHistoricalAlarmsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfHistoricalAlarmsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfHistoricalAlarmsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfHistoricalAlarmsT %p -> %p\n", q, p));
	*(ArrayOfHistoricalAlarmsT*)p = *(ArrayOfHistoricalAlarmsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCurrentAlarmsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCurrentAlarmsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCurrentAlarmsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CurrentAlarmT(soap, this->__ptr + i);
		}
}

int ArrayOfCurrentAlarmsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCurrentAlarmsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCurrentAlarmsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCurrentAlarmsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, int id, const ArrayOfCurrentAlarmsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CurrentAlarmT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCurrentAlarmsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CurrentAlarmT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCurrentAlarmsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCurrentAlarmsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT * SOAP_FMAC4 soap_get_ArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCurrentAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCurrentAlarmsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCurrentAlarmsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT * SOAP_FMAC4 soap_in_ArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, ArrayOfCurrentAlarmsT *a, const char *type)
{	int i, j;
	ns1__CurrentAlarmT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCurrentAlarmsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCurrentAlarmsT, sizeof(ArrayOfCurrentAlarmsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CurrentAlarmT **)soap_malloc(soap, sizeof(ns1__CurrentAlarmT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CurrentAlarmT(soap, NULL, a->__ptr + i, "ns1:CurrentAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CurrentAlarmT **)soap_push_block(soap, sizeof(ns1__CurrentAlarmT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CurrentAlarmT(soap, NULL, p, "ns1:CurrentAlarmT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CurrentAlarmT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCurrentAlarmsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCurrentAlarmsT, 0, sizeof(ArrayOfCurrentAlarmsT), 0, soap_copy_ArrayOfCurrentAlarmsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCurrentAlarmsT * SOAP_FMAC6 soap_new_ArrayOfCurrentAlarmsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCurrentAlarmsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT * SOAP_FMAC4 soap_instantiate_ArrayOfCurrentAlarmsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCurrentAlarmsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCurrentAlarmsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCurrentAlarmsT;
		if (size)
			*size = sizeof(ArrayOfCurrentAlarmsT);
		((ArrayOfCurrentAlarmsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCurrentAlarmsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCurrentAlarmsT);
		for (int i = 0; i < n; i++)
			((ArrayOfCurrentAlarmsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCurrentAlarmsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCurrentAlarmsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCurrentAlarmsT %p -> %p\n", q, p));
	*(ArrayOfCurrentAlarmsT*)p = *(ArrayOfCurrentAlarmsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfEmtasT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfEmtasT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfEmtasT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__EmtaT(soap, this->__ptr + i);
		}
}

int ArrayOfEmtasT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfEmtasT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfEmtasT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfEmtasT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfEmtasT(struct soap *soap, const char *tag, int id, const ArrayOfEmtasT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:EmtaT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfEmtasT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__EmtaT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfEmtasT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfEmtasT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfEmtasT * SOAP_FMAC4 soap_get_ArrayOfEmtasT(struct soap *soap, ArrayOfEmtasT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfEmtasT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfEmtasT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfEmtasT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfEmtasT * SOAP_FMAC4 soap_in_ArrayOfEmtasT(struct soap *soap, const char *tag, ArrayOfEmtasT *a, const char *type)
{	int i, j;
	ns1__EmtaT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfEmtasT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfEmtasT, sizeof(ArrayOfEmtasT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__EmtaT **)soap_malloc(soap, sizeof(ns1__EmtaT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__EmtaT(soap, NULL, a->__ptr + i, "ns1:EmtaT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__EmtaT **)soap_push_block(soap, sizeof(ns1__EmtaT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__EmtaT(soap, NULL, p, "ns1:EmtaT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__EmtaT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfEmtasT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfEmtasT, 0, sizeof(ArrayOfEmtasT), 0, soap_copy_ArrayOfEmtasT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfEmtasT * SOAP_FMAC6 soap_new_ArrayOfEmtasT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfEmtasT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfEmtasT(struct soap *soap, ArrayOfEmtasT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfEmtasT * SOAP_FMAC4 soap_instantiate_ArrayOfEmtasT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfEmtasT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfEmtasT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfEmtasT;
		if (size)
			*size = sizeof(ArrayOfEmtasT);
		((ArrayOfEmtasT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfEmtasT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfEmtasT);
		for (int i = 0; i < n; i++)
			((ArrayOfEmtasT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfEmtasT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfEmtasT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfEmtasT %p -> %p\n", q, p));
	*(ArrayOfEmtasT*)p = *(ArrayOfEmtasT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCableModemsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCableModemsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCableModemsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CableModemT(soap, this->__ptr + i);
		}
}

int ArrayOfCableModemsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCableModemsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCableModemsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCableModemsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCableModemsT(struct soap *soap, const char *tag, int id, const ArrayOfCableModemsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CableModemT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCableModemsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CableModemT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCableModemsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCableModemsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCableModemsT * SOAP_FMAC4 soap_get_ArrayOfCableModemsT(struct soap *soap, ArrayOfCableModemsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCableModemsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCableModemsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCableModemsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCableModemsT * SOAP_FMAC4 soap_in_ArrayOfCableModemsT(struct soap *soap, const char *tag, ArrayOfCableModemsT *a, const char *type)
{	int i, j;
	ns1__CableModemT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCableModemsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCableModemsT, sizeof(ArrayOfCableModemsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CableModemT **)soap_malloc(soap, sizeof(ns1__CableModemT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CableModemT(soap, NULL, a->__ptr + i, "ns1:CableModemT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CableModemT **)soap_push_block(soap, sizeof(ns1__CableModemT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CableModemT(soap, NULL, p, "ns1:CableModemT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CableModemT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCableModemsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCableModemsT, 0, sizeof(ArrayOfCableModemsT), 0, soap_copy_ArrayOfCableModemsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCableModemsT * SOAP_FMAC6 soap_new_ArrayOfCableModemsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCableModemsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCableModemsT(struct soap *soap, ArrayOfCableModemsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCableModemsT * SOAP_FMAC4 soap_instantiate_ArrayOfCableModemsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCableModemsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCableModemsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCableModemsT;
		if (size)
			*size = sizeof(ArrayOfCableModemsT);
		((ArrayOfCableModemsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCableModemsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCableModemsT);
		for (int i = 0; i < n; i++)
			((ArrayOfCableModemsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCableModemsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCableModemsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCableModemsT %p -> %p\n", q, p));
	*(ArrayOfCableModemsT*)p = *(ArrayOfCableModemsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfHfcsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfHfcsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfHfcsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__HfcT(soap, this->__ptr + i);
		}
}

int ArrayOfHfcsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfHfcsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfHfcsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfHfcsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfHfcsT(struct soap *soap, const char *tag, int id, const ArrayOfHfcsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:HfcT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfHfcsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__HfcT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfHfcsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfHfcsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfHfcsT * SOAP_FMAC4 soap_get_ArrayOfHfcsT(struct soap *soap, ArrayOfHfcsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfHfcsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfHfcsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfHfcsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfHfcsT * SOAP_FMAC4 soap_in_ArrayOfHfcsT(struct soap *soap, const char *tag, ArrayOfHfcsT *a, const char *type)
{	int i, j;
	ns1__HfcT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfHfcsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfHfcsT, sizeof(ArrayOfHfcsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__HfcT **)soap_malloc(soap, sizeof(ns1__HfcT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__HfcT(soap, NULL, a->__ptr + i, "ns1:HfcT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__HfcT **)soap_push_block(soap, sizeof(ns1__HfcT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__HfcT(soap, NULL, p, "ns1:HfcT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__HfcT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfHfcsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfHfcsT, 0, sizeof(ArrayOfHfcsT), 0, soap_copy_ArrayOfHfcsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfHfcsT * SOAP_FMAC6 soap_new_ArrayOfHfcsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfHfcsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfHfcsT(struct soap *soap, ArrayOfHfcsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfHfcsT * SOAP_FMAC4 soap_instantiate_ArrayOfHfcsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfHfcsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfHfcsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfHfcsT;
		if (size)
			*size = sizeof(ArrayOfHfcsT);
		((ArrayOfHfcsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfHfcsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfHfcsT);
		for (int i = 0; i < n; i++)
			((ArrayOfHfcsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfHfcsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfHfcsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfHfcsT %p -> %p\n", q, p));
	*(ArrayOfHfcsT*)p = *(ArrayOfHfcsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfChannelsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfChannelsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfChannelsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__ChannelT(soap, this->__ptr + i);
		}
}

int ArrayOfChannelsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfChannelsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfChannelsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfChannelsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfChannelsT(struct soap *soap, const char *tag, int id, const ArrayOfChannelsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:ChannelT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfChannelsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__ChannelT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfChannelsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfChannelsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfChannelsT * SOAP_FMAC4 soap_get_ArrayOfChannelsT(struct soap *soap, ArrayOfChannelsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfChannelsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfChannelsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfChannelsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfChannelsT * SOAP_FMAC4 soap_in_ArrayOfChannelsT(struct soap *soap, const char *tag, ArrayOfChannelsT *a, const char *type)
{	int i, j;
	ns1__ChannelT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfChannelsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfChannelsT, sizeof(ArrayOfChannelsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__ChannelT **)soap_malloc(soap, sizeof(ns1__ChannelT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__ChannelT(soap, NULL, a->__ptr + i, "ns1:ChannelT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__ChannelT **)soap_push_block(soap, sizeof(ns1__ChannelT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__ChannelT(soap, NULL, p, "ns1:ChannelT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__ChannelT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfChannelsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfChannelsT, 0, sizeof(ArrayOfChannelsT), 0, soap_copy_ArrayOfChannelsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfChannelsT * SOAP_FMAC6 soap_new_ArrayOfChannelsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfChannelsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfChannelsT(struct soap *soap, ArrayOfChannelsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfChannelsT * SOAP_FMAC4 soap_instantiate_ArrayOfChannelsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfChannelsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfChannelsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfChannelsT;
		if (size)
			*size = sizeof(ArrayOfChannelsT);
		((ArrayOfChannelsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfChannelsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfChannelsT);
		for (int i = 0; i < n; i++)
			((ArrayOfChannelsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfChannelsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfChannelsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfChannelsT %p -> %p\n", q, p));
	*(ArrayOfChannelsT*)p = *(ArrayOfChannelsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfSnmpV2CAttributesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfSnmpV2CAttributesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfSnmpV2CAttributesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__SnmpV2CAttributesT(soap, this->__ptr + i);
		}
}

int ArrayOfSnmpV2CAttributesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfSnmpV2CAttributesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfSnmpV2CAttributesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfSnmpV2CAttributesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfSnmpV2CAttributesT(struct soap *soap, const char *tag, int id, const ArrayOfSnmpV2CAttributesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:SnmpV2CAttributesT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfSnmpV2CAttributesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__SnmpV2CAttributesT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfSnmpV2CAttributesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfSnmpV2CAttributesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT * SOAP_FMAC4 soap_get_ArrayOfSnmpV2CAttributesT(struct soap *soap, ArrayOfSnmpV2CAttributesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfSnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfSnmpV2CAttributesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfSnmpV2CAttributesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT * SOAP_FMAC4 soap_in_ArrayOfSnmpV2CAttributesT(struct soap *soap, const char *tag, ArrayOfSnmpV2CAttributesT *a, const char *type)
{	int i, j;
	ns1__SnmpV2CAttributesT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfSnmpV2CAttributesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfSnmpV2CAttributesT, sizeof(ArrayOfSnmpV2CAttributesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__SnmpV2CAttributesT **)soap_malloc(soap, sizeof(ns1__SnmpV2CAttributesT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__SnmpV2CAttributesT(soap, NULL, a->__ptr + i, "ns1:SnmpV2CAttributesT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__SnmpV2CAttributesT **)soap_push_block(soap, sizeof(ns1__SnmpV2CAttributesT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__SnmpV2CAttributesT(soap, NULL, p, "ns1:SnmpV2CAttributesT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__SnmpV2CAttributesT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfSnmpV2CAttributesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfSnmpV2CAttributesT, 0, sizeof(ArrayOfSnmpV2CAttributesT), 0, soap_copy_ArrayOfSnmpV2CAttributesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfSnmpV2CAttributesT * SOAP_FMAC6 soap_new_ArrayOfSnmpV2CAttributesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfSnmpV2CAttributesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfSnmpV2CAttributesT(struct soap *soap, ArrayOfSnmpV2CAttributesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT * SOAP_FMAC4 soap_instantiate_ArrayOfSnmpV2CAttributesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfSnmpV2CAttributesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfSnmpV2CAttributesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfSnmpV2CAttributesT;
		if (size)
			*size = sizeof(ArrayOfSnmpV2CAttributesT);
		((ArrayOfSnmpV2CAttributesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfSnmpV2CAttributesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfSnmpV2CAttributesT);
		for (int i = 0; i < n; i++)
			((ArrayOfSnmpV2CAttributesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfSnmpV2CAttributesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfSnmpV2CAttributesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfSnmpV2CAttributesT %p -> %p\n", q, p));
	*(ArrayOfSnmpV2CAttributesT*)p = *(ArrayOfSnmpV2CAttributesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmtsesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmtsesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmtsesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmtsT(soap, this->__ptr + i);
		}
}

int ArrayOfCmtsesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmtsesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmtsesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmtsesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmtsesT(struct soap *soap, const char *tag, int id, const ArrayOfCmtsesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmtsT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmtsesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmtsT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmtsesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmtsesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmtsesT * SOAP_FMAC4 soap_get_ArrayOfCmtsesT(struct soap *soap, ArrayOfCmtsesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmtsesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmtsesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmtsesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmtsesT * SOAP_FMAC4 soap_in_ArrayOfCmtsesT(struct soap *soap, const char *tag, ArrayOfCmtsesT *a, const char *type)
{	int i, j;
	ns1__CmtsT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmtsesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmtsesT, sizeof(ArrayOfCmtsesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmtsT **)soap_malloc(soap, sizeof(ns1__CmtsT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmtsT(soap, NULL, a->__ptr + i, "ns1:CmtsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmtsT **)soap_push_block(soap, sizeof(ns1__CmtsT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmtsT(soap, NULL, p, "ns1:CmtsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmtsT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmtsesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmtsesT, 0, sizeof(ArrayOfCmtsesT), 0, soap_copy_ArrayOfCmtsesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmtsesT * SOAP_FMAC6 soap_new_ArrayOfCmtsesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmtsesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmtsesT(struct soap *soap, ArrayOfCmtsesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmtsesT * SOAP_FMAC4 soap_instantiate_ArrayOfCmtsesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmtsesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmtsesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmtsesT;
		if (size)
			*size = sizeof(ArrayOfCmtsesT);
		((ArrayOfCmtsesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmtsesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmtsesT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmtsesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmtsesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmtsesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmtsesT %p -> %p\n", q, p));
	*(ArrayOfCmtsesT*)p = *(ArrayOfCmtsesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfCmsesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfCmsesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfCmsesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__CmsT(soap, this->__ptr + i);
		}
}

int ArrayOfCmsesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfCmsesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfCmsesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfCmsesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfCmsesT(struct soap *soap, const char *tag, int id, const ArrayOfCmsesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:CmsT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfCmsesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__CmsT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfCmsesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfCmsesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfCmsesT * SOAP_FMAC4 soap_get_ArrayOfCmsesT(struct soap *soap, ArrayOfCmsesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfCmsesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfCmsesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfCmsesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfCmsesT * SOAP_FMAC4 soap_in_ArrayOfCmsesT(struct soap *soap, const char *tag, ArrayOfCmsesT *a, const char *type)
{	int i, j;
	ns1__CmsT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfCmsesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfCmsesT, sizeof(ArrayOfCmsesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__CmsT **)soap_malloc(soap, sizeof(ns1__CmsT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__CmsT(soap, NULL, a->__ptr + i, "ns1:CmsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__CmsT **)soap_push_block(soap, sizeof(ns1__CmsT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__CmsT(soap, NULL, p, "ns1:CmsT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__CmsT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfCmsesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfCmsesT, 0, sizeof(ArrayOfCmsesT), 0, soap_copy_ArrayOfCmsesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfCmsesT * SOAP_FMAC6 soap_new_ArrayOfCmsesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfCmsesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfCmsesT(struct soap *soap, ArrayOfCmsesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfCmsesT * SOAP_FMAC4 soap_instantiate_ArrayOfCmsesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfCmsesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfCmsesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfCmsesT;
		if (size)
			*size = sizeof(ArrayOfCmsesT);
		((ArrayOfCmsesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfCmsesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfCmsesT);
		for (int i = 0; i < n; i++)
			((ArrayOfCmsesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfCmsesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfCmsesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfCmsesT %p -> %p\n", q, p));
	*(ArrayOfCmsesT*)p = *(ArrayOfCmsesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfBladesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfBladesT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfBladesT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__BladeT(soap, this->__ptr + i);
		}
}

int ArrayOfBladesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfBladesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfBladesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfBladesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfBladesT(struct soap *soap, const char *tag, int id, const ArrayOfBladesT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:BladeT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfBladesT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__BladeT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfBladesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfBladesT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfBladesT * SOAP_FMAC4 soap_get_ArrayOfBladesT(struct soap *soap, ArrayOfBladesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfBladesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfBladesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfBladesT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfBladesT * SOAP_FMAC4 soap_in_ArrayOfBladesT(struct soap *soap, const char *tag, ArrayOfBladesT *a, const char *type)
{	int i, j;
	ns1__BladeT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfBladesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfBladesT, sizeof(ArrayOfBladesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__BladeT **)soap_malloc(soap, sizeof(ns1__BladeT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__BladeT(soap, NULL, a->__ptr + i, "ns1:BladeT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__BladeT **)soap_push_block(soap, sizeof(ns1__BladeT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__BladeT(soap, NULL, p, "ns1:BladeT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__BladeT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfBladesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfBladesT, 0, sizeof(ArrayOfBladesT), 0, soap_copy_ArrayOfBladesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfBladesT * SOAP_FMAC6 soap_new_ArrayOfBladesT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfBladesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfBladesT(struct soap *soap, ArrayOfBladesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfBladesT * SOAP_FMAC4 soap_instantiate_ArrayOfBladesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfBladesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfBladesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfBladesT;
		if (size)
			*size = sizeof(ArrayOfBladesT);
		((ArrayOfBladesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfBladesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfBladesT);
		for (int i = 0; i < n; i++)
			((ArrayOfBladesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfBladesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfBladesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfBladesT %p -> %p\n", q, p));
	*(ArrayOfBladesT*)p = *(ArrayOfBladesT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfMarketsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfMarketsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfMarketsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__MarketT(soap, this->__ptr + i);
		}
}

int ArrayOfMarketsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfMarketsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfMarketsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfMarketsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfMarketsT(struct soap *soap, const char *tag, int id, const ArrayOfMarketsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:MarketT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfMarketsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__MarketT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfMarketsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfMarketsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfMarketsT * SOAP_FMAC4 soap_get_ArrayOfMarketsT(struct soap *soap, ArrayOfMarketsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfMarketsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfMarketsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfMarketsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfMarketsT * SOAP_FMAC4 soap_in_ArrayOfMarketsT(struct soap *soap, const char *tag, ArrayOfMarketsT *a, const char *type)
{	int i, j;
	ns1__MarketT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfMarketsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfMarketsT, sizeof(ArrayOfMarketsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__MarketT **)soap_malloc(soap, sizeof(ns1__MarketT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__MarketT(soap, NULL, a->__ptr + i, "ns1:MarketT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__MarketT **)soap_push_block(soap, sizeof(ns1__MarketT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__MarketT(soap, NULL, p, "ns1:MarketT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__MarketT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfMarketsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfMarketsT, 0, sizeof(ArrayOfMarketsT), 0, soap_copy_ArrayOfMarketsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfMarketsT * SOAP_FMAC6 soap_new_ArrayOfMarketsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfMarketsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfMarketsT(struct soap *soap, ArrayOfMarketsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfMarketsT * SOAP_FMAC4 soap_instantiate_ArrayOfMarketsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfMarketsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfMarketsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfMarketsT;
		if (size)
			*size = sizeof(ArrayOfMarketsT);
		((ArrayOfMarketsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfMarketsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfMarketsT);
		for (int i = 0; i < n; i++)
			((ArrayOfMarketsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfMarketsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfMarketsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfMarketsT %p -> %p\n", q, p));
	*(ArrayOfMarketsT*)p = *(ArrayOfMarketsT*)q;
}
#ifdef __cplusplus
}
#endif

void ArrayOfRegionsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	this->__size = 0;
	this->__ptr = NULL;
}

void ArrayOfRegionsT::soap_serialize(struct soap *soap) const
{
	if (this->__ptr && !soap_array_reference(soap, this, (struct soap_array*)&this->__ptr, 1, SOAP_TYPE_ArrayOfRegionsT))
		for (int i = 0; i < this->__size; i++)
		{
			soap_serialize_PointerTons1__RegionT(soap, this->__ptr + i);
		}
}

int ArrayOfRegionsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, (struct soap_array*)&this->__ptr, 1, tag, SOAP_TYPE_ArrayOfRegionsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ArrayOfRegionsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{	return soap_out_ArrayOfRegionsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ArrayOfRegionsT(struct soap *soap, const char *tag, int id, const ArrayOfRegionsT *a, const char *type)
{
	int i, n = a->__size;
	char *t = soap_putsize(soap, "ns1:RegionT", a->__size);
	id = soap_element_id(soap, tag, id, a, (struct soap_array*)&a->__ptr, 1, type, SOAP_TYPE_ArrayOfRegionsT);
	if (id < 0)
		return soap->error;
	soap_array_begin_out(soap, tag, id, t, NULL);
	for (i = 0; i < n; i++)
	{
		soap->position = 1;
		soap->positions[0] = i;
		soap_out_PointerTons1__RegionT(soap, "item", -1, &a->__ptr[i], "");
	}
	soap->position = 0;
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ArrayOfRegionsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ArrayOfRegionsT(soap, this, tag, type);
}

SOAP_FMAC3 ArrayOfRegionsT * SOAP_FMAC4 soap_get_ArrayOfRegionsT(struct soap *soap, ArrayOfRegionsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ArrayOfRegionsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ArrayOfRegionsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ArrayOfRegionsT(soap, tag, this, type);
}

SOAP_FMAC3 ArrayOfRegionsT * SOAP_FMAC4 soap_in_ArrayOfRegionsT(struct soap *soap, const char *tag, ArrayOfRegionsT *a, const char *type)
{	int i, j;
	ns1__RegionT **p;
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (soap_match_array(soap, type))
	{	soap->error = SOAP_TYPE;
		return NULL;
	}
	a = (ArrayOfRegionsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ArrayOfRegionsT, sizeof(ArrayOfRegionsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
		a->soap_default(soap);
	if (soap->body && !*soap->href)
	{
		a->__size = soap_getsize(soap->arraySize, soap->arrayOffset, &j);
		if (a->__size >= 0)
		{	a->__ptr = (ns1__RegionT **)soap_malloc(soap, sizeof(ns1__RegionT *) * a->__size);
			for (i = 0; i < a->__size; i++)
				a->__ptr[i] = NULL;
			for (i = 0; i < a->__size; i++)
			{	soap_peek_element(soap);
				if (soap->position)
				{	i = soap->positions[0]-j;
					if (i < 0 || i >= a->__size)
					{	soap->error = SOAP_IOB;
						return NULL;
					}
				}
				if (!soap_in_PointerTons1__RegionT(soap, NULL, a->__ptr + i, "ns1:RegionT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
		}
		else
		{	soap_new_block(soap);
			for (a->__size = 0; ; a->__size++)
			{	p = (ns1__RegionT **)soap_push_block(soap, sizeof(ns1__RegionT *));
				if (!p)
					return NULL;
				*p = NULL;
				if (!soap_in_PointerTons1__RegionT(soap, NULL, p, "ns1:RegionT"))
				{	if (soap->error != SOAP_NO_TAG)
						return NULL;
					soap->error = SOAP_OK;
					break;
				}
			}
			soap_pop_block(soap);
			a->__ptr = (ns1__RegionT **)soap_malloc(soap, soap->blist->size);
			soap_save_block(soap, (char*)a->__ptr, 1);
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ArrayOfRegionsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ArrayOfRegionsT, 0, sizeof(ArrayOfRegionsT), 0, soap_copy_ArrayOfRegionsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ArrayOfRegionsT * SOAP_FMAC6 soap_new_ArrayOfRegionsT(struct soap *soap, int n)
{	return soap_instantiate_ArrayOfRegionsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ArrayOfRegionsT(struct soap *soap, ArrayOfRegionsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ArrayOfRegionsT * SOAP_FMAC4 soap_instantiate_ArrayOfRegionsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ArrayOfRegionsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ArrayOfRegionsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ArrayOfRegionsT;
		if (size)
			*size = sizeof(ArrayOfRegionsT);
		((ArrayOfRegionsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ArrayOfRegionsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ArrayOfRegionsT);
		for (int i = 0; i < n; i++)
			((ArrayOfRegionsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ArrayOfRegionsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ArrayOfRegionsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ArrayOfRegionsT %p -> %p\n", q, p));
	*(ArrayOfRegionsT*)p = *(ArrayOfRegionsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AlarmHistoryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__AlarmHistoryT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__AlarmHistoryT*)this)->alarmId);
	soap_default_std__string(soap, &((ns1__AlarmHistoryT*)this)->timeStamp);
	soap_default_std__string(soap, &((ns1__AlarmHistoryT*)this)->alarmState);
	/* transient soap skipped */
}

void ns1__AlarmHistoryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__AlarmHistoryT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__AlarmHistoryT*)this)->alarmId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AlarmHistoryT*)this)->alarmId);
	soap_embedded(soap, &((ns1__AlarmHistoryT*)this)->timeStamp, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmHistoryT*)this)->timeStamp);
	soap_embedded(soap, &((ns1__AlarmHistoryT*)this)->alarmState, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AlarmHistoryT*)this)->alarmState);
	/* transient soap skipped */
}

int ns1__AlarmHistoryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AlarmHistoryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AlarmHistoryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AlarmHistoryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AlarmHistoryT(struct soap *soap, const char *tag, int id, const ns1__AlarmHistoryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AlarmHistoryT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__AlarmHistoryT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "alarmId", -1, &(((ns1__AlarmHistoryT*)a)->alarmId), "");
	soap_out_std__string(soap, "timeStamp", -1, &(((ns1__AlarmHistoryT*)a)->timeStamp), "");
	soap_out_std__string(soap, "alarmState", -1, &(((ns1__AlarmHistoryT*)a)->alarmState), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AlarmHistoryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AlarmHistoryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT * SOAP_FMAC4 soap_get_ns1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AlarmHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AlarmHistoryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AlarmHistoryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT * SOAP_FMAC4 soap_in_ns1__AlarmHistoryT(struct soap *soap, const char *tag, ns1__AlarmHistoryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AlarmHistoryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AlarmHistoryT, sizeof(ns1__AlarmHistoryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AlarmHistoryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AlarmHistoryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_alarmId1 = 1, soap_flag_timeStamp1 = 1, soap_flag_alarmState1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__AlarmHistoryT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_alarmId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmId", &(((ns1__AlarmHistoryT*)a)->alarmId), "xsd:integer"))
				{	soap_flag_alarmId1--;
					continue;
				}
			if (soap_flag_timeStamp1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "timeStamp", &(((ns1__AlarmHistoryT*)a)->timeStamp), "xsd:string"))
				{	soap_flag_timeStamp1--;
					continue;
				}
			if (soap_flag_alarmState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmState", &(((ns1__AlarmHistoryT*)a)->alarmState), "xsd:string"))
				{	soap_flag_alarmState1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_alarmId1 > 0 || soap_flag_timeStamp1 > 0 || soap_flag_alarmState1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AlarmHistoryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AlarmHistoryT, 0, sizeof(ns1__AlarmHistoryT), 0, soap_copy_ns1__AlarmHistoryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AlarmHistoryT * SOAP_FMAC6 soap_new_ns1__AlarmHistoryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AlarmHistoryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AlarmHistoryT * SOAP_FMAC4 soap_instantiate_ns1__AlarmHistoryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AlarmHistoryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AlarmHistoryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AlarmHistoryT;
		if (size)
			*size = sizeof(ns1__AlarmHistoryT);
		((ns1__AlarmHistoryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AlarmHistoryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AlarmHistoryT);
		for (int i = 0; i < n; i++)
			((ns1__AlarmHistoryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AlarmHistoryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AlarmHistoryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AlarmHistoryT %p -> %p\n", q, p));
	*(ns1__AlarmHistoryT*)p = *(ns1__AlarmHistoryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HistoricalAlarmDetailsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HistoricalAlarmDetailsT*)this)->historicalAlarm = NULL;
	soap_default_std__string(soap, &((ns1__HistoricalAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

void ns1__HistoricalAlarmDetailsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HistoricalAlarmT(soap, &((ns1__HistoricalAlarmDetailsT*)this)->historicalAlarm);
	soap_embedded(soap, &((ns1__HistoricalAlarmDetailsT*)this)->alarmDetails, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HistoricalAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

int ns1__HistoricalAlarmDetailsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HistoricalAlarmDetailsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HistoricalAlarmDetailsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistoricalAlarmDetailsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistoricalAlarmDetailsT(struct soap *soap, const char *tag, int id, const ns1__HistoricalAlarmDetailsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistoricalAlarmDetailsT), type);
	soap_out_PointerTons1__HistoricalAlarmT(soap, "historicalAlarm", -1, &(((ns1__HistoricalAlarmDetailsT*)a)->historicalAlarm), "");
	soap_out_std__string(soap, "alarmDetails", -1, &(((ns1__HistoricalAlarmDetailsT*)a)->alarmDetails), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HistoricalAlarmDetailsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistoricalAlarmDetailsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmDetailsT * SOAP_FMAC4 soap_get_ns1__HistoricalAlarmDetailsT(struct soap *soap, ns1__HistoricalAlarmDetailsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistoricalAlarmDetailsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HistoricalAlarmDetailsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HistoricalAlarmDetailsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmDetailsT * SOAP_FMAC4 soap_in_ns1__HistoricalAlarmDetailsT(struct soap *soap, const char *tag, ns1__HistoricalAlarmDetailsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistoricalAlarmDetailsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistoricalAlarmDetailsT, sizeof(ns1__HistoricalAlarmDetailsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HistoricalAlarmDetailsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HistoricalAlarmDetailsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_historicalAlarm1 = 1, soap_flag_alarmDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_historicalAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HistoricalAlarmT(soap, "historicalAlarm", &(((ns1__HistoricalAlarmDetailsT*)a)->historicalAlarm), "ns1:HistoricalAlarmT"))
				{	soap_flag_historicalAlarm1--;
					continue;
				}
			if (soap_flag_alarmDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmDetails", &(((ns1__HistoricalAlarmDetailsT*)a)->alarmDetails), "xsd:string"))
				{	soap_flag_alarmDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_historicalAlarm1 > 0 || soap_flag_alarmDetails1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmDetailsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistoricalAlarmDetailsT, 0, sizeof(ns1__HistoricalAlarmDetailsT), 0, soap_copy_ns1__HistoricalAlarmDetailsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HistoricalAlarmDetailsT * SOAP_FMAC6 soap_new_ns1__HistoricalAlarmDetailsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HistoricalAlarmDetailsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HistoricalAlarmDetailsT(struct soap *soap, ns1__HistoricalAlarmDetailsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HistoricalAlarmDetailsT * SOAP_FMAC4 soap_instantiate_ns1__HistoricalAlarmDetailsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistoricalAlarmDetailsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HistoricalAlarmDetailsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HistoricalAlarmDetailsT;
		if (size)
			*size = sizeof(ns1__HistoricalAlarmDetailsT);
		((ns1__HistoricalAlarmDetailsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HistoricalAlarmDetailsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HistoricalAlarmDetailsT);
		for (int i = 0; i < n; i++)
			((ns1__HistoricalAlarmDetailsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HistoricalAlarmDetailsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HistoricalAlarmDetailsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HistoricalAlarmDetailsT %p -> %p\n", q, p));
	*(ns1__HistoricalAlarmDetailsT*)p = *(ns1__HistoricalAlarmDetailsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HistoricalAlarmT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HistoricalAlarmT*)this)->abstractAlarm = NULL;
	soap_default_std__string(soap, &((ns1__HistoricalAlarmT*)this)->clearedUser);
	/* transient soap skipped */
}

void ns1__HistoricalAlarmT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AbstractAlarmT(soap, &((ns1__HistoricalAlarmT*)this)->abstractAlarm);
	soap_embedded(soap, &((ns1__HistoricalAlarmT*)this)->clearedUser, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HistoricalAlarmT*)this)->clearedUser);
	/* transient soap skipped */
}

int ns1__HistoricalAlarmT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HistoricalAlarmT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HistoricalAlarmT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HistoricalAlarmT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HistoricalAlarmT(struct soap *soap, const char *tag, int id, const ns1__HistoricalAlarmT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HistoricalAlarmT), type);
	soap_out_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", -1, &(((ns1__HistoricalAlarmT*)a)->abstractAlarm), "");
	soap_out_std__string(soap, "clearedUser", -1, &(((ns1__HistoricalAlarmT*)a)->clearedUser), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HistoricalAlarmT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HistoricalAlarmT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT * SOAP_FMAC4 soap_get_ns1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HistoricalAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HistoricalAlarmT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HistoricalAlarmT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT * SOAP_FMAC4 soap_in_ns1__HistoricalAlarmT(struct soap *soap, const char *tag, ns1__HistoricalAlarmT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HistoricalAlarmT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HistoricalAlarmT, sizeof(ns1__HistoricalAlarmT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HistoricalAlarmT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HistoricalAlarmT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_abstractAlarm1 = 1, soap_flag_clearedUser1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_abstractAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", &(((ns1__HistoricalAlarmT*)a)->abstractAlarm), "ns1:AbstractAlarmT"))
				{	soap_flag_abstractAlarm1--;
					continue;
				}
			if (soap_flag_clearedUser1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "clearedUser", &(((ns1__HistoricalAlarmT*)a)->clearedUser), "xsd:string"))
				{	soap_flag_clearedUser1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_abstractAlarm1 > 0 || soap_flag_clearedUser1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HistoricalAlarmT, 0, sizeof(ns1__HistoricalAlarmT), 0, soap_copy_ns1__HistoricalAlarmT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HistoricalAlarmT * SOAP_FMAC6 soap_new_ns1__HistoricalAlarmT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HistoricalAlarmT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HistoricalAlarmT * SOAP_FMAC4 soap_instantiate_ns1__HistoricalAlarmT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HistoricalAlarmT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HistoricalAlarmT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HistoricalAlarmT;
		if (size)
			*size = sizeof(ns1__HistoricalAlarmT);
		((ns1__HistoricalAlarmT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HistoricalAlarmT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HistoricalAlarmT);
		for (int i = 0; i < n; i++)
			((ns1__HistoricalAlarmT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HistoricalAlarmT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HistoricalAlarmT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HistoricalAlarmT %p -> %p\n", q, p));
	*(ns1__HistoricalAlarmT*)p = *(ns1__HistoricalAlarmT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CurrentAlarmDetailsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CurrentAlarmDetailsT*)this)->currentAlarm = NULL;
	soap_default_std__string(soap, &((ns1__CurrentAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

void ns1__CurrentAlarmDetailsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CurrentAlarmT(soap, &((ns1__CurrentAlarmDetailsT*)this)->currentAlarm);
	soap_embedded(soap, &((ns1__CurrentAlarmDetailsT*)this)->alarmDetails, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CurrentAlarmDetailsT*)this)->alarmDetails);
	/* transient soap skipped */
}

int ns1__CurrentAlarmDetailsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CurrentAlarmDetailsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CurrentAlarmDetailsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CurrentAlarmDetailsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CurrentAlarmDetailsT(struct soap *soap, const char *tag, int id, const ns1__CurrentAlarmDetailsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CurrentAlarmDetailsT), type);
	soap_out_PointerTons1__CurrentAlarmT(soap, "currentAlarm", -1, &(((ns1__CurrentAlarmDetailsT*)a)->currentAlarm), "");
	soap_out_std__string(soap, "alarmDetails", -1, &(((ns1__CurrentAlarmDetailsT*)a)->alarmDetails), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CurrentAlarmDetailsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CurrentAlarmDetailsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CurrentAlarmDetailsT * SOAP_FMAC4 soap_get_ns1__CurrentAlarmDetailsT(struct soap *soap, ns1__CurrentAlarmDetailsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CurrentAlarmDetailsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CurrentAlarmDetailsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CurrentAlarmDetailsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CurrentAlarmDetailsT * SOAP_FMAC4 soap_in_ns1__CurrentAlarmDetailsT(struct soap *soap, const char *tag, ns1__CurrentAlarmDetailsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CurrentAlarmDetailsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CurrentAlarmDetailsT, sizeof(ns1__CurrentAlarmDetailsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CurrentAlarmDetailsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CurrentAlarmDetailsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_currentAlarm1 = 1, soap_flag_alarmDetails1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_currentAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CurrentAlarmT(soap, "currentAlarm", &(((ns1__CurrentAlarmDetailsT*)a)->currentAlarm), "ns1:CurrentAlarmT"))
				{	soap_flag_currentAlarm1--;
					continue;
				}
			if (soap_flag_alarmDetails1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmDetails", &(((ns1__CurrentAlarmDetailsT*)a)->alarmDetails), "xsd:string"))
				{	soap_flag_alarmDetails1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_currentAlarm1 > 0 || soap_flag_alarmDetails1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmDetailsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CurrentAlarmDetailsT, 0, sizeof(ns1__CurrentAlarmDetailsT), 0, soap_copy_ns1__CurrentAlarmDetailsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CurrentAlarmDetailsT * SOAP_FMAC6 soap_new_ns1__CurrentAlarmDetailsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CurrentAlarmDetailsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CurrentAlarmDetailsT(struct soap *soap, ns1__CurrentAlarmDetailsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CurrentAlarmDetailsT * SOAP_FMAC4 soap_instantiate_ns1__CurrentAlarmDetailsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CurrentAlarmDetailsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CurrentAlarmDetailsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CurrentAlarmDetailsT;
		if (size)
			*size = sizeof(ns1__CurrentAlarmDetailsT);
		((ns1__CurrentAlarmDetailsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CurrentAlarmDetailsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CurrentAlarmDetailsT);
		for (int i = 0; i < n; i++)
			((ns1__CurrentAlarmDetailsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CurrentAlarmDetailsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CurrentAlarmDetailsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CurrentAlarmDetailsT %p -> %p\n", q, p));
	*(ns1__CurrentAlarmDetailsT*)p = *(ns1__CurrentAlarmDetailsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CurrentAlarmT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CurrentAlarmT*)this)->abstractAlarm = NULL;
	/* transient soap skipped */
}

void ns1__CurrentAlarmT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__AbstractAlarmT(soap, &((ns1__CurrentAlarmT*)this)->abstractAlarm);
	/* transient soap skipped */
}

int ns1__CurrentAlarmT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CurrentAlarmT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CurrentAlarmT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CurrentAlarmT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CurrentAlarmT(struct soap *soap, const char *tag, int id, const ns1__CurrentAlarmT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CurrentAlarmT), type);
	soap_out_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", -1, &(((ns1__CurrentAlarmT*)a)->abstractAlarm), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CurrentAlarmT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CurrentAlarmT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT * SOAP_FMAC4 soap_get_ns1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CurrentAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CurrentAlarmT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CurrentAlarmT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT * SOAP_FMAC4 soap_in_ns1__CurrentAlarmT(struct soap *soap, const char *tag, ns1__CurrentAlarmT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CurrentAlarmT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CurrentAlarmT, sizeof(ns1__CurrentAlarmT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CurrentAlarmT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CurrentAlarmT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_abstractAlarm1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_abstractAlarm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__AbstractAlarmT(soap, "abstractAlarm", &(((ns1__CurrentAlarmT*)a)->abstractAlarm), "ns1:AbstractAlarmT"))
				{	soap_flag_abstractAlarm1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_abstractAlarm1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CurrentAlarmT, 0, sizeof(ns1__CurrentAlarmT), 0, soap_copy_ns1__CurrentAlarmT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CurrentAlarmT * SOAP_FMAC6 soap_new_ns1__CurrentAlarmT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CurrentAlarmT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CurrentAlarmT * SOAP_FMAC4 soap_instantiate_ns1__CurrentAlarmT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CurrentAlarmT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CurrentAlarmT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CurrentAlarmT;
		if (size)
			*size = sizeof(ns1__CurrentAlarmT);
		((ns1__CurrentAlarmT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CurrentAlarmT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CurrentAlarmT);
		for (int i = 0; i < n; i++)
			((ns1__CurrentAlarmT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CurrentAlarmT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CurrentAlarmT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CurrentAlarmT %p -> %p\n", q, p));
	*(ns1__CurrentAlarmT*)p = *(ns1__CurrentAlarmT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__AbstractAlarmT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__AbstractAlarmT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmId);
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->resourceId);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->resourceName);
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTime);
	soap_default_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTimeUSec);
	soap_default_short(soap, &((ns1__AbstractAlarmT*)this)->soakDuration);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmState);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmType);
	soap_default_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmSubType);
	/* transient soap skipped */
}

void ns1__AbstractAlarmT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__AbstractAlarmT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmId);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->resourceId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->resourceId);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->resourceName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->resourceName);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmTime, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTime);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmTimeUSec, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__AbstractAlarmT*)this)->alarmTimeUSec);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->soakDuration, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmState, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmState);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmType);
	soap_embedded(soap, &((ns1__AbstractAlarmT*)this)->alarmSubType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__AbstractAlarmT*)this)->alarmSubType);
	/* transient soap skipped */
}

int ns1__AbstractAlarmT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__AbstractAlarmT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__AbstractAlarmT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__AbstractAlarmT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__AbstractAlarmT(struct soap *soap, const char *tag, int id, const ns1__AbstractAlarmT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__AbstractAlarmT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__AbstractAlarmT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "alarmId", -1, &(((ns1__AbstractAlarmT*)a)->alarmId), "");
	soap_out_xsd__integer(soap, "resourceId", -1, &(((ns1__AbstractAlarmT*)a)->resourceId), "");
	soap_out_std__string(soap, "resourceName", -1, &(((ns1__AbstractAlarmT*)a)->resourceName), "");
	soap_out_xsd__integer(soap, "alarmTime", -1, &(((ns1__AbstractAlarmT*)a)->alarmTime), "");
	soap_out_xsd__integer(soap, "alarmTimeUSec", -1, &(((ns1__AbstractAlarmT*)a)->alarmTimeUSec), "");
	soap_out_short(soap, "soakDuration", -1, &(((ns1__AbstractAlarmT*)a)->soakDuration), "");
	soap_out_std__string(soap, "alarmState", -1, &(((ns1__AbstractAlarmT*)a)->alarmState), "");
	soap_out_std__string(soap, "alarmType", -1, &(((ns1__AbstractAlarmT*)a)->alarmType), "");
	soap_out_std__string(soap, "alarmSubType", -1, &(((ns1__AbstractAlarmT*)a)->alarmSubType), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__AbstractAlarmT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__AbstractAlarmT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__AbstractAlarmT * SOAP_FMAC4 soap_get_ns1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__AbstractAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__AbstractAlarmT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__AbstractAlarmT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__AbstractAlarmT * SOAP_FMAC4 soap_in_ns1__AbstractAlarmT(struct soap *soap, const char *tag, ns1__AbstractAlarmT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__AbstractAlarmT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__AbstractAlarmT, sizeof(ns1__AbstractAlarmT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__AbstractAlarmT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__AbstractAlarmT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_alarmId1 = 1, soap_flag_resourceId1 = 1, soap_flag_resourceName1 = 1, soap_flag_alarmTime1 = 1, soap_flag_alarmTimeUSec1 = 1, soap_flag_soakDuration1 = 1, soap_flag_alarmState1 = 1, soap_flag_alarmType1 = 1, soap_flag_alarmSubType1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__AbstractAlarmT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_alarmId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmId", &(((ns1__AbstractAlarmT*)a)->alarmId), "xsd:integer"))
				{	soap_flag_alarmId1--;
					continue;
				}
			if (soap_flag_resourceId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "resourceId", &(((ns1__AbstractAlarmT*)a)->resourceId), "xsd:integer"))
				{	soap_flag_resourceId1--;
					continue;
				}
			if (soap_flag_resourceName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "resourceName", &(((ns1__AbstractAlarmT*)a)->resourceName), "xsd:string"))
				{	soap_flag_resourceName1--;
					continue;
				}
			if (soap_flag_alarmTime1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmTime", &(((ns1__AbstractAlarmT*)a)->alarmTime), "xsd:integer"))
				{	soap_flag_alarmTime1--;
					continue;
				}
			if (soap_flag_alarmTimeUSec1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "alarmTimeUSec", &(((ns1__AbstractAlarmT*)a)->alarmTimeUSec), "xsd:integer"))
				{	soap_flag_alarmTimeUSec1--;
					continue;
				}
			if (soap_flag_soakDuration1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "soakDuration", &(((ns1__AbstractAlarmT*)a)->soakDuration), "xsd:short"))
				{	soap_flag_soakDuration1--;
					continue;
				}
			if (soap_flag_alarmState1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmState", &(((ns1__AbstractAlarmT*)a)->alarmState), "xsd:string"))
				{	soap_flag_alarmState1--;
					continue;
				}
			if (soap_flag_alarmType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmType", &(((ns1__AbstractAlarmT*)a)->alarmType), "xsd:string"))
				{	soap_flag_alarmType1--;
					continue;
				}
			if (soap_flag_alarmSubType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "alarmSubType", &(((ns1__AbstractAlarmT*)a)->alarmSubType), "xsd:string"))
				{	soap_flag_alarmSubType1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_alarmId1 > 0 || soap_flag_resourceId1 > 0 || soap_flag_resourceName1 > 0 || soap_flag_alarmTime1 > 0 || soap_flag_alarmTimeUSec1 > 0 || soap_flag_soakDuration1 > 0 || soap_flag_alarmState1 > 0 || soap_flag_alarmType1 > 0 || soap_flag_alarmSubType1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__AbstractAlarmT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__AbstractAlarmT, 0, sizeof(ns1__AbstractAlarmT), 0, soap_copy_ns1__AbstractAlarmT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__AbstractAlarmT * SOAP_FMAC6 soap_new_ns1__AbstractAlarmT(struct soap *soap, int n)
{	return soap_instantiate_ns1__AbstractAlarmT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__AbstractAlarmT * SOAP_FMAC4 soap_instantiate_ns1__AbstractAlarmT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__AbstractAlarmT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__AbstractAlarmT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__AbstractAlarmT;
		if (size)
			*size = sizeof(ns1__AbstractAlarmT);
		((ns1__AbstractAlarmT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__AbstractAlarmT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__AbstractAlarmT);
		for (int i = 0; i < n; i++)
			((ns1__AbstractAlarmT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__AbstractAlarmT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__AbstractAlarmT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__AbstractAlarmT %p -> %p\n", q, p));
	*(ns1__AbstractAlarmT*)p = *(ns1__AbstractAlarmT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__EmtaSecondaryT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__EmtaSecondaryT*)this)->phone1);
	soap_default_std__string(soap, &((ns1__EmtaSecondaryT*)this)->phone2);
	/* transient soap skipped */
}

void ns1__EmtaSecondaryT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__EmtaSecondaryT*)this)->phone1, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__EmtaSecondaryT*)this)->phone1);
	soap_embedded(soap, &((ns1__EmtaSecondaryT*)this)->phone2, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__EmtaSecondaryT*)this)->phone2);
	/* transient soap skipped */
}

int ns1__EmtaSecondaryT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EmtaSecondaryT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__EmtaSecondaryT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EmtaSecondaryT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EmtaSecondaryT(struct soap *soap, const char *tag, int id, const ns1__EmtaSecondaryT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EmtaSecondaryT), type);
	soap_out_std__string(soap, "phone1", -1, &(((ns1__EmtaSecondaryT*)a)->phone1), "");
	soap_out_std__string(soap, "phone2", -1, &(((ns1__EmtaSecondaryT*)a)->phone2), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__EmtaSecondaryT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EmtaSecondaryT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EmtaSecondaryT * SOAP_FMAC4 soap_get_ns1__EmtaSecondaryT(struct soap *soap, ns1__EmtaSecondaryT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EmtaSecondaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__EmtaSecondaryT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EmtaSecondaryT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EmtaSecondaryT * SOAP_FMAC4 soap_in_ns1__EmtaSecondaryT(struct soap *soap, const char *tag, ns1__EmtaSecondaryT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EmtaSecondaryT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EmtaSecondaryT, sizeof(ns1__EmtaSecondaryT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EmtaSecondaryT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EmtaSecondaryT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_phone11 = 1, soap_flag_phone21 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_phone11 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "phone1", &(((ns1__EmtaSecondaryT*)a)->phone1), "xsd:string"))
				{	soap_flag_phone11--;
					continue;
				}
			if (soap_flag_phone21 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "phone2", &(((ns1__EmtaSecondaryT*)a)->phone2), "xsd:string"))
				{	soap_flag_phone21--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_phone11 > 0 || soap_flag_phone21 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EmtaSecondaryT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EmtaSecondaryT, 0, sizeof(ns1__EmtaSecondaryT), 0, soap_copy_ns1__EmtaSecondaryT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__EmtaSecondaryT * SOAP_FMAC6 soap_new_ns1__EmtaSecondaryT(struct soap *soap, int n)
{	return soap_instantiate_ns1__EmtaSecondaryT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__EmtaSecondaryT(struct soap *soap, ns1__EmtaSecondaryT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__EmtaSecondaryT * SOAP_FMAC4 soap_instantiate_ns1__EmtaSecondaryT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EmtaSecondaryT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EmtaSecondaryT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__EmtaSecondaryT;
		if (size)
			*size = sizeof(ns1__EmtaSecondaryT);
		((ns1__EmtaSecondaryT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__EmtaSecondaryT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EmtaSecondaryT);
		for (int i = 0; i < n; i++)
			((ns1__EmtaSecondaryT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EmtaSecondaryT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EmtaSecondaryT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EmtaSecondaryT %p -> %p\n", q, p));
	*(ns1__EmtaSecondaryT*)p = *(ns1__EmtaSecondaryT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__EmtaT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__EmtaT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__EmtaT*)this)->emtaResId);
	((ns1__EmtaT*)this)->cmResId = NULL;
	soap_default_std__string(soap, &((ns1__EmtaT*)this)->macAddress);
	soap_default_ns1__StatusColorT(soap, &((ns1__EmtaT*)this)->statusColor);
	soap_default_std__string(soap, &((ns1__EmtaT*)this)->host);
	soap_default_std__string(soap, &((ns1__EmtaT*)this)->fqdn);
	/* transient soap skipped */
}

void ns1__EmtaT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__EmtaT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__EmtaT*)this)->emtaResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__EmtaT*)this)->emtaResId);
	soap_serialize_PointerToxsd__integer(soap, &((ns1__EmtaT*)this)->cmResId);
	soap_embedded(soap, &((ns1__EmtaT*)this)->macAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__EmtaT*)this)->macAddress);
	soap_embedded(soap, &((ns1__EmtaT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__EmtaT*)this)->host);
	soap_embedded(soap, &((ns1__EmtaT*)this)->fqdn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__EmtaT*)this)->fqdn);
	/* transient soap skipped */
}

int ns1__EmtaT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__EmtaT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__EmtaT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__EmtaT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__EmtaT(struct soap *soap, const char *tag, int id, const ns1__EmtaT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__EmtaT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__EmtaT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "emtaResId", -1, &(((ns1__EmtaT*)a)->emtaResId), "");
	soap_out_PointerToxsd__integer(soap, "cmResId", -1, &(((ns1__EmtaT*)a)->cmResId), "");
	soap_out_std__string(soap, "macAddress", -1, &(((ns1__EmtaT*)a)->macAddress), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__EmtaT*)a)->statusColor), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__EmtaT*)a)->host), "");
	soap_out_std__string(soap, "fqdn", -1, &(((ns1__EmtaT*)a)->fqdn), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__EmtaT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__EmtaT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__EmtaT * SOAP_FMAC4 soap_get_ns1__EmtaT(struct soap *soap, ns1__EmtaT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__EmtaT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__EmtaT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__EmtaT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__EmtaT * SOAP_FMAC4 soap_in_ns1__EmtaT(struct soap *soap, const char *tag, ns1__EmtaT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__EmtaT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__EmtaT, sizeof(ns1__EmtaT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__EmtaT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__EmtaT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_emtaResId1 = 1, soap_flag_cmResId1 = 1, soap_flag_macAddress1 = 1, soap_flag_statusColor1 = 1, soap_flag_host1 = 1, soap_flag_fqdn1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__EmtaT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_emtaResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "emtaResId", &(((ns1__EmtaT*)a)->emtaResId), "xsd:integer"))
				{	soap_flag_emtaResId1--;
					continue;
				}
			if (soap_flag_cmResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerToxsd__integer(soap, "cmResId", &(((ns1__EmtaT*)a)->cmResId), "xsd:integer"))
				{	soap_flag_cmResId1--;
					continue;
				}
			if (soap_flag_macAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "macAddress", &(((ns1__EmtaT*)a)->macAddress), "xsd:string"))
				{	soap_flag_macAddress1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__EmtaT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__EmtaT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			if (soap_flag_fqdn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "fqdn", &(((ns1__EmtaT*)a)->fqdn), "xsd:string"))
				{	soap_flag_fqdn1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_emtaResId1 > 0 || soap_flag_macAddress1 > 0 || soap_flag_statusColor1 > 0 || soap_flag_host1 > 0 || soap_flag_fqdn1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__EmtaT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__EmtaT, 0, sizeof(ns1__EmtaT), 0, soap_copy_ns1__EmtaT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__EmtaT * SOAP_FMAC6 soap_new_ns1__EmtaT(struct soap *soap, int n)
{	return soap_instantiate_ns1__EmtaT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__EmtaT(struct soap *soap, ns1__EmtaT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__EmtaT * SOAP_FMAC4 soap_instantiate_ns1__EmtaT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__EmtaT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__EmtaT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__EmtaT;
		if (size)
			*size = sizeof(ns1__EmtaT);
		((ns1__EmtaT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__EmtaT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__EmtaT);
		for (int i = 0; i < n; i++)
			((ns1__EmtaT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__EmtaT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__EmtaT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__EmtaT %p -> %p\n", q, p));
	*(ns1__EmtaT*)p = *(ns1__EmtaT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CableModemT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CableModemT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->cmResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->cmtsResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->upChannelResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->downChannelResId);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->hfcResId);
	soap_default_std__string(soap, &((ns1__CableModemT*)this)->macAddress);
	soap_default_ns1__StatusColorT(soap, &((ns1__CableModemT*)this)->statusColor);
	soap_default_std__string(soap, &((ns1__CableModemT*)this)->cmStatus);
	soap_default_std__string(soap, &((ns1__CableModemT*)this)->host);
	soap_default_std__string(soap, &((ns1__CableModemT*)this)->fqdn);
	soap_default_xsd__integer(soap, &((ns1__CableModemT*)this)->cmIndex);
	/* transient soap skipped */
}

void ns1__CableModemT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__CableModemT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__CableModemT*)this)->cmResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->cmResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->upChannelResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->upChannelResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->downChannelResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->downChannelResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__CableModemT*)this)->macAddress, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CableModemT*)this)->macAddress);
	soap_embedded(soap, &((ns1__CableModemT*)this)->cmStatus, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CableModemT*)this)->cmStatus);
	soap_embedded(soap, &((ns1__CableModemT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CableModemT*)this)->host);
	soap_embedded(soap, &((ns1__CableModemT*)this)->fqdn, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CableModemT*)this)->fqdn);
	soap_embedded(soap, &((ns1__CableModemT*)this)->cmIndex, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CableModemT*)this)->cmIndex);
	/* transient soap skipped */
}

int ns1__CableModemT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CableModemT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CableModemT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CableModemT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CableModemT(struct soap *soap, const char *tag, int id, const ns1__CableModemT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CableModemT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__CableModemT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "cmResId", -1, &(((ns1__CableModemT*)a)->cmResId), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__CableModemT*)a)->cmtsResId), "");
	soap_out_xsd__integer(soap, "upChannelResId", -1, &(((ns1__CableModemT*)a)->upChannelResId), "");
	soap_out_xsd__integer(soap, "downChannelResId", -1, &(((ns1__CableModemT*)a)->downChannelResId), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__CableModemT*)a)->hfcResId), "");
	soap_out_std__string(soap, "macAddress", -1, &(((ns1__CableModemT*)a)->macAddress), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__CableModemT*)a)->statusColor), "");
	soap_out_std__string(soap, "cmStatus", -1, &(((ns1__CableModemT*)a)->cmStatus), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__CableModemT*)a)->host), "");
	soap_out_std__string(soap, "fqdn", -1, &(((ns1__CableModemT*)a)->fqdn), "");
	soap_out_xsd__integer(soap, "cmIndex", -1, &(((ns1__CableModemT*)a)->cmIndex), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CableModemT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CableModemT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CableModemT * SOAP_FMAC4 soap_get_ns1__CableModemT(struct soap *soap, ns1__CableModemT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CableModemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CableModemT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CableModemT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CableModemT * SOAP_FMAC4 soap_in_ns1__CableModemT(struct soap *soap, const char *tag, ns1__CableModemT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CableModemT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CableModemT, sizeof(ns1__CableModemT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CableModemT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CableModemT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_cmResId1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_upChannelResId1 = 1, soap_flag_downChannelResId1 = 1, soap_flag_hfcResId1 = 1, soap_flag_macAddress1 = 1, soap_flag_statusColor1 = 1, soap_flag_cmStatus1 = 1, soap_flag_host1 = 1, soap_flag_fqdn1 = 1, soap_flag_cmIndex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__CableModemT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_cmResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmResId", &(((ns1__CableModemT*)a)->cmResId), "xsd:integer"))
				{	soap_flag_cmResId1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__CableModemT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_upChannelResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "upChannelResId", &(((ns1__CableModemT*)a)->upChannelResId), "xsd:integer"))
				{	soap_flag_upChannelResId1--;
					continue;
				}
			if (soap_flag_downChannelResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "downChannelResId", &(((ns1__CableModemT*)a)->downChannelResId), "xsd:integer"))
				{	soap_flag_downChannelResId1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__CableModemT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_macAddress1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "macAddress", &(((ns1__CableModemT*)a)->macAddress), "xsd:string"))
				{	soap_flag_macAddress1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__CableModemT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_cmStatus1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmStatus", &(((ns1__CableModemT*)a)->cmStatus), "xsd:string"))
				{	soap_flag_cmStatus1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__CableModemT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			if (soap_flag_fqdn1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "fqdn", &(((ns1__CableModemT*)a)->fqdn), "xsd:string"))
				{	soap_flag_fqdn1--;
					continue;
				}
			if (soap_flag_cmIndex1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmIndex", &(((ns1__CableModemT*)a)->cmIndex), "xsd:integer"))
				{	soap_flag_cmIndex1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_cmResId1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_upChannelResId1 > 0 || soap_flag_downChannelResId1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_macAddress1 > 0 || soap_flag_statusColor1 > 0 || soap_flag_cmStatus1 > 0 || soap_flag_host1 > 0 || soap_flag_fqdn1 > 0 || soap_flag_cmIndex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CableModemT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CableModemT, 0, sizeof(ns1__CableModemT), 0, soap_copy_ns1__CableModemT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CableModemT * SOAP_FMAC6 soap_new_ns1__CableModemT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CableModemT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CableModemT(struct soap *soap, ns1__CableModemT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CableModemT * SOAP_FMAC4 soap_instantiate_ns1__CableModemT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CableModemT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CableModemT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CableModemT;
		if (size)
			*size = sizeof(ns1__CableModemT);
		((ns1__CableModemT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CableModemT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CableModemT);
		for (int i = 0; i < n; i++)
			((ns1__CableModemT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CableModemT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CableModemT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CableModemT %p -> %p\n", q, p));
	*(ns1__CableModemT*)p = *(ns1__CableModemT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__HfcT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__HfcT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__HfcT*)this)->hfcResId);
	soap_default_xsd__integer(soap, &((ns1__HfcT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__HfcT*)this)->hfcName);
	soap_default_ns1__StatusColorT(soap, &((ns1__HfcT*)this)->statusColor);
	((ns1__HfcT*)this)->counts = NULL;
	/* transient soap skipped */
}

void ns1__HfcT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__HfcT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__HfcT*)this)->hfcResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__HfcT*)this)->hfcResId);
	soap_embedded(soap, &((ns1__HfcT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__HfcT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__HfcT*)this)->hfcName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__HfcT*)this)->hfcName);
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__HfcT*)this)->counts);
	/* transient soap skipped */
}

int ns1__HfcT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__HfcT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__HfcT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__HfcT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__HfcT(struct soap *soap, const char *tag, int id, const ns1__HfcT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__HfcT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__HfcT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "hfcResId", -1, &(((ns1__HfcT*)a)->hfcResId), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__HfcT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "hfcName", -1, &(((ns1__HfcT*)a)->hfcName), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__HfcT*)a)->statusColor), "");
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__HfcT*)a)->counts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__HfcT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__HfcT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__HfcT * SOAP_FMAC4 soap_get_ns1__HfcT(struct soap *soap, ns1__HfcT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__HfcT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__HfcT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__HfcT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__HfcT * SOAP_FMAC4 soap_in_ns1__HfcT(struct soap *soap, const char *tag, ns1__HfcT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__HfcT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__HfcT, sizeof(ns1__HfcT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__HfcT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__HfcT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_hfcResId1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_hfcName1 = 1, soap_flag_statusColor1 = 1, soap_flag_counts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__HfcT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_hfcResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "hfcResId", &(((ns1__HfcT*)a)->hfcResId), "xsd:integer"))
				{	soap_flag_hfcResId1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__HfcT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_hfcName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "hfcName", &(((ns1__HfcT*)a)->hfcName), "xsd:string"))
				{	soap_flag_hfcName1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__HfcT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__HfcT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_hfcResId1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_hfcName1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__HfcT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__HfcT, 0, sizeof(ns1__HfcT), 0, soap_copy_ns1__HfcT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__HfcT * SOAP_FMAC6 soap_new_ns1__HfcT(struct soap *soap, int n)
{	return soap_instantiate_ns1__HfcT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__HfcT(struct soap *soap, ns1__HfcT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__HfcT * SOAP_FMAC4 soap_instantiate_ns1__HfcT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__HfcT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__HfcT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__HfcT;
		if (size)
			*size = sizeof(ns1__HfcT);
		((ns1__HfcT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__HfcT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__HfcT);
		for (int i = 0; i < n; i++)
			((ns1__HfcT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__HfcT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__HfcT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__HfcT %p -> %p\n", q, p));
	*(ns1__HfcT*)p = *(ns1__HfcT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ChannelT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__ChannelT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__ChannelT*)this)->channelResId);
	soap_default_xsd__integer(soap, &((ns1__ChannelT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__ChannelT*)this)->channelName);
	soap_default_ns1__ChannelTypeT(soap, &((ns1__ChannelT*)this)->channelType);
	soap_default_ns1__StatusColorT(soap, &((ns1__ChannelT*)this)->statusColor);
	((ns1__ChannelT*)this)->counts = NULL;
	/* transient soap skipped */
}

void ns1__ChannelT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__ChannelT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__ChannelT*)this)->channelResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__ChannelT*)this)->channelResId);
	soap_embedded(soap, &((ns1__ChannelT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__ChannelT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__ChannelT*)this)->channelName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__ChannelT*)this)->channelName);
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__ChannelT*)this)->counts);
	/* transient soap skipped */
}

int ns1__ChannelT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ChannelT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ChannelT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ChannelT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChannelT(struct soap *soap, const char *tag, int id, const ns1__ChannelT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChannelT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__ChannelT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "channelResId", -1, &(((ns1__ChannelT*)a)->channelResId), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__ChannelT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "channelName", -1, &(((ns1__ChannelT*)a)->channelName), "");
	soap_out_ns1__ChannelTypeT(soap, "channelType", -1, &(((ns1__ChannelT*)a)->channelType), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__ChannelT*)a)->statusColor), "");
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__ChannelT*)a)->counts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ChannelT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ChannelT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ChannelT * SOAP_FMAC4 soap_get_ns1__ChannelT(struct soap *soap, ns1__ChannelT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChannelT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ChannelT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ChannelT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ChannelT * SOAP_FMAC4 soap_in_ns1__ChannelT(struct soap *soap, const char *tag, ns1__ChannelT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ChannelT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChannelT, sizeof(ns1__ChannelT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ChannelT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ChannelT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_channelResId1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_channelName1 = 1, soap_flag_channelType1 = 1, soap_flag_statusColor1 = 1, soap_flag_counts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__ChannelT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_channelResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "channelResId", &(((ns1__ChannelT*)a)->channelResId), "xsd:integer"))
				{	soap_flag_channelResId1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__ChannelT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_channelName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "channelName", &(((ns1__ChannelT*)a)->channelName), "xsd:string"))
				{	soap_flag_channelName1--;
					continue;
				}
			if (soap_flag_channelType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__ChannelTypeT(soap, "channelType", &(((ns1__ChannelT*)a)->channelType), "ns1:ChannelTypeT"))
				{	soap_flag_channelType1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__ChannelT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__ChannelT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_channelResId1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_channelName1 > 0 || soap_flag_channelType1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ChannelT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChannelT, 0, sizeof(ns1__ChannelT), 0, soap_copy_ns1__ChannelT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ChannelT * SOAP_FMAC6 soap_new_ns1__ChannelT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ChannelT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ChannelT(struct soap *soap, ns1__ChannelT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ChannelT * SOAP_FMAC4 soap_instantiate_ns1__ChannelT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ChannelT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ChannelT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ChannelT;
		if (size)
			*size = sizeof(ns1__ChannelT);
		((ns1__ChannelT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ChannelT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ChannelT);
		for (int i = 0; i < n; i++)
			((ns1__ChannelT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ChannelT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ChannelT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ChannelT %p -> %p\n", q, p));
	*(ns1__ChannelT*)p = *(ns1__ChannelT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmtsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmtsT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmtsT*)this)->cmtsResId);
	soap_default_std__string(soap, &((ns1__CmtsT*)this)->cmtsName);
	soap_default_std__string(soap, &((ns1__CmtsT*)this)->cmtsHost);
	soap_default_ns1__SnmpVersionT(soap, &((ns1__CmtsT*)this)->cmtsSnmpVersion);
	soap_default_ns1__SnmpVersionT(soap, &((ns1__CmtsT*)this)->cmSnmpVersion);
	soap_default_ns1__SnmpVersionT(soap, &((ns1__CmtsT*)this)->mtaSnmpVersion);
	soap_default_ns1__StatusColorT(soap, &((ns1__CmtsT*)this)->statusColor);
	((ns1__CmtsT*)this)->counts = NULL;
	/* transient soap skipped */
}

void ns1__CmtsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__CmtsT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__CmtsT*)this)->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmtsT*)this)->cmtsResId);
	soap_embedded(soap, &((ns1__CmtsT*)this)->cmtsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsT*)this)->cmtsName);
	soap_embedded(soap, &((ns1__CmtsT*)this)->cmtsHost, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmtsT*)this)->cmtsHost);
	soap_serialize_PointerTons1__GenericCountsT(soap, &((ns1__CmtsT*)this)->counts);
	/* transient soap skipped */
}

int ns1__CmtsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmtsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmtsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmtsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmtsT(struct soap *soap, const char *tag, int id, const ns1__CmtsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmtsT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__CmtsT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &(((ns1__CmtsT*)a)->cmtsResId), "");
	soap_out_std__string(soap, "cmtsName", -1, &(((ns1__CmtsT*)a)->cmtsName), "");
	soap_out_std__string(soap, "cmtsHost", -1, &(((ns1__CmtsT*)a)->cmtsHost), "");
	soap_out_ns1__SnmpVersionT(soap, "cmtsSnmpVersion", -1, &(((ns1__CmtsT*)a)->cmtsSnmpVersion), "");
	soap_out_ns1__SnmpVersionT(soap, "cmSnmpVersion", -1, &(((ns1__CmtsT*)a)->cmSnmpVersion), "");
	soap_out_ns1__SnmpVersionT(soap, "mtaSnmpVersion", -1, &(((ns1__CmtsT*)a)->mtaSnmpVersion), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__CmtsT*)a)->statusColor), "");
	soap_out_PointerTons1__GenericCountsT(soap, "counts", -1, &(((ns1__CmtsT*)a)->counts), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmtsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmtsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmtsT * SOAP_FMAC4 soap_get_ns1__CmtsT(struct soap *soap, ns1__CmtsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmtsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmtsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmtsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmtsT * SOAP_FMAC4 soap_in_ns1__CmtsT(struct soap *soap, const char *tag, ns1__CmtsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmtsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmtsT, sizeof(ns1__CmtsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmtsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmtsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_cmtsResId1 = 1, soap_flag_cmtsName1 = 1, soap_flag_cmtsHost1 = 1, soap_flag_cmtsSnmpVersion1 = 1, soap_flag_cmSnmpVersion1 = 1, soap_flag_mtaSnmpVersion1 = 1, soap_flag_statusColor1 = 1, soap_flag_counts1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__CmtsT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_cmtsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &(((ns1__CmtsT*)a)->cmtsResId), "xsd:integer"))
				{	soap_flag_cmtsResId1--;
					continue;
				}
			if (soap_flag_cmtsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsName", &(((ns1__CmtsT*)a)->cmtsName), "xsd:string"))
				{	soap_flag_cmtsName1--;
					continue;
				}
			if (soap_flag_cmtsHost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmtsHost", &(((ns1__CmtsT*)a)->cmtsHost), "xsd:string"))
				{	soap_flag_cmtsHost1--;
					continue;
				}
			if (soap_flag_cmtsSnmpVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SnmpVersionT(soap, "cmtsSnmpVersion", &(((ns1__CmtsT*)a)->cmtsSnmpVersion), "ns1:SnmpVersionT"))
				{	soap_flag_cmtsSnmpVersion1--;
					continue;
				}
			if (soap_flag_cmSnmpVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SnmpVersionT(soap, "cmSnmpVersion", &(((ns1__CmtsT*)a)->cmSnmpVersion), "ns1:SnmpVersionT"))
				{	soap_flag_cmSnmpVersion1--;
					continue;
				}
			if (soap_flag_mtaSnmpVersion1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SnmpVersionT(soap, "mtaSnmpVersion", &(((ns1__CmtsT*)a)->mtaSnmpVersion), "ns1:SnmpVersionT"))
				{	soap_flag_mtaSnmpVersion1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__CmtsT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			if (soap_flag_counts1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__GenericCountsT(soap, "counts", &(((ns1__CmtsT*)a)->counts), "ns1:GenericCountsT"))
				{	soap_flag_counts1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_cmtsResId1 > 0 || soap_flag_cmtsName1 > 0 || soap_flag_cmtsHost1 > 0 || soap_flag_cmtsSnmpVersion1 > 0 || soap_flag_cmSnmpVersion1 > 0 || soap_flag_mtaSnmpVersion1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmtsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmtsT, 0, sizeof(ns1__CmtsT), 0, soap_copy_ns1__CmtsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmtsT * SOAP_FMAC6 soap_new_ns1__CmtsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmtsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmtsT(struct soap *soap, ns1__CmtsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmtsT * SOAP_FMAC4 soap_instantiate_ns1__CmtsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmtsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmtsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmtsT;
		if (size)
			*size = sizeof(ns1__CmtsT);
		((ns1__CmtsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmtsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmtsT);
		for (int i = 0; i < n; i++)
			((ns1__CmtsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmtsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmtsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmtsT %p -> %p\n", q, p));
	*(ns1__CmtsT*)p = *(ns1__CmtsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__CmsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	((ns1__CmsT*)this)->topologyKey = NULL;
	soap_default_xsd__integer(soap, &((ns1__CmsT*)this)->cmsResId);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsName);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsType);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsSubType);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->cmsHost);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->loginName);
	soap_default_std__string(soap, &((ns1__CmsT*)this)->loginPassword);
	soap_default_ns1__StatusColorT(soap, &((ns1__CmsT*)this)->statusColor);
	/* transient soap skipped */
}

void ns1__CmsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &((ns1__CmsT*)this)->topologyKey);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__CmsT*)this)->cmsResId);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsName);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsType);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsSubType, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsSubType);
	soap_embedded(soap, &((ns1__CmsT*)this)->cmsHost, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->cmsHost);
	soap_embedded(soap, &((ns1__CmsT*)this)->loginName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->loginName);
	soap_embedded(soap, &((ns1__CmsT*)this)->loginPassword, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__CmsT*)this)->loginPassword);
	/* transient soap skipped */
}

int ns1__CmsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__CmsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__CmsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__CmsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__CmsT(struct soap *soap, const char *tag, int id, const ns1__CmsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__CmsT), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &(((ns1__CmsT*)a)->topologyKey), "");
	soap_out_xsd__integer(soap, "cmsResId", -1, &(((ns1__CmsT*)a)->cmsResId), "");
	soap_out_std__string(soap, "cmsName", -1, &(((ns1__CmsT*)a)->cmsName), "");
	soap_out_std__string(soap, "cmsType", -1, &(((ns1__CmsT*)a)->cmsType), "");
	soap_out_std__string(soap, "cmsSubType", -1, &(((ns1__CmsT*)a)->cmsSubType), "");
	soap_out_std__string(soap, "cmsHost", -1, &(((ns1__CmsT*)a)->cmsHost), "");
	soap_out_std__string(soap, "loginName", -1, &(((ns1__CmsT*)a)->loginName), "");
	soap_out_std__string(soap, "loginPassword", -1, &(((ns1__CmsT*)a)->loginPassword), "");
	soap_out_ns1__StatusColorT(soap, "statusColor", -1, &(((ns1__CmsT*)a)->statusColor), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__CmsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__CmsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__CmsT * SOAP_FMAC4 soap_get_ns1__CmsT(struct soap *soap, ns1__CmsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__CmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__CmsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__CmsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__CmsT * SOAP_FMAC4 soap_in_ns1__CmsT(struct soap *soap, const char *tag, ns1__CmsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__CmsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__CmsT, sizeof(ns1__CmsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__CmsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__CmsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_topologyKey1 = 1, soap_flag_cmsResId1 = 1, soap_flag_cmsName1 = 1, soap_flag_cmsType1 = 1, soap_flag_cmsSubType1 = 1, soap_flag_cmsHost1 = 1, soap_flag_loginName1 = 1, soap_flag_loginPassword1 = 1, soap_flag_statusColor1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &(((ns1__CmsT*)a)->topologyKey), "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey1--;
					continue;
				}
			if (soap_flag_cmsResId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmsResId", &(((ns1__CmsT*)a)->cmsResId), "xsd:integer"))
				{	soap_flag_cmsResId1--;
					continue;
				}
			if (soap_flag_cmsName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsName", &(((ns1__CmsT*)a)->cmsName), "xsd:string"))
				{	soap_flag_cmsName1--;
					continue;
				}
			if (soap_flag_cmsType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsType", &(((ns1__CmsT*)a)->cmsType), "xsd:string"))
				{	soap_flag_cmsType1--;
					continue;
				}
			if (soap_flag_cmsSubType1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsSubType", &(((ns1__CmsT*)a)->cmsSubType), "xsd:string"))
				{	soap_flag_cmsSubType1--;
					continue;
				}
			if (soap_flag_cmsHost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "cmsHost", &(((ns1__CmsT*)a)->cmsHost), "xsd:string"))
				{	soap_flag_cmsHost1--;
					continue;
				}
			if (soap_flag_loginName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginName", &(((ns1__CmsT*)a)->loginName), "xsd:string"))
				{	soap_flag_loginName1--;
					continue;
				}
			if (soap_flag_loginPassword1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginPassword", &(((ns1__CmsT*)a)->loginPassword), "xsd:string"))
				{	soap_flag_loginPassword1--;
					continue;
				}
			if (soap_flag_statusColor1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__StatusColorT(soap, "statusColor", &(((ns1__CmsT*)a)->statusColor), "ns1:StatusColorT"))
				{	soap_flag_statusColor1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_topologyKey1 > 0 || soap_flag_cmsResId1 > 0 || soap_flag_cmsName1 > 0 || soap_flag_cmsType1 > 0 || soap_flag_cmsSubType1 > 0 || soap_flag_cmsHost1 > 0 || soap_flag_loginName1 > 0 || soap_flag_loginPassword1 > 0 || soap_flag_statusColor1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__CmsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__CmsT, 0, sizeof(ns1__CmsT), 0, soap_copy_ns1__CmsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__CmsT * SOAP_FMAC6 soap_new_ns1__CmsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__CmsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__CmsT(struct soap *soap, ns1__CmsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__CmsT * SOAP_FMAC4 soap_instantiate_ns1__CmsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__CmsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__CmsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__CmsT;
		if (size)
			*size = sizeof(ns1__CmsT);
		((ns1__CmsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__CmsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__CmsT);
		for (int i = 0; i < n; i++)
			((ns1__CmsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__CmsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__CmsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__CmsT %p -> %p\n", q, p));
	*(ns1__CmsT*)p = *(ns1__CmsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__BladeT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__BladeT*)this)->regionId);
	soap_default_xsd__integer(soap, &((ns1__BladeT*)this)->marketId);
	soap_default_xsd__integer(soap, &((ns1__BladeT*)this)->bladeId);
	soap_default_std__string(soap, &((ns1__BladeT*)this)->name);
	soap_default_std__string(soap, &((ns1__BladeT*)this)->host);
	/* transient soap skipped */
}

void ns1__BladeT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__BladeT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__BladeT*)this)->regionId);
	soap_embedded(soap, &((ns1__BladeT*)this)->marketId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__BladeT*)this)->marketId);
	soap_embedded(soap, &((ns1__BladeT*)this)->bladeId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__BladeT*)this)->bladeId);
	soap_embedded(soap, &((ns1__BladeT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__BladeT*)this)->name);
	soap_embedded(soap, &((ns1__BladeT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__BladeT*)this)->host);
	/* transient soap skipped */
}

int ns1__BladeT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__BladeT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__BladeT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__BladeT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__BladeT(struct soap *soap, const char *tag, int id, const ns1__BladeT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__BladeT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__BladeT*)a)->regionId), "");
	soap_out_xsd__integer(soap, "marketId", -1, &(((ns1__BladeT*)a)->marketId), "");
	soap_out_xsd__integer(soap, "bladeId", -1, &(((ns1__BladeT*)a)->bladeId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__BladeT*)a)->name), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__BladeT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__BladeT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__BladeT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__BladeT * SOAP_FMAC4 soap_get_ns1__BladeT(struct soap *soap, ns1__BladeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__BladeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__BladeT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__BladeT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__BladeT * SOAP_FMAC4 soap_in_ns1__BladeT(struct soap *soap, const char *tag, ns1__BladeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__BladeT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__BladeT, sizeof(ns1__BladeT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__BladeT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__BladeT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_marketId1 = 1, soap_flag_bladeId1 = 1, soap_flag_name1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__BladeT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_marketId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "marketId", &(((ns1__BladeT*)a)->marketId), "xsd:integer"))
				{	soap_flag_marketId1--;
					continue;
				}
			if (soap_flag_bladeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "bladeId", &(((ns1__BladeT*)a)->bladeId), "xsd:integer"))
				{	soap_flag_bladeId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__BladeT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__BladeT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_marketId1 > 0 || soap_flag_bladeId1 > 0 || soap_flag_name1 > 0 || soap_flag_host1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__BladeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__BladeT, 0, sizeof(ns1__BladeT), 0, soap_copy_ns1__BladeT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__BladeT * SOAP_FMAC6 soap_new_ns1__BladeT(struct soap *soap, int n)
{	return soap_instantiate_ns1__BladeT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__BladeT(struct soap *soap, ns1__BladeT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__BladeT * SOAP_FMAC4 soap_instantiate_ns1__BladeT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__BladeT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__BladeT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__BladeT;
		if (size)
			*size = sizeof(ns1__BladeT);
		((ns1__BladeT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__BladeT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__BladeT);
		for (int i = 0; i < n; i++)
			((ns1__BladeT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__BladeT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__BladeT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__BladeT %p -> %p\n", q, p));
	*(ns1__BladeT*)p = *(ns1__BladeT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__MarketT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__MarketT*)this)->regionId);
	soap_default_xsd__integer(soap, &((ns1__MarketT*)this)->marketId);
	soap_default_std__string(soap, &((ns1__MarketT*)this)->name);
	soap_default_std__string(soap, &((ns1__MarketT*)this)->host);
	/* transient soap skipped */
}

void ns1__MarketT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__MarketT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MarketT*)this)->regionId);
	soap_embedded(soap, &((ns1__MarketT*)this)->marketId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__MarketT*)this)->marketId);
	soap_embedded(soap, &((ns1__MarketT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MarketT*)this)->name);
	soap_embedded(soap, &((ns1__MarketT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__MarketT*)this)->host);
	/* transient soap skipped */
}

int ns1__MarketT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__MarketT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__MarketT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__MarketT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__MarketT(struct soap *soap, const char *tag, int id, const ns1__MarketT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__MarketT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__MarketT*)a)->regionId), "");
	soap_out_xsd__integer(soap, "marketId", -1, &(((ns1__MarketT*)a)->marketId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__MarketT*)a)->name), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__MarketT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__MarketT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__MarketT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__MarketT * SOAP_FMAC4 soap_get_ns1__MarketT(struct soap *soap, ns1__MarketT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__MarketT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__MarketT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__MarketT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__MarketT * SOAP_FMAC4 soap_in_ns1__MarketT(struct soap *soap, const char *tag, ns1__MarketT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__MarketT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__MarketT, sizeof(ns1__MarketT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__MarketT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__MarketT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_marketId1 = 1, soap_flag_name1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__MarketT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_marketId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "marketId", &(((ns1__MarketT*)a)->marketId), "xsd:integer"))
				{	soap_flag_marketId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__MarketT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__MarketT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_marketId1 > 0 || soap_flag_name1 > 0 || soap_flag_host1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__MarketT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__MarketT, 0, sizeof(ns1__MarketT), 0, soap_copy_ns1__MarketT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__MarketT * SOAP_FMAC6 soap_new_ns1__MarketT(struct soap *soap, int n)
{	return soap_instantiate_ns1__MarketT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__MarketT(struct soap *soap, ns1__MarketT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__MarketT * SOAP_FMAC4 soap_instantiate_ns1__MarketT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__MarketT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__MarketT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__MarketT;
		if (size)
			*size = sizeof(ns1__MarketT);
		((ns1__MarketT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__MarketT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__MarketT);
		for (int i = 0; i < n; i++)
			((ns1__MarketT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__MarketT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__MarketT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__MarketT %p -> %p\n", q, p));
	*(ns1__MarketT*)p = *(ns1__MarketT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__RegionT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__RegionT*)this)->regionId);
	soap_default_std__string(soap, &((ns1__RegionT*)this)->name);
	soap_default_std__string(soap, &((ns1__RegionT*)this)->host);
	/* transient soap skipped */
}

void ns1__RegionT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__RegionT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__RegionT*)this)->regionId);
	soap_embedded(soap, &((ns1__RegionT*)this)->name, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__RegionT*)this)->name);
	soap_embedded(soap, &((ns1__RegionT*)this)->host, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__RegionT*)this)->host);
	/* transient soap skipped */
}

int ns1__RegionT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__RegionT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__RegionT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__RegionT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__RegionT(struct soap *soap, const char *tag, int id, const ns1__RegionT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__RegionT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__RegionT*)a)->regionId), "");
	soap_out_std__string(soap, "name", -1, &(((ns1__RegionT*)a)->name), "");
	soap_out_std__string(soap, "host", -1, &(((ns1__RegionT*)a)->host), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__RegionT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__RegionT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__RegionT * SOAP_FMAC4 soap_get_ns1__RegionT(struct soap *soap, ns1__RegionT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__RegionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__RegionT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__RegionT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__RegionT * SOAP_FMAC4 soap_in_ns1__RegionT(struct soap *soap, const char *tag, ns1__RegionT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__RegionT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__RegionT, sizeof(ns1__RegionT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__RegionT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__RegionT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_name1 = 1, soap_flag_host1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__RegionT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_name1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "name", &(((ns1__RegionT*)a)->name), "xsd:string"))
				{	soap_flag_name1--;
					continue;
				}
			if (soap_flag_host1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "host", &(((ns1__RegionT*)a)->host), "xsd:string"))
				{	soap_flag_host1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_name1 > 0 || soap_flag_host1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__RegionT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__RegionT, 0, sizeof(ns1__RegionT), 0, soap_copy_ns1__RegionT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__RegionT * SOAP_FMAC6 soap_new_ns1__RegionT(struct soap *soap, int n)
{	return soap_instantiate_ns1__RegionT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__RegionT(struct soap *soap, ns1__RegionT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__RegionT * SOAP_FMAC4 soap_instantiate_ns1__RegionT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__RegionT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__RegionT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__RegionT;
		if (size)
			*size = sizeof(ns1__RegionT);
		((ns1__RegionT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__RegionT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__RegionT);
		for (int i = 0; i < n; i++)
			((ns1__RegionT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__RegionT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__RegionT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__RegionT %p -> %p\n", q, p));
	*(ns1__RegionT*)p = *(ns1__RegionT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__LocalSystemT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_ns1__SystemTypeT(soap, &((ns1__LocalSystemT*)this)->systemType);
	soap_default_std__string(soap, &((ns1__LocalSystemT*)this)->systemName);
	soap_default_std__string(soap, &((ns1__LocalSystemT*)this)->parentHost);
	/* transient soap skipped */
}

void ns1__LocalSystemT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__LocalSystemT*)this)->systemName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LocalSystemT*)this)->systemName);
	soap_embedded(soap, &((ns1__LocalSystemT*)this)->parentHost, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__LocalSystemT*)this)->parentHost);
	/* transient soap skipped */
}

int ns1__LocalSystemT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__LocalSystemT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__LocalSystemT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__LocalSystemT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__LocalSystemT(struct soap *soap, const char *tag, int id, const ns1__LocalSystemT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__LocalSystemT), type);
	soap_out_ns1__SystemTypeT(soap, "systemType", -1, &(((ns1__LocalSystemT*)a)->systemType), "");
	soap_out_std__string(soap, "systemName", -1, &(((ns1__LocalSystemT*)a)->systemName), "");
	soap_out_std__string(soap, "parentHost", -1, &(((ns1__LocalSystemT*)a)->parentHost), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__LocalSystemT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__LocalSystemT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__LocalSystemT * SOAP_FMAC4 soap_get_ns1__LocalSystemT(struct soap *soap, ns1__LocalSystemT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__LocalSystemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__LocalSystemT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__LocalSystemT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__LocalSystemT * SOAP_FMAC4 soap_in_ns1__LocalSystemT(struct soap *soap, const char *tag, ns1__LocalSystemT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__LocalSystemT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__LocalSystemT, sizeof(ns1__LocalSystemT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__LocalSystemT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__LocalSystemT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_systemType1 = 1, soap_flag_systemName1 = 1, soap_flag_parentHost1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_systemType1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_ns1__SystemTypeT(soap, "systemType", &(((ns1__LocalSystemT*)a)->systemType), "ns1:SystemTypeT"))
				{	soap_flag_systemType1--;
					continue;
				}
			if (soap_flag_systemName1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "systemName", &(((ns1__LocalSystemT*)a)->systemName), "xsd:string"))
				{	soap_flag_systemName1--;
					continue;
				}
			if (soap_flag_parentHost1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "parentHost", &(((ns1__LocalSystemT*)a)->parentHost), "xsd:string"))
				{	soap_flag_parentHost1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_systemType1 > 0 || soap_flag_systemName1 > 0 || soap_flag_parentHost1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__LocalSystemT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__LocalSystemT, 0, sizeof(ns1__LocalSystemT), 0, soap_copy_ns1__LocalSystemT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__LocalSystemT * SOAP_FMAC6 soap_new_ns1__LocalSystemT(struct soap *soap, int n)
{	return soap_instantiate_ns1__LocalSystemT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__LocalSystemT(struct soap *soap, ns1__LocalSystemT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__LocalSystemT * SOAP_FMAC4 soap_instantiate_ns1__LocalSystemT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__LocalSystemT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__LocalSystemT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__LocalSystemT;
		if (size)
			*size = sizeof(ns1__LocalSystemT);
		((ns1__LocalSystemT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__LocalSystemT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__LocalSystemT);
		for (int i = 0; i < n; i++)
			((ns1__LocalSystemT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__LocalSystemT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__LocalSystemT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__LocalSystemT %p -> %p\n", q, p));
	*(ns1__LocalSystemT*)p = *(ns1__LocalSystemT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__TopoHierarchyKeyT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->regionId);
	soap_default_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->marketId);
	soap_default_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->bladeId);
	/* transient soap skipped */
}

void ns1__TopoHierarchyKeyT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__TopoHierarchyKeyT*)this)->regionId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->regionId);
	soap_embedded(soap, &((ns1__TopoHierarchyKeyT*)this)->marketId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->marketId);
	soap_embedded(soap, &((ns1__TopoHierarchyKeyT*)this)->bladeId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &((ns1__TopoHierarchyKeyT*)this)->bladeId);
	/* transient soap skipped */
}

int ns1__TopoHierarchyKeyT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__TopoHierarchyKeyT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__TopoHierarchyKeyT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__TopoHierarchyKeyT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__TopoHierarchyKeyT(struct soap *soap, const char *tag, int id, const ns1__TopoHierarchyKeyT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__TopoHierarchyKeyT), type);
	soap_out_xsd__integer(soap, "regionId", -1, &(((ns1__TopoHierarchyKeyT*)a)->regionId), "");
	soap_out_xsd__integer(soap, "marketId", -1, &(((ns1__TopoHierarchyKeyT*)a)->marketId), "");
	soap_out_xsd__integer(soap, "bladeId", -1, &(((ns1__TopoHierarchyKeyT*)a)->bladeId), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__TopoHierarchyKeyT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__TopoHierarchyKeyT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT * SOAP_FMAC4 soap_get_ns1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__TopoHierarchyKeyT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__TopoHierarchyKeyT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__TopoHierarchyKeyT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT * SOAP_FMAC4 soap_in_ns1__TopoHierarchyKeyT(struct soap *soap, const char *tag, ns1__TopoHierarchyKeyT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__TopoHierarchyKeyT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__TopoHierarchyKeyT, sizeof(ns1__TopoHierarchyKeyT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__TopoHierarchyKeyT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__TopoHierarchyKeyT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_regionId1 = 1, soap_flag_marketId1 = 1, soap_flag_bladeId1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_regionId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "regionId", &(((ns1__TopoHierarchyKeyT*)a)->regionId), "xsd:integer"))
				{	soap_flag_regionId1--;
					continue;
				}
			if (soap_flag_marketId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "marketId", &(((ns1__TopoHierarchyKeyT*)a)->marketId), "xsd:integer"))
				{	soap_flag_marketId1--;
					continue;
				}
			if (soap_flag_bladeId1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "bladeId", &(((ns1__TopoHierarchyKeyT*)a)->bladeId), "xsd:integer"))
				{	soap_flag_bladeId1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_regionId1 > 0 || soap_flag_marketId1 > 0 || soap_flag_bladeId1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__TopoHierarchyKeyT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__TopoHierarchyKeyT, 0, sizeof(ns1__TopoHierarchyKeyT), 0, soap_copy_ns1__TopoHierarchyKeyT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__TopoHierarchyKeyT * SOAP_FMAC6 soap_new_ns1__TopoHierarchyKeyT(struct soap *soap, int n)
{	return soap_instantiate_ns1__TopoHierarchyKeyT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT * SOAP_FMAC4 soap_instantiate_ns1__TopoHierarchyKeyT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__TopoHierarchyKeyT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__TopoHierarchyKeyT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__TopoHierarchyKeyT;
		if (size)
			*size = sizeof(ns1__TopoHierarchyKeyT);
		((ns1__TopoHierarchyKeyT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__TopoHierarchyKeyT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__TopoHierarchyKeyT);
		for (int i = 0; i < n; i++)
			((ns1__TopoHierarchyKeyT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__TopoHierarchyKeyT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__TopoHierarchyKeyT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__TopoHierarchyKeyT %p -> %p\n", q, p));
	*(ns1__TopoHierarchyKeyT*)p = *(ns1__TopoHierarchyKeyT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__ResultBatchT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__ResultBatchT*)this)->fromIndex);
	soap_default_short(soap, &((ns1__ResultBatchT*)this)->toIndex);
	/* transient soap skipped */
}

void ns1__ResultBatchT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__ResultBatchT*)this)->fromIndex, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__ResultBatchT*)this)->toIndex, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__ResultBatchT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__ResultBatchT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__ResultBatchT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__ResultBatchT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ResultBatchT(struct soap *soap, const char *tag, int id, const ns1__ResultBatchT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ResultBatchT), type);
	soap_out_short(soap, "fromIndex", -1, &(((ns1__ResultBatchT*)a)->fromIndex), "");
	soap_out_short(soap, "toIndex", -1, &(((ns1__ResultBatchT*)a)->toIndex), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__ResultBatchT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__ResultBatchT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__ResultBatchT * SOAP_FMAC4 soap_get_ns1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ResultBatchT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__ResultBatchT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__ResultBatchT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__ResultBatchT * SOAP_FMAC4 soap_in_ns1__ResultBatchT(struct soap *soap, const char *tag, ns1__ResultBatchT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__ResultBatchT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ResultBatchT, sizeof(ns1__ResultBatchT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__ResultBatchT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__ResultBatchT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_fromIndex1 = 1, soap_flag_toIndex1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fromIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "fromIndex", &(((ns1__ResultBatchT*)a)->fromIndex), "xsd:short"))
				{	soap_flag_fromIndex1--;
					continue;
				}
			if (soap_flag_toIndex1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "toIndex", &(((ns1__ResultBatchT*)a)->toIndex), "xsd:short"))
				{	soap_flag_toIndex1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_fromIndex1 > 0 || soap_flag_toIndex1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__ResultBatchT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ResultBatchT, 0, sizeof(ns1__ResultBatchT), 0, soap_copy_ns1__ResultBatchT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__ResultBatchT * SOAP_FMAC6 soap_new_ns1__ResultBatchT(struct soap *soap, int n)
{	return soap_instantiate_ns1__ResultBatchT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__ResultBatchT * SOAP_FMAC4 soap_instantiate_ns1__ResultBatchT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__ResultBatchT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__ResultBatchT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__ResultBatchT;
		if (size)
			*size = sizeof(ns1__ResultBatchT);
		((ns1__ResultBatchT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__ResultBatchT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__ResultBatchT);
		for (int i = 0; i < n; i++)
			((ns1__ResultBatchT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__ResultBatchT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__ResultBatchT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__ResultBatchT %p -> %p\n", q, p));
	*(ns1__ResultBatchT*)p = *(ns1__ResultBatchT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__InputTimeT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__InputTimeT*)this)->year);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->monthOfYear);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->dayOfMonth);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->hourOfDay);
	soap_default_short(soap, &((ns1__InputTimeT*)this)->minuteOfHour);
	/* transient soap skipped */
}

void ns1__InputTimeT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__InputTimeT*)this)->year, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->monthOfYear, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->dayOfMonth, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->hourOfDay, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__InputTimeT*)this)->minuteOfHour, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__InputTimeT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__InputTimeT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__InputTimeT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__InputTimeT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__InputTimeT(struct soap *soap, const char *tag, int id, const ns1__InputTimeT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__InputTimeT), type);
	soap_out_short(soap, "year", -1, &(((ns1__InputTimeT*)a)->year), "");
	soap_out_short(soap, "monthOfYear", -1, &(((ns1__InputTimeT*)a)->monthOfYear), "");
	soap_out_short(soap, "dayOfMonth", -1, &(((ns1__InputTimeT*)a)->dayOfMonth), "");
	soap_out_short(soap, "hourOfDay", -1, &(((ns1__InputTimeT*)a)->hourOfDay), "");
	soap_out_short(soap, "minuteOfHour", -1, &(((ns1__InputTimeT*)a)->minuteOfHour), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__InputTimeT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__InputTimeT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__InputTimeT * SOAP_FMAC4 soap_get_ns1__InputTimeT(struct soap *soap, ns1__InputTimeT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__InputTimeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__InputTimeT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__InputTimeT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__InputTimeT * SOAP_FMAC4 soap_in_ns1__InputTimeT(struct soap *soap, const char *tag, ns1__InputTimeT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__InputTimeT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__InputTimeT, sizeof(ns1__InputTimeT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__InputTimeT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__InputTimeT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_year1 = 1, soap_flag_monthOfYear1 = 1, soap_flag_dayOfMonth1 = 1, soap_flag_hourOfDay1 = 1, soap_flag_minuteOfHour1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_year1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "year", &(((ns1__InputTimeT*)a)->year), "xsd:short"))
				{	soap_flag_year1--;
					continue;
				}
			if (soap_flag_monthOfYear1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "monthOfYear", &(((ns1__InputTimeT*)a)->monthOfYear), "xsd:short"))
				{	soap_flag_monthOfYear1--;
					continue;
				}
			if (soap_flag_dayOfMonth1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "dayOfMonth", &(((ns1__InputTimeT*)a)->dayOfMonth), "xsd:short"))
				{	soap_flag_dayOfMonth1--;
					continue;
				}
			if (soap_flag_hourOfDay1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "hourOfDay", &(((ns1__InputTimeT*)a)->hourOfDay), "xsd:short"))
				{	soap_flag_hourOfDay1--;
					continue;
				}
			if (soap_flag_minuteOfHour1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "minuteOfHour", &(((ns1__InputTimeT*)a)->minuteOfHour), "xsd:short"))
				{	soap_flag_minuteOfHour1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_year1 > 0 || soap_flag_monthOfYear1 > 0 || soap_flag_dayOfMonth1 > 0 || soap_flag_hourOfDay1 > 0 || soap_flag_minuteOfHour1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__InputTimeT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__InputTimeT, 0, sizeof(ns1__InputTimeT), 0, soap_copy_ns1__InputTimeT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__InputTimeT * SOAP_FMAC6 soap_new_ns1__InputTimeT(struct soap *soap, int n)
{	return soap_instantiate_ns1__InputTimeT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__InputTimeT(struct soap *soap, ns1__InputTimeT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__InputTimeT * SOAP_FMAC4 soap_instantiate_ns1__InputTimeT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__InputTimeT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__InputTimeT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__InputTimeT;
		if (size)
			*size = sizeof(ns1__InputTimeT);
		((ns1__InputTimeT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__InputTimeT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__InputTimeT);
		for (int i = 0; i < n; i++)
			((ns1__InputTimeT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__InputTimeT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__InputTimeT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__InputTimeT %p -> %p\n", q, p));
	*(ns1__InputTimeT*)p = *(ns1__InputTimeT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__GenericCountsT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->totalCm);
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->onlineCm);
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->totalMta);
	soap_default_short(soap, &((ns1__GenericCountsT*)this)->availableMta);
	/* transient soap skipped */
}

void ns1__GenericCountsT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->totalCm, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->onlineCm, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->totalMta, SOAP_TYPE_short);
	soap_embedded(soap, &((ns1__GenericCountsT*)this)->availableMta, SOAP_TYPE_short);
	/* transient soap skipped */
}

int ns1__GenericCountsT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__GenericCountsT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__GenericCountsT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__GenericCountsT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__GenericCountsT(struct soap *soap, const char *tag, int id, const ns1__GenericCountsT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__GenericCountsT), type);
	soap_out_short(soap, "totalCm", -1, &(((ns1__GenericCountsT*)a)->totalCm), "");
	soap_out_short(soap, "onlineCm", -1, &(((ns1__GenericCountsT*)a)->onlineCm), "");
	soap_out_short(soap, "totalMta", -1, &(((ns1__GenericCountsT*)a)->totalMta), "");
	soap_out_short(soap, "availableMta", -1, &(((ns1__GenericCountsT*)a)->availableMta), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__GenericCountsT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__GenericCountsT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__GenericCountsT * SOAP_FMAC4 soap_get_ns1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__GenericCountsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__GenericCountsT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__GenericCountsT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__GenericCountsT * SOAP_FMAC4 soap_in_ns1__GenericCountsT(struct soap *soap, const char *tag, ns1__GenericCountsT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__GenericCountsT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__GenericCountsT, sizeof(ns1__GenericCountsT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__GenericCountsT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__GenericCountsT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_totalCm1 = 1, soap_flag_onlineCm1 = 1, soap_flag_totalMta1 = 1, soap_flag_availableMta1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_totalCm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "totalCm", &(((ns1__GenericCountsT*)a)->totalCm), "xsd:short"))
				{	soap_flag_totalCm1--;
					continue;
				}
			if (soap_flag_onlineCm1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "onlineCm", &(((ns1__GenericCountsT*)a)->onlineCm), "xsd:short"))
				{	soap_flag_onlineCm1--;
					continue;
				}
			if (soap_flag_totalMta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "totalMta", &(((ns1__GenericCountsT*)a)->totalMta), "xsd:short"))
				{	soap_flag_totalMta1--;
					continue;
				}
			if (soap_flag_availableMta1 && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "availableMta", &(((ns1__GenericCountsT*)a)->availableMta), "xsd:short"))
				{	soap_flag_availableMta1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_totalCm1 > 0 || soap_flag_onlineCm1 > 0 || soap_flag_totalMta1 > 0 || soap_flag_availableMta1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__GenericCountsT, 0, sizeof(ns1__GenericCountsT), 0, soap_copy_ns1__GenericCountsT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__GenericCountsT * SOAP_FMAC6 soap_new_ns1__GenericCountsT(struct soap *soap, int n)
{	return soap_instantiate_ns1__GenericCountsT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__GenericCountsT * SOAP_FMAC4 soap_instantiate_ns1__GenericCountsT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__GenericCountsT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__GenericCountsT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__GenericCountsT;
		if (size)
			*size = sizeof(ns1__GenericCountsT);
		((ns1__GenericCountsT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__GenericCountsT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__GenericCountsT);
		for (int i = 0; i < n; i++)
			((ns1__GenericCountsT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__GenericCountsT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__GenericCountsT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__GenericCountsT %p -> %p\n", q, p));
	*(ns1__GenericCountsT*)p = *(ns1__GenericCountsT*)q;
}
#ifdef __cplusplus
}
#endif

void ns1__SnmpV2CAttributesT::soap_default(struct soap *soap)
{
	this->soap = soap;
	soap_default_std__string(soap, &((ns1__SnmpV2CAttributesT*)this)->readCommnunity);
	((ns1__SnmpV2CAttributesT*)this)->writeCommnunity = NULL;
	/* transient soap skipped */
}

void ns1__SnmpV2CAttributesT::soap_serialize(struct soap *soap) const
{
	(void)soap; /* appease -Wall -Werror */
	soap_embedded(soap, &((ns1__SnmpV2CAttributesT*)this)->readCommnunity, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &((ns1__SnmpV2CAttributesT*)this)->readCommnunity);
	soap_serialize_PointerTostd__string(soap, &((ns1__SnmpV2CAttributesT*)this)->writeCommnunity);
	/* transient soap skipped */
}

int ns1__SnmpV2CAttributesT::soap_put(struct soap *soap, const char *tag, const  char *type) const
{
	register int id = soap_embed(soap, (void*)this, NULL, 0, tag, SOAP_TYPE_ns1__SnmpV2CAttributesT);
	if (this->soap_out(soap, tag, id, type))
		return soap->error;
	return soap_putindependent(soap);
}

int ns1__SnmpV2CAttributesT::soap_out(struct soap *soap, const char *tag, int id, const char *type) const
{
	return soap_out_ns1__SnmpV2CAttributesT(soap, tag, id, this, type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SnmpV2CAttributesT(struct soap *soap, const char *tag, int id, const ns1__SnmpV2CAttributesT *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SnmpV2CAttributesT), type);
	soap_out_std__string(soap, "readCommnunity", -1, &(((ns1__SnmpV2CAttributesT*)a)->readCommnunity), "");
	soap_out_PointerTostd__string(soap, "writeCommnunity", -1, &(((ns1__SnmpV2CAttributesT*)a)->writeCommnunity), "");
	/* transient soap skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

void *ns1__SnmpV2CAttributesT::soap_get(struct soap *soap, const char *tag, const char *type)
{
	return soap_get_ns1__SnmpV2CAttributesT(soap, this, tag, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT * SOAP_FMAC4 soap_get_ns1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

void *ns1__SnmpV2CAttributesT::soap_in(struct soap *soap, const char *tag, const char *type)
{	return soap_in_ns1__SnmpV2CAttributesT(soap, tag, this, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT * SOAP_FMAC4 soap_in_ns1__SnmpV2CAttributesT(struct soap *soap, const char *tag, ns1__SnmpV2CAttributesT *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, NULL))
		return NULL;
	a = (ns1__SnmpV2CAttributesT *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SnmpV2CAttributesT, sizeof(ns1__SnmpV2CAttributesT), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	if (soap->alloced)
	{	a->soap_default(soap);
		if (soap->clist->type != SOAP_TYPE_ns1__SnmpV2CAttributesT)
		{	soap_revert(soap);
			*soap->id = '\0';
			return (ns1__SnmpV2CAttributesT *)a->soap_in(soap, tag, type);
		}
	}
	short soap_flag_readCommnunity1 = 1, soap_flag_writeCommnunity1 = 1;
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_readCommnunity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "readCommnunity", &(((ns1__SnmpV2CAttributesT*)a)->readCommnunity), "xsd:string"))
				{	soap_flag_readCommnunity1--;
					continue;
				}
			if (soap_flag_writeCommnunity1 && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_PointerTostd__string(soap, "writeCommnunity", &(((ns1__SnmpV2CAttributesT*)a)->writeCommnunity), "xsd:string"))
				{	soap_flag_writeCommnunity1--;
					continue;
				}
			/* transient soap skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_readCommnunity1 > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (ns1__SnmpV2CAttributesT *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SnmpV2CAttributesT, 0, sizeof(ns1__SnmpV2CAttributesT), 0, soap_copy_ns1__SnmpV2CAttributesT);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 ns1__SnmpV2CAttributesT * SOAP_FMAC6 soap_new_ns1__SnmpV2CAttributesT(struct soap *soap, int n)
{	return soap_instantiate_ns1__SnmpV2CAttributesT(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_ns1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT * SOAP_FMAC4 soap_instantiate_ns1__SnmpV2CAttributesT(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_ns1__SnmpV2CAttributesT(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_ns1__SnmpV2CAttributesT, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new ns1__SnmpV2CAttributesT;
		if (size)
			*size = sizeof(ns1__SnmpV2CAttributesT);
		((ns1__SnmpV2CAttributesT*)cp->ptr)->soap = soap;
	}
	else
	{	cp->ptr = (void*)new ns1__SnmpV2CAttributesT[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(ns1__SnmpV2CAttributesT);
		for (int i = 0; i < n; i++)
			((ns1__SnmpV2CAttributesT*)cp->ptr)[i].soap = soap;
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (ns1__SnmpV2CAttributesT*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_ns1__SnmpV2CAttributesT(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying ns1__SnmpV2CAttributesT %p -> %p\n", q, p));
	*(ns1__SnmpV2CAttributesT*)p = *(ns1__SnmpV2CAttributesT*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default__SOAP_ENC__arrayType(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__SOAP_ENC__arrayType(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__SOAP_ENC__arrayType(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__SOAP_ENC__arrayType);
	if (soap_out__SOAP_ENC__arrayType(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out__SOAP_ENC__arrayType(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE__SOAP_ENC__arrayType), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get__SOAP_ENC__arrayType(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in__SOAP_ENC__arrayType(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in__SOAP_ENC__arrayType(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE__SOAP_ENC__arrayType, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE__SOAP_ENC__arrayType, 0, sizeof(std::string), 0, soap_copy__SOAP_ENC__arrayType);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new__SOAP_ENC__arrayType(struct soap *soap, int n)
{	return soap_instantiate__SOAP_ENC__arrayType(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete__SOAP_ENC__arrayType(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate__SOAP_ENC__arrayType(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate__SOAP_ENC__arrayType(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE__SOAP_ENC__arrayType, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy__SOAP_ENC__arrayType(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_xsd__integer(struct soap *soap, std::string *a)
{	soap_default_std__string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_xsd__integer(struct soap *soap, std::string const*a)
{	soap_serialize_std__string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_xsd__integer(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_xsd__integer);
	if (soap_out_xsd__integer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_xsd__integer(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_xsd__integer), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_xsd__integer(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_xsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_xsd__integer(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_xsd__integer, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_xsd__integer, 0, sizeof(std::string), 0, soap_copy_xsd__integer);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_xsd__integer(struct soap *soap, int n)
{	return soap_instantiate_xsd__integer(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_xsd__integer(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_xsd__integer(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_xsd__integer(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_xsd__integer, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_xsd__integer(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_std__string(struct soap *soap, std::string *p)
{	(void)soap; /* appease -Wall -Werror */
	p->erase();
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_std__string(struct soap *soap, const std::string *p)
{	(void)soap; (void)p; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_std__string(struct soap *soap, const std::string *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_std__string);
	if (soap_out_std__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}
SOAP_FMAC3 int SOAP_FMAC4 soap_out_std__string(struct soap *soap, const char *tag, int id, const std::string *s, const char *type)
{
	if ((soap->mode & SOAP_C_NILSTRING) && s->empty())
		return soap_element_null(soap, tag, id, type);
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, s, SOAP_TYPE_std__string), type) || soap_string_out(soap, s->c_str(), 0) || soap_element_end_out(soap, tag))
		return soap->error;
	return SOAP_OK;
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_get_std__string(struct soap *soap, std::string *p, const char *tag, const char *type)
{
	if ((p = soap_in_std__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC1 std::string * SOAP_FMAC2 soap_in_std__string(struct soap *soap, const char *tag, std::string *s, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, type))
		return NULL;
	if (!s)
		s = soap_new_std__string(soap, -1);
	if (soap->null)
		if (s)
			s->erase();
	if (soap->body && !*soap->href)
	{	char *t;
		s = (std::string*)soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType);
		if (s)
			if ((t = soap_string_in(soap, 1, -1, -1)))
				s->assign(t);
			else
				return NULL;
	}
	else
		s = (std::string*)soap_id_forward(soap, soap->href, soap_class_id_enter(soap, soap->id, s, SOAP_TYPE_std__string, sizeof(std::string), soap->type, soap->arrayType), 0, SOAP_TYPE_std__string, 0, sizeof(std::string), 0, soap_copy_std__string);
	if (soap->body && soap_element_end_in(soap, tag))
		return NULL;
	return s;
}

SOAP_FMAC5 std::string * SOAP_FMAC6 soap_new_std__string(struct soap *soap, int n)
{	return soap_instantiate_std__string(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_std__string(struct soap *soap, std::string *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 std::string * SOAP_FMAC4 soap_instantiate_std__string(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_std__string(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_std__string, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new std::string;
		if (size)
			*size = sizeof(std::string);
	}
	else
	{	cp->ptr = (void*)new std::string[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(std::string);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (std::string*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_std__string(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying std::string %p -> %p\n", q, p));
	*(std::string*)p = *(std::string*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->faultcode);
	soap_serialize_string(soap, &a->faultstring);
	soap_serialize_string(soap, &a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, &a->SOAP_ENV__Node);
	soap_serialize_string(soap, &a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Fault);
	if (soap_out_SOAP_ENV__Fault(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type);
	soap_out__QName(soap, "faultcode", -1, (char*const*)&soap_tmp_faultcode, "");
	soap_out_string(soap, "faultstring", -1, &a->faultstring, "");
	soap_out_string(soap, "faultactor", -1, &a->faultactor, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, "");
	soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, "");
	soap_out_string(soap, "SOAP-ENV:Node", -1, &a->SOAP_ENV__Node, "");
	soap_out_string(soap, "SOAP-ENV:Role", -1, &a->SOAP_ENV__Role, "");
	soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	short soap_flag_faultcode = 1, soap_flag_faultstring = 1, soap_flag_faultactor = 1, soap_flag_detail = 1, soap_flag_SOAP_ENV__Code = 1, soap_flag_SOAP_ENV__Reason = 1, soap_flag_SOAP_ENV__Node = 1, soap_flag_SOAP_ENV__Role = 1, soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "faultcode", &a->faultcode, ""))
				{	soap_flag_faultcode--;
					continue;
				}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultstring", &a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "faultactor", &a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Node", &a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Role", &a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, 0, sizeof(struct SOAP_ENV__Fault), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Fault * SOAP_FMAC6 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Fault(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Fault(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Fault(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Fault, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault;
		if (size)
			*size = sizeof(struct SOAP_ENV__Fault);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Fault[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Fault);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Fault*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Fault(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Fault %p -> %p\n", q, p));
	*(struct SOAP_ENV__Fault*)p = *(struct SOAP_ENV__Fault*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Reason);
	if (soap_out_SOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type);
	soap_out_string(soap, "SOAP-ENV:Text", -1, &a->SOAP_ENV__Text, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	short soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_string(soap, "SOAP-ENV:Text", &a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, 0, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Reason * SOAP_FMAC6 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Reason(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Reason(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Reason(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Reason, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason;
		if (size)
			*size = sizeof(struct SOAP_ENV__Reason);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Reason[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Reason);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Reason*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Reason(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Reason %p -> %p\n", q, p));
	*(struct SOAP_ENV__Reason*)p = *(struct SOAP_ENV__Reason*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__type = 0;
	a->fault = NULL;
	a->__any = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_markelement(soap, a->fault, a->__type);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Detail);
	if (soap_out_SOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type);
	soap_putelement(soap, a->fault, "fault", -1, a->__type);
	soap_outliteral(soap, "-any", &a->__any, NULL);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	short soap_flag_fault = 1, soap_flag___any = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
				if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_inliteral(soap, "-any", &a->__any))
				{	soap_flag___any--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, 0, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Detail * SOAP_FMAC6 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Detail(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Detail(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Detail(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Detail, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail;
		if (size)
			*size = sizeof(struct SOAP_ENV__Detail);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Detail[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Detail);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Detail*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Detail(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Detail %p -> %p\n", q, p));
	*(struct SOAP_ENV__Detail*)p = *(struct SOAP_ENV__Detail*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize__QName(soap, &a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Code);
	if (soap_out_SOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type);
	soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)&soap_tmp_SOAP_ENV__Value, "");
	soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	short soap_flag_SOAP_ENV__Value = 1, soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in__QName(soap, "SOAP-ENV:Value", &a->SOAP_ENV__Value, ""))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, 0, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Code * SOAP_FMAC6 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Code(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Code(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Code(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Code, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Code;
		if (size)
			*size = sizeof(struct SOAP_ENV__Code);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Code[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Code);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Code*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Code(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Code %p -> %p\n", q, p));
	*(struct SOAP_ENV__Code*)p = *(struct SOAP_ENV__Code*)q;
}
#ifdef __cplusplus
}
#endif

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	/* transient dummy skipped */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_SOAP_ENV__Header);
	if (soap_out_SOAP_ENV__Header(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type);
	/* transient dummy skipped */
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
		/* transient dummy skipped */
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, 0, sizeof(struct SOAP_ENV__Header), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct SOAP_ENV__Header * SOAP_FMAC6 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{	return soap_instantiate_SOAP_ENV__Header(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_instantiate_SOAP_ENV__Header(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_SOAP_ENV__Header(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_SOAP_ENV__Header, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct SOAP_ENV__Header;
		if (size)
			*size = sizeof(struct SOAP_ENV__Header);
	}
	else
	{	cp->ptr = (void*)new struct SOAP_ENV__Header[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct SOAP_ENV__Header);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct SOAP_ENV__Header*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_SOAP_ENV__Header(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct SOAP_ENV__Header %p -> %p\n", q, p));
	*(struct SOAP_ENV__Header*)p = *(struct SOAP_ENV__Header*)q;
}
#ifdef __cplusplus
}
#endif

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getConfig(struct soap *soap, struct adm__getConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getConfig(struct soap *soap, const struct adm__getConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getConfig(struct soap *soap, const struct adm__getConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getConfig);
	if (soap_out_adm__getConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getConfig(struct soap *soap, const char *tag, int id, const struct adm__getConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getConfig), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getConfig * SOAP_FMAC4 soap_get_adm__getConfig(struct soap *soap, struct adm__getConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getConfig * SOAP_FMAC4 soap_in_adm__getConfig(struct soap *soap, const char *tag, struct adm__getConfig *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getConfig, sizeof(struct adm__getConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getConfig, 0, sizeof(struct adm__getConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getConfig * SOAP_FMAC6 soap_new_adm__getConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__getConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getConfig(struct soap *soap, struct adm__getConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getConfig * SOAP_FMAC4 soap_instantiate_adm__getConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getConfig;
		if (size)
			*size = sizeof(struct adm__getConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__getConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getConfig %p -> %p\n", q, p));
	*(struct adm__getConfig*)p = *(struct adm__getConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getConfigResponse(struct soap *soap, struct adm__getConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->configData = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getConfigResponse(struct soap *soap, const struct adm__getConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ConfigDownloadT(soap, &a->configData);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getConfigResponse(struct soap *soap, const struct adm__getConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getConfigResponse);
	if (soap_out_adm__getConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__getConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getConfigResponse), type);
	if (a->configData)
		soap_element_result(soap, "configData");
	soap_out_PointerTons1__ConfigDownloadT(soap, "configData", -1, &a->configData, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getConfigResponse * SOAP_FMAC4 soap_get_adm__getConfigResponse(struct soap *soap, struct adm__getConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getConfigResponse * SOAP_FMAC4 soap_in_adm__getConfigResponse(struct soap *soap, const char *tag, struct adm__getConfigResponse *a, const char *type)
{
	short soap_flag_configData = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getConfigResponse, sizeof(struct adm__getConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_configData && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ConfigDownloadT(soap, "configData", &a->configData, "ns1:ConfigDownloadT"))
				{	soap_flag_configData--;
					continue;
				}
			soap_check_result(soap, "configData");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getConfigResponse, 0, sizeof(struct adm__getConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getConfigResponse * SOAP_FMAC6 soap_new_adm__getConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getConfigResponse(struct soap *soap, struct adm__getConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getConfigResponse * SOAP_FMAC4 soap_instantiate_adm__getConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getConfigResponse;
		if (size)
			*size = sizeof(struct adm__getConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getConfigResponse %p -> %p\n", q, p));
	*(struct adm__getConfigResponse*)p = *(struct adm__getConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__downloadConfigFromParent(struct soap *soap, struct adm__downloadConfigFromParent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__downloadConfigFromParent(struct soap *soap, const struct adm__downloadConfigFromParent *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__downloadConfigFromParent(struct soap *soap, const struct adm__downloadConfigFromParent *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__downloadConfigFromParent);
	if (soap_out_adm__downloadConfigFromParent(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__downloadConfigFromParent(struct soap *soap, const char *tag, int id, const struct adm__downloadConfigFromParent *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__downloadConfigFromParent), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__downloadConfigFromParent * SOAP_FMAC4 soap_get_adm__downloadConfigFromParent(struct soap *soap, struct adm__downloadConfigFromParent *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__downloadConfigFromParent(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__downloadConfigFromParent * SOAP_FMAC4 soap_in_adm__downloadConfigFromParent(struct soap *soap, const char *tag, struct adm__downloadConfigFromParent *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__downloadConfigFromParent *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__downloadConfigFromParent, sizeof(struct adm__downloadConfigFromParent), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__downloadConfigFromParent(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__downloadConfigFromParent *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__downloadConfigFromParent, 0, sizeof(struct adm__downloadConfigFromParent), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__downloadConfigFromParent * SOAP_FMAC6 soap_new_adm__downloadConfigFromParent(struct soap *soap, int n)
{	return soap_instantiate_adm__downloadConfigFromParent(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__downloadConfigFromParent(struct soap *soap, struct adm__downloadConfigFromParent *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__downloadConfigFromParent * SOAP_FMAC4 soap_instantiate_adm__downloadConfigFromParent(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__downloadConfigFromParent(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__downloadConfigFromParent, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__downloadConfigFromParent;
		if (size)
			*size = sizeof(struct adm__downloadConfigFromParent);
	}
	else
	{	cp->ptr = (void*)new struct adm__downloadConfigFromParent[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__downloadConfigFromParent);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__downloadConfigFromParent*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__downloadConfigFromParent(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__downloadConfigFromParent %p -> %p\n", q, p));
	*(struct adm__downloadConfigFromParent*)p = *(struct adm__downloadConfigFromParent*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__downloadConfigFromParentResponse(struct soap *soap, struct adm__downloadConfigFromParentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->rc);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__downloadConfigFromParentResponse(struct soap *soap, const struct adm__downloadConfigFromParentResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->rc, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__downloadConfigFromParentResponse(struct soap *soap, const struct adm__downloadConfigFromParentResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__downloadConfigFromParentResponse);
	if (soap_out_adm__downloadConfigFromParentResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__downloadConfigFromParentResponse(struct soap *soap, const char *tag, int id, const struct adm__downloadConfigFromParentResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__downloadConfigFromParentResponse), type);
	soap_element_result(soap, "rc");
	soap_out_short(soap, "rc", -1, &a->rc, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__downloadConfigFromParentResponse * SOAP_FMAC4 soap_get_adm__downloadConfigFromParentResponse(struct soap *soap, struct adm__downloadConfigFromParentResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__downloadConfigFromParentResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__downloadConfigFromParentResponse * SOAP_FMAC4 soap_in_adm__downloadConfigFromParentResponse(struct soap *soap, const char *tag, struct adm__downloadConfigFromParentResponse *a, const char *type)
{
	short soap_flag_rc = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__downloadConfigFromParentResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__downloadConfigFromParentResponse, sizeof(struct adm__downloadConfigFromParentResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__downloadConfigFromParentResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_rc && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "rc", &a->rc, "xsd:short"))
				{	soap_flag_rc--;
					continue;
				}
			soap_check_result(soap, "rc");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_rc > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__downloadConfigFromParentResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__downloadConfigFromParentResponse, 0, sizeof(struct adm__downloadConfigFromParentResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__downloadConfigFromParentResponse * SOAP_FMAC6 soap_new_adm__downloadConfigFromParentResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__downloadConfigFromParentResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__downloadConfigFromParentResponse(struct soap *soap, struct adm__downloadConfigFromParentResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__downloadConfigFromParentResponse * SOAP_FMAC4 soap_instantiate_adm__downloadConfigFromParentResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__downloadConfigFromParentResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__downloadConfigFromParentResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__downloadConfigFromParentResponse;
		if (size)
			*size = sizeof(struct adm__downloadConfigFromParentResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__downloadConfigFromParentResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__downloadConfigFromParentResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__downloadConfigFromParentResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__downloadConfigFromParentResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__downloadConfigFromParentResponse %p -> %p\n", q, p));
	*(struct adm__downloadConfigFromParentResponse*)p = *(struct adm__downloadConfigFromParentResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateRole(struct soap *soap, struct adm__updateRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->role = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateRole(struct soap *soap, const struct adm__updateRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RoleT(soap, &a->role);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateRole(struct soap *soap, const struct adm__updateRole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateRole);
	if (soap_out_adm__updateRole(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateRole(struct soap *soap, const char *tag, int id, const struct adm__updateRole *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateRole), type);
	soap_out_PointerTons1__RoleT(soap, "role", -1, &a->role, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateRole * SOAP_FMAC4 soap_get_adm__updateRole(struct soap *soap, struct adm__updateRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateRole(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateRole * SOAP_FMAC4 soap_in_adm__updateRole(struct soap *soap, const char *tag, struct adm__updateRole *a, const char *type)
{
	short soap_flag_role = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateRole *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateRole, sizeof(struct adm__updateRole), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateRole(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_role && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RoleT(soap, "role", &a->role, "ns1:RoleT"))
				{	soap_flag_role--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateRole, 0, sizeof(struct adm__updateRole), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateRole * SOAP_FMAC6 soap_new_adm__updateRole(struct soap *soap, int n)
{	return soap_instantiate_adm__updateRole(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateRole(struct soap *soap, struct adm__updateRole *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateRole * SOAP_FMAC4 soap_instantiate_adm__updateRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateRole;
		if (size)
			*size = sizeof(struct adm__updateRole);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateRole[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateRole);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateRole*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateRole %p -> %p\n", q, p));
	*(struct adm__updateRole*)p = *(struct adm__updateRole*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateRoleResponse(struct soap *soap, struct adm__updateRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateRoleResponse(struct soap *soap, const struct adm__updateRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateRoleResponse(struct soap *soap, const struct adm__updateRoleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateRoleResponse);
	if (soap_out_adm__updateRoleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateRoleResponse(struct soap *soap, const char *tag, int id, const struct adm__updateRoleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateRoleResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateRoleResponse * SOAP_FMAC4 soap_get_adm__updateRoleResponse(struct soap *soap, struct adm__updateRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateRoleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateRoleResponse * SOAP_FMAC4 soap_in_adm__updateRoleResponse(struct soap *soap, const char *tag, struct adm__updateRoleResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateRoleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateRoleResponse, sizeof(struct adm__updateRoleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateRoleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateRoleResponse, 0, sizeof(struct adm__updateRoleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateRoleResponse * SOAP_FMAC6 soap_new_adm__updateRoleResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateRoleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateRoleResponse(struct soap *soap, struct adm__updateRoleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateRoleResponse * SOAP_FMAC4 soap_instantiate_adm__updateRoleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateRoleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateRoleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateRoleResponse;
		if (size)
			*size = sizeof(struct adm__updateRoleResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateRoleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateRoleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateRoleResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateRoleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateRoleResponse %p -> %p\n", q, p));
	*(struct adm__updateRoleResponse*)p = *(struct adm__updateRoleResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getRole(struct soap *soap, struct adm__getRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->roleName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getRole(struct soap *soap, const struct adm__getRole *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->roleName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->roleName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getRole(struct soap *soap, const struct adm__getRole *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getRole);
	if (soap_out_adm__getRole(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getRole(struct soap *soap, const char *tag, int id, const struct adm__getRole *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getRole), type);
	soap_out_std__string(soap, "roleName", -1, &a->roleName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getRole * SOAP_FMAC4 soap_get_adm__getRole(struct soap *soap, struct adm__getRole *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getRole(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getRole * SOAP_FMAC4 soap_in_adm__getRole(struct soap *soap, const char *tag, struct adm__getRole *a, const char *type)
{
	short soap_flag_roleName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getRole *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getRole, sizeof(struct adm__getRole), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_adm__getRole(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_roleName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "roleName", &a->roleName, "xsd:string"))
				{	soap_flag_roleName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_roleName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getRole *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getRole, 0, sizeof(struct adm__getRole), 0, soap_copy_adm__getRole);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getRole * SOAP_FMAC6 soap_new_adm__getRole(struct soap *soap, int n)
{	return soap_instantiate_adm__getRole(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getRole(struct soap *soap, struct adm__getRole *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getRole * SOAP_FMAC4 soap_instantiate_adm__getRole(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getRole(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getRole, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getRole;
		if (size)
			*size = sizeof(struct adm__getRole);
	}
	else
	{	cp->ptr = (void*)new struct adm__getRole[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getRole);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getRole*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getRole(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getRole %p -> %p\n", q, p));
	*(struct adm__getRole*)p = *(struct adm__getRole*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getRoleResponse(struct soap *soap, struct adm__getRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getRoleResponse(struct soap *soap, const struct adm__getRoleResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RoleT(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getRoleResponse(struct soap *soap, const struct adm__getRoleResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getRoleResponse);
	if (soap_out_adm__getRoleResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getRoleResponse(struct soap *soap, const char *tag, int id, const struct adm__getRoleResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getRoleResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerTons1__RoleT(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getRoleResponse * SOAP_FMAC4 soap_get_adm__getRoleResponse(struct soap *soap, struct adm__getRoleResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getRoleResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getRoleResponse * SOAP_FMAC4 soap_in_adm__getRoleResponse(struct soap *soap, const char *tag, struct adm__getRoleResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getRoleResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getRoleResponse, sizeof(struct adm__getRoleResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getRoleResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RoleT(soap, "result", &a->result, "ns1:RoleT"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getRoleResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getRoleResponse, 0, sizeof(struct adm__getRoleResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getRoleResponse * SOAP_FMAC6 soap_new_adm__getRoleResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getRoleResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getRoleResponse(struct soap *soap, struct adm__getRoleResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getRoleResponse * SOAP_FMAC4 soap_instantiate_adm__getRoleResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getRoleResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getRoleResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getRoleResponse;
		if (size)
			*size = sizeof(struct adm__getRoleResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getRoleResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getRoleResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getRoleResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getRoleResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getRoleResponse %p -> %p\n", q, p));
	*(struct adm__getRoleResponse*)p = *(struct adm__getRoleResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getRoles(struct soap *soap, struct adm__getRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getRoles(struct soap *soap, const struct adm__getRoles *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getRoles(struct soap *soap, const struct adm__getRoles *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getRoles);
	if (soap_out_adm__getRoles(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getRoles(struct soap *soap, const char *tag, int id, const struct adm__getRoles *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getRoles), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getRoles * SOAP_FMAC4 soap_get_adm__getRoles(struct soap *soap, struct adm__getRoles *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getRoles(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getRoles * SOAP_FMAC4 soap_in_adm__getRoles(struct soap *soap, const char *tag, struct adm__getRoles *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getRoles *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getRoles, sizeof(struct adm__getRoles), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getRoles(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getRoles *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getRoles, 0, sizeof(struct adm__getRoles), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getRoles * SOAP_FMAC6 soap_new_adm__getRoles(struct soap *soap, int n)
{	return soap_instantiate_adm__getRoles(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getRoles(struct soap *soap, struct adm__getRoles *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getRoles * SOAP_FMAC4 soap_instantiate_adm__getRoles(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getRoles(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getRoles, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getRoles;
		if (size)
			*size = sizeof(struct adm__getRoles);
	}
	else
	{	cp->ptr = (void*)new struct adm__getRoles[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getRoles);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getRoles*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getRoles(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getRoles %p -> %p\n", q, p));
	*(struct adm__getRoles*)p = *(struct adm__getRoles*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getRolesResponse(struct soap *soap, struct adm__getRolesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->result = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getRolesResponse(struct soap *soap, const struct adm__getRolesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfRoleT(soap, &a->result);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getRolesResponse(struct soap *soap, const struct adm__getRolesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getRolesResponse);
	if (soap_out_adm__getRolesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getRolesResponse(struct soap *soap, const char *tag, int id, const struct adm__getRolesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getRolesResponse), type);
	if (a->result)
		soap_element_result(soap, "result");
	soap_out_PointerToArrayOfRoleT(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getRolesResponse * SOAP_FMAC4 soap_get_adm__getRolesResponse(struct soap *soap, struct adm__getRolesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getRolesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getRolesResponse * SOAP_FMAC4 soap_in_adm__getRolesResponse(struct soap *soap, const char *tag, struct adm__getRolesResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getRolesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getRolesResponse, sizeof(struct adm__getRolesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getRolesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfRoleT(soap, "result", &a->result, "ns1:RoleT"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getRolesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getRolesResponse, 0, sizeof(struct adm__getRolesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getRolesResponse * SOAP_FMAC6 soap_new_adm__getRolesResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getRolesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getRolesResponse(struct soap *soap, struct adm__getRolesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getRolesResponse * SOAP_FMAC4 soap_instantiate_adm__getRolesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getRolesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getRolesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getRolesResponse;
		if (size)
			*size = sizeof(struct adm__getRolesResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getRolesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getRolesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getRolesResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getRolesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getRolesResponse %p -> %p\n", q, p));
	*(struct adm__getRolesResponse*)p = *(struct adm__getRolesResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateUserPassword(struct soap *soap, struct adm__updateUserPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->loginName);
	soap_default_std__string(soap, &a->newPassword);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateUserPassword(struct soap *soap, const struct adm__updateUserPassword *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->loginName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->loginName);
	soap_embedded(soap, &a->newPassword, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->newPassword);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateUserPassword(struct soap *soap, const struct adm__updateUserPassword *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateUserPassword);
	if (soap_out_adm__updateUserPassword(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateUserPassword(struct soap *soap, const char *tag, int id, const struct adm__updateUserPassword *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateUserPassword), type);
	soap_out_std__string(soap, "loginName", -1, &a->loginName, "");
	soap_out_std__string(soap, "newPassword", -1, &a->newPassword, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateUserPassword * SOAP_FMAC4 soap_get_adm__updateUserPassword(struct soap *soap, struct adm__updateUserPassword *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateUserPassword(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateUserPassword * SOAP_FMAC4 soap_in_adm__updateUserPassword(struct soap *soap, const char *tag, struct adm__updateUserPassword *a, const char *type)
{
	short soap_flag_loginName = 1, soap_flag_newPassword = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateUserPassword *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateUserPassword, sizeof(struct adm__updateUserPassword), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_adm__updateUserPassword(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginName", &a->loginName, "xsd:string"))
				{	soap_flag_loginName--;
					continue;
				}
			if (soap_flag_newPassword && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "newPassword", &a->newPassword, "xsd:string"))
				{	soap_flag_newPassword--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loginName > 0 || soap_flag_newPassword > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateUserPassword *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateUserPassword, 0, sizeof(struct adm__updateUserPassword), 0, soap_copy_adm__updateUserPassword);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateUserPassword * SOAP_FMAC6 soap_new_adm__updateUserPassword(struct soap *soap, int n)
{	return soap_instantiate_adm__updateUserPassword(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateUserPassword(struct soap *soap, struct adm__updateUserPassword *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateUserPassword * SOAP_FMAC4 soap_instantiate_adm__updateUserPassword(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateUserPassword(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateUserPassword, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateUserPassword;
		if (size)
			*size = sizeof(struct adm__updateUserPassword);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateUserPassword[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateUserPassword);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateUserPassword*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateUserPassword(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateUserPassword %p -> %p\n", q, p));
	*(struct adm__updateUserPassword*)p = *(struct adm__updateUserPassword*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateUserPasswordResponse(struct soap *soap, struct adm__updateUserPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateUserPasswordResponse(struct soap *soap, const struct adm__updateUserPasswordResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateUserPasswordResponse(struct soap *soap, const struct adm__updateUserPasswordResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateUserPasswordResponse);
	if (soap_out_adm__updateUserPasswordResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateUserPasswordResponse(struct soap *soap, const char *tag, int id, const struct adm__updateUserPasswordResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateUserPasswordResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateUserPasswordResponse * SOAP_FMAC4 soap_get_adm__updateUserPasswordResponse(struct soap *soap, struct adm__updateUserPasswordResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateUserPasswordResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateUserPasswordResponse * SOAP_FMAC4 soap_in_adm__updateUserPasswordResponse(struct soap *soap, const char *tag, struct adm__updateUserPasswordResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateUserPasswordResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateUserPasswordResponse, sizeof(struct adm__updateUserPasswordResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateUserPasswordResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateUserPasswordResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateUserPasswordResponse, 0, sizeof(struct adm__updateUserPasswordResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateUserPasswordResponse * SOAP_FMAC6 soap_new_adm__updateUserPasswordResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateUserPasswordResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateUserPasswordResponse(struct soap *soap, struct adm__updateUserPasswordResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateUserPasswordResponse * SOAP_FMAC4 soap_instantiate_adm__updateUserPasswordResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateUserPasswordResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateUserPasswordResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateUserPasswordResponse;
		if (size)
			*size = sizeof(struct adm__updateUserPasswordResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateUserPasswordResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateUserPasswordResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateUserPasswordResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateUserPasswordResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateUserPasswordResponse %p -> %p\n", q, p));
	*(struct adm__updateUserPasswordResponse*)p = *(struct adm__updateUserPasswordResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateUser(struct soap *soap, struct adm__updateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->user = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateUser(struct soap *soap, const struct adm__updateUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UserT(soap, &a->user);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateUser(struct soap *soap, const struct adm__updateUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateUser);
	if (soap_out_adm__updateUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateUser(struct soap *soap, const char *tag, int id, const struct adm__updateUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateUser), type);
	soap_out_PointerTons1__UserT(soap, "user", -1, &a->user, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateUser * SOAP_FMAC4 soap_get_adm__updateUser(struct soap *soap, struct adm__updateUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateUser * SOAP_FMAC4 soap_in_adm__updateUser(struct soap *soap, const char *tag, struct adm__updateUser *a, const char *type)
{
	short soap_flag_user = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateUser, sizeof(struct adm__updateUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UserT(soap, "user", &a->user, "ns1:UserT"))
				{	soap_flag_user--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateUser, 0, sizeof(struct adm__updateUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateUser * SOAP_FMAC6 soap_new_adm__updateUser(struct soap *soap, int n)
{	return soap_instantiate_adm__updateUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateUser(struct soap *soap, struct adm__updateUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateUser * SOAP_FMAC4 soap_instantiate_adm__updateUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateUser;
		if (size)
			*size = sizeof(struct adm__updateUser);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateUser*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateUser %p -> %p\n", q, p));
	*(struct adm__updateUser*)p = *(struct adm__updateUser*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateUserResponse(struct soap *soap, struct adm__updateUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateUserResponse(struct soap *soap, const struct adm__updateUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateUserResponse(struct soap *soap, const struct adm__updateUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateUserResponse);
	if (soap_out_adm__updateUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateUserResponse(struct soap *soap, const char *tag, int id, const struct adm__updateUserResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateUserResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateUserResponse * SOAP_FMAC4 soap_get_adm__updateUserResponse(struct soap *soap, struct adm__updateUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateUserResponse * SOAP_FMAC4 soap_in_adm__updateUserResponse(struct soap *soap, const char *tag, struct adm__updateUserResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateUserResponse, sizeof(struct adm__updateUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateUserResponse, 0, sizeof(struct adm__updateUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateUserResponse * SOAP_FMAC6 soap_new_adm__updateUserResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateUserResponse(struct soap *soap, struct adm__updateUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateUserResponse * SOAP_FMAC4 soap_instantiate_adm__updateUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateUserResponse;
		if (size)
			*size = sizeof(struct adm__updateUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateUserResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateUserResponse %p -> %p\n", q, p));
	*(struct adm__updateUserResponse*)p = *(struct adm__updateUserResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getUser(struct soap *soap, struct adm__getUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_std__string(soap, &a->loginName);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getUser(struct soap *soap, const struct adm__getUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->loginName, SOAP_TYPE_std__string);
	soap_serialize_std__string(soap, &a->loginName);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getUser(struct soap *soap, const struct adm__getUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getUser);
	if (soap_out_adm__getUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getUser(struct soap *soap, const char *tag, int id, const struct adm__getUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getUser), type);
	soap_out_std__string(soap, "loginName", -1, &a->loginName, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getUser * SOAP_FMAC4 soap_get_adm__getUser(struct soap *soap, struct adm__getUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getUser * SOAP_FMAC4 soap_in_adm__getUser(struct soap *soap, const char *tag, struct adm__getUser *a, const char *type)
{
	short soap_flag_loginName = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getUser *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getUser, sizeof(struct adm__getUser), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_adm__getUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_loginName && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_std__string(soap, "loginName", &a->loginName, "xsd:string"))
				{	soap_flag_loginName--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_loginName > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getUser, 0, sizeof(struct adm__getUser), 0, soap_copy_adm__getUser);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getUser * SOAP_FMAC6 soap_new_adm__getUser(struct soap *soap, int n)
{	return soap_instantiate_adm__getUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getUser(struct soap *soap, struct adm__getUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getUser * SOAP_FMAC4 soap_instantiate_adm__getUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getUser;
		if (size)
			*size = sizeof(struct adm__getUser);
	}
	else
	{	cp->ptr = (void*)new struct adm__getUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getUser*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getUser %p -> %p\n", q, p));
	*(struct adm__getUser*)p = *(struct adm__getUser*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getUserResponse(struct soap *soap, struct adm__getUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getUserResponse(struct soap *soap, const struct adm__getUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UserT(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getUserResponse(struct soap *soap, const struct adm__getUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getUserResponse);
	if (soap_out_adm__getUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getUserResponse(struct soap *soap, const char *tag, int id, const struct adm__getUserResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getUserResponse), type);
	if (a->name)
		soap_element_result(soap, "name");
	soap_out_PointerTons1__UserT(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getUserResponse * SOAP_FMAC4 soap_get_adm__getUserResponse(struct soap *soap, struct adm__getUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getUserResponse * SOAP_FMAC4 soap_in_adm__getUserResponse(struct soap *soap, const char *tag, struct adm__getUserResponse *a, const char *type)
{
	short soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getUserResponse, sizeof(struct adm__getUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UserT(soap, "name", &a->name, "ns1:UserT"))
				{	soap_flag_name--;
					continue;
				}
			soap_check_result(soap, "name");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getUserResponse, 0, sizeof(struct adm__getUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getUserResponse * SOAP_FMAC6 soap_new_adm__getUserResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getUserResponse(struct soap *soap, struct adm__getUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getUserResponse * SOAP_FMAC4 soap_instantiate_adm__getUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getUserResponse;
		if (size)
			*size = sizeof(struct adm__getUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getUserResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getUserResponse %p -> %p\n", q, p));
	*(struct adm__getUserResponse*)p = *(struct adm__getUserResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getUsers(struct soap *soap, struct adm__getUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getUsers(struct soap *soap, const struct adm__getUsers *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getUsers(struct soap *soap, const struct adm__getUsers *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getUsers);
	if (soap_out_adm__getUsers(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getUsers(struct soap *soap, const char *tag, int id, const struct adm__getUsers *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getUsers), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getUsers * SOAP_FMAC4 soap_get_adm__getUsers(struct soap *soap, struct adm__getUsers *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getUsers(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getUsers * SOAP_FMAC4 soap_in_adm__getUsers(struct soap *soap, const char *tag, struct adm__getUsers *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getUsers *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getUsers, sizeof(struct adm__getUsers), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getUsers(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getUsers *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getUsers, 0, sizeof(struct adm__getUsers), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getUsers * SOAP_FMAC6 soap_new_adm__getUsers(struct soap *soap, int n)
{	return soap_instantiate_adm__getUsers(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getUsers(struct soap *soap, struct adm__getUsers *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getUsers * SOAP_FMAC4 soap_instantiate_adm__getUsers(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getUsers(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getUsers, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getUsers;
		if (size)
			*size = sizeof(struct adm__getUsers);
	}
	else
	{	cp->ptr = (void*)new struct adm__getUsers[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getUsers);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getUsers*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getUsers(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getUsers %p -> %p\n", q, p));
	*(struct adm__getUsers*)p = *(struct adm__getUsers*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getUsersResponse(struct soap *soap, struct adm__getUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->name = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getUsersResponse(struct soap *soap, const struct adm__getUsersResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerToArrayOfUserT(soap, &a->name);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getUsersResponse(struct soap *soap, const struct adm__getUsersResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getUsersResponse);
	if (soap_out_adm__getUsersResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getUsersResponse(struct soap *soap, const char *tag, int id, const struct adm__getUsersResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getUsersResponse), type);
	if (a->name)
		soap_element_result(soap, "name");
	soap_out_PointerToArrayOfUserT(soap, "name", -1, &a->name, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getUsersResponse * SOAP_FMAC4 soap_get_adm__getUsersResponse(struct soap *soap, struct adm__getUsersResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getUsersResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getUsersResponse * SOAP_FMAC4 soap_in_adm__getUsersResponse(struct soap *soap, const char *tag, struct adm__getUsersResponse *a, const char *type)
{
	short soap_flag_name = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getUsersResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getUsersResponse, sizeof(struct adm__getUsersResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getUsersResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_name && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfUserT(soap, "name", &a->name, "ns1:UserT"))
				{	soap_flag_name--;
					continue;
				}
			soap_check_result(soap, "name");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getUsersResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getUsersResponse, 0, sizeof(struct adm__getUsersResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getUsersResponse * SOAP_FMAC6 soap_new_adm__getUsersResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getUsersResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getUsersResponse(struct soap *soap, struct adm__getUsersResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getUsersResponse * SOAP_FMAC4 soap_instantiate_adm__getUsersResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getUsersResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getUsersResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getUsersResponse;
		if (size)
			*size = sizeof(struct adm__getUsersResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getUsersResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getUsersResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getUsersResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getUsersResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getUsersResponse %p -> %p\n", q, p));
	*(struct adm__getUsersResponse*)p = *(struct adm__getUsersResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addUser(struct soap *soap, struct adm__addUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->user = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addUser(struct soap *soap, const struct adm__addUser *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__UserT(soap, &a->user);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addUser(struct soap *soap, const struct adm__addUser *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addUser);
	if (soap_out_adm__addUser(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addUser(struct soap *soap, const char *tag, int id, const struct adm__addUser *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addUser), type);
	soap_out_PointerTons1__UserT(soap, "user", -1, &a->user, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addUser * SOAP_FMAC4 soap_get_adm__addUser(struct soap *soap, struct adm__addUser *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addUser(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addUser * SOAP_FMAC4 soap_in_adm__addUser(struct soap *soap, const char *tag, struct adm__addUser *a, const char *type)
{
	short soap_flag_user = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addUser *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addUser, sizeof(struct adm__addUser), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addUser(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_user && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__UserT(soap, "user", &a->user, "ns1:UserT"))
				{	soap_flag_user--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addUser *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addUser, 0, sizeof(struct adm__addUser), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addUser * SOAP_FMAC6 soap_new_adm__addUser(struct soap *soap, int n)
{	return soap_instantiate_adm__addUser(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addUser(struct soap *soap, struct adm__addUser *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addUser * SOAP_FMAC4 soap_instantiate_adm__addUser(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addUser(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addUser, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addUser;
		if (size)
			*size = sizeof(struct adm__addUser);
	}
	else
	{	cp->ptr = (void*)new struct adm__addUser[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addUser);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addUser*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addUser(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addUser %p -> %p\n", q, p));
	*(struct adm__addUser*)p = *(struct adm__addUser*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addUserResponse(struct soap *soap, struct adm__addUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addUserResponse(struct soap *soap, const struct adm__addUserResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addUserResponse(struct soap *soap, const struct adm__addUserResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addUserResponse);
	if (soap_out_adm__addUserResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addUserResponse(struct soap *soap, const char *tag, int id, const struct adm__addUserResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addUserResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addUserResponse * SOAP_FMAC4 soap_get_adm__addUserResponse(struct soap *soap, struct adm__addUserResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addUserResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addUserResponse * SOAP_FMAC4 soap_in_adm__addUserResponse(struct soap *soap, const char *tag, struct adm__addUserResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addUserResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addUserResponse, sizeof(struct adm__addUserResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addUserResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addUserResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addUserResponse, 0, sizeof(struct adm__addUserResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addUserResponse * SOAP_FMAC6 soap_new_adm__addUserResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__addUserResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addUserResponse(struct soap *soap, struct adm__addUserResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addUserResponse * SOAP_FMAC4 soap_instantiate_adm__addUserResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addUserResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addUserResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addUserResponse;
		if (size)
			*size = sizeof(struct adm__addUserResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__addUserResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addUserResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addUserResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addUserResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addUserResponse %p -> %p\n", q, p));
	*(struct adm__addUserResponse*)p = *(struct adm__addUserResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmPerfConfig(struct soap *soap, struct adm__updateCmPerfConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmPerf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmPerfConfig(struct soap *soap, const struct adm__updateCmPerfConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmPerformanceConfigT(soap, &a->cmPerf);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmPerfConfig(struct soap *soap, const struct adm__updateCmPerfConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmPerfConfig);
	if (soap_out_adm__updateCmPerfConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmPerfConfig(struct soap *soap, const char *tag, int id, const struct adm__updateCmPerfConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmPerfConfig), type);
	soap_out_PointerTons1__CmPerformanceConfigT(soap, "cmPerf", -1, &a->cmPerf, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmPerfConfig * SOAP_FMAC4 soap_get_adm__updateCmPerfConfig(struct soap *soap, struct adm__updateCmPerfConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmPerfConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmPerfConfig * SOAP_FMAC4 soap_in_adm__updateCmPerfConfig(struct soap *soap, const char *tag, struct adm__updateCmPerfConfig *a, const char *type)
{
	short soap_flag_cmPerf = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmPerfConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmPerfConfig, sizeof(struct adm__updateCmPerfConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmPerfConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmPerf && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmPerformanceConfigT(soap, "cmPerf", &a->cmPerf, "ns1:CmPerformanceConfigT"))
				{	soap_flag_cmPerf--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmPerfConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmPerfConfig, 0, sizeof(struct adm__updateCmPerfConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmPerfConfig * SOAP_FMAC6 soap_new_adm__updateCmPerfConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmPerfConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmPerfConfig(struct soap *soap, struct adm__updateCmPerfConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmPerfConfig * SOAP_FMAC4 soap_instantiate_adm__updateCmPerfConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmPerfConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmPerfConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmPerfConfig;
		if (size)
			*size = sizeof(struct adm__updateCmPerfConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmPerfConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmPerfConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmPerfConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmPerfConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmPerfConfig %p -> %p\n", q, p));
	*(struct adm__updateCmPerfConfig*)p = *(struct adm__updateCmPerfConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmPerfConfigResponse(struct soap *soap, struct adm__updateCmPerfConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmPerfConfigResponse(struct soap *soap, const struct adm__updateCmPerfConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmPerfConfigResponse(struct soap *soap, const struct adm__updateCmPerfConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmPerfConfigResponse);
	if (soap_out_adm__updateCmPerfConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmPerfConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmPerfConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmPerfConfigResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmPerfConfigResponse * SOAP_FMAC4 soap_get_adm__updateCmPerfConfigResponse(struct soap *soap, struct adm__updateCmPerfConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmPerfConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmPerfConfigResponse * SOAP_FMAC4 soap_in_adm__updateCmPerfConfigResponse(struct soap *soap, const char *tag, struct adm__updateCmPerfConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmPerfConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmPerfConfigResponse, sizeof(struct adm__updateCmPerfConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmPerfConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmPerfConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmPerfConfigResponse, 0, sizeof(struct adm__updateCmPerfConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmPerfConfigResponse * SOAP_FMAC6 soap_new_adm__updateCmPerfConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmPerfConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmPerfConfigResponse(struct soap *soap, struct adm__updateCmPerfConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmPerfConfigResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmPerfConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmPerfConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmPerfConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmPerfConfigResponse;
		if (size)
			*size = sizeof(struct adm__updateCmPerfConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmPerfConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmPerfConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmPerfConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmPerfConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmPerfConfigResponse %p -> %p\n", q, p));
	*(struct adm__updateCmPerfConfigResponse*)p = *(struct adm__updateCmPerfConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmPerfConfig(struct soap *soap, struct adm__getCmPerfConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmPerfConfig(struct soap *soap, const struct adm__getCmPerfConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmPerfConfig(struct soap *soap, const struct adm__getCmPerfConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmPerfConfig);
	if (soap_out_adm__getCmPerfConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmPerfConfig(struct soap *soap, const char *tag, int id, const struct adm__getCmPerfConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmPerfConfig), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmPerfConfig * SOAP_FMAC4 soap_get_adm__getCmPerfConfig(struct soap *soap, struct adm__getCmPerfConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmPerfConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmPerfConfig * SOAP_FMAC4 soap_in_adm__getCmPerfConfig(struct soap *soap, const char *tag, struct adm__getCmPerfConfig *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmPerfConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmPerfConfig, sizeof(struct adm__getCmPerfConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmPerfConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmPerfConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmPerfConfig, 0, sizeof(struct adm__getCmPerfConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmPerfConfig * SOAP_FMAC6 soap_new_adm__getCmPerfConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmPerfConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmPerfConfig(struct soap *soap, struct adm__getCmPerfConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmPerfConfig * SOAP_FMAC4 soap_instantiate_adm__getCmPerfConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmPerfConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmPerfConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmPerfConfig;
		if (size)
			*size = sizeof(struct adm__getCmPerfConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmPerfConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmPerfConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmPerfConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmPerfConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmPerfConfig %p -> %p\n", q, p));
	*(struct adm__getCmPerfConfig*)p = *(struct adm__getCmPerfConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmPerfConfigResponse(struct soap *soap, struct adm__getCmPerfConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmPerf = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmPerfConfigResponse(struct soap *soap, const struct adm__getCmPerfConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmPerformanceConfigT(soap, &a->cmPerf);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmPerfConfigResponse(struct soap *soap, const struct adm__getCmPerfConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmPerfConfigResponse);
	if (soap_out_adm__getCmPerfConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmPerfConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__getCmPerfConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmPerfConfigResponse), type);
	if (a->cmPerf)
		soap_element_result(soap, "cmPerf");
	soap_out_PointerTons1__CmPerformanceConfigT(soap, "cmPerf", -1, &a->cmPerf, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmPerfConfigResponse * SOAP_FMAC4 soap_get_adm__getCmPerfConfigResponse(struct soap *soap, struct adm__getCmPerfConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmPerfConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmPerfConfigResponse * SOAP_FMAC4 soap_in_adm__getCmPerfConfigResponse(struct soap *soap, const char *tag, struct adm__getCmPerfConfigResponse *a, const char *type)
{
	short soap_flag_cmPerf = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmPerfConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmPerfConfigResponse, sizeof(struct adm__getCmPerfConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmPerfConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmPerf && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmPerformanceConfigT(soap, "cmPerf", &a->cmPerf, "ns1:CmPerformanceConfigT"))
				{	soap_flag_cmPerf--;
					continue;
				}
			soap_check_result(soap, "cmPerf");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmPerfConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmPerfConfigResponse, 0, sizeof(struct adm__getCmPerfConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmPerfConfigResponse * SOAP_FMAC6 soap_new_adm__getCmPerfConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmPerfConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmPerfConfigResponse(struct soap *soap, struct adm__getCmPerfConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmPerfConfigResponse * SOAP_FMAC4 soap_instantiate_adm__getCmPerfConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmPerfConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmPerfConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmPerfConfigResponse;
		if (size)
			*size = sizeof(struct adm__getCmPerfConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmPerfConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmPerfConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmPerfConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmPerfConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmPerfConfigResponse %p -> %p\n", q, p));
	*(struct adm__getCmPerfConfigResponse*)p = *(struct adm__getCmPerfConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__deleteBlade(struct soap *soap, struct adm__deleteBlade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__deleteBlade(struct soap *soap, const struct adm__deleteBlade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BladeT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__deleteBlade(struct soap *soap, const struct adm__deleteBlade *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__deleteBlade);
	if (soap_out_adm__deleteBlade(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__deleteBlade(struct soap *soap, const char *tag, int id, const struct adm__deleteBlade *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__deleteBlade), type);
	soap_out_PointerTons1__BladeT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__deleteBlade * SOAP_FMAC4 soap_get_adm__deleteBlade(struct soap *soap, struct adm__deleteBlade *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__deleteBlade(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__deleteBlade * SOAP_FMAC4 soap_in_adm__deleteBlade(struct soap *soap, const char *tag, struct adm__deleteBlade *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__deleteBlade *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__deleteBlade, sizeof(struct adm__deleteBlade), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__deleteBlade(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BladeT(soap, "cmts", &a->cmts, "ns1:BladeT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__deleteBlade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__deleteBlade, 0, sizeof(struct adm__deleteBlade), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__deleteBlade * SOAP_FMAC6 soap_new_adm__deleteBlade(struct soap *soap, int n)
{	return soap_instantiate_adm__deleteBlade(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__deleteBlade(struct soap *soap, struct adm__deleteBlade *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__deleteBlade * SOAP_FMAC4 soap_instantiate_adm__deleteBlade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__deleteBlade(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__deleteBlade, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__deleteBlade;
		if (size)
			*size = sizeof(struct adm__deleteBlade);
	}
	else
	{	cp->ptr = (void*)new struct adm__deleteBlade[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__deleteBlade);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__deleteBlade*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__deleteBlade(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__deleteBlade %p -> %p\n", q, p));
	*(struct adm__deleteBlade*)p = *(struct adm__deleteBlade*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__deleteBladeResponse(struct soap *soap, struct adm__deleteBladeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__deleteBladeResponse(struct soap *soap, const struct adm__deleteBladeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__deleteBladeResponse(struct soap *soap, const struct adm__deleteBladeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__deleteBladeResponse);
	if (soap_out_adm__deleteBladeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__deleteBladeResponse(struct soap *soap, const char *tag, int id, const struct adm__deleteBladeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__deleteBladeResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__deleteBladeResponse * SOAP_FMAC4 soap_get_adm__deleteBladeResponse(struct soap *soap, struct adm__deleteBladeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__deleteBladeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__deleteBladeResponse * SOAP_FMAC4 soap_in_adm__deleteBladeResponse(struct soap *soap, const char *tag, struct adm__deleteBladeResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__deleteBladeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__deleteBladeResponse, sizeof(struct adm__deleteBladeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__deleteBladeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__deleteBladeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__deleteBladeResponse, 0, sizeof(struct adm__deleteBladeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__deleteBladeResponse * SOAP_FMAC6 soap_new_adm__deleteBladeResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__deleteBladeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__deleteBladeResponse(struct soap *soap, struct adm__deleteBladeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__deleteBladeResponse * SOAP_FMAC4 soap_instantiate_adm__deleteBladeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__deleteBladeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__deleteBladeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__deleteBladeResponse;
		if (size)
			*size = sizeof(struct adm__deleteBladeResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__deleteBladeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__deleteBladeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__deleteBladeResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__deleteBladeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__deleteBladeResponse %p -> %p\n", q, p));
	*(struct adm__deleteBladeResponse*)p = *(struct adm__deleteBladeResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addBlade(struct soap *soap, struct adm__addBlade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addBlade(struct soap *soap, const struct adm__addBlade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BladeT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addBlade(struct soap *soap, const struct adm__addBlade *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addBlade);
	if (soap_out_adm__addBlade(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addBlade(struct soap *soap, const char *tag, int id, const struct adm__addBlade *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addBlade), type);
	soap_out_PointerTons1__BladeT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addBlade * SOAP_FMAC4 soap_get_adm__addBlade(struct soap *soap, struct adm__addBlade *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addBlade(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addBlade * SOAP_FMAC4 soap_in_adm__addBlade(struct soap *soap, const char *tag, struct adm__addBlade *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addBlade *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addBlade, sizeof(struct adm__addBlade), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addBlade(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BladeT(soap, "cmts", &a->cmts, "ns1:BladeT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addBlade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addBlade, 0, sizeof(struct adm__addBlade), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addBlade * SOAP_FMAC6 soap_new_adm__addBlade(struct soap *soap, int n)
{	return soap_instantiate_adm__addBlade(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addBlade(struct soap *soap, struct adm__addBlade *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addBlade * SOAP_FMAC4 soap_instantiate_adm__addBlade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addBlade(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addBlade, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addBlade;
		if (size)
			*size = sizeof(struct adm__addBlade);
	}
	else
	{	cp->ptr = (void*)new struct adm__addBlade[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addBlade);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addBlade*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addBlade(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addBlade %p -> %p\n", q, p));
	*(struct adm__addBlade*)p = *(struct adm__addBlade*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addBladeResponse(struct soap *soap, struct adm__addBladeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addBladeResponse(struct soap *soap, const struct adm__addBladeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addBladeResponse(struct soap *soap, const struct adm__addBladeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addBladeResponse);
	if (soap_out_adm__addBladeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addBladeResponse(struct soap *soap, const char *tag, int id, const struct adm__addBladeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addBladeResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addBladeResponse * SOAP_FMAC4 soap_get_adm__addBladeResponse(struct soap *soap, struct adm__addBladeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addBladeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addBladeResponse * SOAP_FMAC4 soap_in_adm__addBladeResponse(struct soap *soap, const char *tag, struct adm__addBladeResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addBladeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addBladeResponse, sizeof(struct adm__addBladeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addBladeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addBladeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addBladeResponse, 0, sizeof(struct adm__addBladeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addBladeResponse * SOAP_FMAC6 soap_new_adm__addBladeResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__addBladeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addBladeResponse(struct soap *soap, struct adm__addBladeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addBladeResponse * SOAP_FMAC4 soap_instantiate_adm__addBladeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addBladeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addBladeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addBladeResponse;
		if (size)
			*size = sizeof(struct adm__addBladeResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__addBladeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addBladeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addBladeResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addBladeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addBladeResponse %p -> %p\n", q, p));
	*(struct adm__addBladeResponse*)p = *(struct adm__addBladeResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateBlade(struct soap *soap, struct adm__updateBlade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateBlade(struct soap *soap, const struct adm__updateBlade *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__BladeT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateBlade(struct soap *soap, const struct adm__updateBlade *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateBlade);
	if (soap_out_adm__updateBlade(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateBlade(struct soap *soap, const char *tag, int id, const struct adm__updateBlade *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateBlade), type);
	soap_out_PointerTons1__BladeT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateBlade * SOAP_FMAC4 soap_get_adm__updateBlade(struct soap *soap, struct adm__updateBlade *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateBlade(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateBlade * SOAP_FMAC4 soap_in_adm__updateBlade(struct soap *soap, const char *tag, struct adm__updateBlade *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateBlade *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateBlade, sizeof(struct adm__updateBlade), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateBlade(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__BladeT(soap, "cmts", &a->cmts, "ns1:BladeT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateBlade *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateBlade, 0, sizeof(struct adm__updateBlade), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateBlade * SOAP_FMAC6 soap_new_adm__updateBlade(struct soap *soap, int n)
{	return soap_instantiate_adm__updateBlade(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateBlade(struct soap *soap, struct adm__updateBlade *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateBlade * SOAP_FMAC4 soap_instantiate_adm__updateBlade(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateBlade(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateBlade, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateBlade;
		if (size)
			*size = sizeof(struct adm__updateBlade);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateBlade[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateBlade);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateBlade*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateBlade(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateBlade %p -> %p\n", q, p));
	*(struct adm__updateBlade*)p = *(struct adm__updateBlade*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateBladeResponse(struct soap *soap, struct adm__updateBladeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateBladeResponse(struct soap *soap, const struct adm__updateBladeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateBladeResponse(struct soap *soap, const struct adm__updateBladeResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateBladeResponse);
	if (soap_out_adm__updateBladeResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateBladeResponse(struct soap *soap, const char *tag, int id, const struct adm__updateBladeResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateBladeResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateBladeResponse * SOAP_FMAC4 soap_get_adm__updateBladeResponse(struct soap *soap, struct adm__updateBladeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateBladeResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateBladeResponse * SOAP_FMAC4 soap_in_adm__updateBladeResponse(struct soap *soap, const char *tag, struct adm__updateBladeResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateBladeResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateBladeResponse, sizeof(struct adm__updateBladeResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateBladeResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateBladeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateBladeResponse, 0, sizeof(struct adm__updateBladeResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateBladeResponse * SOAP_FMAC6 soap_new_adm__updateBladeResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateBladeResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateBladeResponse(struct soap *soap, struct adm__updateBladeResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateBladeResponse * SOAP_FMAC4 soap_instantiate_adm__updateBladeResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateBladeResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateBladeResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateBladeResponse;
		if (size)
			*size = sizeof(struct adm__updateBladeResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateBladeResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateBladeResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateBladeResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateBladeResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateBladeResponse %p -> %p\n", q, p));
	*(struct adm__updateBladeResponse*)p = *(struct adm__updateBladeResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addMarket(struct soap *soap, struct adm__addMarket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addMarket(struct soap *soap, const struct adm__addMarket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MarketT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addMarket(struct soap *soap, const struct adm__addMarket *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addMarket);
	if (soap_out_adm__addMarket(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addMarket(struct soap *soap, const char *tag, int id, const struct adm__addMarket *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addMarket), type);
	soap_out_PointerTons1__MarketT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addMarket * SOAP_FMAC4 soap_get_adm__addMarket(struct soap *soap, struct adm__addMarket *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addMarket(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addMarket * SOAP_FMAC4 soap_in_adm__addMarket(struct soap *soap, const char *tag, struct adm__addMarket *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addMarket *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addMarket, sizeof(struct adm__addMarket), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addMarket(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MarketT(soap, "cmts", &a->cmts, "ns1:MarketT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addMarket *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addMarket, 0, sizeof(struct adm__addMarket), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addMarket * SOAP_FMAC6 soap_new_adm__addMarket(struct soap *soap, int n)
{	return soap_instantiate_adm__addMarket(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addMarket(struct soap *soap, struct adm__addMarket *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addMarket * SOAP_FMAC4 soap_instantiate_adm__addMarket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addMarket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addMarket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addMarket;
		if (size)
			*size = sizeof(struct adm__addMarket);
	}
	else
	{	cp->ptr = (void*)new struct adm__addMarket[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addMarket);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addMarket*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addMarket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addMarket %p -> %p\n", q, p));
	*(struct adm__addMarket*)p = *(struct adm__addMarket*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addMarketResponse(struct soap *soap, struct adm__addMarketResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addMarketResponse(struct soap *soap, const struct adm__addMarketResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addMarketResponse(struct soap *soap, const struct adm__addMarketResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addMarketResponse);
	if (soap_out_adm__addMarketResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addMarketResponse(struct soap *soap, const char *tag, int id, const struct adm__addMarketResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addMarketResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addMarketResponse * SOAP_FMAC4 soap_get_adm__addMarketResponse(struct soap *soap, struct adm__addMarketResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addMarketResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addMarketResponse * SOAP_FMAC4 soap_in_adm__addMarketResponse(struct soap *soap, const char *tag, struct adm__addMarketResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addMarketResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addMarketResponse, sizeof(struct adm__addMarketResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addMarketResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addMarketResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addMarketResponse, 0, sizeof(struct adm__addMarketResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addMarketResponse * SOAP_FMAC6 soap_new_adm__addMarketResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__addMarketResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addMarketResponse(struct soap *soap, struct adm__addMarketResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addMarketResponse * SOAP_FMAC4 soap_instantiate_adm__addMarketResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addMarketResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addMarketResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addMarketResponse;
		if (size)
			*size = sizeof(struct adm__addMarketResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__addMarketResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addMarketResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addMarketResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addMarketResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addMarketResponse %p -> %p\n", q, p));
	*(struct adm__addMarketResponse*)p = *(struct adm__addMarketResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateMarket(struct soap *soap, struct adm__updateMarket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateMarket(struct soap *soap, const struct adm__updateMarket *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MarketT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateMarket(struct soap *soap, const struct adm__updateMarket *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateMarket);
	if (soap_out_adm__updateMarket(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateMarket(struct soap *soap, const char *tag, int id, const struct adm__updateMarket *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateMarket), type);
	soap_out_PointerTons1__MarketT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateMarket * SOAP_FMAC4 soap_get_adm__updateMarket(struct soap *soap, struct adm__updateMarket *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateMarket(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateMarket * SOAP_FMAC4 soap_in_adm__updateMarket(struct soap *soap, const char *tag, struct adm__updateMarket *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateMarket *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateMarket, sizeof(struct adm__updateMarket), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateMarket(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MarketT(soap, "cmts", &a->cmts, "ns1:MarketT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateMarket *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateMarket, 0, sizeof(struct adm__updateMarket), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateMarket * SOAP_FMAC6 soap_new_adm__updateMarket(struct soap *soap, int n)
{	return soap_instantiate_adm__updateMarket(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateMarket(struct soap *soap, struct adm__updateMarket *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateMarket * SOAP_FMAC4 soap_instantiate_adm__updateMarket(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateMarket(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateMarket, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateMarket;
		if (size)
			*size = sizeof(struct adm__updateMarket);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateMarket[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateMarket);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateMarket*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateMarket(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateMarket %p -> %p\n", q, p));
	*(struct adm__updateMarket*)p = *(struct adm__updateMarket*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateMarketResponse(struct soap *soap, struct adm__updateMarketResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateMarketResponse(struct soap *soap, const struct adm__updateMarketResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateMarketResponse(struct soap *soap, const struct adm__updateMarketResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateMarketResponse);
	if (soap_out_adm__updateMarketResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateMarketResponse(struct soap *soap, const char *tag, int id, const struct adm__updateMarketResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateMarketResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateMarketResponse * SOAP_FMAC4 soap_get_adm__updateMarketResponse(struct soap *soap, struct adm__updateMarketResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateMarketResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateMarketResponse * SOAP_FMAC4 soap_in_adm__updateMarketResponse(struct soap *soap, const char *tag, struct adm__updateMarketResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateMarketResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateMarketResponse, sizeof(struct adm__updateMarketResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateMarketResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateMarketResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateMarketResponse, 0, sizeof(struct adm__updateMarketResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateMarketResponse * SOAP_FMAC6 soap_new_adm__updateMarketResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateMarketResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateMarketResponse(struct soap *soap, struct adm__updateMarketResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateMarketResponse * SOAP_FMAC4 soap_instantiate_adm__updateMarketResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateMarketResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateMarketResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateMarketResponse;
		if (size)
			*size = sizeof(struct adm__updateMarketResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateMarketResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateMarketResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateMarketResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateMarketResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateMarketResponse %p -> %p\n", q, p));
	*(struct adm__updateMarketResponse*)p = *(struct adm__updateMarketResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addRegion(struct soap *soap, struct adm__addRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addRegion(struct soap *soap, const struct adm__addRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RegionT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addRegion(struct soap *soap, const struct adm__addRegion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addRegion);
	if (soap_out_adm__addRegion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addRegion(struct soap *soap, const char *tag, int id, const struct adm__addRegion *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addRegion), type);
	soap_out_PointerTons1__RegionT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addRegion * SOAP_FMAC4 soap_get_adm__addRegion(struct soap *soap, struct adm__addRegion *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addRegion(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addRegion * SOAP_FMAC4 soap_in_adm__addRegion(struct soap *soap, const char *tag, struct adm__addRegion *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addRegion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addRegion, sizeof(struct adm__addRegion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addRegion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RegionT(soap, "cmts", &a->cmts, "ns1:RegionT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addRegion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addRegion, 0, sizeof(struct adm__addRegion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addRegion * SOAP_FMAC6 soap_new_adm__addRegion(struct soap *soap, int n)
{	return soap_instantiate_adm__addRegion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addRegion(struct soap *soap, struct adm__addRegion *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addRegion * SOAP_FMAC4 soap_instantiate_adm__addRegion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addRegion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addRegion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addRegion;
		if (size)
			*size = sizeof(struct adm__addRegion);
	}
	else
	{	cp->ptr = (void*)new struct adm__addRegion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addRegion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addRegion*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addRegion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addRegion %p -> %p\n", q, p));
	*(struct adm__addRegion*)p = *(struct adm__addRegion*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addRegionResponse(struct soap *soap, struct adm__addRegionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addRegionResponse(struct soap *soap, const struct adm__addRegionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addRegionResponse(struct soap *soap, const struct adm__addRegionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addRegionResponse);
	if (soap_out_adm__addRegionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addRegionResponse(struct soap *soap, const char *tag, int id, const struct adm__addRegionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addRegionResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addRegionResponse * SOAP_FMAC4 soap_get_adm__addRegionResponse(struct soap *soap, struct adm__addRegionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addRegionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addRegionResponse * SOAP_FMAC4 soap_in_adm__addRegionResponse(struct soap *soap, const char *tag, struct adm__addRegionResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addRegionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addRegionResponse, sizeof(struct adm__addRegionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addRegionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addRegionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addRegionResponse, 0, sizeof(struct adm__addRegionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addRegionResponse * SOAP_FMAC6 soap_new_adm__addRegionResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__addRegionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addRegionResponse(struct soap *soap, struct adm__addRegionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addRegionResponse * SOAP_FMAC4 soap_instantiate_adm__addRegionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addRegionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addRegionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addRegionResponse;
		if (size)
			*size = sizeof(struct adm__addRegionResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__addRegionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addRegionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addRegionResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addRegionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addRegionResponse %p -> %p\n", q, p));
	*(struct adm__addRegionResponse*)p = *(struct adm__addRegionResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateRegion(struct soap *soap, struct adm__updateRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateRegion(struct soap *soap, const struct adm__updateRegion *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__RegionT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateRegion(struct soap *soap, const struct adm__updateRegion *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateRegion);
	if (soap_out_adm__updateRegion(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateRegion(struct soap *soap, const char *tag, int id, const struct adm__updateRegion *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateRegion), type);
	soap_out_PointerTons1__RegionT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateRegion * SOAP_FMAC4 soap_get_adm__updateRegion(struct soap *soap, struct adm__updateRegion *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateRegion(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateRegion * SOAP_FMAC4 soap_in_adm__updateRegion(struct soap *soap, const char *tag, struct adm__updateRegion *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateRegion *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateRegion, sizeof(struct adm__updateRegion), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateRegion(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__RegionT(soap, "cmts", &a->cmts, "ns1:RegionT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateRegion *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateRegion, 0, sizeof(struct adm__updateRegion), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateRegion * SOAP_FMAC6 soap_new_adm__updateRegion(struct soap *soap, int n)
{	return soap_instantiate_adm__updateRegion(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateRegion(struct soap *soap, struct adm__updateRegion *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateRegion * SOAP_FMAC4 soap_instantiate_adm__updateRegion(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateRegion(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateRegion, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateRegion;
		if (size)
			*size = sizeof(struct adm__updateRegion);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateRegion[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateRegion);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateRegion*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateRegion(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateRegion %p -> %p\n", q, p));
	*(struct adm__updateRegion*)p = *(struct adm__updateRegion*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateRegionResponse(struct soap *soap, struct adm__updateRegionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateRegionResponse(struct soap *soap, const struct adm__updateRegionResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateRegionResponse(struct soap *soap, const struct adm__updateRegionResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateRegionResponse);
	if (soap_out_adm__updateRegionResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateRegionResponse(struct soap *soap, const char *tag, int id, const struct adm__updateRegionResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateRegionResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateRegionResponse * SOAP_FMAC4 soap_get_adm__updateRegionResponse(struct soap *soap, struct adm__updateRegionResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateRegionResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateRegionResponse * SOAP_FMAC4 soap_in_adm__updateRegionResponse(struct soap *soap, const char *tag, struct adm__updateRegionResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateRegionResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateRegionResponse, sizeof(struct adm__updateRegionResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateRegionResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateRegionResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateRegionResponse, 0, sizeof(struct adm__updateRegionResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateRegionResponse * SOAP_FMAC6 soap_new_adm__updateRegionResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateRegionResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateRegionResponse(struct soap *soap, struct adm__updateRegionResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateRegionResponse * SOAP_FMAC4 soap_instantiate_adm__updateRegionResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateRegionResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateRegionResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateRegionResponse;
		if (size)
			*size = sizeof(struct adm__updateRegionResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateRegionResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateRegionResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateRegionResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateRegionResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateRegionResponse %p -> %p\n", q, p));
	*(struct adm__updateRegionResponse*)p = *(struct adm__updateRegionResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateLocalSystem(struct soap *soap, struct adm__updateLocalSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateLocalSystem(struct soap *soap, const struct adm__updateLocalSystem *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__LocalSystemT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateLocalSystem(struct soap *soap, const struct adm__updateLocalSystem *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateLocalSystem);
	if (soap_out_adm__updateLocalSystem(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateLocalSystem(struct soap *soap, const char *tag, int id, const struct adm__updateLocalSystem *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateLocalSystem), type);
	soap_out_PointerTons1__LocalSystemT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateLocalSystem * SOAP_FMAC4 soap_get_adm__updateLocalSystem(struct soap *soap, struct adm__updateLocalSystem *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateLocalSystem(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateLocalSystem * SOAP_FMAC4 soap_in_adm__updateLocalSystem(struct soap *soap, const char *tag, struct adm__updateLocalSystem *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateLocalSystem *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateLocalSystem, sizeof(struct adm__updateLocalSystem), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateLocalSystem(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__LocalSystemT(soap, "cmts", &a->cmts, "ns1:LocalSystemT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateLocalSystem *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateLocalSystem, 0, sizeof(struct adm__updateLocalSystem), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateLocalSystem * SOAP_FMAC6 soap_new_adm__updateLocalSystem(struct soap *soap, int n)
{	return soap_instantiate_adm__updateLocalSystem(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateLocalSystem(struct soap *soap, struct adm__updateLocalSystem *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateLocalSystem * SOAP_FMAC4 soap_instantiate_adm__updateLocalSystem(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateLocalSystem(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateLocalSystem, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateLocalSystem;
		if (size)
			*size = sizeof(struct adm__updateLocalSystem);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateLocalSystem[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateLocalSystem);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateLocalSystem*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateLocalSystem(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateLocalSystem %p -> %p\n", q, p));
	*(struct adm__updateLocalSystem*)p = *(struct adm__updateLocalSystem*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateLocalSystemResponse(struct soap *soap, struct adm__updateLocalSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateLocalSystemResponse(struct soap *soap, const struct adm__updateLocalSystemResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateLocalSystemResponse(struct soap *soap, const struct adm__updateLocalSystemResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateLocalSystemResponse);
	if (soap_out_adm__updateLocalSystemResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateLocalSystemResponse(struct soap *soap, const char *tag, int id, const struct adm__updateLocalSystemResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateLocalSystemResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateLocalSystemResponse * SOAP_FMAC4 soap_get_adm__updateLocalSystemResponse(struct soap *soap, struct adm__updateLocalSystemResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateLocalSystemResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateLocalSystemResponse * SOAP_FMAC4 soap_in_adm__updateLocalSystemResponse(struct soap *soap, const char *tag, struct adm__updateLocalSystemResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateLocalSystemResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateLocalSystemResponse, sizeof(struct adm__updateLocalSystemResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateLocalSystemResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateLocalSystemResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateLocalSystemResponse, 0, sizeof(struct adm__updateLocalSystemResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateLocalSystemResponse * SOAP_FMAC6 soap_new_adm__updateLocalSystemResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateLocalSystemResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateLocalSystemResponse(struct soap *soap, struct adm__updateLocalSystemResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateLocalSystemResponse * SOAP_FMAC4 soap_instantiate_adm__updateLocalSystemResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateLocalSystemResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateLocalSystemResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateLocalSystemResponse;
		if (size)
			*size = sizeof(struct adm__updateLocalSystemResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateLocalSystemResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateLocalSystemResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateLocalSystemResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateLocalSystemResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateLocalSystemResponse %p -> %p\n", q, p));
	*(struct adm__updateLocalSystemResponse*)p = *(struct adm__updateLocalSystemResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmsAlarmConfig(struct soap *soap, struct adm__updateCmsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmsAlarmConfig(struct soap *soap, const struct adm__updateCmsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmsAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmsAlarmConfig(struct soap *soap, const struct adm__updateCmsAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmsAlarmConfig);
	if (soap_out_adm__updateCmsAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmsAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__updateCmsAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmsAlarmConfig), type);
	soap_out_PointerTons1__CmsAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmsAlarmConfig * SOAP_FMAC4 soap_get_adm__updateCmsAlarmConfig(struct soap *soap, struct adm__updateCmsAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmsAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmsAlarmConfig * SOAP_FMAC4 soap_in_adm__updateCmsAlarmConfig(struct soap *soap, const char *tag, struct adm__updateCmsAlarmConfig *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmsAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmsAlarmConfig, sizeof(struct adm__updateCmsAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmsAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:CmsAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmsAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmsAlarmConfig, 0, sizeof(struct adm__updateCmsAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmsAlarmConfig * SOAP_FMAC6 soap_new_adm__updateCmsAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmsAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmsAlarmConfig(struct soap *soap, struct adm__updateCmsAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmsAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__updateCmsAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmsAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmsAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmsAlarmConfig;
		if (size)
			*size = sizeof(struct adm__updateCmsAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmsAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmsAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmsAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmsAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmsAlarmConfig %p -> %p\n", q, p));
	*(struct adm__updateCmsAlarmConfig*)p = *(struct adm__updateCmsAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmsAlarmConfigResponse(struct soap *soap, struct adm__updateCmsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmsAlarmConfigResponse(struct soap *soap, const struct adm__updateCmsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmsAlarmConfigResponse(struct soap *soap, const struct adm__updateCmsAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmsAlarmConfigResponse);
	if (soap_out_adm__updateCmsAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmsAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmsAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmsAlarmConfigResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmsAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__updateCmsAlarmConfigResponse(struct soap *soap, struct adm__updateCmsAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmsAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmsAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__updateCmsAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__updateCmsAlarmConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmsAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmsAlarmConfigResponse, sizeof(struct adm__updateCmsAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmsAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmsAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmsAlarmConfigResponse, 0, sizeof(struct adm__updateCmsAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmsAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__updateCmsAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmsAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmsAlarmConfigResponse(struct soap *soap, struct adm__updateCmsAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmsAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmsAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmsAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmsAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmsAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__updateCmsAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmsAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmsAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmsAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmsAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmsAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__updateCmsAlarmConfigResponse*)p = *(struct adm__updateCmsAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmsAlarmConfig(struct soap *soap, struct adm__getCmsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmsAlarmConfig(struct soap *soap, const struct adm__getCmsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmsAlarmConfig(struct soap *soap, const struct adm__getCmsAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmsAlarmConfig);
	if (soap_out_adm__getCmsAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmsAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__getCmsAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmsAlarmConfig), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmsAlarmConfig * SOAP_FMAC4 soap_get_adm__getCmsAlarmConfig(struct soap *soap, struct adm__getCmsAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmsAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmsAlarmConfig * SOAP_FMAC4 soap_in_adm__getCmsAlarmConfig(struct soap *soap, const char *tag, struct adm__getCmsAlarmConfig *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmsAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmsAlarmConfig, sizeof(struct adm__getCmsAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmsAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmsAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmsAlarmConfig, 0, sizeof(struct adm__getCmsAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmsAlarmConfig * SOAP_FMAC6 soap_new_adm__getCmsAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmsAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmsAlarmConfig(struct soap *soap, struct adm__getCmsAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmsAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__getCmsAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmsAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmsAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmsAlarmConfig;
		if (size)
			*size = sizeof(struct adm__getCmsAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmsAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmsAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmsAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmsAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmsAlarmConfig %p -> %p\n", q, p));
	*(struct adm__getCmsAlarmConfig*)p = *(struct adm__getCmsAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmsAlarmConfigResponse(struct soap *soap, struct adm__getCmsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmsAlarmConfigResponse(struct soap *soap, const struct adm__getCmsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmsAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmsAlarmConfigResponse(struct soap *soap, const struct adm__getCmsAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmsAlarmConfigResponse);
	if (soap_out_adm__getCmsAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmsAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__getCmsAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmsAlarmConfigResponse), type);
	if (a->alarmConfig)
		soap_element_result(soap, "alarmConfig");
	soap_out_PointerTons1__CmsAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmsAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__getCmsAlarmConfigResponse(struct soap *soap, struct adm__getCmsAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmsAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmsAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__getCmsAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__getCmsAlarmConfigResponse *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmsAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmsAlarmConfigResponse, sizeof(struct adm__getCmsAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmsAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:CmsAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			soap_check_result(soap, "alarmConfig");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmsAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmsAlarmConfigResponse, 0, sizeof(struct adm__getCmsAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmsAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__getCmsAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmsAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmsAlarmConfigResponse(struct soap *soap, struct adm__getCmsAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmsAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__getCmsAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmsAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmsAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmsAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__getCmsAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmsAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmsAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmsAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmsAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmsAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__getCmsAlarmConfigResponse*)p = *(struct adm__getCmsAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmtsAlarmConfig(struct soap *soap, struct adm__updateCmtsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmtsAlarmConfig(struct soap *soap, const struct adm__updateCmtsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmtsAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmtsAlarmConfig(struct soap *soap, const struct adm__updateCmtsAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmtsAlarmConfig);
	if (soap_out_adm__updateCmtsAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmtsAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__updateCmtsAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmtsAlarmConfig), type);
	soap_out_PointerTons1__CmtsAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmtsAlarmConfig * SOAP_FMAC4 soap_get_adm__updateCmtsAlarmConfig(struct soap *soap, struct adm__updateCmtsAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmtsAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmtsAlarmConfig * SOAP_FMAC4 soap_in_adm__updateCmtsAlarmConfig(struct soap *soap, const char *tag, struct adm__updateCmtsAlarmConfig *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmtsAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmtsAlarmConfig, sizeof(struct adm__updateCmtsAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmtsAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:CmtsAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmtsAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmtsAlarmConfig, 0, sizeof(struct adm__updateCmtsAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmtsAlarmConfig * SOAP_FMAC6 soap_new_adm__updateCmtsAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmtsAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmtsAlarmConfig(struct soap *soap, struct adm__updateCmtsAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmtsAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__updateCmtsAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmtsAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmtsAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmtsAlarmConfig;
		if (size)
			*size = sizeof(struct adm__updateCmtsAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmtsAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmtsAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmtsAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmtsAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmtsAlarmConfig %p -> %p\n", q, p));
	*(struct adm__updateCmtsAlarmConfig*)p = *(struct adm__updateCmtsAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmtsAlarmConfigResponse(struct soap *soap, struct adm__updateCmtsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmtsAlarmConfigResponse(struct soap *soap, const struct adm__updateCmtsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmtsAlarmConfigResponse(struct soap *soap, const struct adm__updateCmtsAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmtsAlarmConfigResponse);
	if (soap_out_adm__updateCmtsAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmtsAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmtsAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmtsAlarmConfigResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmtsAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__updateCmtsAlarmConfigResponse(struct soap *soap, struct adm__updateCmtsAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmtsAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmtsAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__updateCmtsAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__updateCmtsAlarmConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmtsAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmtsAlarmConfigResponse, sizeof(struct adm__updateCmtsAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmtsAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmtsAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmtsAlarmConfigResponse, 0, sizeof(struct adm__updateCmtsAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmtsAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__updateCmtsAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmtsAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmtsAlarmConfigResponse(struct soap *soap, struct adm__updateCmtsAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmtsAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmtsAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmtsAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmtsAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmtsAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__updateCmtsAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmtsAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmtsAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmtsAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmtsAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmtsAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__updateCmtsAlarmConfigResponse*)p = *(struct adm__updateCmtsAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmtsAlarmConfig(struct soap *soap, struct adm__getCmtsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmtsAlarmConfig(struct soap *soap, const struct adm__getCmtsAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmtsAlarmConfig(struct soap *soap, const struct adm__getCmtsAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmtsAlarmConfig);
	if (soap_out_adm__getCmtsAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmtsAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__getCmtsAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmtsAlarmConfig), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmtsAlarmConfig * SOAP_FMAC4 soap_get_adm__getCmtsAlarmConfig(struct soap *soap, struct adm__getCmtsAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmtsAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmtsAlarmConfig * SOAP_FMAC4 soap_in_adm__getCmtsAlarmConfig(struct soap *soap, const char *tag, struct adm__getCmtsAlarmConfig *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmtsAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmtsAlarmConfig, sizeof(struct adm__getCmtsAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmtsAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmtsAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmtsAlarmConfig, 0, sizeof(struct adm__getCmtsAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmtsAlarmConfig * SOAP_FMAC6 soap_new_adm__getCmtsAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmtsAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmtsAlarmConfig(struct soap *soap, struct adm__getCmtsAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmtsAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__getCmtsAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmtsAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmtsAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmtsAlarmConfig;
		if (size)
			*size = sizeof(struct adm__getCmtsAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmtsAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmtsAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmtsAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmtsAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmtsAlarmConfig %p -> %p\n", q, p));
	*(struct adm__getCmtsAlarmConfig*)p = *(struct adm__getCmtsAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmtsAlarmConfigResponse(struct soap *soap, struct adm__getCmtsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmtsAlarmConfigResponse(struct soap *soap, const struct adm__getCmtsAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmtsAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmtsAlarmConfigResponse(struct soap *soap, const struct adm__getCmtsAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmtsAlarmConfigResponse);
	if (soap_out_adm__getCmtsAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmtsAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__getCmtsAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmtsAlarmConfigResponse), type);
	if (a->alarmConfig)
		soap_element_result(soap, "alarmConfig");
	soap_out_PointerTons1__CmtsAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmtsAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__getCmtsAlarmConfigResponse(struct soap *soap, struct adm__getCmtsAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmtsAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmtsAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__getCmtsAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__getCmtsAlarmConfigResponse *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmtsAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmtsAlarmConfigResponse, sizeof(struct adm__getCmtsAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmtsAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:CmtsAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			soap_check_result(soap, "alarmConfig");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmtsAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmtsAlarmConfigResponse, 0, sizeof(struct adm__getCmtsAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmtsAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__getCmtsAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmtsAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmtsAlarmConfigResponse(struct soap *soap, struct adm__getCmtsAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmtsAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__getCmtsAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmtsAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmtsAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmtsAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__getCmtsAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmtsAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmtsAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmtsAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmtsAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmtsAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__getCmtsAlarmConfigResponse*)p = *(struct adm__getCmtsAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateHfcAlarmConfig(struct soap *soap, struct adm__updateHfcAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateHfcAlarmConfig(struct soap *soap, const struct adm__updateHfcAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HfcAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateHfcAlarmConfig(struct soap *soap, const struct adm__updateHfcAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateHfcAlarmConfig);
	if (soap_out_adm__updateHfcAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateHfcAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__updateHfcAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateHfcAlarmConfig), type);
	soap_out_PointerTons1__HfcAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateHfcAlarmConfig * SOAP_FMAC4 soap_get_adm__updateHfcAlarmConfig(struct soap *soap, struct adm__updateHfcAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateHfcAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateHfcAlarmConfig * SOAP_FMAC4 soap_in_adm__updateHfcAlarmConfig(struct soap *soap, const char *tag, struct adm__updateHfcAlarmConfig *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateHfcAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateHfcAlarmConfig, sizeof(struct adm__updateHfcAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateHfcAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HfcAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:HfcAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateHfcAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateHfcAlarmConfig, 0, sizeof(struct adm__updateHfcAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateHfcAlarmConfig * SOAP_FMAC6 soap_new_adm__updateHfcAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__updateHfcAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateHfcAlarmConfig(struct soap *soap, struct adm__updateHfcAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateHfcAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__updateHfcAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateHfcAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateHfcAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateHfcAlarmConfig;
		if (size)
			*size = sizeof(struct adm__updateHfcAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateHfcAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateHfcAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateHfcAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateHfcAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateHfcAlarmConfig %p -> %p\n", q, p));
	*(struct adm__updateHfcAlarmConfig*)p = *(struct adm__updateHfcAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateHfcAlarmConfigResponse(struct soap *soap, struct adm__updateHfcAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateHfcAlarmConfigResponse(struct soap *soap, const struct adm__updateHfcAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateHfcAlarmConfigResponse(struct soap *soap, const struct adm__updateHfcAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateHfcAlarmConfigResponse);
	if (soap_out_adm__updateHfcAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateHfcAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__updateHfcAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateHfcAlarmConfigResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateHfcAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__updateHfcAlarmConfigResponse(struct soap *soap, struct adm__updateHfcAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateHfcAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateHfcAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__updateHfcAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__updateHfcAlarmConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateHfcAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateHfcAlarmConfigResponse, sizeof(struct adm__updateHfcAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateHfcAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateHfcAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateHfcAlarmConfigResponse, 0, sizeof(struct adm__updateHfcAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateHfcAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__updateHfcAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateHfcAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateHfcAlarmConfigResponse(struct soap *soap, struct adm__updateHfcAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateHfcAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__updateHfcAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateHfcAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateHfcAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateHfcAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__updateHfcAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateHfcAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateHfcAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateHfcAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateHfcAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateHfcAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__updateHfcAlarmConfigResponse*)p = *(struct adm__updateHfcAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getHfcAlarmConfig(struct soap *soap, struct adm__getHfcAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getHfcAlarmConfig(struct soap *soap, const struct adm__getHfcAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getHfcAlarmConfig(struct soap *soap, const struct adm__getHfcAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getHfcAlarmConfig);
	if (soap_out_adm__getHfcAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getHfcAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__getHfcAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getHfcAlarmConfig), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getHfcAlarmConfig * SOAP_FMAC4 soap_get_adm__getHfcAlarmConfig(struct soap *soap, struct adm__getHfcAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getHfcAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getHfcAlarmConfig * SOAP_FMAC4 soap_in_adm__getHfcAlarmConfig(struct soap *soap, const char *tag, struct adm__getHfcAlarmConfig *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getHfcAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getHfcAlarmConfig, sizeof(struct adm__getHfcAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getHfcAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getHfcAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getHfcAlarmConfig, 0, sizeof(struct adm__getHfcAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getHfcAlarmConfig * SOAP_FMAC6 soap_new_adm__getHfcAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__getHfcAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getHfcAlarmConfig(struct soap *soap, struct adm__getHfcAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getHfcAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__getHfcAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getHfcAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getHfcAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getHfcAlarmConfig;
		if (size)
			*size = sizeof(struct adm__getHfcAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__getHfcAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getHfcAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getHfcAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getHfcAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getHfcAlarmConfig %p -> %p\n", q, p));
	*(struct adm__getHfcAlarmConfig*)p = *(struct adm__getHfcAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getHfcAlarmConfigResponse(struct soap *soap, struct adm__getHfcAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getHfcAlarmConfigResponse(struct soap *soap, const struct adm__getHfcAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HfcAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getHfcAlarmConfigResponse(struct soap *soap, const struct adm__getHfcAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getHfcAlarmConfigResponse);
	if (soap_out_adm__getHfcAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getHfcAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__getHfcAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getHfcAlarmConfigResponse), type);
	if (a->alarmConfig)
		soap_element_result(soap, "alarmConfig");
	soap_out_PointerTons1__HfcAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getHfcAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__getHfcAlarmConfigResponse(struct soap *soap, struct adm__getHfcAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getHfcAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getHfcAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__getHfcAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__getHfcAlarmConfigResponse *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getHfcAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getHfcAlarmConfigResponse, sizeof(struct adm__getHfcAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getHfcAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HfcAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:HfcAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			soap_check_result(soap, "alarmConfig");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getHfcAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getHfcAlarmConfigResponse, 0, sizeof(struct adm__getHfcAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getHfcAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__getHfcAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getHfcAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getHfcAlarmConfigResponse(struct soap *soap, struct adm__getHfcAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getHfcAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__getHfcAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getHfcAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getHfcAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getHfcAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__getHfcAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getHfcAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getHfcAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getHfcAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getHfcAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getHfcAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__getHfcAlarmConfigResponse*)p = *(struct adm__getHfcAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateMtaAlarmConfig(struct soap *soap, struct adm__updateMtaAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateMtaAlarmConfig(struct soap *soap, const struct adm__updateMtaAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateMtaAlarmConfig(struct soap *soap, const struct adm__updateMtaAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateMtaAlarmConfig);
	if (soap_out_adm__updateMtaAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateMtaAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__updateMtaAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateMtaAlarmConfig), type);
	soap_out_PointerTons1__MtaAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateMtaAlarmConfig * SOAP_FMAC4 soap_get_adm__updateMtaAlarmConfig(struct soap *soap, struct adm__updateMtaAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateMtaAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateMtaAlarmConfig * SOAP_FMAC4 soap_in_adm__updateMtaAlarmConfig(struct soap *soap, const char *tag, struct adm__updateMtaAlarmConfig *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateMtaAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateMtaAlarmConfig, sizeof(struct adm__updateMtaAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateMtaAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:MtaAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateMtaAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateMtaAlarmConfig, 0, sizeof(struct adm__updateMtaAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateMtaAlarmConfig * SOAP_FMAC6 soap_new_adm__updateMtaAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__updateMtaAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateMtaAlarmConfig(struct soap *soap, struct adm__updateMtaAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateMtaAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__updateMtaAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateMtaAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateMtaAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateMtaAlarmConfig;
		if (size)
			*size = sizeof(struct adm__updateMtaAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateMtaAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateMtaAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateMtaAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateMtaAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateMtaAlarmConfig %p -> %p\n", q, p));
	*(struct adm__updateMtaAlarmConfig*)p = *(struct adm__updateMtaAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateMtaAlarmConfigResponse(struct soap *soap, struct adm__updateMtaAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateMtaAlarmConfigResponse(struct soap *soap, const struct adm__updateMtaAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateMtaAlarmConfigResponse(struct soap *soap, const struct adm__updateMtaAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateMtaAlarmConfigResponse);
	if (soap_out_adm__updateMtaAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateMtaAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__updateMtaAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateMtaAlarmConfigResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateMtaAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__updateMtaAlarmConfigResponse(struct soap *soap, struct adm__updateMtaAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateMtaAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateMtaAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__updateMtaAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__updateMtaAlarmConfigResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateMtaAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateMtaAlarmConfigResponse, sizeof(struct adm__updateMtaAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateMtaAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateMtaAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateMtaAlarmConfigResponse, 0, sizeof(struct adm__updateMtaAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateMtaAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__updateMtaAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateMtaAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateMtaAlarmConfigResponse(struct soap *soap, struct adm__updateMtaAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateMtaAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__updateMtaAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateMtaAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateMtaAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateMtaAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__updateMtaAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateMtaAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateMtaAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateMtaAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateMtaAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateMtaAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__updateMtaAlarmConfigResponse*)p = *(struct adm__updateMtaAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getMtaAlarmConfig(struct soap *soap, struct adm__getMtaAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getMtaAlarmConfig(struct soap *soap, const struct adm__getMtaAlarmConfig *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getMtaAlarmConfig(struct soap *soap, const struct adm__getMtaAlarmConfig *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getMtaAlarmConfig);
	if (soap_out_adm__getMtaAlarmConfig(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getMtaAlarmConfig(struct soap *soap, const char *tag, int id, const struct adm__getMtaAlarmConfig *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getMtaAlarmConfig), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getMtaAlarmConfig * SOAP_FMAC4 soap_get_adm__getMtaAlarmConfig(struct soap *soap, struct adm__getMtaAlarmConfig *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getMtaAlarmConfig(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getMtaAlarmConfig * SOAP_FMAC4 soap_in_adm__getMtaAlarmConfig(struct soap *soap, const char *tag, struct adm__getMtaAlarmConfig *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getMtaAlarmConfig *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getMtaAlarmConfig, sizeof(struct adm__getMtaAlarmConfig), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getMtaAlarmConfig(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getMtaAlarmConfig *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getMtaAlarmConfig, 0, sizeof(struct adm__getMtaAlarmConfig), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getMtaAlarmConfig * SOAP_FMAC6 soap_new_adm__getMtaAlarmConfig(struct soap *soap, int n)
{	return soap_instantiate_adm__getMtaAlarmConfig(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getMtaAlarmConfig(struct soap *soap, struct adm__getMtaAlarmConfig *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getMtaAlarmConfig * SOAP_FMAC4 soap_instantiate_adm__getMtaAlarmConfig(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getMtaAlarmConfig(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getMtaAlarmConfig, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getMtaAlarmConfig;
		if (size)
			*size = sizeof(struct adm__getMtaAlarmConfig);
	}
	else
	{	cp->ptr = (void*)new struct adm__getMtaAlarmConfig[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getMtaAlarmConfig);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getMtaAlarmConfig*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getMtaAlarmConfig(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getMtaAlarmConfig %p -> %p\n", q, p));
	*(struct adm__getMtaAlarmConfig*)p = *(struct adm__getMtaAlarmConfig*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getMtaAlarmConfigResponse(struct soap *soap, struct adm__getMtaAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->alarmConfig = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getMtaAlarmConfigResponse(struct soap *soap, const struct adm__getMtaAlarmConfigResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaAlarmConfigT(soap, &a->alarmConfig);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getMtaAlarmConfigResponse(struct soap *soap, const struct adm__getMtaAlarmConfigResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getMtaAlarmConfigResponse);
	if (soap_out_adm__getMtaAlarmConfigResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getMtaAlarmConfigResponse(struct soap *soap, const char *tag, int id, const struct adm__getMtaAlarmConfigResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getMtaAlarmConfigResponse), type);
	if (a->alarmConfig)
		soap_element_result(soap, "alarmConfig");
	soap_out_PointerTons1__MtaAlarmConfigT(soap, "alarmConfig", -1, &a->alarmConfig, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getMtaAlarmConfigResponse * SOAP_FMAC4 soap_get_adm__getMtaAlarmConfigResponse(struct soap *soap, struct adm__getMtaAlarmConfigResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getMtaAlarmConfigResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getMtaAlarmConfigResponse * SOAP_FMAC4 soap_in_adm__getMtaAlarmConfigResponse(struct soap *soap, const char *tag, struct adm__getMtaAlarmConfigResponse *a, const char *type)
{
	short soap_flag_alarmConfig = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getMtaAlarmConfigResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getMtaAlarmConfigResponse, sizeof(struct adm__getMtaAlarmConfigResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getMtaAlarmConfigResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_alarmConfig && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaAlarmConfigT(soap, "alarmConfig", &a->alarmConfig, "ns1:MtaAlarmConfigT"))
				{	soap_flag_alarmConfig--;
					continue;
				}
			soap_check_result(soap, "alarmConfig");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getMtaAlarmConfigResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getMtaAlarmConfigResponse, 0, sizeof(struct adm__getMtaAlarmConfigResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getMtaAlarmConfigResponse * SOAP_FMAC6 soap_new_adm__getMtaAlarmConfigResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getMtaAlarmConfigResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getMtaAlarmConfigResponse(struct soap *soap, struct adm__getMtaAlarmConfigResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getMtaAlarmConfigResponse * SOAP_FMAC4 soap_instantiate_adm__getMtaAlarmConfigResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getMtaAlarmConfigResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getMtaAlarmConfigResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getMtaAlarmConfigResponse;
		if (size)
			*size = sizeof(struct adm__getMtaAlarmConfigResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getMtaAlarmConfigResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getMtaAlarmConfigResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getMtaAlarmConfigResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getMtaAlarmConfigResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getMtaAlarmConfigResponse %p -> %p\n", q, p));
	*(struct adm__getMtaAlarmConfigResponse*)p = *(struct adm__getMtaAlarmConfigResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmsStatusThreshold(struct soap *soap, struct adm__updateCmsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pollintInterval = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmsStatusThreshold(struct soap *soap, const struct adm__updateCmsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmsStatusThresholdT(soap, &a->pollintInterval);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmsStatusThreshold(struct soap *soap, const struct adm__updateCmsStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmsStatusThreshold);
	if (soap_out_adm__updateCmsStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmsStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__updateCmsStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmsStatusThreshold), type);
	soap_out_PointerTons1__CmsStatusThresholdT(soap, "pollintInterval", -1, &a->pollintInterval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmsStatusThreshold * SOAP_FMAC4 soap_get_adm__updateCmsStatusThreshold(struct soap *soap, struct adm__updateCmsStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmsStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmsStatusThreshold * SOAP_FMAC4 soap_in_adm__updateCmsStatusThreshold(struct soap *soap, const char *tag, struct adm__updateCmsStatusThreshold *a, const char *type)
{
	short soap_flag_pollintInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmsStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmsStatusThreshold, sizeof(struct adm__updateCmsStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmsStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pollintInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsStatusThresholdT(soap, "pollintInterval", &a->pollintInterval, "ns1:CmsStatusThresholdT"))
				{	soap_flag_pollintInterval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmsStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmsStatusThreshold, 0, sizeof(struct adm__updateCmsStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmsStatusThreshold * SOAP_FMAC6 soap_new_adm__updateCmsStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmsStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmsStatusThreshold(struct soap *soap, struct adm__updateCmsStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmsStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__updateCmsStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmsStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmsStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmsStatusThreshold;
		if (size)
			*size = sizeof(struct adm__updateCmsStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmsStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmsStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmsStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmsStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmsStatusThreshold %p -> %p\n", q, p));
	*(struct adm__updateCmsStatusThreshold*)p = *(struct adm__updateCmsStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmsStatusThresholdResponse(struct soap *soap, struct adm__updateCmsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmsStatusThresholdResponse(struct soap *soap, const struct adm__updateCmsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmsStatusThresholdResponse(struct soap *soap, const struct adm__updateCmsStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmsStatusThresholdResponse);
	if (soap_out_adm__updateCmsStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmsStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmsStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmsStatusThresholdResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmsStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__updateCmsStatusThresholdResponse(struct soap *soap, struct adm__updateCmsStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmsStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmsStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__updateCmsStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__updateCmsStatusThresholdResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmsStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmsStatusThresholdResponse, sizeof(struct adm__updateCmsStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmsStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmsStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmsStatusThresholdResponse, 0, sizeof(struct adm__updateCmsStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmsStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__updateCmsStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmsStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmsStatusThresholdResponse(struct soap *soap, struct adm__updateCmsStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmsStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmsStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmsStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmsStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmsStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__updateCmsStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmsStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmsStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmsStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmsStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmsStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__updateCmsStatusThresholdResponse*)p = *(struct adm__updateCmsStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmsStatusThreshold(struct soap *soap, struct adm__getCmsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmsStatusThreshold(struct soap *soap, const struct adm__getCmsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmsStatusThreshold(struct soap *soap, const struct adm__getCmsStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmsStatusThreshold);
	if (soap_out_adm__getCmsStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmsStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__getCmsStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmsStatusThreshold), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmsStatusThreshold * SOAP_FMAC4 soap_get_adm__getCmsStatusThreshold(struct soap *soap, struct adm__getCmsStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmsStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmsStatusThreshold * SOAP_FMAC4 soap_in_adm__getCmsStatusThreshold(struct soap *soap, const char *tag, struct adm__getCmsStatusThreshold *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmsStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmsStatusThreshold, sizeof(struct adm__getCmsStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmsStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmsStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmsStatusThreshold, 0, sizeof(struct adm__getCmsStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmsStatusThreshold * SOAP_FMAC6 soap_new_adm__getCmsStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmsStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmsStatusThreshold(struct soap *soap, struct adm__getCmsStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmsStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__getCmsStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmsStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmsStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmsStatusThreshold;
		if (size)
			*size = sizeof(struct adm__getCmsStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmsStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmsStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmsStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmsStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmsStatusThreshold %p -> %p\n", q, p));
	*(struct adm__getCmsStatusThreshold*)p = *(struct adm__getCmsStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmsStatusThresholdResponse(struct soap *soap, struct adm__getCmsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->threshold = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmsStatusThresholdResponse(struct soap *soap, const struct adm__getCmsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmsStatusThresholdT(soap, &a->threshold);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmsStatusThresholdResponse(struct soap *soap, const struct adm__getCmsStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmsStatusThresholdResponse);
	if (soap_out_adm__getCmsStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmsStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__getCmsStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmsStatusThresholdResponse), type);
	if (a->threshold)
		soap_element_result(soap, "threshold");
	soap_out_PointerTons1__CmsStatusThresholdT(soap, "threshold", -1, &a->threshold, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmsStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__getCmsStatusThresholdResponse(struct soap *soap, struct adm__getCmsStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmsStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmsStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__getCmsStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__getCmsStatusThresholdResponse *a, const char *type)
{
	short soap_flag_threshold = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmsStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmsStatusThresholdResponse, sizeof(struct adm__getCmsStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmsStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_threshold && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsStatusThresholdT(soap, "threshold", &a->threshold, "ns1:CmsStatusThresholdT"))
				{	soap_flag_threshold--;
					continue;
				}
			soap_check_result(soap, "threshold");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmsStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmsStatusThresholdResponse, 0, sizeof(struct adm__getCmsStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmsStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__getCmsStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmsStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmsStatusThresholdResponse(struct soap *soap, struct adm__getCmsStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmsStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__getCmsStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmsStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmsStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmsStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__getCmsStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmsStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmsStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmsStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmsStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmsStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__getCmsStatusThresholdResponse*)p = *(struct adm__getCmsStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmtsStatusThreshold(struct soap *soap, struct adm__updateCmtsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pollintInterval = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmtsStatusThreshold(struct soap *soap, const struct adm__updateCmtsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmtsStatusThresholdT(soap, &a->pollintInterval);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmtsStatusThreshold(struct soap *soap, const struct adm__updateCmtsStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmtsStatusThreshold);
	if (soap_out_adm__updateCmtsStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmtsStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__updateCmtsStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmtsStatusThreshold), type);
	soap_out_PointerTons1__CmtsStatusThresholdT(soap, "pollintInterval", -1, &a->pollintInterval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmtsStatusThreshold * SOAP_FMAC4 soap_get_adm__updateCmtsStatusThreshold(struct soap *soap, struct adm__updateCmtsStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmtsStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmtsStatusThreshold * SOAP_FMAC4 soap_in_adm__updateCmtsStatusThreshold(struct soap *soap, const char *tag, struct adm__updateCmtsStatusThreshold *a, const char *type)
{
	short soap_flag_pollintInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmtsStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmtsStatusThreshold, sizeof(struct adm__updateCmtsStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmtsStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pollintInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsStatusThresholdT(soap, "pollintInterval", &a->pollintInterval, "ns1:CmtsStatusThresholdT"))
				{	soap_flag_pollintInterval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmtsStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmtsStatusThreshold, 0, sizeof(struct adm__updateCmtsStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmtsStatusThreshold * SOAP_FMAC6 soap_new_adm__updateCmtsStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmtsStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmtsStatusThreshold(struct soap *soap, struct adm__updateCmtsStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmtsStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__updateCmtsStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmtsStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmtsStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmtsStatusThreshold;
		if (size)
			*size = sizeof(struct adm__updateCmtsStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmtsStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmtsStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmtsStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmtsStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmtsStatusThreshold %p -> %p\n", q, p));
	*(struct adm__updateCmtsStatusThreshold*)p = *(struct adm__updateCmtsStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmtsStatusThresholdResponse(struct soap *soap, struct adm__updateCmtsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmtsStatusThresholdResponse(struct soap *soap, const struct adm__updateCmtsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmtsStatusThresholdResponse(struct soap *soap, const struct adm__updateCmtsStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmtsStatusThresholdResponse);
	if (soap_out_adm__updateCmtsStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmtsStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmtsStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmtsStatusThresholdResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmtsStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__updateCmtsStatusThresholdResponse(struct soap *soap, struct adm__updateCmtsStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmtsStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmtsStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__updateCmtsStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__updateCmtsStatusThresholdResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmtsStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmtsStatusThresholdResponse, sizeof(struct adm__updateCmtsStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmtsStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmtsStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmtsStatusThresholdResponse, 0, sizeof(struct adm__updateCmtsStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmtsStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__updateCmtsStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmtsStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmtsStatusThresholdResponse(struct soap *soap, struct adm__updateCmtsStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmtsStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmtsStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmtsStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmtsStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmtsStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__updateCmtsStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmtsStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmtsStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmtsStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmtsStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmtsStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__updateCmtsStatusThresholdResponse*)p = *(struct adm__updateCmtsStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmtsStatusThreshold(struct soap *soap, struct adm__getCmtsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmtsStatusThreshold(struct soap *soap, const struct adm__getCmtsStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmtsStatusThreshold(struct soap *soap, const struct adm__getCmtsStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmtsStatusThreshold);
	if (soap_out_adm__getCmtsStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmtsStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__getCmtsStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmtsStatusThreshold), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmtsStatusThreshold * SOAP_FMAC4 soap_get_adm__getCmtsStatusThreshold(struct soap *soap, struct adm__getCmtsStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmtsStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmtsStatusThreshold * SOAP_FMAC4 soap_in_adm__getCmtsStatusThreshold(struct soap *soap, const char *tag, struct adm__getCmtsStatusThreshold *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmtsStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmtsStatusThreshold, sizeof(struct adm__getCmtsStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmtsStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmtsStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmtsStatusThreshold, 0, sizeof(struct adm__getCmtsStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmtsStatusThreshold * SOAP_FMAC6 soap_new_adm__getCmtsStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmtsStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmtsStatusThreshold(struct soap *soap, struct adm__getCmtsStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmtsStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__getCmtsStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmtsStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmtsStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmtsStatusThreshold;
		if (size)
			*size = sizeof(struct adm__getCmtsStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmtsStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmtsStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmtsStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmtsStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmtsStatusThreshold %p -> %p\n", q, p));
	*(struct adm__getCmtsStatusThreshold*)p = *(struct adm__getCmtsStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getCmtsStatusThresholdResponse(struct soap *soap, struct adm__getCmtsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->threshold = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getCmtsStatusThresholdResponse(struct soap *soap, const struct adm__getCmtsStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmtsStatusThresholdT(soap, &a->threshold);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getCmtsStatusThresholdResponse(struct soap *soap, const struct adm__getCmtsStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getCmtsStatusThresholdResponse);
	if (soap_out_adm__getCmtsStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getCmtsStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__getCmtsStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getCmtsStatusThresholdResponse), type);
	if (a->threshold)
		soap_element_result(soap, "threshold");
	soap_out_PointerTons1__CmtsStatusThresholdT(soap, "threshold", -1, &a->threshold, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getCmtsStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__getCmtsStatusThresholdResponse(struct soap *soap, struct adm__getCmtsStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getCmtsStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getCmtsStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__getCmtsStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__getCmtsStatusThresholdResponse *a, const char *type)
{
	short soap_flag_threshold = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getCmtsStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getCmtsStatusThresholdResponse, sizeof(struct adm__getCmtsStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getCmtsStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_threshold && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsStatusThresholdT(soap, "threshold", &a->threshold, "ns1:CmtsStatusThresholdT"))
				{	soap_flag_threshold--;
					continue;
				}
			soap_check_result(soap, "threshold");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getCmtsStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getCmtsStatusThresholdResponse, 0, sizeof(struct adm__getCmtsStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getCmtsStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__getCmtsStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getCmtsStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getCmtsStatusThresholdResponse(struct soap *soap, struct adm__getCmtsStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getCmtsStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__getCmtsStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getCmtsStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getCmtsStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getCmtsStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__getCmtsStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getCmtsStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getCmtsStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getCmtsStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getCmtsStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getCmtsStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__getCmtsStatusThresholdResponse*)p = *(struct adm__getCmtsStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateChannelStatusThreshold(struct soap *soap, struct adm__updateChannelStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pollintInterval = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateChannelStatusThreshold(struct soap *soap, const struct adm__updateChannelStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ChannelStatusThresholdT(soap, &a->pollintInterval);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateChannelStatusThreshold(struct soap *soap, const struct adm__updateChannelStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateChannelStatusThreshold);
	if (soap_out_adm__updateChannelStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateChannelStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__updateChannelStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateChannelStatusThreshold), type);
	soap_out_PointerTons1__ChannelStatusThresholdT(soap, "pollintInterval", -1, &a->pollintInterval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateChannelStatusThreshold * SOAP_FMAC4 soap_get_adm__updateChannelStatusThreshold(struct soap *soap, struct adm__updateChannelStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateChannelStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateChannelStatusThreshold * SOAP_FMAC4 soap_in_adm__updateChannelStatusThreshold(struct soap *soap, const char *tag, struct adm__updateChannelStatusThreshold *a, const char *type)
{
	short soap_flag_pollintInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateChannelStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateChannelStatusThreshold, sizeof(struct adm__updateChannelStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateChannelStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pollintInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ChannelStatusThresholdT(soap, "pollintInterval", &a->pollintInterval, "ns1:ChannelStatusThresholdT"))
				{	soap_flag_pollintInterval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateChannelStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateChannelStatusThreshold, 0, sizeof(struct adm__updateChannelStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateChannelStatusThreshold * SOAP_FMAC6 soap_new_adm__updateChannelStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__updateChannelStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateChannelStatusThreshold(struct soap *soap, struct adm__updateChannelStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateChannelStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__updateChannelStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateChannelStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateChannelStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateChannelStatusThreshold;
		if (size)
			*size = sizeof(struct adm__updateChannelStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateChannelStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateChannelStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateChannelStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateChannelStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateChannelStatusThreshold %p -> %p\n", q, p));
	*(struct adm__updateChannelStatusThreshold*)p = *(struct adm__updateChannelStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateChannelStatusThresholdResponse(struct soap *soap, struct adm__updateChannelStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateChannelStatusThresholdResponse(struct soap *soap, const struct adm__updateChannelStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateChannelStatusThresholdResponse(struct soap *soap, const struct adm__updateChannelStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateChannelStatusThresholdResponse);
	if (soap_out_adm__updateChannelStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateChannelStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__updateChannelStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateChannelStatusThresholdResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateChannelStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__updateChannelStatusThresholdResponse(struct soap *soap, struct adm__updateChannelStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateChannelStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateChannelStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__updateChannelStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__updateChannelStatusThresholdResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateChannelStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateChannelStatusThresholdResponse, sizeof(struct adm__updateChannelStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateChannelStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateChannelStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateChannelStatusThresholdResponse, 0, sizeof(struct adm__updateChannelStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateChannelStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__updateChannelStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateChannelStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateChannelStatusThresholdResponse(struct soap *soap, struct adm__updateChannelStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateChannelStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__updateChannelStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateChannelStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateChannelStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateChannelStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__updateChannelStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateChannelStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateChannelStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateChannelStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateChannelStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateChannelStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__updateChannelStatusThresholdResponse*)p = *(struct adm__updateChannelStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getChannelStatusThreshold(struct soap *soap, struct adm__getChannelStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getChannelStatusThreshold(struct soap *soap, const struct adm__getChannelStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getChannelStatusThreshold(struct soap *soap, const struct adm__getChannelStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getChannelStatusThreshold);
	if (soap_out_adm__getChannelStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getChannelStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__getChannelStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getChannelStatusThreshold), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getChannelStatusThreshold * SOAP_FMAC4 soap_get_adm__getChannelStatusThreshold(struct soap *soap, struct adm__getChannelStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getChannelStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getChannelStatusThreshold * SOAP_FMAC4 soap_in_adm__getChannelStatusThreshold(struct soap *soap, const char *tag, struct adm__getChannelStatusThreshold *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getChannelStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getChannelStatusThreshold, sizeof(struct adm__getChannelStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getChannelStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getChannelStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getChannelStatusThreshold, 0, sizeof(struct adm__getChannelStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getChannelStatusThreshold * SOAP_FMAC6 soap_new_adm__getChannelStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__getChannelStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getChannelStatusThreshold(struct soap *soap, struct adm__getChannelStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getChannelStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__getChannelStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getChannelStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getChannelStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getChannelStatusThreshold;
		if (size)
			*size = sizeof(struct adm__getChannelStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__getChannelStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getChannelStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getChannelStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getChannelStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getChannelStatusThreshold %p -> %p\n", q, p));
	*(struct adm__getChannelStatusThreshold*)p = *(struct adm__getChannelStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getChannelStatusThresholdResponse(struct soap *soap, struct adm__getChannelStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->threshold = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getChannelStatusThresholdResponse(struct soap *soap, const struct adm__getChannelStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__ChannelStatusThresholdT(soap, &a->threshold);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getChannelStatusThresholdResponse(struct soap *soap, const struct adm__getChannelStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getChannelStatusThresholdResponse);
	if (soap_out_adm__getChannelStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getChannelStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__getChannelStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getChannelStatusThresholdResponse), type);
	if (a->threshold)
		soap_element_result(soap, "threshold");
	soap_out_PointerTons1__ChannelStatusThresholdT(soap, "threshold", -1, &a->threshold, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getChannelStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__getChannelStatusThresholdResponse(struct soap *soap, struct adm__getChannelStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getChannelStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getChannelStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__getChannelStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__getChannelStatusThresholdResponse *a, const char *type)
{
	short soap_flag_threshold = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getChannelStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getChannelStatusThresholdResponse, sizeof(struct adm__getChannelStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getChannelStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_threshold && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__ChannelStatusThresholdT(soap, "threshold", &a->threshold, "ns1:ChannelStatusThresholdT"))
				{	soap_flag_threshold--;
					continue;
				}
			soap_check_result(soap, "threshold");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getChannelStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getChannelStatusThresholdResponse, 0, sizeof(struct adm__getChannelStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getChannelStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__getChannelStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getChannelStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getChannelStatusThresholdResponse(struct soap *soap, struct adm__getChannelStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getChannelStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__getChannelStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getChannelStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getChannelStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getChannelStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__getChannelStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getChannelStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getChannelStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getChannelStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getChannelStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getChannelStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__getChannelStatusThresholdResponse*)p = *(struct adm__getChannelStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateHfcStatusThreshold(struct soap *soap, struct adm__updateHfcStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pollintInterval = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateHfcStatusThreshold(struct soap *soap, const struct adm__updateHfcStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HfcStatusThresholdT(soap, &a->pollintInterval);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateHfcStatusThreshold(struct soap *soap, const struct adm__updateHfcStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateHfcStatusThreshold);
	if (soap_out_adm__updateHfcStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateHfcStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__updateHfcStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateHfcStatusThreshold), type);
	soap_out_PointerTons1__HfcStatusThresholdT(soap, "pollintInterval", -1, &a->pollintInterval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateHfcStatusThreshold * SOAP_FMAC4 soap_get_adm__updateHfcStatusThreshold(struct soap *soap, struct adm__updateHfcStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateHfcStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateHfcStatusThreshold * SOAP_FMAC4 soap_in_adm__updateHfcStatusThreshold(struct soap *soap, const char *tag, struct adm__updateHfcStatusThreshold *a, const char *type)
{
	short soap_flag_pollintInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateHfcStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateHfcStatusThreshold, sizeof(struct adm__updateHfcStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateHfcStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pollintInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HfcStatusThresholdT(soap, "pollintInterval", &a->pollintInterval, "ns1:HfcStatusThresholdT"))
				{	soap_flag_pollintInterval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateHfcStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateHfcStatusThreshold, 0, sizeof(struct adm__updateHfcStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateHfcStatusThreshold * SOAP_FMAC6 soap_new_adm__updateHfcStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__updateHfcStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateHfcStatusThreshold(struct soap *soap, struct adm__updateHfcStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateHfcStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__updateHfcStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateHfcStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateHfcStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateHfcStatusThreshold;
		if (size)
			*size = sizeof(struct adm__updateHfcStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateHfcStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateHfcStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateHfcStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateHfcStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateHfcStatusThreshold %p -> %p\n", q, p));
	*(struct adm__updateHfcStatusThreshold*)p = *(struct adm__updateHfcStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateHfcStatusThresholdResponse(struct soap *soap, struct adm__updateHfcStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateHfcStatusThresholdResponse(struct soap *soap, const struct adm__updateHfcStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateHfcStatusThresholdResponse(struct soap *soap, const struct adm__updateHfcStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateHfcStatusThresholdResponse);
	if (soap_out_adm__updateHfcStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateHfcStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__updateHfcStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateHfcStatusThresholdResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateHfcStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__updateHfcStatusThresholdResponse(struct soap *soap, struct adm__updateHfcStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateHfcStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateHfcStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__updateHfcStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__updateHfcStatusThresholdResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateHfcStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateHfcStatusThresholdResponse, sizeof(struct adm__updateHfcStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateHfcStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateHfcStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateHfcStatusThresholdResponse, 0, sizeof(struct adm__updateHfcStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateHfcStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__updateHfcStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateHfcStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateHfcStatusThresholdResponse(struct soap *soap, struct adm__updateHfcStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateHfcStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__updateHfcStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateHfcStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateHfcStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateHfcStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__updateHfcStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateHfcStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateHfcStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateHfcStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateHfcStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateHfcStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__updateHfcStatusThresholdResponse*)p = *(struct adm__updateHfcStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getHfcStatusThreshold(struct soap *soap, struct adm__getHfcStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getHfcStatusThreshold(struct soap *soap, const struct adm__getHfcStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getHfcStatusThreshold(struct soap *soap, const struct adm__getHfcStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getHfcStatusThreshold);
	if (soap_out_adm__getHfcStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getHfcStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__getHfcStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getHfcStatusThreshold), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getHfcStatusThreshold * SOAP_FMAC4 soap_get_adm__getHfcStatusThreshold(struct soap *soap, struct adm__getHfcStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getHfcStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getHfcStatusThreshold * SOAP_FMAC4 soap_in_adm__getHfcStatusThreshold(struct soap *soap, const char *tag, struct adm__getHfcStatusThreshold *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getHfcStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getHfcStatusThreshold, sizeof(struct adm__getHfcStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getHfcStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getHfcStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getHfcStatusThreshold, 0, sizeof(struct adm__getHfcStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getHfcStatusThreshold * SOAP_FMAC6 soap_new_adm__getHfcStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__getHfcStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getHfcStatusThreshold(struct soap *soap, struct adm__getHfcStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getHfcStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__getHfcStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getHfcStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getHfcStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getHfcStatusThreshold;
		if (size)
			*size = sizeof(struct adm__getHfcStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__getHfcStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getHfcStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getHfcStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getHfcStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getHfcStatusThreshold %p -> %p\n", q, p));
	*(struct adm__getHfcStatusThreshold*)p = *(struct adm__getHfcStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getHfcStatusThresholdResponse(struct soap *soap, struct adm__getHfcStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->threshold = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getHfcStatusThresholdResponse(struct soap *soap, const struct adm__getHfcStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__HfcStatusThresholdT(soap, &a->threshold);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getHfcStatusThresholdResponse(struct soap *soap, const struct adm__getHfcStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getHfcStatusThresholdResponse);
	if (soap_out_adm__getHfcStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getHfcStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__getHfcStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getHfcStatusThresholdResponse), type);
	if (a->threshold)
		soap_element_result(soap, "threshold");
	soap_out_PointerTons1__HfcStatusThresholdT(soap, "threshold", -1, &a->threshold, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getHfcStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__getHfcStatusThresholdResponse(struct soap *soap, struct adm__getHfcStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getHfcStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getHfcStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__getHfcStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__getHfcStatusThresholdResponse *a, const char *type)
{
	short soap_flag_threshold = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getHfcStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getHfcStatusThresholdResponse, sizeof(struct adm__getHfcStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getHfcStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_threshold && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__HfcStatusThresholdT(soap, "threshold", &a->threshold, "ns1:HfcStatusThresholdT"))
				{	soap_flag_threshold--;
					continue;
				}
			soap_check_result(soap, "threshold");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getHfcStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getHfcStatusThresholdResponse, 0, sizeof(struct adm__getHfcStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getHfcStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__getHfcStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getHfcStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getHfcStatusThresholdResponse(struct soap *soap, struct adm__getHfcStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getHfcStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__getHfcStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getHfcStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getHfcStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getHfcStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__getHfcStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getHfcStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getHfcStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getHfcStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getHfcStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getHfcStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__getHfcStatusThresholdResponse*)p = *(struct adm__getHfcStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateMtaStatusThreshold(struct soap *soap, struct adm__updateMtaStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pollintInterval = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateMtaStatusThreshold(struct soap *soap, const struct adm__updateMtaStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaStatusThresholdT(soap, &a->pollintInterval);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateMtaStatusThreshold(struct soap *soap, const struct adm__updateMtaStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateMtaStatusThreshold);
	if (soap_out_adm__updateMtaStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateMtaStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__updateMtaStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateMtaStatusThreshold), type);
	soap_out_PointerTons1__MtaStatusThresholdT(soap, "pollintInterval", -1, &a->pollintInterval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateMtaStatusThreshold * SOAP_FMAC4 soap_get_adm__updateMtaStatusThreshold(struct soap *soap, struct adm__updateMtaStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateMtaStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateMtaStatusThreshold * SOAP_FMAC4 soap_in_adm__updateMtaStatusThreshold(struct soap *soap, const char *tag, struct adm__updateMtaStatusThreshold *a, const char *type)
{
	short soap_flag_pollintInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateMtaStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateMtaStatusThreshold, sizeof(struct adm__updateMtaStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateMtaStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pollintInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaStatusThresholdT(soap, "pollintInterval", &a->pollintInterval, "ns1:MtaStatusThresholdT"))
				{	soap_flag_pollintInterval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateMtaStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateMtaStatusThreshold, 0, sizeof(struct adm__updateMtaStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateMtaStatusThreshold * SOAP_FMAC6 soap_new_adm__updateMtaStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__updateMtaStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateMtaStatusThreshold(struct soap *soap, struct adm__updateMtaStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateMtaStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__updateMtaStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateMtaStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateMtaStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateMtaStatusThreshold;
		if (size)
			*size = sizeof(struct adm__updateMtaStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateMtaStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateMtaStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateMtaStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateMtaStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateMtaStatusThreshold %p -> %p\n", q, p));
	*(struct adm__updateMtaStatusThreshold*)p = *(struct adm__updateMtaStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateMtaStatusThresholdResponse(struct soap *soap, struct adm__updateMtaStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateMtaStatusThresholdResponse(struct soap *soap, const struct adm__updateMtaStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateMtaStatusThresholdResponse(struct soap *soap, const struct adm__updateMtaStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateMtaStatusThresholdResponse);
	if (soap_out_adm__updateMtaStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateMtaStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__updateMtaStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateMtaStatusThresholdResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateMtaStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__updateMtaStatusThresholdResponse(struct soap *soap, struct adm__updateMtaStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateMtaStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateMtaStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__updateMtaStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__updateMtaStatusThresholdResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateMtaStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateMtaStatusThresholdResponse, sizeof(struct adm__updateMtaStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateMtaStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateMtaStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateMtaStatusThresholdResponse, 0, sizeof(struct adm__updateMtaStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateMtaStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__updateMtaStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateMtaStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateMtaStatusThresholdResponse(struct soap *soap, struct adm__updateMtaStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateMtaStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__updateMtaStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateMtaStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateMtaStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateMtaStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__updateMtaStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateMtaStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateMtaStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateMtaStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateMtaStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateMtaStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__updateMtaStatusThresholdResponse*)p = *(struct adm__updateMtaStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getMtaStatusThreshold(struct soap *soap, struct adm__getMtaStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getMtaStatusThreshold(struct soap *soap, const struct adm__getMtaStatusThreshold *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getMtaStatusThreshold(struct soap *soap, const struct adm__getMtaStatusThreshold *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getMtaStatusThreshold);
	if (soap_out_adm__getMtaStatusThreshold(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getMtaStatusThreshold(struct soap *soap, const char *tag, int id, const struct adm__getMtaStatusThreshold *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getMtaStatusThreshold), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getMtaStatusThreshold * SOAP_FMAC4 soap_get_adm__getMtaStatusThreshold(struct soap *soap, struct adm__getMtaStatusThreshold *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getMtaStatusThreshold(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getMtaStatusThreshold * SOAP_FMAC4 soap_in_adm__getMtaStatusThreshold(struct soap *soap, const char *tag, struct adm__getMtaStatusThreshold *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getMtaStatusThreshold *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getMtaStatusThreshold, sizeof(struct adm__getMtaStatusThreshold), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getMtaStatusThreshold(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getMtaStatusThreshold *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getMtaStatusThreshold, 0, sizeof(struct adm__getMtaStatusThreshold), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getMtaStatusThreshold * SOAP_FMAC6 soap_new_adm__getMtaStatusThreshold(struct soap *soap, int n)
{	return soap_instantiate_adm__getMtaStatusThreshold(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getMtaStatusThreshold(struct soap *soap, struct adm__getMtaStatusThreshold *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getMtaStatusThreshold * SOAP_FMAC4 soap_instantiate_adm__getMtaStatusThreshold(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getMtaStatusThreshold(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getMtaStatusThreshold, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getMtaStatusThreshold;
		if (size)
			*size = sizeof(struct adm__getMtaStatusThreshold);
	}
	else
	{	cp->ptr = (void*)new struct adm__getMtaStatusThreshold[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getMtaStatusThreshold);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getMtaStatusThreshold*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getMtaStatusThreshold(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getMtaStatusThreshold %p -> %p\n", q, p));
	*(struct adm__getMtaStatusThreshold*)p = *(struct adm__getMtaStatusThreshold*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getMtaStatusThresholdResponse(struct soap *soap, struct adm__getMtaStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->threshold = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getMtaStatusThresholdResponse(struct soap *soap, const struct adm__getMtaStatusThresholdResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__MtaStatusThresholdT(soap, &a->threshold);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getMtaStatusThresholdResponse(struct soap *soap, const struct adm__getMtaStatusThresholdResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getMtaStatusThresholdResponse);
	if (soap_out_adm__getMtaStatusThresholdResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getMtaStatusThresholdResponse(struct soap *soap, const char *tag, int id, const struct adm__getMtaStatusThresholdResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getMtaStatusThresholdResponse), type);
	if (a->threshold)
		soap_element_result(soap, "threshold");
	soap_out_PointerTons1__MtaStatusThresholdT(soap, "threshold", -1, &a->threshold, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getMtaStatusThresholdResponse * SOAP_FMAC4 soap_get_adm__getMtaStatusThresholdResponse(struct soap *soap, struct adm__getMtaStatusThresholdResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getMtaStatusThresholdResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getMtaStatusThresholdResponse * SOAP_FMAC4 soap_in_adm__getMtaStatusThresholdResponse(struct soap *soap, const char *tag, struct adm__getMtaStatusThresholdResponse *a, const char *type)
{
	short soap_flag_threshold = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getMtaStatusThresholdResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getMtaStatusThresholdResponse, sizeof(struct adm__getMtaStatusThresholdResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getMtaStatusThresholdResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_threshold && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__MtaStatusThresholdT(soap, "threshold", &a->threshold, "ns1:MtaStatusThresholdT"))
				{	soap_flag_threshold--;
					continue;
				}
			soap_check_result(soap, "threshold");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getMtaStatusThresholdResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getMtaStatusThresholdResponse, 0, sizeof(struct adm__getMtaStatusThresholdResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getMtaStatusThresholdResponse * SOAP_FMAC6 soap_new_adm__getMtaStatusThresholdResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getMtaStatusThresholdResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getMtaStatusThresholdResponse(struct soap *soap, struct adm__getMtaStatusThresholdResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getMtaStatusThresholdResponse * SOAP_FMAC4 soap_instantiate_adm__getMtaStatusThresholdResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getMtaStatusThresholdResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getMtaStatusThresholdResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getMtaStatusThresholdResponse;
		if (size)
			*size = sizeof(struct adm__getMtaStatusThresholdResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getMtaStatusThresholdResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getMtaStatusThresholdResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getMtaStatusThresholdResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getMtaStatusThresholdResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getMtaStatusThresholdResponse %p -> %p\n", q, p));
	*(struct adm__getMtaStatusThresholdResponse*)p = *(struct adm__getMtaStatusThresholdResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updatePollingIntervals(struct soap *soap, struct adm__updatePollingIntervals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pollintInterval = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updatePollingIntervals(struct soap *soap, const struct adm__updatePollingIntervals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PollingIntervalsT(soap, &a->pollintInterval);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updatePollingIntervals(struct soap *soap, const struct adm__updatePollingIntervals *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updatePollingIntervals);
	if (soap_out_adm__updatePollingIntervals(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updatePollingIntervals(struct soap *soap, const char *tag, int id, const struct adm__updatePollingIntervals *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updatePollingIntervals), type);
	soap_out_PointerTons1__PollingIntervalsT(soap, "pollintInterval", -1, &a->pollintInterval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updatePollingIntervals * SOAP_FMAC4 soap_get_adm__updatePollingIntervals(struct soap *soap, struct adm__updatePollingIntervals *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updatePollingIntervals(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updatePollingIntervals * SOAP_FMAC4 soap_in_adm__updatePollingIntervals(struct soap *soap, const char *tag, struct adm__updatePollingIntervals *a, const char *type)
{
	short soap_flag_pollintInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updatePollingIntervals *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updatePollingIntervals, sizeof(struct adm__updatePollingIntervals), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updatePollingIntervals(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pollintInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PollingIntervalsT(soap, "pollintInterval", &a->pollintInterval, "ns1:PollingIntervalsT"))
				{	soap_flag_pollintInterval--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updatePollingIntervals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updatePollingIntervals, 0, sizeof(struct adm__updatePollingIntervals), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updatePollingIntervals * SOAP_FMAC6 soap_new_adm__updatePollingIntervals(struct soap *soap, int n)
{	return soap_instantiate_adm__updatePollingIntervals(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updatePollingIntervals(struct soap *soap, struct adm__updatePollingIntervals *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updatePollingIntervals * SOAP_FMAC4 soap_instantiate_adm__updatePollingIntervals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updatePollingIntervals(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updatePollingIntervals, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updatePollingIntervals;
		if (size)
			*size = sizeof(struct adm__updatePollingIntervals);
	}
	else
	{	cp->ptr = (void*)new struct adm__updatePollingIntervals[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updatePollingIntervals);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updatePollingIntervals*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updatePollingIntervals(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updatePollingIntervals %p -> %p\n", q, p));
	*(struct adm__updatePollingIntervals*)p = *(struct adm__updatePollingIntervals*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updatePollingIntervalsResponse(struct soap *soap, struct adm__updatePollingIntervalsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updatePollingIntervalsResponse(struct soap *soap, const struct adm__updatePollingIntervalsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updatePollingIntervalsResponse(struct soap *soap, const struct adm__updatePollingIntervalsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updatePollingIntervalsResponse);
	if (soap_out_adm__updatePollingIntervalsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updatePollingIntervalsResponse(struct soap *soap, const char *tag, int id, const struct adm__updatePollingIntervalsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updatePollingIntervalsResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updatePollingIntervalsResponse * SOAP_FMAC4 soap_get_adm__updatePollingIntervalsResponse(struct soap *soap, struct adm__updatePollingIntervalsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updatePollingIntervalsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updatePollingIntervalsResponse * SOAP_FMAC4 soap_in_adm__updatePollingIntervalsResponse(struct soap *soap, const char *tag, struct adm__updatePollingIntervalsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updatePollingIntervalsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updatePollingIntervalsResponse, sizeof(struct adm__updatePollingIntervalsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updatePollingIntervalsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updatePollingIntervalsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updatePollingIntervalsResponse, 0, sizeof(struct adm__updatePollingIntervalsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updatePollingIntervalsResponse * SOAP_FMAC6 soap_new_adm__updatePollingIntervalsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updatePollingIntervalsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updatePollingIntervalsResponse(struct soap *soap, struct adm__updatePollingIntervalsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updatePollingIntervalsResponse * SOAP_FMAC4 soap_instantiate_adm__updatePollingIntervalsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updatePollingIntervalsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updatePollingIntervalsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updatePollingIntervalsResponse;
		if (size)
			*size = sizeof(struct adm__updatePollingIntervalsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updatePollingIntervalsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updatePollingIntervalsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updatePollingIntervalsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updatePollingIntervalsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updatePollingIntervalsResponse %p -> %p\n", q, p));
	*(struct adm__updatePollingIntervalsResponse*)p = *(struct adm__updatePollingIntervalsResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getPollingIntervals(struct soap *soap, struct adm__getPollingIntervals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getPollingIntervals(struct soap *soap, const struct adm__getPollingIntervals *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getPollingIntervals(struct soap *soap, const struct adm__getPollingIntervals *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getPollingIntervals);
	if (soap_out_adm__getPollingIntervals(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getPollingIntervals(struct soap *soap, const char *tag, int id, const struct adm__getPollingIntervals *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getPollingIntervals), type);
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getPollingIntervals * SOAP_FMAC4 soap_get_adm__getPollingIntervals(struct soap *soap, struct adm__getPollingIntervals *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getPollingIntervals(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getPollingIntervals * SOAP_FMAC4 soap_in_adm__getPollingIntervals(struct soap *soap, const char *tag, struct adm__getPollingIntervals *a, const char *type)
{;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getPollingIntervals *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getPollingIntervals, sizeof(struct adm__getPollingIntervals), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getPollingIntervals(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getPollingIntervals *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getPollingIntervals, 0, sizeof(struct adm__getPollingIntervals), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getPollingIntervals * SOAP_FMAC6 soap_new_adm__getPollingIntervals(struct soap *soap, int n)
{	return soap_instantiate_adm__getPollingIntervals(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getPollingIntervals(struct soap *soap, struct adm__getPollingIntervals *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getPollingIntervals * SOAP_FMAC4 soap_instantiate_adm__getPollingIntervals(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getPollingIntervals(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getPollingIntervals, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getPollingIntervals;
		if (size)
			*size = sizeof(struct adm__getPollingIntervals);
	}
	else
	{	cp->ptr = (void*)new struct adm__getPollingIntervals[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getPollingIntervals);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getPollingIntervals*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getPollingIntervals(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getPollingIntervals %p -> %p\n", q, p));
	*(struct adm__getPollingIntervals*)p = *(struct adm__getPollingIntervals*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__getPollingIntervalsResponse(struct soap *soap, struct adm__getPollingIntervalsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->pollingInterval = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__getPollingIntervalsResponse(struct soap *soap, const struct adm__getPollingIntervalsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__PollingIntervalsT(soap, &a->pollingInterval);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__getPollingIntervalsResponse(struct soap *soap, const struct adm__getPollingIntervalsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__getPollingIntervalsResponse);
	if (soap_out_adm__getPollingIntervalsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__getPollingIntervalsResponse(struct soap *soap, const char *tag, int id, const struct adm__getPollingIntervalsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__getPollingIntervalsResponse), type);
	if (a->pollingInterval)
		soap_element_result(soap, "pollingInterval");
	soap_out_PointerTons1__PollingIntervalsT(soap, "pollingInterval", -1, &a->pollingInterval, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__getPollingIntervalsResponse * SOAP_FMAC4 soap_get_adm__getPollingIntervalsResponse(struct soap *soap, struct adm__getPollingIntervalsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__getPollingIntervalsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__getPollingIntervalsResponse * SOAP_FMAC4 soap_in_adm__getPollingIntervalsResponse(struct soap *soap, const char *tag, struct adm__getPollingIntervalsResponse *a, const char *type)
{
	short soap_flag_pollingInterval = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__getPollingIntervalsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__getPollingIntervalsResponse, sizeof(struct adm__getPollingIntervalsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__getPollingIntervalsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_pollingInterval && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__PollingIntervalsT(soap, "pollingInterval", &a->pollingInterval, "ns1:PollingIntervalsT"))
				{	soap_flag_pollingInterval--;
					continue;
				}
			soap_check_result(soap, "pollingInterval");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__getPollingIntervalsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__getPollingIntervalsResponse, 0, sizeof(struct adm__getPollingIntervalsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__getPollingIntervalsResponse * SOAP_FMAC6 soap_new_adm__getPollingIntervalsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__getPollingIntervalsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__getPollingIntervalsResponse(struct soap *soap, struct adm__getPollingIntervalsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__getPollingIntervalsResponse * SOAP_FMAC4 soap_instantiate_adm__getPollingIntervalsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__getPollingIntervalsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__getPollingIntervalsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__getPollingIntervalsResponse;
		if (size)
			*size = sizeof(struct adm__getPollingIntervalsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__getPollingIntervalsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__getPollingIntervalsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__getPollingIntervalsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__getPollingIntervalsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__getPollingIntervalsResponse %p -> %p\n", q, p));
	*(struct adm__getPollingIntervalsResponse*)p = *(struct adm__getPollingIntervalsResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__deleteCms(struct soap *soap, struct adm__deleteCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__deleteCms(struct soap *soap, const struct adm__deleteCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmsT(soap, &a->cms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__deleteCms(struct soap *soap, const struct adm__deleteCms *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__deleteCms);
	if (soap_out_adm__deleteCms(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__deleteCms(struct soap *soap, const char *tag, int id, const struct adm__deleteCms *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__deleteCms), type);
	soap_out_PointerTons1__CmsT(soap, "cms", -1, &a->cms, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__deleteCms * SOAP_FMAC4 soap_get_adm__deleteCms(struct soap *soap, struct adm__deleteCms *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__deleteCms(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__deleteCms * SOAP_FMAC4 soap_in_adm__deleteCms(struct soap *soap, const char *tag, struct adm__deleteCms *a, const char *type)
{
	short soap_flag_cms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__deleteCms *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__deleteCms, sizeof(struct adm__deleteCms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__deleteCms(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsT(soap, "cms", &a->cms, "ns1:CmsT"))
				{	soap_flag_cms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__deleteCms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__deleteCms, 0, sizeof(struct adm__deleteCms), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__deleteCms * SOAP_FMAC6 soap_new_adm__deleteCms(struct soap *soap, int n)
{	return soap_instantiate_adm__deleteCms(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__deleteCms(struct soap *soap, struct adm__deleteCms *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__deleteCms * SOAP_FMAC4 soap_instantiate_adm__deleteCms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__deleteCms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__deleteCms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__deleteCms;
		if (size)
			*size = sizeof(struct adm__deleteCms);
	}
	else
	{	cp->ptr = (void*)new struct adm__deleteCms[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__deleteCms);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__deleteCms*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__deleteCms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__deleteCms %p -> %p\n", q, p));
	*(struct adm__deleteCms*)p = *(struct adm__deleteCms*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__deleteCmsResponse(struct soap *soap, struct adm__deleteCmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__deleteCmsResponse(struct soap *soap, const struct adm__deleteCmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__deleteCmsResponse(struct soap *soap, const struct adm__deleteCmsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__deleteCmsResponse);
	if (soap_out_adm__deleteCmsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__deleteCmsResponse(struct soap *soap, const char *tag, int id, const struct adm__deleteCmsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__deleteCmsResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__deleteCmsResponse * SOAP_FMAC4 soap_get_adm__deleteCmsResponse(struct soap *soap, struct adm__deleteCmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__deleteCmsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__deleteCmsResponse * SOAP_FMAC4 soap_in_adm__deleteCmsResponse(struct soap *soap, const char *tag, struct adm__deleteCmsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__deleteCmsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__deleteCmsResponse, sizeof(struct adm__deleteCmsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__deleteCmsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__deleteCmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__deleteCmsResponse, 0, sizeof(struct adm__deleteCmsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__deleteCmsResponse * SOAP_FMAC6 soap_new_adm__deleteCmsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__deleteCmsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__deleteCmsResponse(struct soap *soap, struct adm__deleteCmsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__deleteCmsResponse * SOAP_FMAC4 soap_instantiate_adm__deleteCmsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__deleteCmsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__deleteCmsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__deleteCmsResponse;
		if (size)
			*size = sizeof(struct adm__deleteCmsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__deleteCmsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__deleteCmsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__deleteCmsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__deleteCmsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__deleteCmsResponse %p -> %p\n", q, p));
	*(struct adm__deleteCmsResponse*)p = *(struct adm__deleteCmsResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addCms(struct soap *soap, struct adm__addCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addCms(struct soap *soap, const struct adm__addCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmsT(soap, &a->cms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addCms(struct soap *soap, const struct adm__addCms *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addCms);
	if (soap_out_adm__addCms(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addCms(struct soap *soap, const char *tag, int id, const struct adm__addCms *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addCms), type);
	soap_out_PointerTons1__CmsT(soap, "cms", -1, &a->cms, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addCms * SOAP_FMAC4 soap_get_adm__addCms(struct soap *soap, struct adm__addCms *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addCms(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addCms * SOAP_FMAC4 soap_in_adm__addCms(struct soap *soap, const char *tag, struct adm__addCms *a, const char *type)
{
	short soap_flag_cms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addCms *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addCms, sizeof(struct adm__addCms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addCms(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsT(soap, "cms", &a->cms, "ns1:CmsT"))
				{	soap_flag_cms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addCms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addCms, 0, sizeof(struct adm__addCms), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addCms * SOAP_FMAC6 soap_new_adm__addCms(struct soap *soap, int n)
{	return soap_instantiate_adm__addCms(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addCms(struct soap *soap, struct adm__addCms *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addCms * SOAP_FMAC4 soap_instantiate_adm__addCms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addCms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addCms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addCms;
		if (size)
			*size = sizeof(struct adm__addCms);
	}
	else
	{	cp->ptr = (void*)new struct adm__addCms[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addCms);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addCms*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addCms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addCms %p -> %p\n", q, p));
	*(struct adm__addCms*)p = *(struct adm__addCms*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addCmsResponse(struct soap *soap, struct adm__addCmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addCmsResponse(struct soap *soap, const struct adm__addCmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addCmsResponse(struct soap *soap, const struct adm__addCmsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addCmsResponse);
	if (soap_out_adm__addCmsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addCmsResponse(struct soap *soap, const char *tag, int id, const struct adm__addCmsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addCmsResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addCmsResponse * SOAP_FMAC4 soap_get_adm__addCmsResponse(struct soap *soap, struct adm__addCmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addCmsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addCmsResponse * SOAP_FMAC4 soap_in_adm__addCmsResponse(struct soap *soap, const char *tag, struct adm__addCmsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addCmsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addCmsResponse, sizeof(struct adm__addCmsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addCmsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addCmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addCmsResponse, 0, sizeof(struct adm__addCmsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addCmsResponse * SOAP_FMAC6 soap_new_adm__addCmsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__addCmsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addCmsResponse(struct soap *soap, struct adm__addCmsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addCmsResponse * SOAP_FMAC4 soap_instantiate_adm__addCmsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addCmsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addCmsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addCmsResponse;
		if (size)
			*size = sizeof(struct adm__addCmsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__addCmsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addCmsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addCmsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addCmsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addCmsResponse %p -> %p\n", q, p));
	*(struct adm__addCmsResponse*)p = *(struct adm__addCmsResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCms(struct soap *soap, struct adm__updateCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cms = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCms(struct soap *soap, const struct adm__updateCms *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmsT(soap, &a->cms);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCms(struct soap *soap, const struct adm__updateCms *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCms);
	if (soap_out_adm__updateCms(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCms(struct soap *soap, const char *tag, int id, const struct adm__updateCms *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCms), type);
	soap_out_PointerTons1__CmsT(soap, "cms", -1, &a->cms, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCms * SOAP_FMAC4 soap_get_adm__updateCms(struct soap *soap, struct adm__updateCms *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCms(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCms * SOAP_FMAC4 soap_in_adm__updateCms(struct soap *soap, const char *tag, struct adm__updateCms *a, const char *type)
{
	short soap_flag_cms = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCms *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCms, sizeof(struct adm__updateCms), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCms(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cms && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmsT(soap, "cms", &a->cms, "ns1:CmsT"))
				{	soap_flag_cms--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCms *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCms, 0, sizeof(struct adm__updateCms), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCms * SOAP_FMAC6 soap_new_adm__updateCms(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCms(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCms(struct soap *soap, struct adm__updateCms *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCms * SOAP_FMAC4 soap_instantiate_adm__updateCms(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCms(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCms, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCms;
		if (size)
			*size = sizeof(struct adm__updateCms);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCms[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCms);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCms*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCms(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCms %p -> %p\n", q, p));
	*(struct adm__updateCms*)p = *(struct adm__updateCms*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmsResponse(struct soap *soap, struct adm__updateCmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmsResponse(struct soap *soap, const struct adm__updateCmsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmsResponse(struct soap *soap, const struct adm__updateCmsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmsResponse);
	if (soap_out_adm__updateCmsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmsResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmsResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmsResponse * SOAP_FMAC4 soap_get_adm__updateCmsResponse(struct soap *soap, struct adm__updateCmsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmsResponse * SOAP_FMAC4 soap_in_adm__updateCmsResponse(struct soap *soap, const char *tag, struct adm__updateCmsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmsResponse, sizeof(struct adm__updateCmsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmsResponse, 0, sizeof(struct adm__updateCmsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmsResponse * SOAP_FMAC6 soap_new_adm__updateCmsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmsResponse(struct soap *soap, struct adm__updateCmsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmsResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmsResponse;
		if (size)
			*size = sizeof(struct adm__updateCmsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmsResponse %p -> %p\n", q, p));
	*(struct adm__updateCmsResponse*)p = *(struct adm__updateCmsResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, struct adm__updateCmtsAllSnmpV2CAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->topologyKey = NULL;
	soap_default_xsd__integer(soap, &a->cmtsResId);
	a->attributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, const struct adm__updateCmtsAllSnmpV2CAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &a->topologyKey);
	soap_embedded(soap, &a->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &a->cmtsResId);
	soap_serialize_PointerToArrayOfSnmpV2CAttributesT(soap, &a->attributes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, const struct adm__updateCmtsAllSnmpV2CAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes);
	if (soap_out_adm__updateCmtsAllSnmpV2CAttributes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, const char *tag, int id, const struct adm__updateCmtsAllSnmpV2CAttributes *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &a->topologyKey, "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &a->cmtsResId, "");
	soap_out_PointerToArrayOfSnmpV2CAttributesT(soap, "attributes", -1, &a->attributes, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmtsAllSnmpV2CAttributes * SOAP_FMAC4 soap_get_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, struct adm__updateCmtsAllSnmpV2CAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmtsAllSnmpV2CAttributes(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmtsAllSnmpV2CAttributes * SOAP_FMAC4 soap_in_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, const char *tag, struct adm__updateCmtsAllSnmpV2CAttributes *a, const char *type)
{
	short soap_flag_topologyKey = 1, soap_flag_cmtsResId = 1, soap_flag_attributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmtsAllSnmpV2CAttributes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes, sizeof(struct adm__updateCmtsAllSnmpV2CAttributes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_adm__updateCmtsAllSnmpV2CAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &a->topologyKey, "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey--;
					continue;
				}
			if (soap_flag_cmtsResId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &a->cmtsResId, "xsd:integer"))
				{	soap_flag_cmtsResId--;
					continue;
				}
			if (soap_flag_attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSnmpV2CAttributesT(soap, "attributes", &a->attributes, "ns1:SnmpV2CAttributesT"))
				{	soap_flag_attributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmtsResId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmtsAllSnmpV2CAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes, 0, sizeof(struct adm__updateCmtsAllSnmpV2CAttributes), 0, soap_copy_adm__updateCmtsAllSnmpV2CAttributes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmtsAllSnmpV2CAttributes * SOAP_FMAC6 soap_new_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmtsAllSnmpV2CAttributes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, struct adm__updateCmtsAllSnmpV2CAttributes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmtsAllSnmpV2CAttributes * SOAP_FMAC4 soap_instantiate_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmtsAllSnmpV2CAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmtsAllSnmpV2CAttributes;
		if (size)
			*size = sizeof(struct adm__updateCmtsAllSnmpV2CAttributes);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmtsAllSnmpV2CAttributes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmtsAllSnmpV2CAttributes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmtsAllSnmpV2CAttributes*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmtsAllSnmpV2CAttributes %p -> %p\n", q, p));
	*(struct adm__updateCmtsAllSnmpV2CAttributes*)p = *(struct adm__updateCmtsAllSnmpV2CAttributes*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, struct adm__updateCmtsAllSnmpV2CAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const struct adm__updateCmtsAllSnmpV2CAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const struct adm__updateCmtsAllSnmpV2CAttributesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse);
	if (soap_out_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmtsAllSnmpV2CAttributesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC4 soap_get_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, struct adm__updateCmtsAllSnmpV2CAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC4 soap_in_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const char *tag, struct adm__updateCmtsAllSnmpV2CAttributesResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmtsAllSnmpV2CAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse, sizeof(struct adm__updateCmtsAllSnmpV2CAttributesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmtsAllSnmpV2CAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse, 0, sizeof(struct adm__updateCmtsAllSnmpV2CAttributesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC6 soap_new_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmtsAllSnmpV2CAttributesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, struct adm__updateCmtsAllSnmpV2CAttributesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmtsAllSnmpV2CAttributesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmtsAllSnmpV2CAttributesResponse;
		if (size)
			*size = sizeof(struct adm__updateCmtsAllSnmpV2CAttributesResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmtsAllSnmpV2CAttributesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmtsAllSnmpV2CAttributesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmtsAllSnmpV2CAttributesResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmtsAllSnmpV2CAttributesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmtsAllSnmpV2CAttributesResponse %p -> %p\n", q, p));
	*(struct adm__updateCmtsAllSnmpV2CAttributesResponse*)p = *(struct adm__updateCmtsAllSnmpV2CAttributesResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, struct adm__addCmtsAllSnmpV2CAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->topologyKey = NULL;
	soap_default_xsd__integer(soap, &a->cmtsResId);
	a->attributes = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, const struct adm__addCmtsAllSnmpV2CAttributes *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__TopoHierarchyKeyT(soap, &a->topologyKey);
	soap_embedded(soap, &a->cmtsResId, SOAP_TYPE_xsd__integer);
	soap_serialize_xsd__integer(soap, &a->cmtsResId);
	soap_serialize_PointerToArrayOfSnmpV2CAttributesT(soap, &a->attributes);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, const struct adm__addCmtsAllSnmpV2CAttributes *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes);
	if (soap_out_adm__addCmtsAllSnmpV2CAttributes(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, const char *tag, int id, const struct adm__addCmtsAllSnmpV2CAttributes *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes), type);
	soap_out_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", -1, &a->topologyKey, "");
	soap_out_xsd__integer(soap, "cmtsResId", -1, &a->cmtsResId, "");
	soap_out_PointerToArrayOfSnmpV2CAttributesT(soap, "attributes", -1, &a->attributes, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addCmtsAllSnmpV2CAttributes * SOAP_FMAC4 soap_get_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, struct adm__addCmtsAllSnmpV2CAttributes *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addCmtsAllSnmpV2CAttributes(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addCmtsAllSnmpV2CAttributes * SOAP_FMAC4 soap_in_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, const char *tag, struct adm__addCmtsAllSnmpV2CAttributes *a, const char *type)
{
	short soap_flag_topologyKey = 1, soap_flag_cmtsResId = 1, soap_flag_attributes = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addCmtsAllSnmpV2CAttributes *)soap_class_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes, sizeof(struct adm__addCmtsAllSnmpV2CAttributes), soap->type, soap->arrayType);
	if (!a)
		return NULL;
	soap_default_adm__addCmtsAllSnmpV2CAttributes(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_topologyKey && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__TopoHierarchyKeyT(soap, "topologyKey", &a->topologyKey, "ns1:TopoHierarchyKeyT"))
				{	soap_flag_topologyKey--;
					continue;
				}
			if (soap_flag_cmtsResId && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
				if (soap_in_xsd__integer(soap, "cmtsResId", &a->cmtsResId, "xsd:integer"))
				{	soap_flag_cmtsResId--;
					continue;
				}
			if (soap_flag_attributes && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerToArrayOfSnmpV2CAttributesT(soap, "attributes", &a->attributes, "ns1:SnmpV2CAttributesT"))
				{	soap_flag_attributes--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_cmtsResId > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addCmtsAllSnmpV2CAttributes *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes, 0, sizeof(struct adm__addCmtsAllSnmpV2CAttributes), 0, soap_copy_adm__addCmtsAllSnmpV2CAttributes);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addCmtsAllSnmpV2CAttributes * SOAP_FMAC6 soap_new_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, int n)
{	return soap_instantiate_adm__addCmtsAllSnmpV2CAttributes(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, struct adm__addCmtsAllSnmpV2CAttributes *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addCmtsAllSnmpV2CAttributes * SOAP_FMAC4 soap_instantiate_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addCmtsAllSnmpV2CAttributes(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addCmtsAllSnmpV2CAttributes;
		if (size)
			*size = sizeof(struct adm__addCmtsAllSnmpV2CAttributes);
	}
	else
	{	cp->ptr = (void*)new struct adm__addCmtsAllSnmpV2CAttributes[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addCmtsAllSnmpV2CAttributes);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addCmtsAllSnmpV2CAttributes*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addCmtsAllSnmpV2CAttributes %p -> %p\n", q, p));
	*(struct adm__addCmtsAllSnmpV2CAttributes*)p = *(struct adm__addCmtsAllSnmpV2CAttributes*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, struct adm__addCmtsAllSnmpV2CAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const struct adm__addCmtsAllSnmpV2CAttributesResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const struct adm__addCmtsAllSnmpV2CAttributesResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse);
	if (soap_out_adm__addCmtsAllSnmpV2CAttributesResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const char *tag, int id, const struct adm__addCmtsAllSnmpV2CAttributesResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC4 soap_get_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, struct adm__addCmtsAllSnmpV2CAttributesResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addCmtsAllSnmpV2CAttributesResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC4 soap_in_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, const char *tag, struct adm__addCmtsAllSnmpV2CAttributesResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addCmtsAllSnmpV2CAttributesResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse, sizeof(struct adm__addCmtsAllSnmpV2CAttributesResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addCmtsAllSnmpV2CAttributesResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addCmtsAllSnmpV2CAttributesResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse, 0, sizeof(struct adm__addCmtsAllSnmpV2CAttributesResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC6 soap_new_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__addCmtsAllSnmpV2CAttributesResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, struct adm__addCmtsAllSnmpV2CAttributesResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addCmtsAllSnmpV2CAttributesResponse * SOAP_FMAC4 soap_instantiate_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addCmtsAllSnmpV2CAttributesResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addCmtsAllSnmpV2CAttributesResponse;
		if (size)
			*size = sizeof(struct adm__addCmtsAllSnmpV2CAttributesResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__addCmtsAllSnmpV2CAttributesResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addCmtsAllSnmpV2CAttributesResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addCmtsAllSnmpV2CAttributesResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addCmtsAllSnmpV2CAttributesResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addCmtsAllSnmpV2CAttributesResponse %p -> %p\n", q, p));
	*(struct adm__addCmtsAllSnmpV2CAttributesResponse*)p = *(struct adm__addCmtsAllSnmpV2CAttributesResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__deleteCmts(struct soap *soap, struct adm__deleteCmts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__deleteCmts(struct soap *soap, const struct adm__deleteCmts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmtsT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__deleteCmts(struct soap *soap, const struct adm__deleteCmts *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__deleteCmts);
	if (soap_out_adm__deleteCmts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__deleteCmts(struct soap *soap, const char *tag, int id, const struct adm__deleteCmts *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__deleteCmts), type);
	soap_out_PointerTons1__CmtsT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__deleteCmts * SOAP_FMAC4 soap_get_adm__deleteCmts(struct soap *soap, struct adm__deleteCmts *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__deleteCmts(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__deleteCmts * SOAP_FMAC4 soap_in_adm__deleteCmts(struct soap *soap, const char *tag, struct adm__deleteCmts *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__deleteCmts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__deleteCmts, sizeof(struct adm__deleteCmts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__deleteCmts(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsT(soap, "cmts", &a->cmts, "ns1:CmtsT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__deleteCmts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__deleteCmts, 0, sizeof(struct adm__deleteCmts), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__deleteCmts * SOAP_FMAC6 soap_new_adm__deleteCmts(struct soap *soap, int n)
{	return soap_instantiate_adm__deleteCmts(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__deleteCmts(struct soap *soap, struct adm__deleteCmts *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__deleteCmts * SOAP_FMAC4 soap_instantiate_adm__deleteCmts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__deleteCmts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__deleteCmts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__deleteCmts;
		if (size)
			*size = sizeof(struct adm__deleteCmts);
	}
	else
	{	cp->ptr = (void*)new struct adm__deleteCmts[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__deleteCmts);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__deleteCmts*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__deleteCmts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__deleteCmts %p -> %p\n", q, p));
	*(struct adm__deleteCmts*)p = *(struct adm__deleteCmts*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__deleteCmtsResponse(struct soap *soap, struct adm__deleteCmtsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__deleteCmtsResponse(struct soap *soap, const struct adm__deleteCmtsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__deleteCmtsResponse(struct soap *soap, const struct adm__deleteCmtsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__deleteCmtsResponse);
	if (soap_out_adm__deleteCmtsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__deleteCmtsResponse(struct soap *soap, const char *tag, int id, const struct adm__deleteCmtsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__deleteCmtsResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__deleteCmtsResponse * SOAP_FMAC4 soap_get_adm__deleteCmtsResponse(struct soap *soap, struct adm__deleteCmtsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__deleteCmtsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__deleteCmtsResponse * SOAP_FMAC4 soap_in_adm__deleteCmtsResponse(struct soap *soap, const char *tag, struct adm__deleteCmtsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__deleteCmtsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__deleteCmtsResponse, sizeof(struct adm__deleteCmtsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__deleteCmtsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__deleteCmtsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__deleteCmtsResponse, 0, sizeof(struct adm__deleteCmtsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__deleteCmtsResponse * SOAP_FMAC6 soap_new_adm__deleteCmtsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__deleteCmtsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__deleteCmtsResponse(struct soap *soap, struct adm__deleteCmtsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__deleteCmtsResponse * SOAP_FMAC4 soap_instantiate_adm__deleteCmtsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__deleteCmtsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__deleteCmtsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__deleteCmtsResponse;
		if (size)
			*size = sizeof(struct adm__deleteCmtsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__deleteCmtsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__deleteCmtsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__deleteCmtsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__deleteCmtsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__deleteCmtsResponse %p -> %p\n", q, p));
	*(struct adm__deleteCmtsResponse*)p = *(struct adm__deleteCmtsResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addCmts(struct soap *soap, struct adm__addCmts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addCmts(struct soap *soap, const struct adm__addCmts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmtsT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addCmts(struct soap *soap, const struct adm__addCmts *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addCmts);
	if (soap_out_adm__addCmts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addCmts(struct soap *soap, const char *tag, int id, const struct adm__addCmts *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addCmts), type);
	soap_out_PointerTons1__CmtsT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addCmts * SOAP_FMAC4 soap_get_adm__addCmts(struct soap *soap, struct adm__addCmts *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addCmts(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addCmts * SOAP_FMAC4 soap_in_adm__addCmts(struct soap *soap, const char *tag, struct adm__addCmts *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addCmts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addCmts, sizeof(struct adm__addCmts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addCmts(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsT(soap, "cmts", &a->cmts, "ns1:CmtsT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addCmts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addCmts, 0, sizeof(struct adm__addCmts), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addCmts * SOAP_FMAC6 soap_new_adm__addCmts(struct soap *soap, int n)
{	return soap_instantiate_adm__addCmts(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addCmts(struct soap *soap, struct adm__addCmts *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addCmts * SOAP_FMAC4 soap_instantiate_adm__addCmts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addCmts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addCmts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addCmts;
		if (size)
			*size = sizeof(struct adm__addCmts);
	}
	else
	{	cp->ptr = (void*)new struct adm__addCmts[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addCmts);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addCmts*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addCmts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addCmts %p -> %p\n", q, p));
	*(struct adm__addCmts*)p = *(struct adm__addCmts*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__addCmtsResponse(struct soap *soap, struct adm__addCmtsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__addCmtsResponse(struct soap *soap, const struct adm__addCmtsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__addCmtsResponse(struct soap *soap, const struct adm__addCmtsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__addCmtsResponse);
	if (soap_out_adm__addCmtsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__addCmtsResponse(struct soap *soap, const char *tag, int id, const struct adm__addCmtsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__addCmtsResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__addCmtsResponse * SOAP_FMAC4 soap_get_adm__addCmtsResponse(struct soap *soap, struct adm__addCmtsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__addCmtsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__addCmtsResponse * SOAP_FMAC4 soap_in_adm__addCmtsResponse(struct soap *soap, const char *tag, struct adm__addCmtsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__addCmtsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__addCmtsResponse, sizeof(struct adm__addCmtsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__addCmtsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__addCmtsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__addCmtsResponse, 0, sizeof(struct adm__addCmtsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__addCmtsResponse * SOAP_FMAC6 soap_new_adm__addCmtsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__addCmtsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__addCmtsResponse(struct soap *soap, struct adm__addCmtsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__addCmtsResponse * SOAP_FMAC4 soap_instantiate_adm__addCmtsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__addCmtsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__addCmtsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__addCmtsResponse;
		if (size)
			*size = sizeof(struct adm__addCmtsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__addCmtsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__addCmtsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__addCmtsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__addCmtsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__addCmtsResponse %p -> %p\n", q, p));
	*(struct adm__addCmtsResponse*)p = *(struct adm__addCmtsResponse*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmts(struct soap *soap, struct adm__updateCmts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->cmts = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmts(struct soap *soap, const struct adm__updateCmts *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_serialize_PointerTons1__CmtsT(soap, &a->cmts);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmts(struct soap *soap, const struct adm__updateCmts *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmts);
	if (soap_out_adm__updateCmts(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmts(struct soap *soap, const char *tag, int id, const struct adm__updateCmts *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmts), type);
	soap_out_PointerTons1__CmtsT(soap, "cmts", -1, &a->cmts, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmts * SOAP_FMAC4 soap_get_adm__updateCmts(struct soap *soap, struct adm__updateCmts *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmts(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmts * SOAP_FMAC4 soap_in_adm__updateCmts(struct soap *soap, const char *tag, struct adm__updateCmts *a, const char *type)
{
	short soap_flag_cmts = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmts *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmts, sizeof(struct adm__updateCmts), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmts(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_cmts && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_PointerTons1__CmtsT(soap, "cmts", &a->cmts, "ns1:CmtsT"))
				{	soap_flag_cmts--;
					continue;
				}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmts *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmts, 0, sizeof(struct adm__updateCmts), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmts * SOAP_FMAC6 soap_new_adm__updateCmts(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmts(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmts(struct soap *soap, struct adm__updateCmts *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmts * SOAP_FMAC4 soap_instantiate_adm__updateCmts(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmts(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmts, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmts;
		if (size)
			*size = sizeof(struct adm__updateCmts);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmts[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmts);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmts*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmts(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmts %p -> %p\n", q, p));
	*(struct adm__updateCmts*)p = *(struct adm__updateCmts*)q;
}
#ifdef __cplusplus
}
#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_adm__updateCmtsResponse(struct soap *soap, struct adm__updateCmtsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_short(soap, &a->result);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_adm__updateCmtsResponse(struct soap *soap, const struct adm__updateCmtsResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_embedded(soap, &a->result, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_adm__updateCmtsResponse(struct soap *soap, const struct adm__updateCmtsResponse *a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_adm__updateCmtsResponse);
	if (soap_out_adm__updateCmtsResponse(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_adm__updateCmtsResponse(struct soap *soap, const char *tag, int id, const struct adm__updateCmtsResponse *a, const char *type)
{
	soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_adm__updateCmtsResponse), type);
	soap_element_result(soap, "result");
	soap_out_short(soap, "result", -1, &a->result, "");
	soap_element_end_out(soap, tag);
	return SOAP_OK;
}

SOAP_FMAC3 struct adm__updateCmtsResponse * SOAP_FMAC4 soap_get_adm__updateCmtsResponse(struct soap *soap, struct adm__updateCmtsResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_adm__updateCmtsResponse(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct adm__updateCmtsResponse * SOAP_FMAC4 soap_in_adm__updateCmtsResponse(struct soap *soap, const char *tag, struct adm__updateCmtsResponse *a, const char *type)
{
	short soap_flag_result = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct adm__updateCmtsResponse *)soap_id_enter(soap, soap->id, a, SOAP_TYPE_adm__updateCmtsResponse, sizeof(struct adm__updateCmtsResponse), 0, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_adm__updateCmtsResponse(soap, a);
	if (soap->body && !*soap->href)
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_result && soap->error == SOAP_TAG_MISMATCH)
				if (soap_in_short(soap, "result", &a->result, "xsd:short"))
				{	soap_flag_result--;
					continue;
				}
			soap_check_result(soap, "result");
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if ((soap->mode & SOAP_XML_STRICT) && (soap_flag_result > 0))
		{	soap->error = SOAP_OCCURS;
			return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct adm__updateCmtsResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_adm__updateCmtsResponse, 0, sizeof(struct adm__updateCmtsResponse), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC5 struct adm__updateCmtsResponse * SOAP_FMAC6 soap_new_adm__updateCmtsResponse(struct soap *soap, int n)
{	return soap_instantiate_adm__updateCmtsResponse(soap, n, NULL, NULL, NULL);
}

SOAP_FMAC5 void SOAP_FMAC6 soap_delete_adm__updateCmtsResponse(struct soap *soap, struct adm__updateCmtsResponse *p)
{	soap_delete(soap, p);
}

SOAP_FMAC3 struct adm__updateCmtsResponse * SOAP_FMAC4 soap_instantiate_adm__updateCmtsResponse(struct soap *soap, int n, const char *type, const char *arrayType, size_t *size)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_instantiate_adm__updateCmtsResponse(%d, %s, %s)\n", n, type?type:"", arrayType?arrayType:""));
	struct soap_clist *cp = soap_link(soap, NULL, SOAP_TYPE_adm__updateCmtsResponse, n, soap_fdelete);
	if (!cp)
		return NULL;
	if (n < 0)
	{	cp->ptr = (void*)new struct adm__updateCmtsResponse;
		if (size)
			*size = sizeof(struct adm__updateCmtsResponse);
	}
	else
	{	cp->ptr = (void*)new struct adm__updateCmtsResponse[n];
		if (!cp->ptr)
		{	soap->error = SOAP_EOM;
			return NULL;
		}
		if (size)
			*size = n * sizeof(struct adm__updateCmtsResponse);
	}
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Instantiated location=%p\n", cp->ptr));
	return (struct adm__updateCmtsResponse*)cp->ptr;
}

#ifdef __cplusplus
extern "C" {
#endif
SOAP_FMAC3 void SOAP_FMAC4 soap_copy_adm__updateCmtsResponse(struct soap *soap, int st, int tt, void *p, size_t len, const void *q, size_t n)
{
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Copying struct adm__updateCmtsResponse %p -> %p\n", q, p));
	*(struct adm__updateCmtsResponse*)p = *(struct adm__updateCmtsResponse*)q;
}
#ifdef __cplusplus
}
#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Reason);
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Detail);
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToSOAP_ENV__Code);
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ConfigDownloadT(struct soap *soap, ns1__ConfigDownloadT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ConfigDownloadT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ConfigDownloadT(struct soap *soap, ns1__ConfigDownloadT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ConfigDownloadT);
	if (soap_out_PointerTons1__ConfigDownloadT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ConfigDownloadT(struct soap *soap, const char *tag, int id, ns1__ConfigDownloadT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ConfigDownloadT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ConfigDownloadT ** SOAP_FMAC4 soap_get_PointerTons1__ConfigDownloadT(struct soap *soap, ns1__ConfigDownloadT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ConfigDownloadT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ConfigDownloadT ** SOAP_FMAC4 soap_in_PointerTons1__ConfigDownloadT(struct soap *soap, const char *tag, ns1__ConfigDownloadT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ConfigDownloadT **)soap_malloc(soap, sizeof(ns1__ConfigDownloadT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ConfigDownloadT *)soap_instantiate_ns1__ConfigDownloadT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ConfigDownloadT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ConfigDownloadT, sizeof(ns1__ConfigDownloadT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__LocalSystemT(struct soap *soap, ns1__LocalSystemT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__LocalSystemT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__LocalSystemT(struct soap *soap, ns1__LocalSystemT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__LocalSystemT);
	if (soap_out_PointerTons1__LocalSystemT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__LocalSystemT(struct soap *soap, const char *tag, int id, ns1__LocalSystemT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__LocalSystemT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__LocalSystemT ** SOAP_FMAC4 soap_get_PointerTons1__LocalSystemT(struct soap *soap, ns1__LocalSystemT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__LocalSystemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__LocalSystemT ** SOAP_FMAC4 soap_in_PointerTons1__LocalSystemT(struct soap *soap, const char *tag, ns1__LocalSystemT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__LocalSystemT **)soap_malloc(soap, sizeof(ns1__LocalSystemT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__LocalSystemT *)soap_instantiate_ns1__LocalSystemT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__LocalSystemT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__LocalSystemT, sizeof(ns1__LocalSystemT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmsStatusThresholdT(struct soap *soap, ns1__CmsStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmsStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmsStatusThresholdT(struct soap *soap, ns1__CmsStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmsStatusThresholdT);
	if (soap_out_PointerTons1__CmsStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmsStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__CmsStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmsStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmsStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__CmsStatusThresholdT(struct soap *soap, ns1__CmsStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmsStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmsStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__CmsStatusThresholdT(struct soap *soap, const char *tag, ns1__CmsStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmsStatusThresholdT **)soap_malloc(soap, sizeof(ns1__CmsStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmsStatusThresholdT *)soap_instantiate_ns1__CmsStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmsStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmsStatusThresholdT, sizeof(ns1__CmsStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmtsStatusThresholdT(struct soap *soap, ns1__CmtsStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmtsStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmtsStatusThresholdT(struct soap *soap, ns1__CmtsStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmtsStatusThresholdT);
	if (soap_out_PointerTons1__CmtsStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmtsStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__CmtsStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmtsStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__CmtsStatusThresholdT(struct soap *soap, ns1__CmtsStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmtsStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmtsStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__CmtsStatusThresholdT(struct soap *soap, const char *tag, ns1__CmtsStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmtsStatusThresholdT **)soap_malloc(soap, sizeof(ns1__CmtsStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmtsStatusThresholdT *)soap_instantiate_ns1__CmtsStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmtsStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmtsStatusThresholdT, sizeof(ns1__CmtsStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChannelStatusThresholdT(struct soap *soap, ns1__ChannelStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChannelStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChannelStatusThresholdT(struct soap *soap, ns1__ChannelStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChannelStatusThresholdT);
	if (soap_out_PointerTons1__ChannelStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChannelStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__ChannelStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChannelStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__ChannelStatusThresholdT(struct soap *soap, ns1__ChannelStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChannelStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ChannelStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__ChannelStatusThresholdT(struct soap *soap, const char *tag, ns1__ChannelStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChannelStatusThresholdT **)soap_malloc(soap, sizeof(ns1__ChannelStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ChannelStatusThresholdT *)soap_instantiate_ns1__ChannelStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ChannelStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChannelStatusThresholdT, sizeof(ns1__ChannelStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcStatusThresholdT(struct soap *soap, ns1__HfcStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcStatusThresholdT(struct soap *soap, ns1__HfcStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcStatusThresholdT);
	if (soap_out_PointerTons1__HfcStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__HfcStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__HfcStatusThresholdT(struct soap *soap, ns1__HfcStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__HfcStatusThresholdT(struct soap *soap, const char *tag, ns1__HfcStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcStatusThresholdT **)soap_malloc(soap, sizeof(ns1__HfcStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcStatusThresholdT *)soap_instantiate_ns1__HfcStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcStatusThresholdT, sizeof(ns1__HfcStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaStatusThresholdT(struct soap *soap, ns1__MtaStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaStatusThresholdT(struct soap *soap, ns1__MtaStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaStatusThresholdT);
	if (soap_out_PointerTons1__MtaStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__MtaStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__MtaStatusThresholdT(struct soap *soap, ns1__MtaStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__MtaStatusThresholdT(struct soap *soap, const char *tag, ns1__MtaStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaStatusThresholdT **)soap_malloc(soap, sizeof(ns1__MtaStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaStatusThresholdT *)soap_instantiate_ns1__MtaStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaStatusThresholdT, sizeof(ns1__MtaStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfSnmpV2CAttributesT(struct soap *soap, ArrayOfSnmpV2CAttributesT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfSnmpV2CAttributesT(struct soap *soap, ArrayOfSnmpV2CAttributesT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfSnmpV2CAttributesT);
	if (soap_out_PointerToArrayOfSnmpV2CAttributesT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfSnmpV2CAttributesT(struct soap *soap, const char *tag, int id, ArrayOfSnmpV2CAttributesT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfSnmpV2CAttributesT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT ** SOAP_FMAC4 soap_get_PointerToArrayOfSnmpV2CAttributesT(struct soap *soap, ArrayOfSnmpV2CAttributesT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfSnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfSnmpV2CAttributesT ** SOAP_FMAC4 soap_in_PointerToArrayOfSnmpV2CAttributesT(struct soap *soap, const char *tag, ArrayOfSnmpV2CAttributesT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfSnmpV2CAttributesT **)soap_malloc(soap, sizeof(ArrayOfSnmpV2CAttributesT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfSnmpV2CAttributesT *)soap_instantiate_ArrayOfSnmpV2CAttributesT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfSnmpV2CAttributesT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfSnmpV2CAttributesT, sizeof(ArrayOfSnmpV2CAttributesT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmStatusSummaryT))
		soap_serialize_PointerTons1__CmStatusSummaryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmStatusSummaryT);
	if (soap_out_PointerToPointerTons1__CmStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__CmStatusSummaryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmStatusSummaryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmStatusSummaryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusSummaryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, ns1__CmStatusSummaryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusSummaryT ***)soap_malloc(soap, sizeof(ns1__CmStatusSummaryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmStatusSummaryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmStatusSummaryT, sizeof(ns1__CmStatusSummaryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmStatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmStatusSummaryT);
	if (soap_out_PointerTons1__CmStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__CmStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmStatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__CmStatusSummaryT(struct soap *soap, ns1__CmStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__CmStatusSummaryT(struct soap *soap, const char *tag, ns1__CmStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusSummaryT **)soap_malloc(soap, sizeof(ns1__CmStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmStatusSummaryT *)soap_instantiate_ns1__CmStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmStatusSummaryT, sizeof(ns1__CmStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaStatusSummaryT))
		soap_serialize_PointerTons1__MtaStatusSummaryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaStatusSummaryT);
	if (soap_out_PointerToPointerTons1__MtaStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__MtaStatusSummaryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaStatusSummaryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaStatusSummaryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaStatusSummaryT ***)soap_malloc(soap, sizeof(ns1__MtaStatusSummaryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaStatusSummaryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaStatusSummaryT, sizeof(ns1__MtaStatusSummaryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaStatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaStatusSummaryT);
	if (soap_out_PointerTons1__MtaStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__MtaStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaStatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaStatusSummaryT(struct soap *soap, ns1__MtaStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaStatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaStatusSummaryT(struct soap *soap, const char *tag, ns1__MtaStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaStatusSummaryT **)soap_malloc(soap, sizeof(ns1__MtaStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaStatusSummaryT *)soap_instantiate_ns1__MtaStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaStatusSummaryT, sizeof(ns1__MtaStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__HfcStatusSummaryT))
		soap_serialize_PointerTons1__HfcStatusSummaryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__HfcStatusSummaryT);
	if (soap_out_PointerToPointerTons1__HfcStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__HfcStatusSummaryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__HfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__HfcStatusSummaryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__HfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcStatusSummaryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcStatusSummaryT ***)soap_malloc(soap, sizeof(ns1__HfcStatusSummaryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__HfcStatusSummaryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__HfcStatusSummaryT, sizeof(ns1__HfcStatusSummaryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcStatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcStatusSummaryT);
	if (soap_out_PointerTons1__HfcStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, int id, ns1__HfcStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcStatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__HfcStatusSummaryT(struct soap *soap, ns1__HfcStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcStatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__HfcStatusSummaryT(struct soap *soap, const char *tag, ns1__HfcStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcStatusSummaryT **)soap_malloc(soap, sizeof(ns1__HfcStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcStatusSummaryT *)soap_instantiate_ns1__HfcStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcStatusSummaryT, sizeof(ns1__HfcStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AlarmTypeConfigT))
		soap_serialize_PointerTons1__AlarmTypeConfigT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AlarmTypeConfigT);
	if (soap_out_PointerToPointerTons1__AlarmTypeConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, int id, ns1__AlarmTypeConfigT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AlarmTypeConfigT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmTypeConfigT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, ns1__AlarmTypeConfigT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmTypeConfigT ***)soap_malloc(soap, sizeof(ns1__AlarmTypeConfigT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AlarmTypeConfigT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AlarmTypeConfigT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AlarmTypeConfigT, sizeof(ns1__AlarmTypeConfigT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT))
		soap_serialize_PointerTons1__AggregateStatusThresholdT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AggregateStatusThresholdT);
	if (soap_out_PointerToPointerTons1__AggregateStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateStatusThresholdT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AggregateStatusThresholdT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, ns1__AggregateStatusThresholdT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateStatusThresholdT ***)soap_malloc(soap, sizeof(ns1__AggregateStatusThresholdT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AggregateStatusThresholdT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AggregateStatusThresholdT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT, sizeof(ns1__AggregateStatusThresholdT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AggregateStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AggregateStatusThresholdT);
	if (soap_out_PointerTons1__AggregateStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AggregateStatusThresholdT(struct soap *soap, ns1__AggregateStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AggregateStatusThresholdT(struct soap *soap, const char *tag, ns1__AggregateStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AggregateStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AggregateStatusThresholdT *)soap_instantiate_ns1__AggregateStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AggregateStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AggregateStatusThresholdT, sizeof(ns1__AggregateStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT))
		soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AlarmBasedStatusThresholdT);
	if (soap_out_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AlarmBasedStatusThresholdT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AlarmBasedStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, ns1__AlarmBasedStatusThresholdT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmBasedStatusThresholdT ***)soap_malloc(soap, sizeof(ns1__AlarmBasedStatusThresholdT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AlarmBasedStatusThresholdT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT, sizeof(ns1__AlarmBasedStatusThresholdT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AlarmBasedStatusThresholdT);
	if (soap_out_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, int id, ns1__AlarmBasedStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, ns1__AlarmBasedStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AlarmBasedStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmBasedStatusThresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AlarmBasedStatusThresholdT(struct soap *soap, const char *tag, ns1__AlarmBasedStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmBasedStatusThresholdT **)soap_malloc(soap, sizeof(ns1__AlarmBasedStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AlarmBasedStatusThresholdT *)soap_instantiate_ns1__AlarmBasedStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AlarmBasedStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AlarmBasedStatusThresholdT, sizeof(ns1__AlarmBasedStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UserT(struct soap *soap, ns1__UserT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UserT))
		soap_serialize_PointerTons1__UserT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UserT(struct soap *soap, ns1__UserT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UserT);
	if (soap_out_PointerToPointerTons1__UserT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UserT(struct soap *soap, const char *tag, int id, ns1__UserT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UserT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UserT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UserT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UserT(struct soap *soap, ns1__UserT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UserT(struct soap *soap, const char *tag, ns1__UserT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserT ***)soap_malloc(soap, sizeof(ns1__UserT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UserT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UserT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UserT, sizeof(ns1__UserT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserT(struct soap *soap, ns1__UserT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserT(struct soap *soap, ns1__UserT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserT);
	if (soap_out_PointerTons1__UserT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserT(struct soap *soap, const char *tag, int id, ns1__UserT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UserT ** SOAP_FMAC4 soap_get_PointerTons1__UserT(struct soap *soap, ns1__UserT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserT ** SOAP_FMAC4 soap_in_PointerTons1__UserT(struct soap *soap, const char *tag, ns1__UserT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserT **)soap_malloc(soap, sizeof(ns1__UserT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UserT *)soap_instantiate_ns1__UserT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__UserT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserT, sizeof(ns1__UserT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__RoleT(struct soap *soap, ns1__RoleT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__RoleT))
		soap_serialize_PointerTons1__RoleT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__RoleT(struct soap *soap, ns1__RoleT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__RoleT);
	if (soap_out_PointerToPointerTons1__RoleT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__RoleT(struct soap *soap, const char *tag, int id, ns1__RoleT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__RoleT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__RoleT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__RoleT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__RoleT(struct soap *soap, ns1__RoleT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__RoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RoleT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__RoleT(struct soap *soap, const char *tag, ns1__RoleT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RoleT ***)soap_malloc(soap, sizeof(ns1__RoleT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__RoleT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__RoleT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__RoleT, sizeof(ns1__RoleT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RoleT(struct soap *soap, ns1__RoleT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RoleT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RoleT(struct soap *soap, ns1__RoleT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RoleT);
	if (soap_out_PointerTons1__RoleT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RoleT(struct soap *soap, const char *tag, int id, ns1__RoleT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RoleT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RoleT ** SOAP_FMAC4 soap_get_PointerTons1__RoleT(struct soap *soap, ns1__RoleT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RoleT ** SOAP_FMAC4 soap_in_PointerTons1__RoleT(struct soap *soap, const char *tag, ns1__RoleT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RoleT **)soap_malloc(soap, sizeof(ns1__RoleT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RoleT *)soap_instantiate_ns1__RoleT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__RoleT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RoleT, sizeof(ns1__RoleT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ApplicationDomainT))
		soap_serialize_PointerTons1__ApplicationDomainT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ApplicationDomainT);
	if (soap_out_PointerToPointerTons1__ApplicationDomainT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ApplicationDomainT(struct soap *soap, const char *tag, int id, ns1__ApplicationDomainT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ApplicationDomainT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ApplicationDomainT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ApplicationDomainT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ApplicationDomainT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ApplicationDomainT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ApplicationDomainT(struct soap *soap, const char *tag, ns1__ApplicationDomainT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApplicationDomainT ***)soap_malloc(soap, sizeof(ns1__ApplicationDomainT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ApplicationDomainT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ApplicationDomainT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ApplicationDomainT, sizeof(ns1__ApplicationDomainT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ApplicationDomainT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ApplicationDomainT);
	if (soap_out_PointerTons1__ApplicationDomainT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ApplicationDomainT(struct soap *soap, const char *tag, int id, ns1__ApplicationDomainT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ApplicationDomainT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ApplicationDomainT ** SOAP_FMAC4 soap_get_PointerTons1__ApplicationDomainT(struct soap *soap, ns1__ApplicationDomainT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ApplicationDomainT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ApplicationDomainT ** SOAP_FMAC4 soap_in_PointerTons1__ApplicationDomainT(struct soap *soap, const char *tag, ns1__ApplicationDomainT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ApplicationDomainT **)soap_malloc(soap, sizeof(ns1__ApplicationDomainT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ApplicationDomainT *)soap_instantiate_ns1__ApplicationDomainT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ApplicationDomainT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ApplicationDomainT, sizeof(ns1__ApplicationDomainT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__UserAccessT(struct soap *soap, ns1__UserAccessT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__UserAccessT))
		soap_serialize_PointerTons1__UserAccessT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__UserAccessT(struct soap *soap, ns1__UserAccessT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__UserAccessT);
	if (soap_out_PointerToPointerTons1__UserAccessT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__UserAccessT(struct soap *soap, const char *tag, int id, ns1__UserAccessT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__UserAccessT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__UserAccessT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__UserAccessT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__UserAccessT(struct soap *soap, ns1__UserAccessT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__UserAccessT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserAccessT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__UserAccessT(struct soap *soap, const char *tag, ns1__UserAccessT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserAccessT ***)soap_malloc(soap, sizeof(ns1__UserAccessT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__UserAccessT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__UserAccessT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__UserAccessT, sizeof(ns1__UserAccessT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__UserAccessT(struct soap *soap, ns1__UserAccessT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__UserAccessT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__UserAccessT(struct soap *soap, ns1__UserAccessT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__UserAccessT);
	if (soap_out_PointerTons1__UserAccessT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__UserAccessT(struct soap *soap, const char *tag, int id, ns1__UserAccessT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__UserAccessT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__UserAccessT ** SOAP_FMAC4 soap_get_PointerTons1__UserAccessT(struct soap *soap, ns1__UserAccessT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__UserAccessT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__UserAccessT ** SOAP_FMAC4 soap_in_PointerTons1__UserAccessT(struct soap *soap, const char *tag, ns1__UserAccessT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__UserAccessT **)soap_malloc(soap, sizeof(ns1__UserAccessT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__UserAccessT *)soap_instantiate_ns1__UserAccessT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__UserAccessT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__UserAccessT, sizeof(ns1__UserAccessT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CMSLineT))
		soap_serialize_PointerTons1__CMSLineT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CMSLineT);
	if (soap_out_PointerToPointerTons1__CMSLineT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CMSLineT(struct soap *soap, const char *tag, int id, ns1__CMSLineT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CMSLineT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CMSLineT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CMSLineT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CMSLineT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CMSLineT(struct soap *soap, const char *tag, ns1__CMSLineT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CMSLineT ***)soap_malloc(soap, sizeof(ns1__CMSLineT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CMSLineT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CMSLineT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CMSLineT, sizeof(ns1__CMSLineT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTEQueryInputT))
		soap_serialize_PointerTons1__CTEQueryInputT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTEQueryInputT);
	if (soap_out_PointerToPointerTons1__CTEQueryInputT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, int id, ns1__CTEQueryInputT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTEQueryInputT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTEQueryInputT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEQueryInputT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, ns1__CTEQueryInputT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEQueryInputT ***)soap_malloc(soap, sizeof(ns1__CTEQueryInputT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTEQueryInputT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTEQueryInputT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTEQueryInputT, sizeof(ns1__CTEQueryInputT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEQueryInputT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEQueryInputT);
	if (soap_out_PointerTons1__CTEQueryInputT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, int id, ns1__CTEQueryInputT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEQueryInputT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEQueryInputT ** SOAP_FMAC4 soap_get_PointerTons1__CTEQueryInputT(struct soap *soap, ns1__CTEQueryInputT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEQueryInputT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEQueryInputT ** SOAP_FMAC4 soap_in_PointerTons1__CTEQueryInputT(struct soap *soap, const char *tag, ns1__CTEQueryInputT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEQueryInputT **)soap_malloc(soap, sizeof(ns1__CTEQueryInputT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEQueryInputT *)soap_instantiate_ns1__CTEQueryInputT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEQueryInputT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEQueryInputT, sizeof(ns1__CTEQueryInputT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTEDataT))
		soap_serialize_PointerTons1__CTEDataT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTEDataT);
	if (soap_out_PointerToPointerTons1__CTEDataT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTEDataT(struct soap *soap, const char *tag, int id, ns1__CTEDataT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTEDataT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTEDataT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTEDataT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEDataT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTEDataT(struct soap *soap, const char *tag, ns1__CTEDataT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEDataT ***)soap_malloc(soap, sizeof(ns1__CTEDataT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTEDataT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTEDataT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTEDataT, sizeof(ns1__CTEDataT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEDataT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEDataT);
	if (soap_out_PointerTons1__CTEDataT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEDataT(struct soap *soap, const char *tag, int id, ns1__CTEDataT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEDataT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEDataT ** SOAP_FMAC4 soap_get_PointerTons1__CTEDataT(struct soap *soap, ns1__CTEDataT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEDataT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEDataT ** SOAP_FMAC4 soap_in_PointerTons1__CTEDataT(struct soap *soap, const char *tag, ns1__CTEDataT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEDataT **)soap_malloc(soap, sizeof(ns1__CTEDataT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEDataT *)soap_instantiate_ns1__CTEDataT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEDataT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEDataT, sizeof(ns1__CTEDataT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CTECustomerT))
		soap_serialize_PointerTons1__CTECustomerT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CTECustomerT);
	if (soap_out_PointerToPointerTons1__CTECustomerT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CTECustomerT(struct soap *soap, const char *tag, int id, ns1__CTECustomerT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CTECustomerT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CTECustomerT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CTECustomerT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTECustomerT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CTECustomerT(struct soap *soap, const char *tag, ns1__CTECustomerT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTECustomerT ***)soap_malloc(soap, sizeof(ns1__CTECustomerT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CTECustomerT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CTECustomerT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CTECustomerT, sizeof(ns1__CTECustomerT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT))
		soap_serialize_PointerTons1__CmPerformanceHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmPerformanceHistoryT);
	if (soap_out_PointerToPointerTons1__CmPerformanceHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, int id, ns1__CmPerformanceHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmPerformanceHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, ns1__CmPerformanceHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmPerformanceHistoryT ***)soap_malloc(soap, sizeof(ns1__CmPerformanceHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmPerformanceHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT, sizeof(ns1__CmPerformanceHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmPerformanceHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmPerformanceHistoryT);
	if (soap_out_PointerTons1__CmPerformanceHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, int id, ns1__CmPerformanceHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmPerformanceHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__CmPerformanceHistoryT(struct soap *soap, ns1__CmPerformanceHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmPerformanceHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmPerformanceHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__CmPerformanceHistoryT(struct soap *soap, const char *tag, ns1__CmPerformanceHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmPerformanceHistoryT **)soap_malloc(soap, sizeof(ns1__CmPerformanceHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmPerformanceHistoryT *)soap_instantiate_ns1__CmPerformanceHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmPerformanceHistoryT, sizeof(ns1__CmPerformanceHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT))
		soap_serialize_PointerTons1__MtaPingStatusHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaPingStatusHistoryT);
	if (soap_out_PointerToPointerTons1__MtaPingStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaPingStatusHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaPingStatusHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaPingStatusHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaPingStatusHistoryT ***)soap_malloc(soap, sizeof(ns1__MtaPingStatusHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaPingStatusHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT, sizeof(ns1__MtaPingStatusHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaPingStatusHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaPingStatusHistoryT);
	if (soap_out_PointerTons1__MtaPingStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaPingStatusHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaPingStatusHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, ns1__MtaPingStatusHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaPingStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaPingStatusHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaPingStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaPingStatusHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaPingStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaPingStatusHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaPingStatusHistoryT *)soap_instantiate_ns1__MtaPingStatusHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaPingStatusHistoryT, sizeof(ns1__MtaPingStatusHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT))
		soap_serialize_PointerTons1__MtaProvStatusHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaProvStatusHistoryT);
	if (soap_out_PointerToPointerTons1__MtaProvStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaProvStatusHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaProvStatusHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaProvStatusHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaProvStatusHistoryT ***)soap_malloc(soap, sizeof(ns1__MtaProvStatusHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaProvStatusHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT, sizeof(ns1__MtaProvStatusHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaProvStatusHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaProvStatusHistoryT);
	if (soap_out_PointerTons1__MtaProvStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaProvStatusHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaProvStatusHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, ns1__MtaProvStatusHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaProvStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaProvStatusHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaProvStatusHistoryT(struct soap *soap, const char *tag, ns1__MtaProvStatusHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaProvStatusHistoryT **)soap_malloc(soap, sizeof(ns1__MtaProvStatusHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaProvStatusHistoryT *)soap_instantiate_ns1__MtaProvStatusHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaProvStatusHistoryT, sizeof(ns1__MtaProvStatusHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT))
		soap_serialize_PointerTons1__MtaAvailabilityHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MtaAvailabilityHistoryT);
	if (soap_out_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaAvailabilityHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, ns1__MtaAvailabilityHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaAvailabilityHistoryT ***)soap_malloc(soap, sizeof(ns1__MtaAvailabilityHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT, sizeof(ns1__MtaAvailabilityHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaAvailabilityHistoryT);
	if (soap_out_PointerTons1__MtaAvailabilityHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, int id, ns1__MtaAvailabilityHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaAvailabilityHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, ns1__MtaAvailabilityHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaAvailabilityHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaAvailabilityHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__MtaAvailabilityHistoryT(struct soap *soap, const char *tag, ns1__MtaAvailabilityHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaAvailabilityHistoryT **)soap_malloc(soap, sizeof(ns1__MtaAvailabilityHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaAvailabilityHistoryT *)soap_instantiate_ns1__MtaAvailabilityHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaAvailabilityHistoryT, sizeof(ns1__MtaAvailabilityHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmStatusHistoryT))
		soap_serialize_PointerTons1__CmStatusHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmStatusHistoryT);
	if (soap_out_PointerToPointerTons1__CmStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__CmStatusHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmStatusHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmStatusHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, ns1__CmStatusHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusHistoryT ***)soap_malloc(soap, sizeof(ns1__CmStatusHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmStatusHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmStatusHistoryT, sizeof(ns1__CmStatusHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmStatusHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmStatusHistoryT);
	if (soap_out_PointerTons1__CmStatusHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, int id, ns1__CmStatusHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmStatusHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmStatusHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__CmStatusHistoryT(struct soap *soap, ns1__CmStatusHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmStatusHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__CmStatusHistoryT(struct soap *soap, const char *tag, ns1__CmStatusHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusHistoryT **)soap_malloc(soap, sizeof(ns1__CmStatusHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmStatusHistoryT *)soap_instantiate_ns1__CmStatusHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmStatusHistoryT, sizeof(ns1__CmStatusHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__GenericCountsHistoryT))
		soap_serialize_PointerTons1__GenericCountsHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__GenericCountsHistoryT);
	if (soap_out_PointerToPointerTons1__GenericCountsHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, int id, ns1__GenericCountsHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__GenericCountsHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__GenericCountsHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__GenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GenericCountsHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, ns1__GenericCountsHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericCountsHistoryT ***)soap_malloc(soap, sizeof(ns1__GenericCountsHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__GenericCountsHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__GenericCountsHistoryT, sizeof(ns1__GenericCountsHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericCountsHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GenericCountsHistoryT);
	if (soap_out_PointerTons1__GenericCountsHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, int id, ns1__GenericCountsHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericCountsHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GenericCountsHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__GenericCountsHistoryT(struct soap *soap, ns1__GenericCountsHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericCountsHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GenericCountsHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__GenericCountsHistoryT(struct soap *soap, const char *tag, ns1__GenericCountsHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericCountsHistoryT **)soap_malloc(soap, sizeof(ns1__GenericCountsHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericCountsHistoryT *)soap_instantiate_ns1__GenericCountsHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericCountsHistoryT, sizeof(ns1__GenericCountsHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__QueryStateT))
		soap_serialize_PointerTons1__QueryStateT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__QueryStateT);
	if (soap_out_PointerToPointerTons1__QueryStateT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__QueryStateT(struct soap *soap, const char *tag, int id, ns1__QueryStateT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__QueryStateT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__QueryStateT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__QueryStateT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__QueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__QueryStateT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__QueryStateT(struct soap *soap, const char *tag, ns1__QueryStateT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QueryStateT ***)soap_malloc(soap, sizeof(ns1__QueryStateT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__QueryStateT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__QueryStateT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__QueryStateT, sizeof(ns1__QueryStateT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__QueryStateT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__QueryStateT);
	if (soap_out_PointerTons1__QueryStateT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__QueryStateT(struct soap *soap, const char *tag, int id, ns1__QueryStateT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__QueryStateT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__QueryStateT ** SOAP_FMAC4 soap_get_PointerTons1__QueryStateT(struct soap *soap, ns1__QueryStateT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__QueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__QueryStateT ** SOAP_FMAC4 soap_in_PointerTons1__QueryStateT(struct soap *soap, const char *tag, ns1__QueryStateT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__QueryStateT **)soap_malloc(soap, sizeof(ns1__QueryStateT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__QueryStateT *)soap_instantiate_ns1__QueryStateT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__QueryStateT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__QueryStateT, sizeof(ns1__QueryStateT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ScrollPageT))
		soap_serialize_PointerTons1__ScrollPageT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ScrollPageT);
	if (soap_out_PointerToPointerTons1__ScrollPageT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ScrollPageT(struct soap *soap, const char *tag, int id, ns1__ScrollPageT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ScrollPageT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ScrollPageT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ScrollPageT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ScrollPageT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ScrollPageT(struct soap *soap, const char *tag, ns1__ScrollPageT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScrollPageT ***)soap_malloc(soap, sizeof(ns1__ScrollPageT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ScrollPageT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ScrollPageT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ScrollPageT, sizeof(ns1__ScrollPageT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ScrollPageT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ScrollPageT);
	if (soap_out_PointerTons1__ScrollPageT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ScrollPageT(struct soap *soap, const char *tag, int id, ns1__ScrollPageT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ScrollPageT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ScrollPageT ** SOAP_FMAC4 soap_get_PointerTons1__ScrollPageT(struct soap *soap, ns1__ScrollPageT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ScrollPageT ** SOAP_FMAC4 soap_in_PointerTons1__ScrollPageT(struct soap *soap, const char *tag, ns1__ScrollPageT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ScrollPageT **)soap_malloc(soap, sizeof(ns1__ScrollPageT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ScrollPageT *)soap_instantiate_ns1__ScrollPageT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ScrollPageT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ScrollPageT, sizeof(ns1__ScrollPageT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__AlarmHistoryT))
		soap_serialize_PointerTons1__AlarmHistoryT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__AlarmHistoryT);
	if (soap_out_PointerToPointerTons1__AlarmHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, int id, ns1__AlarmHistoryT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__AlarmHistoryT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__AlarmHistoryT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__AlarmHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmHistoryT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, ns1__AlarmHistoryT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmHistoryT ***)soap_malloc(soap, sizeof(ns1__AlarmHistoryT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__AlarmHistoryT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__AlarmHistoryT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__AlarmHistoryT, sizeof(ns1__AlarmHistoryT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AlarmHistoryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AlarmHistoryT);
	if (soap_out_PointerTons1__AlarmHistoryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, int id, ns1__AlarmHistoryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AlarmHistoryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AlarmHistoryT ** SOAP_FMAC4 soap_get_PointerTons1__AlarmHistoryT(struct soap *soap, ns1__AlarmHistoryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AlarmHistoryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmHistoryT ** SOAP_FMAC4 soap_in_PointerTons1__AlarmHistoryT(struct soap *soap, const char *tag, ns1__AlarmHistoryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmHistoryT **)soap_malloc(soap, sizeof(ns1__AlarmHistoryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AlarmHistoryT *)soap_instantiate_ns1__AlarmHistoryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AlarmHistoryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AlarmHistoryT, sizeof(ns1__AlarmHistoryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__HistoricalAlarmT))
		soap_serialize_PointerTons1__HistoricalAlarmT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__HistoricalAlarmT);
	if (soap_out_PointerToPointerTons1__HistoricalAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, int id, ns1__HistoricalAlarmT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__HistoricalAlarmT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__HistoricalAlarmT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__HistoricalAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HistoricalAlarmT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, ns1__HistoricalAlarmT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HistoricalAlarmT ***)soap_malloc(soap, sizeof(ns1__HistoricalAlarmT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__HistoricalAlarmT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__HistoricalAlarmT, sizeof(ns1__HistoricalAlarmT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CurrentAlarmT))
		soap_serialize_PointerTons1__CurrentAlarmT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CurrentAlarmT);
	if (soap_out_PointerToPointerTons1__CurrentAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, int id, ns1__CurrentAlarmT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CurrentAlarmT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CurrentAlarmT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CurrentAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CurrentAlarmT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, ns1__CurrentAlarmT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CurrentAlarmT ***)soap_malloc(soap, sizeof(ns1__CurrentAlarmT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CurrentAlarmT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CurrentAlarmT, sizeof(ns1__CurrentAlarmT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__EmtaT(struct soap *soap, ns1__EmtaT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__EmtaT))
		soap_serialize_PointerTons1__EmtaT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__EmtaT(struct soap *soap, ns1__EmtaT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__EmtaT);
	if (soap_out_PointerToPointerTons1__EmtaT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__EmtaT(struct soap *soap, const char *tag, int id, ns1__EmtaT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__EmtaT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__EmtaT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__EmtaT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__EmtaT(struct soap *soap, ns1__EmtaT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__EmtaT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__EmtaT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__EmtaT(struct soap *soap, const char *tag, ns1__EmtaT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EmtaT ***)soap_malloc(soap, sizeof(ns1__EmtaT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__EmtaT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__EmtaT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__EmtaT, sizeof(ns1__EmtaT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CableModemT(struct soap *soap, ns1__CableModemT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CableModemT))
		soap_serialize_PointerTons1__CableModemT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CableModemT(struct soap *soap, ns1__CableModemT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CableModemT);
	if (soap_out_PointerToPointerTons1__CableModemT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CableModemT(struct soap *soap, const char *tag, int id, ns1__CableModemT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CableModemT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CableModemT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CableModemT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CableModemT(struct soap *soap, ns1__CableModemT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CableModemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CableModemT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CableModemT(struct soap *soap, const char *tag, ns1__CableModemT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CableModemT ***)soap_malloc(soap, sizeof(ns1__CableModemT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CableModemT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CableModemT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CableModemT, sizeof(ns1__CableModemT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__HfcT(struct soap *soap, ns1__HfcT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__HfcT))
		soap_serialize_PointerTons1__HfcT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__HfcT(struct soap *soap, ns1__HfcT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__HfcT);
	if (soap_out_PointerToPointerTons1__HfcT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__HfcT(struct soap *soap, const char *tag, int id, ns1__HfcT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__HfcT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__HfcT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__HfcT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__HfcT(struct soap *soap, ns1__HfcT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__HfcT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__HfcT(struct soap *soap, const char *tag, ns1__HfcT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcT ***)soap_malloc(soap, sizeof(ns1__HfcT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__HfcT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__HfcT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__HfcT, sizeof(ns1__HfcT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcT(struct soap *soap, ns1__HfcT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcT(struct soap *soap, ns1__HfcT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcT);
	if (soap_out_PointerTons1__HfcT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcT(struct soap *soap, const char *tag, int id, ns1__HfcT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcT ** SOAP_FMAC4 soap_get_PointerTons1__HfcT(struct soap *soap, ns1__HfcT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcT ** SOAP_FMAC4 soap_in_PointerTons1__HfcT(struct soap *soap, const char *tag, ns1__HfcT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcT **)soap_malloc(soap, sizeof(ns1__HfcT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcT *)soap_instantiate_ns1__HfcT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcT, sizeof(ns1__HfcT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__ChannelT(struct soap *soap, ns1__ChannelT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__ChannelT))
		soap_serialize_PointerTons1__ChannelT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__ChannelT(struct soap *soap, ns1__ChannelT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__ChannelT);
	if (soap_out_PointerToPointerTons1__ChannelT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__ChannelT(struct soap *soap, const char *tag, int id, ns1__ChannelT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__ChannelT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__ChannelT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__ChannelT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__ChannelT(struct soap *soap, ns1__ChannelT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__ChannelT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ChannelT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__ChannelT(struct soap *soap, const char *tag, ns1__ChannelT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChannelT ***)soap_malloc(soap, sizeof(ns1__ChannelT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__ChannelT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__ChannelT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__ChannelT, sizeof(ns1__ChannelT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ChannelT(struct soap *soap, ns1__ChannelT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ChannelT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ChannelT(struct soap *soap, ns1__ChannelT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ChannelT);
	if (soap_out_PointerTons1__ChannelT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ChannelT(struct soap *soap, const char *tag, int id, ns1__ChannelT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ChannelT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ChannelT ** SOAP_FMAC4 soap_get_PointerTons1__ChannelT(struct soap *soap, ns1__ChannelT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ChannelT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ChannelT ** SOAP_FMAC4 soap_in_PointerTons1__ChannelT(struct soap *soap, const char *tag, ns1__ChannelT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ChannelT **)soap_malloc(soap, sizeof(ns1__ChannelT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ChannelT *)soap_instantiate_ns1__ChannelT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ChannelT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ChannelT, sizeof(ns1__ChannelT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT))
		soap_serialize_PointerTons1__SnmpV2CAttributesT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__SnmpV2CAttributesT);
	if (soap_out_PointerToPointerTons1__SnmpV2CAttributesT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, int id, ns1__SnmpV2CAttributesT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__SnmpV2CAttributesT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__SnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, ns1__SnmpV2CAttributesT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnmpV2CAttributesT ***)soap_malloc(soap, sizeof(ns1__SnmpV2CAttributesT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__SnmpV2CAttributesT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__SnmpV2CAttributesT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT, sizeof(ns1__SnmpV2CAttributesT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SnmpV2CAttributesT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SnmpV2CAttributesT);
	if (soap_out_PointerTons1__SnmpV2CAttributesT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, int id, ns1__SnmpV2CAttributesT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SnmpV2CAttributesT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT ** SOAP_FMAC4 soap_get_PointerTons1__SnmpV2CAttributesT(struct soap *soap, ns1__SnmpV2CAttributesT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SnmpV2CAttributesT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SnmpV2CAttributesT ** SOAP_FMAC4 soap_in_PointerTons1__SnmpV2CAttributesT(struct soap *soap, const char *tag, ns1__SnmpV2CAttributesT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SnmpV2CAttributesT **)soap_malloc(soap, sizeof(ns1__SnmpV2CAttributesT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SnmpV2CAttributesT *)soap_instantiate_ns1__SnmpV2CAttributesT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SnmpV2CAttributesT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SnmpV2CAttributesT, sizeof(ns1__SnmpV2CAttributesT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmtsT(struct soap *soap, ns1__CmtsT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmtsT))
		soap_serialize_PointerTons1__CmtsT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmtsT(struct soap *soap, ns1__CmtsT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmtsT);
	if (soap_out_PointerToPointerTons1__CmtsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmtsT(struct soap *soap, const char *tag, int id, ns1__CmtsT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmtsT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmtsT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmtsT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmtsT(struct soap *soap, ns1__CmtsT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmtsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmtsT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmtsT(struct soap *soap, const char *tag, ns1__CmtsT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmtsT ***)soap_malloc(soap, sizeof(ns1__CmtsT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmtsT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmtsT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmtsT, sizeof(ns1__CmtsT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmtsT(struct soap *soap, ns1__CmtsT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmtsT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmtsT(struct soap *soap, ns1__CmtsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmtsT);
	if (soap_out_PointerTons1__CmtsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmtsT(struct soap *soap, const char *tag, int id, ns1__CmtsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmtsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmtsT ** SOAP_FMAC4 soap_get_PointerTons1__CmtsT(struct soap *soap, ns1__CmtsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmtsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmtsT ** SOAP_FMAC4 soap_in_PointerTons1__CmtsT(struct soap *soap, const char *tag, ns1__CmtsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmtsT **)soap_malloc(soap, sizeof(ns1__CmtsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmtsT *)soap_instantiate_ns1__CmtsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmtsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmtsT, sizeof(ns1__CmtsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__CmsT(struct soap *soap, ns1__CmsT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__CmsT))
		soap_serialize_PointerTons1__CmsT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__CmsT(struct soap *soap, ns1__CmsT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__CmsT);
	if (soap_out_PointerToPointerTons1__CmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__CmsT(struct soap *soap, const char *tag, int id, ns1__CmsT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__CmsT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__CmsT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__CmsT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__CmsT(struct soap *soap, ns1__CmsT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__CmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmsT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__CmsT(struct soap *soap, const char *tag, ns1__CmsT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmsT ***)soap_malloc(soap, sizeof(ns1__CmsT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__CmsT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__CmsT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__CmsT, sizeof(ns1__CmsT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmsT(struct soap *soap, ns1__CmsT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmsT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmsT(struct soap *soap, ns1__CmsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmsT);
	if (soap_out_PointerTons1__CmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmsT(struct soap *soap, const char *tag, int id, ns1__CmsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmsT ** SOAP_FMAC4 soap_get_PointerTons1__CmsT(struct soap *soap, ns1__CmsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmsT ** SOAP_FMAC4 soap_in_PointerTons1__CmsT(struct soap *soap, const char *tag, ns1__CmsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmsT **)soap_malloc(soap, sizeof(ns1__CmsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmsT *)soap_instantiate_ns1__CmsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmsT, sizeof(ns1__CmsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__BladeT(struct soap *soap, ns1__BladeT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__BladeT))
		soap_serialize_PointerTons1__BladeT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__BladeT(struct soap *soap, ns1__BladeT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__BladeT);
	if (soap_out_PointerToPointerTons1__BladeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__BladeT(struct soap *soap, const char *tag, int id, ns1__BladeT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__BladeT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__BladeT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__BladeT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__BladeT(struct soap *soap, ns1__BladeT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__BladeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__BladeT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__BladeT(struct soap *soap, const char *tag, ns1__BladeT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BladeT ***)soap_malloc(soap, sizeof(ns1__BladeT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__BladeT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__BladeT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__BladeT, sizeof(ns1__BladeT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__BladeT(struct soap *soap, ns1__BladeT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__BladeT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__BladeT(struct soap *soap, ns1__BladeT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__BladeT);
	if (soap_out_PointerTons1__BladeT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__BladeT(struct soap *soap, const char *tag, int id, ns1__BladeT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__BladeT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__BladeT ** SOAP_FMAC4 soap_get_PointerTons1__BladeT(struct soap *soap, ns1__BladeT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__BladeT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__BladeT ** SOAP_FMAC4 soap_in_PointerTons1__BladeT(struct soap *soap, const char *tag, ns1__BladeT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__BladeT **)soap_malloc(soap, sizeof(ns1__BladeT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__BladeT *)soap_instantiate_ns1__BladeT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__BladeT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__BladeT, sizeof(ns1__BladeT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__MarketT(struct soap *soap, ns1__MarketT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__MarketT))
		soap_serialize_PointerTons1__MarketT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__MarketT(struct soap *soap, ns1__MarketT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__MarketT);
	if (soap_out_PointerToPointerTons1__MarketT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__MarketT(struct soap *soap, const char *tag, int id, ns1__MarketT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__MarketT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__MarketT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__MarketT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__MarketT(struct soap *soap, ns1__MarketT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__MarketT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MarketT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__MarketT(struct soap *soap, const char *tag, ns1__MarketT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketT ***)soap_malloc(soap, sizeof(ns1__MarketT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__MarketT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__MarketT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__MarketT, sizeof(ns1__MarketT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MarketT(struct soap *soap, ns1__MarketT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MarketT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MarketT(struct soap *soap, ns1__MarketT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MarketT);
	if (soap_out_PointerTons1__MarketT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MarketT(struct soap *soap, const char *tag, int id, ns1__MarketT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MarketT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MarketT ** SOAP_FMAC4 soap_get_PointerTons1__MarketT(struct soap *soap, ns1__MarketT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MarketT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MarketT ** SOAP_FMAC4 soap_in_PointerTons1__MarketT(struct soap *soap, const char *tag, ns1__MarketT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MarketT **)soap_malloc(soap, sizeof(ns1__MarketT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MarketT *)soap_instantiate_ns1__MarketT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MarketT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MarketT, sizeof(ns1__MarketT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToPointerTons1__RegionT(struct soap *soap, ns1__RegionT **const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_PointerTons1__RegionT))
		soap_serialize_PointerTons1__RegionT(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToPointerTons1__RegionT(struct soap *soap, ns1__RegionT **const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToPointerTons1__RegionT);
	if (soap_out_PointerToPointerTons1__RegionT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToPointerTons1__RegionT(struct soap *soap, const char *tag, int id, ns1__RegionT **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_PointerTons1__RegionT);
	if (id < 0)
		return soap->error;
	return soap_out_PointerTons1__RegionT(soap, tag, id, *a, type);
}

SOAP_FMAC3 ns1__RegionT *** SOAP_FMAC4 soap_get_PointerToPointerTons1__RegionT(struct soap *soap, ns1__RegionT ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToPointerTons1__RegionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RegionT *** SOAP_FMAC4 soap_in_PointerToPointerTons1__RegionT(struct soap *soap, const char *tag, ns1__RegionT ***a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RegionT ***)soap_malloc(soap, sizeof(ns1__RegionT **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_PointerTons1__RegionT(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (ns1__RegionT ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_PointerTons1__RegionT, sizeof(ns1__RegionT *), 1);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__RegionT(struct soap *soap, ns1__RegionT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__RegionT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__RegionT(struct soap *soap, ns1__RegionT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__RegionT);
	if (soap_out_PointerTons1__RegionT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__RegionT(struct soap *soap, const char *tag, int id, ns1__RegionT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__RegionT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__RegionT ** SOAP_FMAC4 soap_get_PointerTons1__RegionT(struct soap *soap, ns1__RegionT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__RegionT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__RegionT ** SOAP_FMAC4 soap_in_PointerTons1__RegionT(struct soap *soap, const char *tag, ns1__RegionT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__RegionT **)soap_malloc(soap, sizeof(ns1__RegionT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__RegionT *)soap_instantiate_ns1__RegionT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__RegionT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__RegionT, sizeof(ns1__RegionT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfHistoricalAlarmsT);
	if (soap_out_PointerToArrayOfHistoricalAlarmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, int id, ArrayOfHistoricalAlarmsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfHistoricalAlarmsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT ** SOAP_FMAC4 soap_get_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, ArrayOfHistoricalAlarmsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfHistoricalAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfHistoricalAlarmsT ** SOAP_FMAC4 soap_in_PointerToArrayOfHistoricalAlarmsT(struct soap *soap, const char *tag, ArrayOfHistoricalAlarmsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfHistoricalAlarmsT **)soap_malloc(soap, sizeof(ArrayOfHistoricalAlarmsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfHistoricalAlarmsT *)soap_instantiate_ArrayOfHistoricalAlarmsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfHistoricalAlarmsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfHistoricalAlarmsT, sizeof(ArrayOfHistoricalAlarmsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCurrentAlarmsT);
	if (soap_out_PointerToArrayOfCurrentAlarmsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, int id, ArrayOfCurrentAlarmsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCurrentAlarmsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT ** SOAP_FMAC4 soap_get_PointerToArrayOfCurrentAlarmsT(struct soap *soap, ArrayOfCurrentAlarmsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCurrentAlarmsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfCurrentAlarmsT ** SOAP_FMAC4 soap_in_PointerToArrayOfCurrentAlarmsT(struct soap *soap, const char *tag, ArrayOfCurrentAlarmsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCurrentAlarmsT **)soap_malloc(soap, sizeof(ArrayOfCurrentAlarmsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCurrentAlarmsT *)soap_instantiate_ArrayOfCurrentAlarmsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfCurrentAlarmsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCurrentAlarmsT, sizeof(ArrayOfCurrentAlarmsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfCmStatusSummaryT);
	if (soap_out_PointerToArrayOfCmStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, int id, ArrayOfCmStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfCmStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT ** SOAP_FMAC4 soap_get_PointerToArrayOfCmStatusSummaryT(struct soap *soap, ArrayOfCmStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfCmStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfCmStatusSummaryT ** SOAP_FMAC4 soap_in_PointerToArrayOfCmStatusSummaryT(struct soap *soap, const char *tag, ArrayOfCmStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfCmStatusSummaryT **)soap_malloc(soap, sizeof(ArrayOfCmStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfCmStatusSummaryT *)soap_instantiate_ArrayOfCmStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfCmStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfCmStatusSummaryT, sizeof(ArrayOfCmStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfHfcStatusSummaryT);
	if (soap_out_PointerToArrayOfHfcStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, int id, ArrayOfHfcStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfHfcStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT ** SOAP_FMAC4 soap_get_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, ArrayOfHfcStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfHfcStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfHfcStatusSummaryT ** SOAP_FMAC4 soap_in_PointerToArrayOfHfcStatusSummaryT(struct soap *soap, const char *tag, ArrayOfHfcStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfHfcStatusSummaryT **)soap_malloc(soap, sizeof(ArrayOfHfcStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfHfcStatusSummaryT *)soap_instantiate_ArrayOfHfcStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfHfcStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfHfcStatusSummaryT, sizeof(ArrayOfHfcStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfQueryStateT);
	if (soap_out_PointerToArrayOfQueryStateT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfQueryStateT(struct soap *soap, const char *tag, int id, ArrayOfQueryStateT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfQueryStateT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfQueryStateT ** SOAP_FMAC4 soap_get_PointerToArrayOfQueryStateT(struct soap *soap, ArrayOfQueryStateT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfQueryStateT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfQueryStateT ** SOAP_FMAC4 soap_in_PointerToArrayOfQueryStateT(struct soap *soap, const char *tag, ArrayOfQueryStateT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfQueryStateT **)soap_malloc(soap, sizeof(ArrayOfQueryStateT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfQueryStateT *)soap_instantiate_ArrayOfQueryStateT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfQueryStateT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfQueryStateT, sizeof(ArrayOfQueryStateT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfMtaStatusSummaryT);
	if (soap_out_PointerToArrayOfMtaStatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, int id, ArrayOfMtaStatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfMtaStatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT ** SOAP_FMAC4 soap_get_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, ArrayOfMtaStatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfMtaStatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfMtaStatusSummaryT ** SOAP_FMAC4 soap_in_PointerToArrayOfMtaStatusSummaryT(struct soap *soap, const char *tag, ArrayOfMtaStatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfMtaStatusSummaryT **)soap_malloc(soap, sizeof(ArrayOfMtaStatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfMtaStatusSummaryT *)soap_instantiate_ArrayOfMtaStatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfMtaStatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfMtaStatusSummaryT, sizeof(ArrayOfMtaStatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__StatusSummaryT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__StatusSummaryT);
	if (soap_out_PointerTons1__StatusSummaryT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__StatusSummaryT(struct soap *soap, const char *tag, int id, ns1__StatusSummaryT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__StatusSummaryT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__StatusSummaryT ** SOAP_FMAC4 soap_get_PointerTons1__StatusSummaryT(struct soap *soap, ns1__StatusSummaryT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__StatusSummaryT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__StatusSummaryT ** SOAP_FMAC4 soap_in_PointerTons1__StatusSummaryT(struct soap *soap, const char *tag, ns1__StatusSummaryT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__StatusSummaryT **)soap_malloc(soap, sizeof(ns1__StatusSummaryT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__StatusSummaryT *)soap_instantiate_ns1__StatusSummaryT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__StatusSummaryT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__StatusSummaryT, sizeof(ns1__StatusSummaryT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfUserT(struct soap *soap, ArrayOfUserT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfUserT(struct soap *soap, ArrayOfUserT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfUserT);
	if (soap_out_PointerToArrayOfUserT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfUserT(struct soap *soap, const char *tag, int id, ArrayOfUserT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfUserT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfUserT ** SOAP_FMAC4 soap_get_PointerToArrayOfUserT(struct soap *soap, ArrayOfUserT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfUserT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfUserT ** SOAP_FMAC4 soap_in_PointerToArrayOfUserT(struct soap *soap, const char *tag, ArrayOfUserT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfUserT **)soap_malloc(soap, sizeof(ArrayOfUserT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfUserT *)soap_instantiate_ArrayOfUserT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfUserT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfUserT, sizeof(ArrayOfUserT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfRoleT(struct soap *soap, ArrayOfRoleT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfRoleT(struct soap *soap, ArrayOfRoleT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfRoleT);
	if (soap_out_PointerToArrayOfRoleT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfRoleT(struct soap *soap, const char *tag, int id, ArrayOfRoleT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfRoleT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfRoleT ** SOAP_FMAC4 soap_get_PointerToArrayOfRoleT(struct soap *soap, ArrayOfRoleT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfRoleT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfRoleT ** SOAP_FMAC4 soap_in_PointerToArrayOfRoleT(struct soap *soap, const char *tag, ArrayOfRoleT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfRoleT **)soap_malloc(soap, sizeof(ArrayOfRoleT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfRoleT *)soap_instantiate_ArrayOfRoleT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfRoleT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfRoleT, sizeof(ArrayOfRoleT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__PollingIntervalsT(struct soap *soap, ns1__PollingIntervalsT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__PollingIntervalsT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__PollingIntervalsT(struct soap *soap, ns1__PollingIntervalsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__PollingIntervalsT);
	if (soap_out_PointerTons1__PollingIntervalsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__PollingIntervalsT(struct soap *soap, const char *tag, int id, ns1__PollingIntervalsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__PollingIntervalsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__PollingIntervalsT ** SOAP_FMAC4 soap_get_PointerTons1__PollingIntervalsT(struct soap *soap, ns1__PollingIntervalsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__PollingIntervalsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__PollingIntervalsT ** SOAP_FMAC4 soap_in_PointerTons1__PollingIntervalsT(struct soap *soap, const char *tag, ns1__PollingIntervalsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__PollingIntervalsT **)soap_malloc(soap, sizeof(ns1__PollingIntervalsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__PollingIntervalsT *)soap_instantiate_ns1__PollingIntervalsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__PollingIntervalsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__PollingIntervalsT, sizeof(ns1__PollingIntervalsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcAlarmConfigT(struct soap *soap, ns1__HfcAlarmConfigT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcAlarmConfigT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcAlarmConfigT(struct soap *soap, ns1__HfcAlarmConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcAlarmConfigT);
	if (soap_out_PointerTons1__HfcAlarmConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcAlarmConfigT(struct soap *soap, const char *tag, int id, ns1__HfcAlarmConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcAlarmConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcAlarmConfigT ** SOAP_FMAC4 soap_get_PointerTons1__HfcAlarmConfigT(struct soap *soap, ns1__HfcAlarmConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcAlarmConfigT ** SOAP_FMAC4 soap_in_PointerTons1__HfcAlarmConfigT(struct soap *soap, const char *tag, ns1__HfcAlarmConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcAlarmConfigT **)soap_malloc(soap, sizeof(ns1__HfcAlarmConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcAlarmConfigT *)soap_instantiate_ns1__HfcAlarmConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcAlarmConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcAlarmConfigT, sizeof(ns1__HfcAlarmConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaAlarmConfigT(struct soap *soap, ns1__MtaAlarmConfigT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaAlarmConfigT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaAlarmConfigT(struct soap *soap, ns1__MtaAlarmConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaAlarmConfigT);
	if (soap_out_PointerTons1__MtaAlarmConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaAlarmConfigT(struct soap *soap, const char *tag, int id, ns1__MtaAlarmConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaAlarmConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaAlarmConfigT ** SOAP_FMAC4 soap_get_PointerTons1__MtaAlarmConfigT(struct soap *soap, ns1__MtaAlarmConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaAlarmConfigT ** SOAP_FMAC4 soap_in_PointerTons1__MtaAlarmConfigT(struct soap *soap, const char *tag, ns1__MtaAlarmConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaAlarmConfigT **)soap_malloc(soap, sizeof(ns1__MtaAlarmConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaAlarmConfigT *)soap_instantiate_ns1__MtaAlarmConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaAlarmConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaAlarmConfigT, sizeof(ns1__MtaAlarmConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmtsAlarmConfigT(struct soap *soap, ns1__CmtsAlarmConfigT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmtsAlarmConfigT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmtsAlarmConfigT(struct soap *soap, ns1__CmtsAlarmConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmtsAlarmConfigT);
	if (soap_out_PointerTons1__CmtsAlarmConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmtsAlarmConfigT(struct soap *soap, const char *tag, int id, ns1__CmtsAlarmConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmtsAlarmConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT ** SOAP_FMAC4 soap_get_PointerTons1__CmtsAlarmConfigT(struct soap *soap, ns1__CmtsAlarmConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmtsAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmtsAlarmConfigT ** SOAP_FMAC4 soap_in_PointerTons1__CmtsAlarmConfigT(struct soap *soap, const char *tag, ns1__CmtsAlarmConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmtsAlarmConfigT **)soap_malloc(soap, sizeof(ns1__CmtsAlarmConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmtsAlarmConfigT *)soap_instantiate_ns1__CmtsAlarmConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmtsAlarmConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmtsAlarmConfigT, sizeof(ns1__CmtsAlarmConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmsAlarmConfigT(struct soap *soap, ns1__CmsAlarmConfigT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmsAlarmConfigT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmsAlarmConfigT(struct soap *soap, ns1__CmsAlarmConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmsAlarmConfigT);
	if (soap_out_PointerTons1__CmsAlarmConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmsAlarmConfigT(struct soap *soap, const char *tag, int id, ns1__CmsAlarmConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmsAlarmConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmsAlarmConfigT ** SOAP_FMAC4 soap_get_PointerTons1__CmsAlarmConfigT(struct soap *soap, ns1__CmsAlarmConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmsAlarmConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmsAlarmConfigT ** SOAP_FMAC4 soap_in_PointerTons1__CmsAlarmConfigT(struct soap *soap, const char *tag, ns1__CmsAlarmConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmsAlarmConfigT **)soap_malloc(soap, sizeof(ns1__CmsAlarmConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmsAlarmConfigT *)soap_instantiate_ns1__CmsAlarmConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmsAlarmConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmsAlarmConfigT, sizeof(ns1__CmsAlarmConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmPerformanceConfigT(struct soap *soap, ns1__CmPerformanceConfigT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmPerformanceConfigT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmPerformanceConfigT(struct soap *soap, ns1__CmPerformanceConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmPerformanceConfigT);
	if (soap_out_PointerTons1__CmPerformanceConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmPerformanceConfigT(struct soap *soap, const char *tag, int id, ns1__CmPerformanceConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmPerformanceConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmPerformanceConfigT ** SOAP_FMAC4 soap_get_PointerTons1__CmPerformanceConfigT(struct soap *soap, ns1__CmPerformanceConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmPerformanceConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmPerformanceConfigT ** SOAP_FMAC4 soap_in_PointerTons1__CmPerformanceConfigT(struct soap *soap, const char *tag, ns1__CmPerformanceConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmPerformanceConfigT **)soap_malloc(soap, sizeof(ns1__CmPerformanceConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmPerformanceConfigT *)soap_instantiate_ns1__CmPerformanceConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmPerformanceConfigT, sizeof(ns1__CmPerformanceConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AlarmTypeConfigT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AlarmTypeConfigT);
	if (soap_out_PointerTons1__AlarmTypeConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, int id, ns1__AlarmTypeConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AlarmTypeConfigT ** SOAP_FMAC4 soap_get_PointerTons1__AlarmTypeConfigT(struct soap *soap, ns1__AlarmTypeConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AlarmTypeConfigT ** SOAP_FMAC4 soap_in_PointerTons1__AlarmTypeConfigT(struct soap *soap, const char *tag, ns1__AlarmTypeConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AlarmTypeConfigT **)soap_malloc(soap, sizeof(ns1__AlarmTypeConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AlarmTypeConfigT *)soap_instantiate_ns1__AlarmTypeConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AlarmTypeConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AlarmTypeConfigT, sizeof(ns1__AlarmTypeConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAlarmTypeConfigT);
	if (soap_out_PointerToArrayOfAlarmTypeConfigT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, int id, ArrayOfAlarmTypeConfigT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmTypeConfigT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT ** SOAP_FMAC4 soap_get_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, ArrayOfAlarmTypeConfigT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAlarmTypeConfigT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfAlarmTypeConfigT ** SOAP_FMAC4 soap_in_PointerToArrayOfAlarmTypeConfigT(struct soap *soap, const char *tag, ArrayOfAlarmTypeConfigT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfAlarmTypeConfigT **)soap_malloc(soap, sizeof(ArrayOfAlarmTypeConfigT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfAlarmTypeConfigT *)soap_instantiate_ArrayOfAlarmTypeConfigT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmTypeConfigT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAlarmTypeConfigT, sizeof(ArrayOfAlarmTypeConfigT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HfcPowerTresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HfcPowerTresholdT);
	if (soap_out_PointerTons1__HfcPowerTresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HfcPowerTresholdT(struct soap *soap, const char *tag, int id, ns1__HfcPowerTresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HfcPowerTresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HfcPowerTresholdT ** SOAP_FMAC4 soap_get_PointerTons1__HfcPowerTresholdT(struct soap *soap, ns1__HfcPowerTresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HfcPowerTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HfcPowerTresholdT ** SOAP_FMAC4 soap_in_PointerTons1__HfcPowerTresholdT(struct soap *soap, const char *tag, ns1__HfcPowerTresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HfcPowerTresholdT **)soap_malloc(soap, sizeof(ns1__HfcPowerTresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HfcPowerTresholdT *)soap_instantiate_ns1__HfcPowerTresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HfcPowerTresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HfcPowerTresholdT, sizeof(ns1__HfcPowerTresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AggregateMtaTresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AggregateMtaTresholdT);
	if (soap_out_PointerTons1__AggregateMtaTresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AggregateMtaTresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateMtaTresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AggregateMtaTresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AggregateMtaTresholdT(struct soap *soap, ns1__AggregateMtaTresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AggregateMtaTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateMtaTresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AggregateMtaTresholdT(struct soap *soap, const char *tag, ns1__AggregateMtaTresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateMtaTresholdT **)soap_malloc(soap, sizeof(ns1__AggregateMtaTresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AggregateMtaTresholdT *)soap_instantiate_ns1__AggregateMtaTresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AggregateMtaTresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AggregateMtaTresholdT, sizeof(ns1__AggregateMtaTresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__SoakWindowT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__SoakWindowT(struct soap *soap, ns1__SoakWindowT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__SoakWindowT);
	if (soap_out_PointerTons1__SoakWindowT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__SoakWindowT(struct soap *soap, const char *tag, int id, ns1__SoakWindowT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__SoakWindowT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__SoakWindowT ** SOAP_FMAC4 soap_get_PointerTons1__SoakWindowT(struct soap *soap, ns1__SoakWindowT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__SoakWindowT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__SoakWindowT ** SOAP_FMAC4 soap_in_PointerTons1__SoakWindowT(struct soap *soap, const char *tag, ns1__SoakWindowT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__SoakWindowT **)soap_malloc(soap, sizeof(ns1__SoakWindowT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__SoakWindowT *)soap_instantiate_ns1__SoakWindowT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__SoakWindowT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__SoakWindowT, sizeof(ns1__SoakWindowT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AggregateCmOfflineTresholdT);
	if (soap_out_PointerTons1__AggregateCmOfflineTresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, int id, ns1__AggregateCmOfflineTresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT ** SOAP_FMAC4 soap_get_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, ns1__AggregateCmOfflineTresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AggregateCmOfflineTresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AggregateCmOfflineTresholdT ** SOAP_FMAC4 soap_in_PointerTons1__AggregateCmOfflineTresholdT(struct soap *soap, const char *tag, ns1__AggregateCmOfflineTresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AggregateCmOfflineTresholdT **)soap_malloc(soap, sizeof(ns1__AggregateCmOfflineTresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AggregateCmOfflineTresholdT *)soap_instantiate_ns1__AggregateCmOfflineTresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AggregateCmOfflineTresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AggregateCmOfflineTresholdT, sizeof(ns1__AggregateCmOfflineTresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAggregateStatusThresholdT);
	if (soap_out_PointerToArrayOfAggregateStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, int id, ArrayOfAggregateStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAggregateStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT ** SOAP_FMAC4 soap_get_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, ArrayOfAggregateStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAggregateStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfAggregateStatusThresholdT ** SOAP_FMAC4 soap_in_PointerToArrayOfAggregateStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAggregateStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfAggregateStatusThresholdT **)soap_malloc(soap, sizeof(ArrayOfAggregateStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfAggregateStatusThresholdT *)soap_instantiate_ArrayOfAggregateStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfAggregateStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAggregateStatusThresholdT, sizeof(ArrayOfAggregateStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfAlarmStatusThresholdT);
	if (soap_out_PointerToArrayOfAlarmStatusThresholdT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, int id, ArrayOfAlarmStatusThresholdT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfAlarmStatusThresholdT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT ** SOAP_FMAC4 soap_get_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, ArrayOfAlarmStatusThresholdT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfAlarmStatusThresholdT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfAlarmStatusThresholdT ** SOAP_FMAC4 soap_in_PointerToArrayOfAlarmStatusThresholdT(struct soap *soap, const char *tag, ArrayOfAlarmStatusThresholdT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfAlarmStatusThresholdT **)soap_malloc(soap, sizeof(ArrayOfAlarmStatusThresholdT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfAlarmStatusThresholdT *)soap_instantiate_ArrayOfAlarmStatusThresholdT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfAlarmStatusThresholdT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfAlarmStatusThresholdT, sizeof(ArrayOfAlarmStatusThresholdT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfApplicationDomainT(struct soap *soap, ArrayOfApplicationDomainT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfApplicationDomainT(struct soap *soap, ArrayOfApplicationDomainT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfApplicationDomainT);
	if (soap_out_PointerToArrayOfApplicationDomainT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfApplicationDomainT(struct soap *soap, const char *tag, int id, ArrayOfApplicationDomainT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfApplicationDomainT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfApplicationDomainT ** SOAP_FMAC4 soap_get_PointerToArrayOfApplicationDomainT(struct soap *soap, ArrayOfApplicationDomainT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfApplicationDomainT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfApplicationDomainT ** SOAP_FMAC4 soap_in_PointerToArrayOfApplicationDomainT(struct soap *soap, const char *tag, ArrayOfApplicationDomainT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfApplicationDomainT **)soap_malloc(soap, sizeof(ArrayOfApplicationDomainT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfApplicationDomainT *)soap_instantiate_ArrayOfApplicationDomainT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfApplicationDomainT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfApplicationDomainT, sizeof(ArrayOfApplicationDomainT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfUserAccessT(struct soap *soap, ArrayOfUserAccessT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfUserAccessT(struct soap *soap, ArrayOfUserAccessT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfUserAccessT);
	if (soap_out_PointerToArrayOfUserAccessT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfUserAccessT(struct soap *soap, const char *tag, int id, ArrayOfUserAccessT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfUserAccessT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfUserAccessT ** SOAP_FMAC4 soap_get_PointerToArrayOfUserAccessT(struct soap *soap, ArrayOfUserAccessT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfUserAccessT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfUserAccessT ** SOAP_FMAC4 soap_in_PointerToArrayOfUserAccessT(struct soap *soap, const char *tag, ArrayOfUserAccessT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfUserAccessT **)soap_malloc(soap, sizeof(ArrayOfUserAccessT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfUserAccessT *)soap_instantiate_ArrayOfUserAccessT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfUserAccessT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfUserAccessT, sizeof(ArrayOfUserAccessT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CMSLineT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CMSLineT);
	if (soap_out_PointerTons1__CMSLineT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CMSLineT(struct soap *soap, const char *tag, int id, ns1__CMSLineT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CMSLineT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CMSLineT ** SOAP_FMAC4 soap_get_PointerTons1__CMSLineT(struct soap *soap, ns1__CMSLineT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CMSLineT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CMSLineT ** SOAP_FMAC4 soap_in_PointerTons1__CMSLineT(struct soap *soap, const char *tag, ns1__CMSLineT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CMSLineT **)soap_malloc(soap, sizeof(ns1__CMSLineT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CMSLineT *)soap_instantiate_ns1__CMSLineT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CMSLineT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CMSLineT, sizeof(ns1__CMSLineT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEAbstractNameT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEAbstractNameT);
	if (soap_out_PointerTons1__CTEAbstractNameT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEAbstractNameT(struct soap *soap, const char *tag, int id, ns1__CTEAbstractNameT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEAbstractNameT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEAbstractNameT ** SOAP_FMAC4 soap_get_PointerTons1__CTEAbstractNameT(struct soap *soap, ns1__CTEAbstractNameT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEAbstractNameT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEAbstractNameT ** SOAP_FMAC4 soap_in_PointerTons1__CTEAbstractNameT(struct soap *soap, const char *tag, ns1__CTEAbstractNameT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEAbstractNameT **)soap_malloc(soap, sizeof(ns1__CTEAbstractNameT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEAbstractNameT *)soap_instantiate_ns1__CTEAbstractNameT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractNameT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEAbstractNameT, sizeof(ns1__CTEAbstractNameT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTEAbstractMacT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTEAbstractMacT);
	if (soap_out_PointerTons1__CTEAbstractMacT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTEAbstractMacT(struct soap *soap, const char *tag, int id, ns1__CTEAbstractMacT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTEAbstractMacT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTEAbstractMacT ** SOAP_FMAC4 soap_get_PointerTons1__CTEAbstractMacT(struct soap *soap, ns1__CTEAbstractMacT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTEAbstractMacT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTEAbstractMacT ** SOAP_FMAC4 soap_in_PointerTons1__CTEAbstractMacT(struct soap *soap, const char *tag, ns1__CTEAbstractMacT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTEAbstractMacT **)soap_malloc(soap, sizeof(ns1__CTEAbstractMacT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTEAbstractMacT *)soap_instantiate_ns1__CTEAbstractMacT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTEAbstractMacT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTEAbstractMacT, sizeof(ns1__CTEAbstractMacT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CTECustomerT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CTECustomerT);
	if (soap_out_PointerTons1__CTECustomerT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CTECustomerT(struct soap *soap, const char *tag, int id, ns1__CTECustomerT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CTECustomerT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CTECustomerT ** SOAP_FMAC4 soap_get_PointerTons1__CTECustomerT(struct soap *soap, ns1__CTECustomerT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CTECustomerT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CTECustomerT ** SOAP_FMAC4 soap_in_PointerTons1__CTECustomerT(struct soap *soap, const char *tag, ns1__CTECustomerT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CTECustomerT **)soap_malloc(soap, sizeof(ns1__CTECustomerT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CTECustomerT *)soap_instantiate_ns1__CTECustomerT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CTECustomerT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CTECustomerT, sizeof(ns1__CTECustomerT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToshort(struct soap *soap, short *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_short);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToshort(struct soap *soap, short *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToshort);
	if (soap_out_PointerToshort(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToshort(struct soap *soap, const char *tag, int id, short *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_short);
	if (id < 0)
		return soap->error;
	return soap_out_short(soap, tag, id, *a, type);
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_get_PointerToshort(struct soap *soap, short **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToshort(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 short ** SOAP_FMAC4 soap_in_PointerToshort(struct soap *soap, const char *tag, short **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (short **)soap_malloc(soap, sizeof(short *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_short(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (short **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_short, sizeof(short), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmPerformanceT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmPerformanceT);
	if (soap_out_PointerTons1__CmPerformanceT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmPerformanceT(struct soap *soap, const char *tag, int id, ns1__CmPerformanceT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmPerformanceT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmPerformanceT ** SOAP_FMAC4 soap_get_PointerTons1__CmPerformanceT(struct soap *soap, ns1__CmPerformanceT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmPerformanceT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmPerformanceT ** SOAP_FMAC4 soap_in_PointerTons1__CmPerformanceT(struct soap *soap, const char *tag, ns1__CmPerformanceT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmPerformanceT **)soap_malloc(soap, sizeof(ns1__CmPerformanceT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmPerformanceT *)soap_instantiate_ns1__CmPerformanceT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmPerformanceT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmPerformanceT, sizeof(ns1__CmPerformanceT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaPingStatusT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaPingStatusT);
	if (soap_out_PointerTons1__MtaPingStatusT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaPingStatusT(struct soap *soap, const char *tag, int id, ns1__MtaPingStatusT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaPingStatusT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaPingStatusT ** SOAP_FMAC4 soap_get_PointerTons1__MtaPingStatusT(struct soap *soap, ns1__MtaPingStatusT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaPingStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaPingStatusT ** SOAP_FMAC4 soap_in_PointerTons1__MtaPingStatusT(struct soap *soap, const char *tag, ns1__MtaPingStatusT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaPingStatusT **)soap_malloc(soap, sizeof(ns1__MtaPingStatusT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaPingStatusT *)soap_instantiate_ns1__MtaPingStatusT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaPingStatusT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaPingStatusT, sizeof(ns1__MtaPingStatusT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaProvStatusT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaProvStatusT);
	if (soap_out_PointerTons1__MtaProvStatusT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaProvStatusT(struct soap *soap, const char *tag, int id, ns1__MtaProvStatusT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaProvStatusT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaProvStatusT ** SOAP_FMAC4 soap_get_PointerTons1__MtaProvStatusT(struct soap *soap, ns1__MtaProvStatusT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaProvStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaProvStatusT ** SOAP_FMAC4 soap_in_PointerTons1__MtaProvStatusT(struct soap *soap, const char *tag, ns1__MtaProvStatusT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaProvStatusT **)soap_malloc(soap, sizeof(ns1__MtaProvStatusT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaProvStatusT *)soap_instantiate_ns1__MtaProvStatusT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaProvStatusT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaProvStatusT, sizeof(ns1__MtaProvStatusT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__MtaAvailabilityT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__MtaAvailabilityT);
	if (soap_out_PointerTons1__MtaAvailabilityT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__MtaAvailabilityT(struct soap *soap, const char *tag, int id, ns1__MtaAvailabilityT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__MtaAvailabilityT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__MtaAvailabilityT ** SOAP_FMAC4 soap_get_PointerTons1__MtaAvailabilityT(struct soap *soap, ns1__MtaAvailabilityT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__MtaAvailabilityT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__MtaAvailabilityT ** SOAP_FMAC4 soap_in_PointerTons1__MtaAvailabilityT(struct soap *soap, const char *tag, ns1__MtaAvailabilityT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__MtaAvailabilityT **)soap_malloc(soap, sizeof(ns1__MtaAvailabilityT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__MtaAvailabilityT *)soap_instantiate_ns1__MtaAvailabilityT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__MtaAvailabilityT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__MtaAvailabilityT, sizeof(ns1__MtaAvailabilityT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CmStatusT(struct soap *soap, ns1__CmStatusT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CmStatusT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CmStatusT(struct soap *soap, ns1__CmStatusT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CmStatusT);
	if (soap_out_PointerTons1__CmStatusT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CmStatusT(struct soap *soap, const char *tag, int id, ns1__CmStatusT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CmStatusT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CmStatusT ** SOAP_FMAC4 soap_get_PointerTons1__CmStatusT(struct soap *soap, ns1__CmStatusT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CmStatusT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CmStatusT ** SOAP_FMAC4 soap_in_PointerTons1__CmStatusT(struct soap *soap, const char *tag, ns1__CmStatusT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CmStatusT **)soap_malloc(soap, sizeof(ns1__CmStatusT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CmStatusT *)soap_instantiate_ns1__CmStatusT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CmStatusT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CmStatusT, sizeof(ns1__CmStatusT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *const*a)
{
	if (*a)
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToArrayOfScrollPageT);
	if (soap_out_PointerToArrayOfScrollPageT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToArrayOfScrollPageT(struct soap *soap, const char *tag, int id, ArrayOfScrollPageT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, (struct soap_array*)&(*a)->__ptr, 1, type, SOAP_TYPE_ArrayOfScrollPageT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ArrayOfScrollPageT ** SOAP_FMAC4 soap_get_PointerToArrayOfScrollPageT(struct soap *soap, ArrayOfScrollPageT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToArrayOfScrollPageT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ArrayOfScrollPageT ** SOAP_FMAC4 soap_in_PointerToArrayOfScrollPageT(struct soap *soap, const char *tag, ArrayOfScrollPageT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ArrayOfScrollPageT **)soap_malloc(soap, sizeof(ArrayOfScrollPageT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ArrayOfScrollPageT *)soap_instantiate_ArrayOfScrollPageT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ArrayOfScrollPageT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ArrayOfScrollPageT, sizeof(ArrayOfScrollPageT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__ResultBatchT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__ResultBatchT(struct soap *soap, ns1__ResultBatchT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__ResultBatchT);
	if (soap_out_PointerTons1__ResultBatchT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__ResultBatchT(struct soap *soap, const char *tag, int id, ns1__ResultBatchT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__ResultBatchT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__ResultBatchT ** SOAP_FMAC4 soap_get_PointerTons1__ResultBatchT(struct soap *soap, ns1__ResultBatchT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__ResultBatchT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__ResultBatchT ** SOAP_FMAC4 soap_in_PointerTons1__ResultBatchT(struct soap *soap, const char *tag, ns1__ResultBatchT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__ResultBatchT **)soap_malloc(soap, sizeof(ns1__ResultBatchT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__ResultBatchT *)soap_instantiate_ns1__ResultBatchT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__ResultBatchT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__ResultBatchT, sizeof(ns1__ResultBatchT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__EmtaT(struct soap *soap, ns1__EmtaT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__EmtaT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__EmtaT(struct soap *soap, ns1__EmtaT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__EmtaT);
	if (soap_out_PointerTons1__EmtaT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__EmtaT(struct soap *soap, const char *tag, int id, ns1__EmtaT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__EmtaT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__EmtaT ** SOAP_FMAC4 soap_get_PointerTons1__EmtaT(struct soap *soap, ns1__EmtaT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__EmtaT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__EmtaT ** SOAP_FMAC4 soap_in_PointerTons1__EmtaT(struct soap *soap, const char *tag, ns1__EmtaT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__EmtaT **)soap_malloc(soap, sizeof(ns1__EmtaT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__EmtaT *)soap_instantiate_ns1__EmtaT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__EmtaT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__EmtaT, sizeof(ns1__EmtaT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CableModemT(struct soap *soap, ns1__CableModemT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CableModemT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CableModemT(struct soap *soap, ns1__CableModemT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CableModemT);
	if (soap_out_PointerTons1__CableModemT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CableModemT(struct soap *soap, const char *tag, int id, ns1__CableModemT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CableModemT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CableModemT ** SOAP_FMAC4 soap_get_PointerTons1__CableModemT(struct soap *soap, ns1__CableModemT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CableModemT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CableModemT ** SOAP_FMAC4 soap_in_PointerTons1__CableModemT(struct soap *soap, const char *tag, ns1__CableModemT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CableModemT **)soap_malloc(soap, sizeof(ns1__CableModemT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CableModemT *)soap_instantiate_ns1__CableModemT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CableModemT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CableModemT, sizeof(ns1__CableModemT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__HistoricalAlarmT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__HistoricalAlarmT);
	if (soap_out_PointerTons1__HistoricalAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, int id, ns1__HistoricalAlarmT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__HistoricalAlarmT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__HistoricalAlarmT ** SOAP_FMAC4 soap_get_PointerTons1__HistoricalAlarmT(struct soap *soap, ns1__HistoricalAlarmT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__HistoricalAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__HistoricalAlarmT ** SOAP_FMAC4 soap_in_PointerTons1__HistoricalAlarmT(struct soap *soap, const char *tag, ns1__HistoricalAlarmT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__HistoricalAlarmT **)soap_malloc(soap, sizeof(ns1__HistoricalAlarmT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__HistoricalAlarmT *)soap_instantiate_ns1__HistoricalAlarmT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__HistoricalAlarmT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__HistoricalAlarmT, sizeof(ns1__HistoricalAlarmT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__CurrentAlarmT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__CurrentAlarmT);
	if (soap_out_PointerTons1__CurrentAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, int id, ns1__CurrentAlarmT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__CurrentAlarmT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__CurrentAlarmT ** SOAP_FMAC4 soap_get_PointerTons1__CurrentAlarmT(struct soap *soap, ns1__CurrentAlarmT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__CurrentAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__CurrentAlarmT ** SOAP_FMAC4 soap_in_PointerTons1__CurrentAlarmT(struct soap *soap, const char *tag, ns1__CurrentAlarmT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__CurrentAlarmT **)soap_malloc(soap, sizeof(ns1__CurrentAlarmT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__CurrentAlarmT *)soap_instantiate_ns1__CurrentAlarmT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__CurrentAlarmT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__CurrentAlarmT, sizeof(ns1__CurrentAlarmT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__AbstractAlarmT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__AbstractAlarmT);
	if (soap_out_PointerTons1__AbstractAlarmT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__AbstractAlarmT(struct soap *soap, const char *tag, int id, ns1__AbstractAlarmT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__AbstractAlarmT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__AbstractAlarmT ** SOAP_FMAC4 soap_get_PointerTons1__AbstractAlarmT(struct soap *soap, ns1__AbstractAlarmT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__AbstractAlarmT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__AbstractAlarmT ** SOAP_FMAC4 soap_in_PointerTons1__AbstractAlarmT(struct soap *soap, const char *tag, ns1__AbstractAlarmT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__AbstractAlarmT **)soap_malloc(soap, sizeof(ns1__AbstractAlarmT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__AbstractAlarmT *)soap_instantiate_ns1__AbstractAlarmT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__AbstractAlarmT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__AbstractAlarmT, sizeof(ns1__AbstractAlarmT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToxsd__integer(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_xsd__integer))
		soap_serialize_xsd__integer(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToxsd__integer(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerToxsd__integer);
	if (soap_out_PointerToxsd__integer(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToxsd__integer(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_xsd__integer);
	if (id < 0)
		return soap->error;
	return soap_out_xsd__integer(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerToxsd__integer(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToxsd__integer(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerToxsd__integer(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_xsd__integer(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_xsd__integer, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__GenericCountsT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__GenericCountsT(struct soap *soap, ns1__GenericCountsT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__GenericCountsT);
	if (soap_out_PointerTons1__GenericCountsT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__GenericCountsT(struct soap *soap, const char *tag, int id, ns1__GenericCountsT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__GenericCountsT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__GenericCountsT ** SOAP_FMAC4 soap_get_PointerTons1__GenericCountsT(struct soap *soap, ns1__GenericCountsT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__GenericCountsT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__GenericCountsT ** SOAP_FMAC4 soap_in_PointerTons1__GenericCountsT(struct soap *soap, const char *tag, ns1__GenericCountsT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__GenericCountsT **)soap_malloc(soap, sizeof(ns1__GenericCountsT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__GenericCountsT *)soap_instantiate_ns1__GenericCountsT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__GenericCountsT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__GenericCountsT, sizeof(ns1__GenericCountsT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTons1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_ns1__TopoHierarchyKeyT))
		(*a)->soap_serialize(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTons1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTons1__TopoHierarchyKeyT);
	if (soap_out_PointerTons1__TopoHierarchyKeyT(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTons1__TopoHierarchyKeyT(struct soap *soap, const char *tag, int id, ns1__TopoHierarchyKeyT *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_ns1__TopoHierarchyKeyT);
	if (id < 0)
		return soap->error;
	return (*a)->soap_out(soap, tag, id, type);
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT ** SOAP_FMAC4 soap_get_PointerTons1__TopoHierarchyKeyT(struct soap *soap, ns1__TopoHierarchyKeyT **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTons1__TopoHierarchyKeyT(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 ns1__TopoHierarchyKeyT ** SOAP_FMAC4 soap_in_PointerTons1__TopoHierarchyKeyT(struct soap *soap, const char *tag, ns1__TopoHierarchyKeyT **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (ns1__TopoHierarchyKeyT **)soap_malloc(soap, sizeof(ns1__TopoHierarchyKeyT *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = (ns1__TopoHierarchyKeyT *)soap_instantiate_ns1__TopoHierarchyKeyT(soap, -1, soap->type, soap->arrayType, NULL)))
			return NULL;
		(*a)->soap_default(soap);
		if (!(*a)->soap_in(soap, tag, NULL))
			return NULL;
	}
	else
	{	a = (ns1__TopoHierarchyKeyT **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_ns1__TopoHierarchyKeyT, sizeof(ns1__TopoHierarchyKeyT), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostd__string(struct soap *soap, std::string *const*a)
{
	if (!soap_reference(soap, *a, SOAP_TYPE_std__string))
		soap_serialize_std__string(soap, *a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostd__string(struct soap *soap, std::string *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_PointerTostd__string);
	if (soap_out_PointerTostd__string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostd__string(struct soap *soap, const char *tag, int id, std::string *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_std__string);
	if (id < 0)
		return soap->error;
	return soap_out_std__string(soap, tag, id, *a, type);
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_get_PointerTostd__string(struct soap *soap, std::string **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostd__string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 std::string ** SOAP_FMAC4 soap_in_PointerTostd__string(struct soap *soap, const char *tag, std::string **a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (std::string **)soap_malloc(soap, sizeof(std::string *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_std__string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (std::string **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_std__string, sizeof(std::string), 0);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default__QName(struct soap *soap, char **a)
{	soap_default_string(soap, a);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{	soap_serialize_string(soap, a);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE__QName);
	if (soap_out__QName(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, -1, -1);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_string(struct soap *soap, char **a)
{	(void)soap; /* appease -Wall -Werror */
#ifdef SOAP_DEFAULT_string
	*a = SOAP_DEFAULT_string;
#else
	*a = (char *)0;
#endif
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	soap_reference(soap, *a, SOAP_TYPE_string);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	register int id = soap_embed(soap, (void*)a, NULL, 0, tag, SOAP_TYPE_string);
	if (soap_out_string(soap, tag, id, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		soap_getindependent(soap);
	return p;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	return soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, -1, -1);
}

/* End of AdminServC.cpp */
