/* CteServStub.h
   Generated by gSOAP 2.7.9c from include/CteServices.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef CteServStub_H
#define CteServStub_H
#include <vector>
#define WITH_NONAMESPACES
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__SystemTypeT
#define SOAP_TYPE_ns1__SystemTypeT (125)
/* ns1:SystemTypeT */
enum ns1__SystemTypeT {ns1__SystemTypeT__EnterpriseServer = 0, ns1__SystemTypeT__RegionServer = 1, ns1__SystemTypeT__MarketServer = 2, ns1__SystemTypeT__BladeServer = 3};
#endif

#ifndef SOAP_TYPE_ns1__ResourceTypeT
#define SOAP_TYPE_ns1__ResourceTypeT (126)
/* ns1:ResourceTypeT */
enum ns1__ResourceTypeT {ns1__ResourceTypeT__CMTS = 0, ns1__ResourceTypeT__CMS = 1, ns1__ResourceTypeT__Channel = 2, ns1__ResourceTypeT__HFC = 3, ns1__ResourceTypeT__CM = 4, ns1__ResourceTypeT__MTA = 5};
#endif

#ifndef SOAP_TYPE_ns1__StatusColorT
#define SOAP_TYPE_ns1__StatusColorT (127)
/* ns1:StatusColorT */
enum ns1__StatusColorT {ns1__StatusColorT__Gray = 0, ns1__StatusColorT__Green = 1, ns1__StatusColorT__Yellow = 2, ns1__StatusColorT__Orange = 3, ns1__StatusColorT__Red = 4};
#endif

#ifndef SOAP_TYPE_ns1__SnmpVersionT
#define SOAP_TYPE_ns1__SnmpVersionT (128)
/* ns1:SnmpVersionT */
enum ns1__SnmpVersionT {ns1__SnmpVersionT__v1 = 0, ns1__SnmpVersionT__v2c = 1, ns1__SnmpVersionT__v3 = 2};
#endif

#ifndef SOAP_TYPE_ns1__ChannelTypeT
#define SOAP_TYPE_ns1__ChannelTypeT (129)
/* ns1:ChannelTypeT */
enum ns1__ChannelTypeT {ns1__ChannelTypeT__Upstream = 0, ns1__ChannelTypeT__Downstream = 1};
#endif

#ifndef SOAP_TYPE_ns1__EndUserDeviceTypeT
#define SOAP_TYPE_ns1__EndUserDeviceTypeT (130)
/* ns1:EndUserDeviceTypeT */
enum ns1__EndUserDeviceTypeT {ns1__EndUserDeviceTypeT__CM = 0, ns1__EndUserDeviceTypeT__eMTA = 1};
#endif

#ifndef SOAP_TYPE_ns1__UserAccessTypeT
#define SOAP_TYPE_ns1__UserAccessTypeT (131)
/* ns1:UserAccessTypeT */
enum ns1__UserAccessTypeT {ns1__UserAccessTypeT__None = 0, ns1__UserAccessTypeT__Read = 1, ns1__UserAccessTypeT__Write = 2, ns1__UserAccessTypeT__Execute = 3};
#endif

#ifndef SOAP_TYPE_ns1__ApplicationDomainTypeT
#define SOAP_TYPE_ns1__ApplicationDomainTypeT (132)
/* ns1:ApplicationDomainTypeT */
enum ns1__ApplicationDomainTypeT {ns1__ApplicationDomainTypeT__Alarm = 0, ns1__ApplicationDomainTypeT__CSR_x0020Portal = 1, ns1__ApplicationDomainTypeT__System_x0020Administration = 2, ns1__ApplicationDomainTypeT__User_x0020Administration = 3};
#endif

#ifndef SOAP_TYPE_ns1__EventTypeT
#define SOAP_TYPE_ns1__EventTypeT (133)
/* ns1:EventTypeT */
enum ns1__EventTypeT {ns1__EventTypeT__Add = 0, ns1__EventTypeT__Delete = 1, ns1__EventTypeT__Update = 2};
#endif

#ifndef SOAP_TYPE_ns1__EventCategoryT
#define SOAP_TYPE_ns1__EventCategoryT (134)
/* ns1:EventCategoryT */
enum ns1__EventCategoryT {ns1__EventCategoryT__Resource = 0, ns1__EventCategoryT__Configuration = 1};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare */

#endif



#ifndef SOAP_TYPE_ns1__SnmpV2CAttributesT
#define SOAP_TYPE_ns1__SnmpV2CAttributesT (10)
/* ns1:SnmpV2CAttributesT */
class SOAP_CMAC ns1__SnmpV2CAttributesT
{
public:
	std::string readCommnunity;	/* required element of type xsd:string */
	std::string *writeCommnunity;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__SnmpV2CAttributesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SnmpV2CAttributesT() : writeCommnunity(NULL), soap(NULL) { }
	virtual ~ns1__SnmpV2CAttributesT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GenericCountsT
#define SOAP_TYPE_ns1__GenericCountsT (11)
/* ns1:GenericCountsT */
class SOAP_CMAC ns1__GenericCountsT
{
public:
	short totalCm;	/* required element of type xsd:short */
	short onlineCm;	/* required element of type xsd:short */
	short totalMta;	/* required element of type xsd:short */
	short availableMta;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__GenericCountsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GenericCountsT() : soap(NULL) { }
	virtual ~ns1__GenericCountsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InputTimeT
#define SOAP_TYPE_ns1__InputTimeT (12)
/* ns1:InputTimeT */
class SOAP_CMAC ns1__InputTimeT
{
public:
	short year;	/* required element of type xsd:short */
	short monthOfYear;	/* required element of type xsd:short */
	short dayOfMonth;	/* required element of type xsd:short */
	short hourOfDay;	/* required element of type xsd:short */
	short minuteOfHour;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__InputTimeT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InputTimeT() : soap(NULL) { }
	virtual ~ns1__InputTimeT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ResultBatchT
#define SOAP_TYPE_ns1__ResultBatchT (13)
/* ns1:ResultBatchT */
class SOAP_CMAC ns1__ResultBatchT
{
public:
	short fromIndex;	/* required element of type xsd:short */
	short toIndex;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__ResultBatchT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ResultBatchT() : soap(NULL) { }
	virtual ~ns1__ResultBatchT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TopoHierarchyKeyT
#define SOAP_TYPE_ns1__TopoHierarchyKeyT (14)
/* ns1:TopoHierarchyKeyT */
class SOAP_CMAC ns1__TopoHierarchyKeyT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string marketId;	/* required element of type xsd:integer */
	std::string bladeId;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__TopoHierarchyKeyT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TopoHierarchyKeyT() : soap(NULL) { }
	virtual ~ns1__TopoHierarchyKeyT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LocalSystemT
#define SOAP_TYPE_ns1__LocalSystemT (15)
/* ns1:LocalSystemT */
class SOAP_CMAC ns1__LocalSystemT
{
public:
	enum ns1__SystemTypeT systemType;	/* required element of type ns1:SystemTypeT */
	std::string systemName;	/* required element of type xsd:string */
	std::string parentHost;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__LocalSystemT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LocalSystemT() : soap(NULL) { }
	virtual ~ns1__LocalSystemT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RegionT
#define SOAP_TYPE_ns1__RegionT (16)
/* ns1:RegionT */
class SOAP_CMAC ns1__RegionT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__RegionT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RegionT() : soap(NULL) { }
	virtual ~ns1__RegionT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MarketT
#define SOAP_TYPE_ns1__MarketT (17)
/* ns1:MarketT */
class SOAP_CMAC ns1__MarketT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string marketId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__MarketT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MarketT() : soap(NULL) { }
	virtual ~ns1__MarketT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BladeT
#define SOAP_TYPE_ns1__BladeT (18)
/* ns1:BladeT */
class SOAP_CMAC ns1__BladeT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string marketId;	/* required element of type xsd:integer */
	std::string bladeId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__BladeT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BladeT() : soap(NULL) { }
	virtual ~ns1__BladeT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmsT
#define SOAP_TYPE_ns1__CmsT (19)
/* ns1:CmsT */
class SOAP_CMAC ns1__CmsT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string cmsResId;	/* required element of type xsd:integer */
	std::string cmsName;	/* required element of type xsd:string */
	std::string cmsType;	/* required element of type xsd:string */
	std::string cmsSubType;	/* required element of type xsd:string */
	std::string cmsHost;	/* required element of type xsd:string */
	std::string loginName;	/* required element of type xsd:string */
	std::string loginPassword;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__CmsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmsT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__CmsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsT
#define SOAP_TYPE_ns1__CmtsT (20)
/* ns1:CmtsT */
class SOAP_CMAC ns1__CmtsT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	std::string cmtsHost;	/* required element of type xsd:string */
	enum ns1__SnmpVersionT cmtsSnmpVersion;	/* required element of type ns1:SnmpVersionT */
	enum ns1__SnmpVersionT cmSnmpVersion;	/* required element of type ns1:SnmpVersionT */
	enum ns1__SnmpVersionT mtaSnmpVersion;	/* required element of type ns1:SnmpVersionT */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	ns1__GenericCountsT *counts;	/* optional element of type ns1:GenericCountsT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__CmtsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsT() : topologyKey(NULL), counts(NULL), soap(NULL) { }
	virtual ~ns1__CmtsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ChannelT
#define SOAP_TYPE_ns1__ChannelT (21)
/* ns1:ChannelT */
class SOAP_CMAC ns1__ChannelT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string channelResId;	/* required element of type xsd:integer */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string channelName;	/* required element of type xsd:string */
	enum ns1__ChannelTypeT channelType;	/* required element of type ns1:ChannelTypeT */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	ns1__GenericCountsT *counts;	/* optional element of type ns1:GenericCountsT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__ChannelT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ChannelT() : topologyKey(NULL), counts(NULL), soap(NULL) { }
	virtual ~ns1__ChannelT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcT
#define SOAP_TYPE_ns1__HfcT (22)
/* ns1:HfcT */
class SOAP_CMAC ns1__HfcT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string hfcName;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	ns1__GenericCountsT *counts;	/* optional element of type ns1:GenericCountsT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__HfcT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcT() : topologyKey(NULL), counts(NULL), soap(NULL) { }
	virtual ~ns1__HfcT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CableModemT
#define SOAP_TYPE_ns1__CableModemT (23)
/* ns1:CableModemT */
class SOAP_CMAC ns1__CableModemT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string cmResId;	/* required element of type xsd:integer */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string upChannelResId;	/* required element of type xsd:integer */
	std::string downChannelResId;	/* required element of type xsd:integer */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string macAddress;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	std::string cmStatus;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	std::string fqdn;	/* required element of type xsd:string */
	std::string cmIndex;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__CableModemT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CableModemT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__CableModemT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EmtaT
#define SOAP_TYPE_ns1__EmtaT (24)
/* ns1:EmtaT */
class SOAP_CMAC ns1__EmtaT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string emtaResId;	/* required element of type xsd:integer */
	std::string *cmResId;	/* optional element of type xsd:integer */
	std::string macAddress;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	std::string host;	/* required element of type xsd:string */
	std::string fqdn;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__EmtaT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EmtaT() : topologyKey(NULL), cmResId(NULL), soap(NULL) { }
	virtual ~ns1__EmtaT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EmtaSecondaryT
#define SOAP_TYPE_ns1__EmtaSecondaryT (25)
/* ns1:EmtaSecondaryT */
class SOAP_CMAC ns1__EmtaSecondaryT
{
public:
	std::string phone1;	/* required element of type xsd:string */
	std::string phone2;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__EmtaSecondaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EmtaSecondaryT() : soap(NULL) { }
	virtual ~ns1__EmtaSecondaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AbstractAlarmT
#define SOAP_TYPE_ns1__AbstractAlarmT (26)
/* ns1:AbstractAlarmT */
class SOAP_CMAC ns1__AbstractAlarmT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string alarmId;	/* required element of type xsd:integer */
	std::string resourceId;	/* required element of type xsd:integer */
	std::string resourceName;	/* required element of type xsd:string */
	std::string alarmTime;	/* required element of type xsd:integer */
	std::string alarmTimeUSec;	/* required element of type xsd:integer */
	short soakDuration;	/* required element of type xsd:short */
	std::string alarmState;	/* required element of type xsd:string */
	std::string alarmType;	/* required element of type xsd:string */
	std::string alarmSubType;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__AbstractAlarmT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AbstractAlarmT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__AbstractAlarmT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CurrentAlarmT
#define SOAP_TYPE_ns1__CurrentAlarmT (27)
/* ns1:CurrentAlarmT */
class SOAP_CMAC ns1__CurrentAlarmT
{
public:
	ns1__AbstractAlarmT *abstractAlarm;	/* required element of type ns1:AbstractAlarmT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__CurrentAlarmT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CurrentAlarmT() : abstractAlarm(NULL), soap(NULL) { }
	virtual ~ns1__CurrentAlarmT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CurrentAlarmDetailsT
#define SOAP_TYPE_ns1__CurrentAlarmDetailsT (28)
/* ns1:CurrentAlarmDetailsT */
class SOAP_CMAC ns1__CurrentAlarmDetailsT
{
public:
	ns1__CurrentAlarmT *currentAlarm;	/* required element of type ns1:CurrentAlarmT */
	std::string alarmDetails;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__CurrentAlarmDetailsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CurrentAlarmDetailsT() : currentAlarm(NULL), soap(NULL) { }
	virtual ~ns1__CurrentAlarmDetailsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HistoricalAlarmT
#define SOAP_TYPE_ns1__HistoricalAlarmT (29)
/* ns1:HistoricalAlarmT */
class SOAP_CMAC ns1__HistoricalAlarmT
{
public:
	ns1__AbstractAlarmT *abstractAlarm;	/* required element of type ns1:AbstractAlarmT */
	std::string clearedUser;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__HistoricalAlarmT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HistoricalAlarmT() : abstractAlarm(NULL), soap(NULL) { }
	virtual ~ns1__HistoricalAlarmT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HistoricalAlarmDetailsT
#define SOAP_TYPE_ns1__HistoricalAlarmDetailsT (30)
/* ns1:HistoricalAlarmDetailsT */
class SOAP_CMAC ns1__HistoricalAlarmDetailsT
{
public:
	ns1__HistoricalAlarmT *historicalAlarm;	/* required element of type ns1:HistoricalAlarmT */
	std::string alarmDetails;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__HistoricalAlarmDetailsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HistoricalAlarmDetailsT() : historicalAlarm(NULL), soap(NULL) { }
	virtual ~ns1__HistoricalAlarmDetailsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AlarmHistoryT
#define SOAP_TYPE_ns1__AlarmHistoryT (31)
/* ns1:AlarmHistoryT */
class SOAP_CMAC ns1__AlarmHistoryT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string alarmId;	/* required element of type xsd:integer */
	std::string timeStamp;	/* required element of type xsd:string */
	std::string alarmState;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__AlarmHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AlarmHistoryT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__AlarmHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MappedEuDevicesT
#define SOAP_TYPE_ns1__MappedEuDevicesT (45)
/* ns1:MappedEuDevicesT */
class SOAP_CMAC ns1__MappedEuDevicesT
{
public:
	ns1__CableModemT *cm;	/* optional element of type ns1:CableModemT */
	ns1__EmtaT *mta;	/* optional element of type ns1:EmtaT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__MappedEuDevicesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MappedEuDevicesT() : cm(NULL), mta(NULL), soap(NULL) { }
	virtual ~ns1__MappedEuDevicesT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ScrollPageT
#define SOAP_TYPE_ns1__ScrollPageT (46)
/* ns1:ScrollPageT */
class SOAP_CMAC ns1__ScrollPageT
{
public:
	ns1__ResultBatchT *batch;	/* required element of type ns1:ResultBatchT */
	std::string start;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__ScrollPageT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ScrollPageT() : batch(NULL), soap(NULL) { }
	virtual ~ns1__ScrollPageT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__QueryStateT
#define SOAP_TYPE_ns1__QueryStateT (48)
/* ns1:QueryStateT */
class SOAP_CMAC ns1__QueryStateT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	class ArrayOfScrollPageT *pages;	/* required element of type ArrayOfScrollPageT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__QueryStateT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__QueryStateT() : topologyKey(NULL), pages(NULL), soap(NULL) { }
	virtual ~ns1__QueryStateT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GenericCountsHistoryT
#define SOAP_TYPE_ns1__GenericCountsHistoryT (50)
/* ns1:GenericCountsHistoryT */
class SOAP_CMAC ns1__GenericCountsHistoryT
{
public:
	ns1__GenericCountsT *counts;	/* required element of type ns1:GenericCountsT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__GenericCountsHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GenericCountsHistoryT() : counts(NULL), soap(NULL) { }
	virtual ~ns1__GenericCountsHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusT
#define SOAP_TYPE_ns1__CmStatusT (52)
/* ns1:CmStatusT */
class SOAP_CMAC ns1__CmStatusT
{
public:
	short docsisState;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__CmStatusT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusT() : soap(NULL) { }
	virtual ~ns1__CmStatusT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusHistoryT
#define SOAP_TYPE_ns1__CmStatusHistoryT (53)
/* ns1:CmStatusHistoryT */
class SOAP_CMAC ns1__CmStatusHistoryT
{
public:
	ns1__CmStatusT *cmStatus;	/* required element of type ns1:CmStatusT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__CmStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusHistoryT() : cmStatus(NULL), soap(NULL) { }
	virtual ~ns1__CmStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaAvailabilityT
#define SOAP_TYPE_ns1__MtaAvailabilityT (55)
/* ns1:MtaAvailabilityT */
class SOAP_CMAC ns1__MtaAvailabilityT
{
public:
	short available;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__MtaAvailabilityT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaAvailabilityT() : soap(NULL) { }
	virtual ~ns1__MtaAvailabilityT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaAvailabilityHistoryT
#define SOAP_TYPE_ns1__MtaAvailabilityHistoryT (56)
/* ns1:MtaAvailabilityHistoryT */
class SOAP_CMAC ns1__MtaAvailabilityHistoryT
{
public:
	ns1__MtaAvailabilityT *available;	/* required element of type ns1:MtaAvailabilityT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__MtaAvailabilityHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaAvailabilityHistoryT() : available(NULL), soap(NULL) { }
	virtual ~ns1__MtaAvailabilityHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaProvStatusT
#define SOAP_TYPE_ns1__MtaProvStatusT (58)
/* ns1:MtaProvStatusT */
class SOAP_CMAC ns1__MtaProvStatusT
{
public:
	short provState;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__MtaProvStatusT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaProvStatusT() : soap(NULL) { }
	virtual ~ns1__MtaProvStatusT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaProvStatusHistoryT
#define SOAP_TYPE_ns1__MtaProvStatusHistoryT (59)
/* ns1:MtaProvStatusHistoryT */
class SOAP_CMAC ns1__MtaProvStatusHistoryT
{
public:
	ns1__MtaProvStatusT *provStatus;	/* required element of type ns1:MtaProvStatusT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__MtaProvStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaProvStatusHistoryT() : provStatus(NULL), soap(NULL) { }
	virtual ~ns1__MtaProvStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaPingStatusT
#define SOAP_TYPE_ns1__MtaPingStatusT (61)
/* ns1:MtaPingStatusT */
class SOAP_CMAC ns1__MtaPingStatusT
{
public:
	short pingState;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__MtaPingStatusT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaPingStatusT() : soap(NULL) { }
	virtual ~ns1__MtaPingStatusT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaPingStatusHistoryT
#define SOAP_TYPE_ns1__MtaPingStatusHistoryT (62)
/* ns1:MtaPingStatusHistoryT */
class SOAP_CMAC ns1__MtaPingStatusHistoryT
{
public:
	ns1__MtaPingStatusT *pingStatus;	/* required element of type ns1:MtaPingStatusT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns1__MtaPingStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaPingStatusHistoryT() : pingStatus(NULL), soap(NULL) { }
	virtual ~ns1__MtaPingStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmPerformanceT
#define SOAP_TYPE_ns1__CmPerformanceT (64)
/* ns1:CmPerformanceT */
class SOAP_CMAC ns1__CmPerformanceT
{
public:
	short downstreamSNR;	/* required element of type xsd:short */
	short downstreamPower;	/* required element of type xsd:short */
	short upstreamPower;	/* required element of type xsd:short */
	short t1Timeouts;	/* required element of type xsd:short */
	short t2Timeouts;	/* required element of type xsd:short */
	short t3Timeouts;	/* required element of type xsd:short */
	short t4Timeouts;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__CmPerformanceT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmPerformanceT() : soap(NULL) { }
	virtual ~ns1__CmPerformanceT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmPerformanceHistoryT
#define SOAP_TYPE_ns1__CmPerformanceHistoryT (65)
/* ns1:CmPerformanceHistoryT */
class SOAP_CMAC ns1__CmPerformanceHistoryT
{
public:
	ns1__CmPerformanceT *cmPerformance;	/* required element of type ns1:CmPerformanceT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns1__CmPerformanceHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmPerformanceHistoryT() : cmPerformance(NULL), soap(NULL) { }
	virtual ~ns1__CmPerformanceHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmCurrentPerformanceT
#define SOAP_TYPE_ns1__CmCurrentPerformanceT (66)
/* ns1:CmCurrentPerformanceT */
class SOAP_CMAC ns1__CmCurrentPerformanceT
{
public:
	ns1__CmPerformanceT *cmPerformance;	/* required element of type ns1:CmPerformanceT */
	std::string recordedTime;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns1__CmCurrentPerformanceT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmCurrentPerformanceT() : cmPerformance(NULL), soap(NULL) { }
	virtual ~ns1__CmCurrentPerformanceT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTECustomerT
#define SOAP_TYPE_ns1__CTECustomerT (68)
/* ns1:CTECustomerT */
class SOAP_CMAC ns1__CTECustomerT
{
public:
	std::string *accountNumber;	/* optional element of type xsd:string */
	short *accountActive;	/* optional element of type xsd:short */
	std::string firstName;	/* required element of type xsd:string */
	std::string lastName;	/* required element of type xsd:string */
	std::string street1;	/* required element of type xsd:string */
	std::string *street2;	/* optional element of type xsd:string */
	std::string city;	/* required element of type xsd:string */
	std::string state;	/* required element of type xsd:string */
	std::string zip;	/* required element of type xsd:string */
	std::string phone1;	/* required element of type xsd:string */
	std::string *phone2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__CTECustomerT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTECustomerT() : accountNumber(NULL), accountActive(NULL), street2(NULL), phone2(NULL), soap(NULL) { }
	virtual ~ns1__CTECustomerT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEAbstractMacT
#define SOAP_TYPE_ns1__CTEAbstractMacT (70)
/* ns1:CTEAbstractMacT */
class SOAP_CMAC ns1__CTEAbstractMacT
{
public:
	std::string mac;	/* required element of type xsd:string */
	std::string *fqdn;	/* optional element of type xsd:string */
	std::string *host;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns1__CTEAbstractMacT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEAbstractMacT() : fqdn(NULL), host(NULL), soap(NULL) { }
	virtual ~ns1__CTEAbstractMacT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEAbstractNameT
#define SOAP_TYPE_ns1__CTEAbstractNameT (71)
/* ns1:CTEAbstractNameT */
class SOAP_CMAC ns1__CTEAbstractNameT
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string *fqdn;	/* optional element of type xsd:string */
	std::string *host;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__CTEAbstractNameT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEAbstractNameT() : fqdn(NULL), host(NULL), soap(NULL) { }
	virtual ~ns1__CTEAbstractNameT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEDataT
#define SOAP_TYPE_ns1__CTEDataT (72)
/* ns1:CTEDataT */
class SOAP_CMAC ns1__CTEDataT
{
public:
	ns1__CTECustomerT *customer;	/* required element of type ns1:CTECustomerT */
	ns1__CTEAbstractMacT *cm;	/* optional element of type ns1:CTEAbstractMacT */
	ns1__CTEAbstractMacT *mta;	/* optional element of type ns1:CTEAbstractMacT */
	ns1__CTEAbstractNameT *cmts;	/* optional element of type ns1:CTEAbstractNameT */
	ns1__CTEAbstractNameT *cms;	/* optional element of type ns1:CTEAbstractNameT */
	std::string *hfcName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns1__CTEDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEDataT() : customer(NULL), cm(NULL), mta(NULL), cmts(NULL), cms(NULL), hfcName(NULL), soap(NULL) { }
	virtual ~ns1__CTEDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEQueryInputT
#define SOAP_TYPE_ns1__CTEQueryInputT (74)
/* ns1:CTEQueryInputT */
class SOAP_CMAC ns1__CTEQueryInputT
{
public:
	std::string *accountNumber;	/* optional element of type xsd:string */
	std::string *firstName;	/* optional element of type xsd:string */
	std::string *lastName;	/* optional element of type xsd:string */
	std::string *primaryPhone;	/* optional element of type xsd:string */
	std::string *cmMac;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns1__CTEQueryInputT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEQueryInputT() : accountNumber(NULL), firstName(NULL), lastName(NULL), primaryPhone(NULL), cmMac(NULL), soap(NULL) { }
	virtual ~ns1__CTEQueryInputT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CMSLineT
#define SOAP_TYPE_ns1__CMSLineT (76)
/* ns1:CMSLineT */
class SOAP_CMAC ns1__CMSLineT
{
public:
	std::string number;	/* required element of type xsd:string */
	std::string status;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns1__CMSLineT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CMSLineT() : soap(NULL) { }
	virtual ~ns1__CMSLineT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CMSResultT
#define SOAP_TYPE_ns1__CMSResultT (78)
/* ns1:CMSResultT */
class SOAP_CMAC ns1__CMSResultT
{
public:
	ns1__CMSLineT *line1;	/* required element of type ns1:CMSLineT */
	ns1__CMSLineT *line2;	/* optional element of type ns1:CMSLineT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns1__CMSResultT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CMSResultT() : line1(NULL), line2(NULL), soap(NULL) { }
	virtual ~ns1__CMSResultT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UserAccessT
#define SOAP_TYPE_ns1__UserAccessT (79)
/* ns1:UserAccessT */
class SOAP_CMAC ns1__UserAccessT
{
public:
	enum ns1__UserAccessTypeT type;	/* required element of type ns1:UserAccessTypeT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns1__UserAccessT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UserAccessT() : soap(NULL) { }
	virtual ~ns1__UserAccessT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ApplicationDomainT
#define SOAP_TYPE_ns1__ApplicationDomainT (81)
/* ns1:ApplicationDomainT */
class SOAP_CMAC ns1__ApplicationDomainT
{
public:
	enum ns1__ApplicationDomainTypeT type;	/* required element of type ns1:ApplicationDomainTypeT */
	class ArrayOfUserAccessT *accessRights;	/* optional element of type ArrayOfUserAccessT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns1__ApplicationDomainT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ApplicationDomainT() : accessRights(NULL), soap(NULL) { }
	virtual ~ns1__ApplicationDomainT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RoleT
#define SOAP_TYPE_ns1__RoleT (83)
/* ns1:RoleT */
class SOAP_CMAC ns1__RoleT
{
public:
	std::string roleName;	/* required element of type xsd:string */
	class ArrayOfApplicationDomainT *domains;	/* optional element of type ArrayOfApplicationDomainT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns1__RoleT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RoleT() : domains(NULL), soap(NULL) { }
	virtual ~ns1__RoleT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UserT
#define SOAP_TYPE_ns1__UserT (85)
/* ns1:UserT */
class SOAP_CMAC ns1__UserT
{
public:
	std::string userId;	/* required element of type xsd:string */
	std::string firstName;	/* required element of type xsd:string */
	std::string lastName;	/* required element of type xsd:string */
	std::string *middleInitial;	/* optional element of type xsd:string */
	std::string location;	/* required element of type xsd:string */
	std::string loginName;	/* required element of type xsd:string */
	std::string *loginPassword;	/* optional element of type xsd:string */
	short *isActive;	/* optional element of type xsd:short */
	std::string *roleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns1__UserT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UserT() : middleInitial(NULL), loginPassword(NULL), isActive(NULL), roleName(NULL), soap(NULL) { }
	virtual ~ns1__UserT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PollingIntervalsT
#define SOAP_TYPE_ns1__PollingIntervalsT (87)
/* ns1:PollingIntervalsT */
class SOAP_CMAC ns1__PollingIntervalsT
{
public:
	std::string cmtsPollInterval;	/* required element of type xsd:string */
	std::string cmPollInterval;	/* required element of type xsd:string */
	std::string mtaPollInterval;	/* required element of type xsd:string */
	std::string mtaPingInterval;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ns1__PollingIntervalsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PollingIntervalsT() : soap(NULL) { }
	virtual ~ns1__PollingIntervalsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AlarmBasedStatusThresholdT
#define SOAP_TYPE_ns1__AlarmBasedStatusThresholdT (88)
/* ns1:AlarmBasedStatusThresholdT */
class SOAP_CMAC ns1__AlarmBasedStatusThresholdT
{
public:
	enum ns1__StatusColorT color;	/* required element of type ns1:StatusColorT */
	std::string alarmType;	/* required element of type xsd:string */
	std::string alarmState;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ns1__AlarmBasedStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AlarmBasedStatusThresholdT() : soap(NULL) { }
	virtual ~ns1__AlarmBasedStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AggregateStatusThresholdT
#define SOAP_TYPE_ns1__AggregateStatusThresholdT (90)
/* ns1:AggregateStatusThresholdT */
class SOAP_CMAC ns1__AggregateStatusThresholdT
{
public:
	enum ns1__StatusColorT color;	/* required element of type ns1:StatusColorT */
	enum ns1__StatusColorT childColor;	/* required element of type ns1:StatusColorT */
	std::string thresholdPercent;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ns1__AggregateStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AggregateStatusThresholdT() : soap(NULL) { }
	virtual ~ns1__AggregateStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaStatusThresholdT
#define SOAP_TYPE_ns1__MtaStatusThresholdT (92)
/* ns1:MtaStatusThresholdT */
class SOAP_CMAC ns1__MtaStatusThresholdT
{
public:
	class ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns1__MtaStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaStatusThresholdT() : alarmThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__MtaStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcStatusThresholdT
#define SOAP_TYPE_ns1__HfcStatusThresholdT (93)
/* ns1:HfcStatusThresholdT */
class SOAP_CMAC ns1__HfcStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	class ArrayOfAggregateStatusThresholdT *aggThreshArray;	/* required element of type ArrayOfAggregateStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns1__HfcStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcStatusThresholdT() : alarmThreshArray(NULL), aggThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__HfcStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ChannelStatusThresholdT
#define SOAP_TYPE_ns1__ChannelStatusThresholdT (94)
/* ns1:ChannelStatusThresholdT */
class SOAP_CMAC ns1__ChannelStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	ArrayOfAggregateStatusThresholdT *aggThreshArray;	/* required element of type ArrayOfAggregateStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns1__ChannelStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ChannelStatusThresholdT() : alarmThreshArray(NULL), aggThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__ChannelStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsStatusThresholdT
#define SOAP_TYPE_ns1__CmtsStatusThresholdT (95)
/* ns1:CmtsStatusThresholdT */
class SOAP_CMAC ns1__CmtsStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	ArrayOfAggregateStatusThresholdT *aggThreshArray;	/* required element of type ArrayOfAggregateStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns1__CmtsStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsStatusThresholdT() : alarmThreshArray(NULL), aggThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__CmtsStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmsStatusThresholdT
#define SOAP_TYPE_ns1__CmsStatusThresholdT (96)
/* ns1:CmsStatusThresholdT */
class SOAP_CMAC ns1__CmsStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns1__CmsStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmsStatusThresholdT() : alarmThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__CmsStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SoakWindowT
#define SOAP_TYPE_ns1__SoakWindowT (97)
/* ns1:SoakWindowT */
class SOAP_CMAC ns1__SoakWindowT
{
public:
	std::string soakWindow_USCORE1_USCOREStartTime;	/* required element of type xsd:string */
	std::string soakWindow_USCORE1_USCOREDuration;	/* required element of type xsd:string */
	std::string soakWindow_USCORE2_USCOREStartTime;	/* required element of type xsd:string */
	std::string soakWindow_USCORE2_USCOREDuration;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns1__SoakWindowT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SoakWindowT() : soap(NULL) { }
	virtual ~ns1__SoakWindowT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AggregateCmOfflineTresholdT
#define SOAP_TYPE_ns1__AggregateCmOfflineTresholdT (98)
/* ns1:AggregateCmOfflineTresholdT */
class SOAP_CMAC ns1__AggregateCmOfflineTresholdT
{
public:
	std::string percentCmOffline_USCORE1;	/* required element of type xsd:string */
	std::string maxCm_USCORE1;	/* required element of type xsd:string */
	std::string percentCmOffline_USCORE2;	/* required element of type xsd:string */
	std::string maxCm_USCORE2;	/* required element of type xsd:string */
	std::string detectionWindow;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns1__AggregateCmOfflineTresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AggregateCmOfflineTresholdT() : soap(NULL) { }
	virtual ~ns1__AggregateCmOfflineTresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AggregateMtaTresholdT
#define SOAP_TYPE_ns1__AggregateMtaTresholdT (99)
/* ns1:AggregateMtaTresholdT */
class SOAP_CMAC ns1__AggregateMtaTresholdT
{
public:
	std::string mtaThresholdCount;	/* required element of type xsd:string */
	std::string detectionWindow;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns1__AggregateMtaTresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AggregateMtaTresholdT() : soap(NULL) { }
	virtual ~ns1__AggregateMtaTresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcPowerTresholdT
#define SOAP_TYPE_ns1__HfcPowerTresholdT (100)
/* ns1:HfcPowerTresholdT */
class SOAP_CMAC ns1__HfcPowerTresholdT
{
public:
	std::string thresholdCount;	/* required element of type xsd:string */
	std::string detectionWindow;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns1__HfcPowerTresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcPowerTresholdT() : soap(NULL) { }
	virtual ~ns1__HfcPowerTresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcAlarmConfigT
#define SOAP_TYPE_ns1__HfcAlarmConfigT (101)
/* ns1:HfcAlarmConfigT */
class SOAP_CMAC ns1__HfcAlarmConfigT
{
public:
	ns1__AggregateCmOfflineTresholdT *cmThresold;	/* required element of type ns1:AggregateCmOfflineTresholdT */
	ns1__SoakWindowT *cmSoakWindow;	/* required element of type ns1:SoakWindowT */
	ns1__AggregateMtaTresholdT *mtaThresold;	/* required element of type ns1:AggregateMtaTresholdT */
	ns1__SoakWindowT *mtaSoakWindow;	/* required element of type ns1:SoakWindowT */
	ns1__HfcPowerTresholdT *powerThresold;	/* required element of type ns1:HfcPowerTresholdT */
	ns1__SoakWindowT *powerSoakWindow;	/* required element of type ns1:SoakWindowT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns1__HfcAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcAlarmConfigT() : cmThresold(NULL), cmSoakWindow(NULL), mtaThresold(NULL), mtaSoakWindow(NULL), powerThresold(NULL), powerSoakWindow(NULL), soap(NULL) { }
	virtual ~ns1__HfcAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AlarmTypeConfigT
#define SOAP_TYPE_ns1__AlarmTypeConfigT (102)
/* ns1:AlarmTypeConfigT */
class SOAP_CMAC ns1__AlarmTypeConfigT
{
public:
	std::string alarmType;	/* required element of type xsd:string */
	ns1__SoakWindowT *soakWindow;	/* required element of type ns1:SoakWindowT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns1__AlarmTypeConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AlarmTypeConfigT() : soakWindow(NULL), soap(NULL) { }
	virtual ~ns1__AlarmTypeConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaAlarmConfigT
#define SOAP_TYPE_ns1__MtaAlarmConfigT (104)
/* ns1:MtaAlarmConfigT */
class SOAP_CMAC ns1__MtaAlarmConfigT
{
public:
	class ArrayOfAlarmTypeConfigT *alarmTypes;	/* required element of type ArrayOfAlarmTypeConfigT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns1__MtaAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaAlarmConfigT() : alarmTypes(NULL), soap(NULL) { }
	virtual ~ns1__MtaAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsAlarmConfigT
#define SOAP_TYPE_ns1__CmtsAlarmConfigT (105)
/* ns1:CmtsAlarmConfigT */
class SOAP_CMAC ns1__CmtsAlarmConfigT
{
public:
	ns1__AlarmTypeConfigT *cmtsDown;	/* required element of type ns1:AlarmTypeConfigT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns1__CmtsAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsAlarmConfigT() : cmtsDown(NULL), soap(NULL) { }
	virtual ~ns1__CmtsAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmsAlarmConfigT
#define SOAP_TYPE_ns1__CmsAlarmConfigT (106)
/* ns1:CmsAlarmConfigT */
class SOAP_CMAC ns1__CmsAlarmConfigT
{
public:
	ns1__AlarmTypeConfigT *cmsLossOfComm;	/* required element of type ns1:AlarmTypeConfigT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns1__CmsAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmsAlarmConfigT() : cmsLossOfComm(NULL), soap(NULL) { }
	virtual ~ns1__CmsAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmPerformanceConfigT
#define SOAP_TYPE_ns1__CmPerformanceConfigT (107)
/* ns1:CmPerformanceConfigT */
class SOAP_CMAC ns1__CmPerformanceConfigT
{
public:
	std::string downstreamSnrLower;	/* required element of type xsd:string */
	std::string downstreamPowerLower;	/* required element of type xsd:string */
	std::string downstreamPowerUpper;	/* required element of type xsd:string */
	std::string upstreamPowerLower;	/* required element of type xsd:string */
	std::string upstreamPowerUpper;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns1__CmPerformanceConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmPerformanceConfigT() : soap(NULL) { }
	virtual ~ns1__CmPerformanceConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ConfigDownloadT
#define SOAP_TYPE_ns1__ConfigDownloadT (108)
/* ns1:ConfigDownloadT */
class SOAP_CMAC ns1__ConfigDownloadT
{
public:
	ns1__CmPerformanceConfigT *cmPerfCfg;	/* optional element of type ns1:CmPerformanceConfigT */
	ns1__CmsAlarmConfigT *cmsAlarmCfg;	/* optional element of type ns1:CmsAlarmConfigT */
	ns1__CmtsAlarmConfigT *cmtsAlarmCfg;	/* optional element of type ns1:CmtsAlarmConfigT */
	ns1__MtaAlarmConfigT *mtaAlarmCfg;	/* optional element of type ns1:MtaAlarmConfigT */
	ns1__HfcAlarmConfigT *hfcAlarmCfg;	/* optional element of type ns1:HfcAlarmConfigT */
	ns1__PollingIntervalsT *pollingIntervals;	/* optional element of type ns1:PollingIntervalsT */
	ArrayOfUserAccessT *userAccessRights;	/* optional element of type ArrayOfUserAccessT */
	ArrayOfApplicationDomainT *applicationDomains;	/* optional element of type ArrayOfApplicationDomainT */
	class ArrayOfRoleT *roles;	/* optional element of type ArrayOfRoleT */
	class ArrayOfUserT *users;	/* optional element of type ArrayOfUserT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns1__ConfigDownloadT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ConfigDownloadT() : cmPerfCfg(NULL), cmsAlarmCfg(NULL), cmtsAlarmCfg(NULL), mtaAlarmCfg(NULL), hfcAlarmCfg(NULL), pollingIntervals(NULL), userAccessRights(NULL), applicationDomains(NULL), roles(NULL), users(NULL), soap(NULL) { }
	virtual ~ns1__ConfigDownloadT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsCmDataT
#define SOAP_TYPE_ns1__CmtsCmDataT (109)
/* ns1:CmtsCmDataT */
class SOAP_CMAC ns1__CmtsCmDataT
{
public:
	std::string cmIpAddress;	/* required element of type xsd:string */
	std::string cmMac;	/* required element of type xsd:string */
	std::string upstreamChannelIndex;	/* required element of type xsd:string */
	std::string downstreamChannelIndex;	/* required element of type xsd:string */
	std::string cmIndex;	/* required element of type xsd:string */
	std::string cmStatus;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns1__CmtsCmDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsCmDataT() : soap(NULL) { }
	virtual ~ns1__CmtsCmDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmDataT
#define SOAP_TYPE_ns1__CmDataT (110)
/* ns1:CmDataT */
class SOAP_CMAC ns1__CmDataT
{
public:
	std::string mac;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	std::string cmIndex;	/* required element of type xsd:string */
	std::string downstreamSNR;	/* required element of type xsd:string */
	std::string downstreamPower;	/* required element of type xsd:string */
	std::string upstreamPower;	/* required element of type xsd:string */
	std::string t1Count;	/* required element of type xsd:string */
	std::string t2Count;	/* required element of type xsd:string */
	std::string t3Count;	/* required element of type xsd:string */
	std::string t4Count;	/* required element of type xsd:string */
	std::string *field1;	/* optional element of type xsd:string */
	std::string *field2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns1__CmDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmDataT() : field1(NULL), field2(NULL), soap(NULL) { }
	virtual ~ns1__CmDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaDataT
#define SOAP_TYPE_ns1__MtaDataT (111)
/* ns1:MtaDataT */
class SOAP_CMAC ns1__MtaDataT
{
public:
	std::string provStatus;	/* required element of type xsd:string */
	std::string provCounter;	/* required element of type xsd:string */
	std::string *pingStatus;	/* optional element of type xsd:string */
	std::string *batteryStatus1;	/* optional element of type xsd:string */
	std::string *batteryStatus2;	/* optional element of type xsd:string */
	std::string *field1;	/* optional element of type xsd:string */
	std::string *field2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns1__MtaDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaDataT() : pingStatus(NULL), batteryStatus1(NULL), batteryStatus2(NULL), field1(NULL), field2(NULL), soap(NULL) { }
	virtual ~ns1__MtaDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StatusSummaryT
#define SOAP_TYPE_ns1__StatusSummaryT (112)
/* ns1:StatusSummaryT */
class SOAP_CMAC ns1__StatusSummaryT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string resId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string sumRedStatusTime;	/* required element of type xsd:integer */
	std::string sumGreenStatusTime;	/* required element of type xsd:integer */
	short sumStateChanges;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_ns1__StatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StatusSummaryT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__StatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcStatusSummaryT
#define SOAP_TYPE_ns1__HfcStatusSummaryT (113)
/* ns1:HfcStatusSummaryT */
class SOAP_CMAC ns1__HfcStatusSummaryT
{
public:
	ns1__StatusSummaryT *statusSummary;	/* required element of type ns1:StatusSummaryT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE_ns1__HfcStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcStatusSummaryT() : statusSummary(NULL), soap(NULL) { }
	virtual ~ns1__HfcStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaStatusSummaryT
#define SOAP_TYPE_ns1__MtaStatusSummaryT (115)
/* ns1:MtaStatusSummaryT */
class SOAP_CMAC ns1__MtaStatusSummaryT
{
public:
	ns1__StatusSummaryT *statusSummary;	/* required element of type ns1:StatusSummaryT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string hfcName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE_ns1__MtaStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaStatusSummaryT() : statusSummary(NULL), soap(NULL) { }
	virtual ~ns1__MtaStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusSummaryT
#define SOAP_TYPE_ns1__CmStatusSummaryT (117)
/* ns1:CmStatusSummaryT */
class SOAP_CMAC ns1__CmStatusSummaryT
{
public:
	ns1__StatusSummaryT *statusSummary;	/* required element of type ns1:StatusSummaryT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string hfcName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE_ns1__CmStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusSummaryT() : statusSummary(NULL), soap(NULL) { }
	virtual ~ns1__CmStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaStatusSummaryRespT
#define SOAP_TYPE_ns1__MtaStatusSummaryRespT (119)
/* ns1:MtaStatusSummaryRespT */
class SOAP_CMAC ns1__MtaStatusSummaryRespT
{
public:
	class ArrayOfMtaStatusSummaryT *mtaData;	/* required element of type ArrayOfMtaStatusSummaryT */
	class ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE_ns1__MtaStatusSummaryRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaStatusSummaryRespT() : mtaData(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__MtaStatusSummaryRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcStatusSummaryRespT
#define SOAP_TYPE_ns1__HfcStatusSummaryRespT (120)
/* ns1:HfcStatusSummaryRespT */
class SOAP_CMAC ns1__HfcStatusSummaryRespT
{
public:
	class ArrayOfHfcStatusSummaryT *hfcData;	/* required element of type ArrayOfHfcStatusSummaryT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE_ns1__HfcStatusSummaryRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcStatusSummaryRespT() : hfcData(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__HfcStatusSummaryRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusSummaryRespT
#define SOAP_TYPE_ns1__CmStatusSummaryRespT (121)
/* ns1:CmStatusSummaryRespT */
class SOAP_CMAC ns1__CmStatusSummaryRespT
{
public:
	class ArrayOfCmStatusSummaryT *cmData;	/* required element of type ArrayOfCmStatusSummaryT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE_ns1__CmStatusSummaryRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusSummaryRespT() : cmData(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__CmStatusSummaryRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CurrentAlarmsRespT
#define SOAP_TYPE_ns1__CurrentAlarmsRespT (122)
/* ns1:CurrentAlarmsRespT */
class SOAP_CMAC ns1__CurrentAlarmsRespT
{
public:
	class ArrayOfCurrentAlarmsT *alarms;	/* required element of type ArrayOfCurrentAlarmT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE_ns1__CurrentAlarmsRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CurrentAlarmsRespT() : alarms(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__CurrentAlarmsRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HistoricalAlarmsRespT
#define SOAP_TYPE_ns1__HistoricalAlarmsRespT (123)
/* ns1:HistoricalAlarmsRespT */
class SOAP_CMAC ns1__HistoricalAlarmsRespT
{
public:
	class ArrayOfHistoricalAlarmsT *alarms;	/* required element of type ArrayOfHistoricalAlarmT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_ns1__HistoricalAlarmsRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HistoricalAlarmsRespT() : alarms(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__HistoricalAlarmsRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EventMessageT
#define SOAP_TYPE_ns1__EventMessageT (124)
/* ns1:EventMessageT */
class SOAP_CMAC ns1__EventMessageT
{
public:
	enum ns1__EventTypeT eventType;	/* required element of type ns1:EventTypeT */
	enum ns1__EventCategoryT eventCategory;	/* required element of type ns1:EventCategoryT */
	std::string eventSubCategory;	/* required element of type xsd:string */
	std::string *objectId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE_ns1__EventMessageT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EventMessageT() : objectId(NULL), soap(NULL) { }
	virtual ~ns1__EventMessageT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfRegionsT
#define SOAP_TYPE_ArrayOfRegionsT (32)
/* SOAP encoded array of ns1:RegionT schema type: */
class SOAP_CMAC ArrayOfRegionsT
{
public:
	ns1__RegionT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ArrayOfRegionsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfRegionsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfRegionsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMarketsT
#define SOAP_TYPE_ArrayOfMarketsT (33)
/* SOAP encoded array of ns1:MarketT schema type: */
class SOAP_CMAC ArrayOfMarketsT
{
public:
	ns1__MarketT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ArrayOfMarketsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMarketsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMarketsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfBladesT
#define SOAP_TYPE_ArrayOfBladesT (34)
/* SOAP encoded array of ns1:BladeT schema type: */
class SOAP_CMAC ArrayOfBladesT
{
public:
	ns1__BladeT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ArrayOfBladesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfBladesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfBladesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmsesT
#define SOAP_TYPE_ArrayOfCmsesT (35)
/* SOAP encoded array of ns1:CmsT schema type: */
class SOAP_CMAC ArrayOfCmsesT
{
public:
	ns1__CmsT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ArrayOfCmsesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmsesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmsesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmtsesT
#define SOAP_TYPE_ArrayOfCmtsesT (36)
/* SOAP encoded array of ns1:CmtsT schema type: */
class SOAP_CMAC ArrayOfCmtsesT
{
public:
	ns1__CmtsT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ArrayOfCmtsesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmtsesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmtsesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfSnmpV2CAttributesT
#define SOAP_TYPE_ArrayOfSnmpV2CAttributesT (37)
/* SOAP encoded array of ns1:SnmpV2CAttributesT schema type: */
class SOAP_CMAC ArrayOfSnmpV2CAttributesT
{
public:
	ns1__SnmpV2CAttributesT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ArrayOfSnmpV2CAttributesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfSnmpV2CAttributesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfSnmpV2CAttributesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfChannelsT
#define SOAP_TYPE_ArrayOfChannelsT (38)
/* SOAP encoded array of ns1:ChannelT schema type: */
class SOAP_CMAC ArrayOfChannelsT
{
public:
	ns1__ChannelT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ArrayOfChannelsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfChannelsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfChannelsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfHfcsT
#define SOAP_TYPE_ArrayOfHfcsT (39)
/* SOAP encoded array of ns1:HfcT schema type: */
class SOAP_CMAC ArrayOfHfcsT
{
public:
	ns1__HfcT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ArrayOfHfcsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfHfcsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfHfcsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCableModemsT
#define SOAP_TYPE_ArrayOfCableModemsT (40)
/* SOAP encoded array of ns1:CableModemT schema type: */
class SOAP_CMAC ArrayOfCableModemsT
{
public:
	ns1__CableModemT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ArrayOfCableModemsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCableModemsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCableModemsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfEmtasT
#define SOAP_TYPE_ArrayOfEmtasT (41)
/* SOAP encoded array of ns1:EmtaT schema type: */
class SOAP_CMAC ArrayOfEmtasT
{
public:
	ns1__EmtaT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ArrayOfEmtasT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfEmtasT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfEmtasT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCurrentAlarmsT
#define SOAP_TYPE_ArrayOfCurrentAlarmsT (42)
/* SOAP encoded array of ns1:CurrentAlarmT schema type: */
class SOAP_CMAC ArrayOfCurrentAlarmsT
{
public:
	ns1__CurrentAlarmT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ArrayOfCurrentAlarmsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCurrentAlarmsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCurrentAlarmsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfHistoricalAlarmsT
#define SOAP_TYPE_ArrayOfHistoricalAlarmsT (43)
/* SOAP encoded array of ns1:HistoricalAlarmT schema type: */
class SOAP_CMAC ArrayOfHistoricalAlarmsT
{
public:
	ns1__HistoricalAlarmT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ArrayOfHistoricalAlarmsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfHistoricalAlarmsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfHistoricalAlarmsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAlarmHistoriesT
#define SOAP_TYPE_ArrayOfAlarmHistoriesT (44)
/* SOAP encoded array of ns1:AlarmHistoryT schema type: */
class SOAP_CMAC ArrayOfAlarmHistoriesT
{
public:
	ns1__AlarmHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ArrayOfAlarmHistoriesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAlarmHistoriesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAlarmHistoriesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfScrollPageT
#define SOAP_TYPE_ArrayOfScrollPageT (47)
/* SOAP encoded array of ns1:ScrollPageT schema type: */
class SOAP_CMAC ArrayOfScrollPageT
{
public:
	ns1__ScrollPageT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ArrayOfScrollPageT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfScrollPageT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfScrollPageT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfQueryStateT
#define SOAP_TYPE_ArrayOfQueryStateT (49)
/* SOAP encoded array of ns1:QueryStateT schema type: */
class SOAP_CMAC ArrayOfQueryStateT
{
public:
	ns1__QueryStateT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ArrayOfQueryStateT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfQueryStateT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfQueryStateT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfGenericCountsHistoryT
#define SOAP_TYPE_ArrayOfGenericCountsHistoryT (51)
/* SOAP encoded array of ns1:GenericCountsHistoryT schema type: */
class SOAP_CMAC ArrayOfGenericCountsHistoryT
{
public:
	ns1__GenericCountsHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ArrayOfGenericCountsHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfGenericCountsHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfGenericCountsHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmStatusHistoryT
#define SOAP_TYPE_ArrayOfCmStatusHistoryT (54)
/* SOAP encoded array of ns1:CmStatusHistoryT schema type: */
class SOAP_CMAC ArrayOfCmStatusHistoryT
{
public:
	ns1__CmStatusHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ArrayOfCmStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmStatusHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT
#define SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT (57)
/* SOAP encoded array of ns1:MtaAvailabilityHistoryT schema type: */
class SOAP_CMAC ArrayOfMtaAvailabilityHistoryT
{
public:
	ns1__MtaAvailabilityHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaAvailabilityHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaAvailabilityHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaProvStatusHistoryT
#define SOAP_TYPE_ArrayOfMtaProvStatusHistoryT (60)
/* SOAP encoded array of ns1:MtaProvStatusHistoryT schema type: */
class SOAP_CMAC ArrayOfMtaProvStatusHistoryT
{
public:
	ns1__MtaProvStatusHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ArrayOfMtaProvStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaProvStatusHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaProvStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaPingStatusHistoryT
#define SOAP_TYPE_ArrayOfMtaPingStatusHistoryT (63)
/* SOAP encoded array of ns1:MtaPingStatusHistoryT schema type: */
class SOAP_CMAC ArrayOfMtaPingStatusHistoryT
{
public:
	ns1__MtaPingStatusHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ArrayOfMtaPingStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaPingStatusHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaPingStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmPerformanceHistoryT
#define SOAP_TYPE_ArrayOfCmPerformanceHistoryT (67)
/* SOAP encoded array of ns1:CmPerformanceHistoryT schema type: */
class SOAP_CMAC ArrayOfCmPerformanceHistoryT
{
public:
	ns1__CmPerformanceHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ArrayOfCmPerformanceHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmPerformanceHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmPerformanceHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCTECustomerT
#define SOAP_TYPE_ArrayOfCTECustomerT (69)
/* SOAP encoded array of ns1:CTECustomerT schema type: */
class SOAP_CMAC ArrayOfCTECustomerT
{
public:
	ns1__CTECustomerT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ArrayOfCTECustomerT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCTECustomerT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCTECustomerT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCTEDataT
#define SOAP_TYPE_ArrayOfCTEDataT (73)
/* SOAP encoded array of ns1:CTEDataT schema type: */
class SOAP_CMAC ArrayOfCTEDataT
{
public:
	ns1__CTEDataT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ArrayOfCTEDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCTEDataT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCTEDataT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCTEQueryInputT
#define SOAP_TYPE_ArrayOfCTEQueryInputT (75)
/* SOAP encoded array of ns1:CTEQueryInputT schema type: */
class SOAP_CMAC ArrayOfCTEQueryInputT
{
public:
	ns1__CTEQueryInputT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ArrayOfCTEQueryInputT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCTEQueryInputT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCTEQueryInputT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCMSLineT
#define SOAP_TYPE_ArrayOfCMSLineT (77)
/* SOAP encoded array of ns1:CMSLineT schema type: */
class SOAP_CMAC ArrayOfCMSLineT
{
public:
	ns1__CMSLineT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ArrayOfCMSLineT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCMSLineT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCMSLineT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfUserAccessT
#define SOAP_TYPE_ArrayOfUserAccessT (80)
/* SOAP encoded array of ns1:UserAccessT schema type: */
class SOAP_CMAC ArrayOfUserAccessT
{
public:
	ns1__UserAccessT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ArrayOfUserAccessT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfUserAccessT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfUserAccessT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfApplicationDomainT
#define SOAP_TYPE_ArrayOfApplicationDomainT (82)
/* SOAP encoded array of ns1:ApplicationDomainT schema type: */
class SOAP_CMAC ArrayOfApplicationDomainT
{
public:
	ns1__ApplicationDomainT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ArrayOfApplicationDomainT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfApplicationDomainT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfApplicationDomainT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfRoleT
#define SOAP_TYPE_ArrayOfRoleT (84)
/* SOAP encoded array of ns1:RoleT schema type: */
class SOAP_CMAC ArrayOfRoleT
{
public:
	ns1__RoleT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ArrayOfRoleT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfRoleT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfRoleT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfUserT
#define SOAP_TYPE_ArrayOfUserT (86)
/* SOAP encoded array of ns1:UserT schema type: */
class SOAP_CMAC ArrayOfUserT
{
public:
	ns1__UserT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ArrayOfUserT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfUserT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfUserT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAlarmStatusThresholdT
#define SOAP_TYPE_ArrayOfAlarmStatusThresholdT (89)
/* SOAP encoded array of ns1:AlarmBasedStatusThresholdT schema type: */
class SOAP_CMAC ArrayOfAlarmStatusThresholdT
{
public:
	ns1__AlarmBasedStatusThresholdT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ArrayOfAlarmStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAlarmStatusThresholdT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAlarmStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAggregateStatusThresholdT
#define SOAP_TYPE_ArrayOfAggregateStatusThresholdT (91)
/* SOAP encoded array of ns1:AggregateStatusThresholdT schema type: */
class SOAP_CMAC ArrayOfAggregateStatusThresholdT
{
public:
	ns1__AggregateStatusThresholdT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ArrayOfAggregateStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAggregateStatusThresholdT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAggregateStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAlarmTypeConfigT
#define SOAP_TYPE_ArrayOfAlarmTypeConfigT (103)
/* SOAP encoded array of ns1:AlarmTypeConfigT schema type: */
class SOAP_CMAC ArrayOfAlarmTypeConfigT
{
public:
	ns1__AlarmTypeConfigT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ArrayOfAlarmTypeConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAlarmTypeConfigT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAlarmTypeConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfHfcStatusSummaryT
#define SOAP_TYPE_ArrayOfHfcStatusSummaryT (114)
/* SOAP encoded array of ns1:HfcStatusSummaryT schema type: */
class SOAP_CMAC ArrayOfHfcStatusSummaryT
{
public:
	ns1__HfcStatusSummaryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_ArrayOfHfcStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfHfcStatusSummaryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfHfcStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaStatusSummaryT
#define SOAP_TYPE_ArrayOfMtaStatusSummaryT (116)
/* SOAP encoded array of ns1:MtaStatusSummaryT schema type: */
class SOAP_CMAC ArrayOfMtaStatusSummaryT
{
public:
	ns1__MtaStatusSummaryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_ArrayOfMtaStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaStatusSummaryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmStatusSummaryT
#define SOAP_TYPE_ArrayOfCmStatusSummaryT (118)
/* SOAP encoded array of ns1:CmStatusSummaryT schema type: */
class SOAP_CMAC ArrayOfCmStatusSummaryT
{
public:
	ns1__CmStatusSummaryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE_ArrayOfCmStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmStatusSummaryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_cte__getCteDataResponse
#define SOAP_TYPE_cte__getCteDataResponse (247)
/* cte:getCteDataResponse */
struct cte__getCteDataResponse
{
public:
	ArrayOfCTEDataT *name;	/* RPC return element */	/* optional element of type ArrayOfCTEDataT */
};
#endif

#ifndef SOAP_TYPE_cte__getCteData
#define SOAP_TYPE_cte__getCteData (252)
/* cte:getCteData */
struct cte__getCteData
{
public:
	ArrayOfCTEQueryInputT *queryInput;	/* optional element of type ArrayOfCTEQueryInputT */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (255)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	void *dummy;	/* transient */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (256)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (258)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (259)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (260)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (4)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (8)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE__SOAP_ENC__arrayType
#define SOAP_TYPE__SOAP_ENC__arrayType (9)
typedef std::string _SOAP_ENC__arrayType;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operations                                                         *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 cte__getCteData(struct soap*, ArrayOfCTEQueryInputT *queryInput, struct cte__getCteDataResponse &_param_1);

/******************************************************************************\
 *                                                                            *
 * Skeletons                                                                  *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 CteServ_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 CteServ_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cte__getCteData(struct soap*);

#endif

/* End of CteServStub.h */
