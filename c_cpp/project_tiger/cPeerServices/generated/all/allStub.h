/* allStub.h
   Generated by gSOAP 2.7.9c from include/allServices.h
   Copyright(C) 2000-2006, Robert van Engelen, Genivia Inc. All Rights Reserved.
   This part of the software is released under one of the following licenses:
   GPL, the gSOAP public license, or Genivia's license for commercial use.
*/

#ifndef allStub_H
#define allStub_H
#include <vector>
#define WITH_NONAMESPACES
#include "stdsoap2.h"

/******************************************************************************\
 *                                                                            *
 * Enumerations                                                               *
 *                                                                            *
\******************************************************************************/


#ifndef SOAP_TYPE_ns1__SystemTypeT
#define SOAP_TYPE_ns1__SystemTypeT (125)
/* ns1:SystemTypeT */
enum ns1__SystemTypeT {ns1__SystemTypeT__EnterpriseServer = 0, ns1__SystemTypeT__RegionServer = 1, ns1__SystemTypeT__MarketServer = 2, ns1__SystemTypeT__BladeServer = 3};
#endif

#ifndef SOAP_TYPE_ns1__ResourceTypeT
#define SOAP_TYPE_ns1__ResourceTypeT (126)
/* ns1:ResourceTypeT */
enum ns1__ResourceTypeT {ns1__ResourceTypeT__CMTS = 0, ns1__ResourceTypeT__CMS = 1, ns1__ResourceTypeT__Channel = 2, ns1__ResourceTypeT__HFC = 3, ns1__ResourceTypeT__CM = 4, ns1__ResourceTypeT__MTA = 5};
#endif

#ifndef SOAP_TYPE_ns1__StatusColorT
#define SOAP_TYPE_ns1__StatusColorT (127)
/* ns1:StatusColorT */
enum ns1__StatusColorT {ns1__StatusColorT__Gray = 0, ns1__StatusColorT__Green = 1, ns1__StatusColorT__Yellow = 2, ns1__StatusColorT__Orange = 3, ns1__StatusColorT__Red = 4};
#endif

#ifndef SOAP_TYPE_ns1__SnmpVersionT
#define SOAP_TYPE_ns1__SnmpVersionT (128)
/* ns1:SnmpVersionT */
enum ns1__SnmpVersionT {ns1__SnmpVersionT__v1 = 0, ns1__SnmpVersionT__v2c = 1, ns1__SnmpVersionT__v3 = 2};
#endif

#ifndef SOAP_TYPE_ns1__ChannelTypeT
#define SOAP_TYPE_ns1__ChannelTypeT (129)
/* ns1:ChannelTypeT */
enum ns1__ChannelTypeT {ns1__ChannelTypeT__Upstream = 0, ns1__ChannelTypeT__Downstream = 1};
#endif

#ifndef SOAP_TYPE_ns1__EndUserDeviceTypeT
#define SOAP_TYPE_ns1__EndUserDeviceTypeT (130)
/* ns1:EndUserDeviceTypeT */
enum ns1__EndUserDeviceTypeT {ns1__EndUserDeviceTypeT__CM = 0, ns1__EndUserDeviceTypeT__eMTA = 1};
#endif

#ifndef SOAP_TYPE_ns1__UserAccessTypeT
#define SOAP_TYPE_ns1__UserAccessTypeT (131)
/* ns1:UserAccessTypeT */
enum ns1__UserAccessTypeT {ns1__UserAccessTypeT__None = 0, ns1__UserAccessTypeT__Read = 1, ns1__UserAccessTypeT__Write = 2, ns1__UserAccessTypeT__Execute = 3};
#endif

#ifndef SOAP_TYPE_ns1__ApplicationDomainTypeT
#define SOAP_TYPE_ns1__ApplicationDomainTypeT (132)
/* ns1:ApplicationDomainTypeT */
enum ns1__ApplicationDomainTypeT {ns1__ApplicationDomainTypeT__Alarm = 0, ns1__ApplicationDomainTypeT__CSR_x0020Portal = 1, ns1__ApplicationDomainTypeT__System_x0020Administration = 2, ns1__ApplicationDomainTypeT__User_x0020Administration = 3};
#endif

#ifndef SOAP_TYPE_ns1__EventTypeT
#define SOAP_TYPE_ns1__EventTypeT (133)
/* ns1:EventTypeT */
enum ns1__EventTypeT {ns1__EventTypeT__Add = 0, ns1__EventTypeT__Delete = 1, ns1__EventTypeT__Update = 2};
#endif

#ifndef SOAP_TYPE_ns1__EventCategoryT
#define SOAP_TYPE_ns1__EventCategoryT (134)
/* ns1:EventCategoryT */
enum ns1__EventCategoryT {ns1__EventCategoryT__Resource = 0, ns1__EventCategoryT__Configuration = 1};
#endif

/******************************************************************************\
 *                                                                            *
 * Classes and Structs                                                        *
 *                                                                            *
\******************************************************************************/


#if 0 /* volatile type: do not redeclare */

#endif



#ifndef SOAP_TYPE_ns1__SnmpV2CAttributesT
#define SOAP_TYPE_ns1__SnmpV2CAttributesT (10)
/* ns1:SnmpV2CAttributesT */
class SOAP_CMAC ns1__SnmpV2CAttributesT
{
public:
	std::string readCommnunity;	/* required element of type xsd:string */
	std::string *writeCommnunity;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 10; } /* = unique id SOAP_TYPE_ns1__SnmpV2CAttributesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SnmpV2CAttributesT() : writeCommnunity(NULL), soap(NULL) { }
	virtual ~ns1__SnmpV2CAttributesT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GenericCountsT
#define SOAP_TYPE_ns1__GenericCountsT (11)
/* ns1:GenericCountsT */
class SOAP_CMAC ns1__GenericCountsT
{
public:
	short totalCm;	/* required element of type xsd:short */
	short onlineCm;	/* required element of type xsd:short */
	short totalMta;	/* required element of type xsd:short */
	short availableMta;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 11; } /* = unique id SOAP_TYPE_ns1__GenericCountsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GenericCountsT() : soap(NULL) { }
	virtual ~ns1__GenericCountsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__InputTimeT
#define SOAP_TYPE_ns1__InputTimeT (12)
/* ns1:InputTimeT */
class SOAP_CMAC ns1__InputTimeT
{
public:
	short year;	/* required element of type xsd:short */
	short monthOfYear;	/* required element of type xsd:short */
	short dayOfMonth;	/* required element of type xsd:short */
	short hourOfDay;	/* required element of type xsd:short */
	short minuteOfHour;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 12; } /* = unique id SOAP_TYPE_ns1__InputTimeT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__InputTimeT() : soap(NULL) { }
	virtual ~ns1__InputTimeT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ResultBatchT
#define SOAP_TYPE_ns1__ResultBatchT (13)
/* ns1:ResultBatchT */
class SOAP_CMAC ns1__ResultBatchT
{
public:
	short fromIndex;	/* required element of type xsd:short */
	short toIndex;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 13; } /* = unique id SOAP_TYPE_ns1__ResultBatchT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ResultBatchT() : soap(NULL) { }
	virtual ~ns1__ResultBatchT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__TopoHierarchyKeyT
#define SOAP_TYPE_ns1__TopoHierarchyKeyT (14)
/* ns1:TopoHierarchyKeyT */
class SOAP_CMAC ns1__TopoHierarchyKeyT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string marketId;	/* required element of type xsd:integer */
	std::string bladeId;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 14; } /* = unique id SOAP_TYPE_ns1__TopoHierarchyKeyT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__TopoHierarchyKeyT() : soap(NULL) { }
	virtual ~ns1__TopoHierarchyKeyT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__LocalSystemT
#define SOAP_TYPE_ns1__LocalSystemT (15)
/* ns1:LocalSystemT */
class SOAP_CMAC ns1__LocalSystemT
{
public:
	enum ns1__SystemTypeT systemType;	/* required element of type ns1:SystemTypeT */
	std::string systemName;	/* required element of type xsd:string */
	std::string parentHost;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 15; } /* = unique id SOAP_TYPE_ns1__LocalSystemT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__LocalSystemT() : soap(NULL) { }
	virtual ~ns1__LocalSystemT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RegionT
#define SOAP_TYPE_ns1__RegionT (16)
/* ns1:RegionT */
class SOAP_CMAC ns1__RegionT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 16; } /* = unique id SOAP_TYPE_ns1__RegionT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RegionT() : soap(NULL) { }
	virtual ~ns1__RegionT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MarketT
#define SOAP_TYPE_ns1__MarketT (17)
/* ns1:MarketT */
class SOAP_CMAC ns1__MarketT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string marketId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 17; } /* = unique id SOAP_TYPE_ns1__MarketT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MarketT() : soap(NULL) { }
	virtual ~ns1__MarketT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__BladeT
#define SOAP_TYPE_ns1__BladeT (18)
/* ns1:BladeT */
class SOAP_CMAC ns1__BladeT
{
public:
	std::string regionId;	/* required element of type xsd:integer */
	std::string marketId;	/* required element of type xsd:integer */
	std::string bladeId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 18; } /* = unique id SOAP_TYPE_ns1__BladeT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__BladeT() : soap(NULL) { }
	virtual ~ns1__BladeT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmsT
#define SOAP_TYPE_ns1__CmsT (19)
/* ns1:CmsT */
class SOAP_CMAC ns1__CmsT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string cmsResId;	/* required element of type xsd:integer */
	std::string cmsName;	/* required element of type xsd:string */
	std::string cmsType;	/* required element of type xsd:string */
	std::string cmsSubType;	/* required element of type xsd:string */
	std::string cmsHost;	/* required element of type xsd:string */
	std::string loginName;	/* required element of type xsd:string */
	std::string loginPassword;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 19; } /* = unique id SOAP_TYPE_ns1__CmsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmsT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__CmsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsT
#define SOAP_TYPE_ns1__CmtsT (20)
/* ns1:CmtsT */
class SOAP_CMAC ns1__CmtsT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	std::string cmtsHost;	/* required element of type xsd:string */
	enum ns1__SnmpVersionT cmtsSnmpVersion;	/* required element of type ns1:SnmpVersionT */
	enum ns1__SnmpVersionT cmSnmpVersion;	/* required element of type ns1:SnmpVersionT */
	enum ns1__SnmpVersionT mtaSnmpVersion;	/* required element of type ns1:SnmpVersionT */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	ns1__GenericCountsT *counts;	/* optional element of type ns1:GenericCountsT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 20; } /* = unique id SOAP_TYPE_ns1__CmtsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsT() : topologyKey(NULL), counts(NULL), soap(NULL) { }
	virtual ~ns1__CmtsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ChannelT
#define SOAP_TYPE_ns1__ChannelT (21)
/* ns1:ChannelT */
class SOAP_CMAC ns1__ChannelT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string channelResId;	/* required element of type xsd:integer */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string channelName;	/* required element of type xsd:string */
	enum ns1__ChannelTypeT channelType;	/* required element of type ns1:ChannelTypeT */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	ns1__GenericCountsT *counts;	/* optional element of type ns1:GenericCountsT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 21; } /* = unique id SOAP_TYPE_ns1__ChannelT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ChannelT() : topologyKey(NULL), counts(NULL), soap(NULL) { }
	virtual ~ns1__ChannelT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcT
#define SOAP_TYPE_ns1__HfcT (22)
/* ns1:HfcT */
class SOAP_CMAC ns1__HfcT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string hfcName;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	ns1__GenericCountsT *counts;	/* optional element of type ns1:GenericCountsT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 22; } /* = unique id SOAP_TYPE_ns1__HfcT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcT() : topologyKey(NULL), counts(NULL), soap(NULL) { }
	virtual ~ns1__HfcT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CableModemT
#define SOAP_TYPE_ns1__CableModemT (23)
/* ns1:CableModemT */
class SOAP_CMAC ns1__CableModemT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string cmResId;	/* required element of type xsd:integer */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string upChannelResId;	/* required element of type xsd:integer */
	std::string downChannelResId;	/* required element of type xsd:integer */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string macAddress;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	std::string cmStatus;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	std::string fqdn;	/* required element of type xsd:string */
	std::string cmIndex;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 23; } /* = unique id SOAP_TYPE_ns1__CableModemT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CableModemT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__CableModemT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EmtaT
#define SOAP_TYPE_ns1__EmtaT (24)
/* ns1:EmtaT */
class SOAP_CMAC ns1__EmtaT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string emtaResId;	/* required element of type xsd:integer */
	std::string *cmResId;	/* optional element of type xsd:integer */
	std::string macAddress;	/* required element of type xsd:string */
	enum ns1__StatusColorT statusColor;	/* required element of type ns1:StatusColorT */
	std::string host;	/* required element of type xsd:string */
	std::string fqdn;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 24; } /* = unique id SOAP_TYPE_ns1__EmtaT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EmtaT() : topologyKey(NULL), cmResId(NULL), soap(NULL) { }
	virtual ~ns1__EmtaT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EmtaSecondaryT
#define SOAP_TYPE_ns1__EmtaSecondaryT (25)
/* ns1:EmtaSecondaryT */
class SOAP_CMAC ns1__EmtaSecondaryT
{
public:
	std::string phone1;	/* required element of type xsd:string */
	std::string phone2;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 25; } /* = unique id SOAP_TYPE_ns1__EmtaSecondaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EmtaSecondaryT() : soap(NULL) { }
	virtual ~ns1__EmtaSecondaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AbstractAlarmT
#define SOAP_TYPE_ns1__AbstractAlarmT (26)
/* ns1:AbstractAlarmT */
class SOAP_CMAC ns1__AbstractAlarmT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string alarmId;	/* required element of type xsd:integer */
	std::string resourceId;	/* required element of type xsd:integer */
	std::string resourceName;	/* required element of type xsd:string */
	std::string alarmTime;	/* required element of type xsd:integer */
	std::string alarmTimeUSec;	/* required element of type xsd:integer */
	short soakDuration;	/* required element of type xsd:short */
	std::string alarmState;	/* required element of type xsd:string */
	std::string alarmType;	/* required element of type xsd:string */
	std::string alarmSubType;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 26; } /* = unique id SOAP_TYPE_ns1__AbstractAlarmT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AbstractAlarmT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__AbstractAlarmT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CurrentAlarmT
#define SOAP_TYPE_ns1__CurrentAlarmT (27)
/* ns1:CurrentAlarmT */
class SOAP_CMAC ns1__CurrentAlarmT
{
public:
	ns1__AbstractAlarmT *abstractAlarm;	/* required element of type ns1:AbstractAlarmT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 27; } /* = unique id SOAP_TYPE_ns1__CurrentAlarmT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CurrentAlarmT() : abstractAlarm(NULL), soap(NULL) { }
	virtual ~ns1__CurrentAlarmT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CurrentAlarmDetailsT
#define SOAP_TYPE_ns1__CurrentAlarmDetailsT (28)
/* ns1:CurrentAlarmDetailsT */
class SOAP_CMAC ns1__CurrentAlarmDetailsT
{
public:
	ns1__CurrentAlarmT *currentAlarm;	/* required element of type ns1:CurrentAlarmT */
	std::string alarmDetails;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 28; } /* = unique id SOAP_TYPE_ns1__CurrentAlarmDetailsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CurrentAlarmDetailsT() : currentAlarm(NULL), soap(NULL) { }
	virtual ~ns1__CurrentAlarmDetailsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HistoricalAlarmT
#define SOAP_TYPE_ns1__HistoricalAlarmT (29)
/* ns1:HistoricalAlarmT */
class SOAP_CMAC ns1__HistoricalAlarmT
{
public:
	ns1__AbstractAlarmT *abstractAlarm;	/* required element of type ns1:AbstractAlarmT */
	std::string clearedUser;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 29; } /* = unique id SOAP_TYPE_ns1__HistoricalAlarmT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HistoricalAlarmT() : abstractAlarm(NULL), soap(NULL) { }
	virtual ~ns1__HistoricalAlarmT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HistoricalAlarmDetailsT
#define SOAP_TYPE_ns1__HistoricalAlarmDetailsT (30)
/* ns1:HistoricalAlarmDetailsT */
class SOAP_CMAC ns1__HistoricalAlarmDetailsT
{
public:
	ns1__HistoricalAlarmT *historicalAlarm;	/* required element of type ns1:HistoricalAlarmT */
	std::string alarmDetails;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 30; } /* = unique id SOAP_TYPE_ns1__HistoricalAlarmDetailsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HistoricalAlarmDetailsT() : historicalAlarm(NULL), soap(NULL) { }
	virtual ~ns1__HistoricalAlarmDetailsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AlarmHistoryT
#define SOAP_TYPE_ns1__AlarmHistoryT (31)
/* ns1:AlarmHistoryT */
class SOAP_CMAC ns1__AlarmHistoryT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* required element of type ns1:TopoHierarchyKeyT */
	std::string alarmId;	/* required element of type xsd:integer */
	std::string timeStamp;	/* required element of type xsd:string */
	std::string alarmState;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 31; } /* = unique id SOAP_TYPE_ns1__AlarmHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AlarmHistoryT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__AlarmHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MappedEuDevicesT
#define SOAP_TYPE_ns1__MappedEuDevicesT (45)
/* ns1:MappedEuDevicesT */
class SOAP_CMAC ns1__MappedEuDevicesT
{
public:
	ns1__CableModemT *cm;	/* optional element of type ns1:CableModemT */
	ns1__EmtaT *mta;	/* optional element of type ns1:EmtaT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 45; } /* = unique id SOAP_TYPE_ns1__MappedEuDevicesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MappedEuDevicesT() : cm(NULL), mta(NULL), soap(NULL) { }
	virtual ~ns1__MappedEuDevicesT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ScrollPageT
#define SOAP_TYPE_ns1__ScrollPageT (46)
/* ns1:ScrollPageT */
class SOAP_CMAC ns1__ScrollPageT
{
public:
	ns1__ResultBatchT *batch;	/* required element of type ns1:ResultBatchT */
	std::string start;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 46; } /* = unique id SOAP_TYPE_ns1__ScrollPageT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ScrollPageT() : batch(NULL), soap(NULL) { }
	virtual ~ns1__ScrollPageT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__QueryStateT
#define SOAP_TYPE_ns1__QueryStateT (48)
/* ns1:QueryStateT */
class SOAP_CMAC ns1__QueryStateT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	class ArrayOfScrollPageT *pages;	/* required element of type ArrayOfScrollPageT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 48; } /* = unique id SOAP_TYPE_ns1__QueryStateT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__QueryStateT() : topologyKey(NULL), pages(NULL), soap(NULL) { }
	virtual ~ns1__QueryStateT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__GenericCountsHistoryT
#define SOAP_TYPE_ns1__GenericCountsHistoryT (50)
/* ns1:GenericCountsHistoryT */
class SOAP_CMAC ns1__GenericCountsHistoryT
{
public:
	ns1__GenericCountsT *counts;	/* required element of type ns1:GenericCountsT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 50; } /* = unique id SOAP_TYPE_ns1__GenericCountsHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__GenericCountsHistoryT() : counts(NULL), soap(NULL) { }
	virtual ~ns1__GenericCountsHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusT
#define SOAP_TYPE_ns1__CmStatusT (52)
/* ns1:CmStatusT */
class SOAP_CMAC ns1__CmStatusT
{
public:
	short docsisState;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 52; } /* = unique id SOAP_TYPE_ns1__CmStatusT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusT() : soap(NULL) { }
	virtual ~ns1__CmStatusT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusHistoryT
#define SOAP_TYPE_ns1__CmStatusHistoryT (53)
/* ns1:CmStatusHistoryT */
class SOAP_CMAC ns1__CmStatusHistoryT
{
public:
	ns1__CmStatusT *cmStatus;	/* required element of type ns1:CmStatusT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 53; } /* = unique id SOAP_TYPE_ns1__CmStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusHistoryT() : cmStatus(NULL), soap(NULL) { }
	virtual ~ns1__CmStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaAvailabilityT
#define SOAP_TYPE_ns1__MtaAvailabilityT (55)
/* ns1:MtaAvailabilityT */
class SOAP_CMAC ns1__MtaAvailabilityT
{
public:
	short available;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 55; } /* = unique id SOAP_TYPE_ns1__MtaAvailabilityT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaAvailabilityT() : soap(NULL) { }
	virtual ~ns1__MtaAvailabilityT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaAvailabilityHistoryT
#define SOAP_TYPE_ns1__MtaAvailabilityHistoryT (56)
/* ns1:MtaAvailabilityHistoryT */
class SOAP_CMAC ns1__MtaAvailabilityHistoryT
{
public:
	ns1__MtaAvailabilityT *available;	/* required element of type ns1:MtaAvailabilityT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 56; } /* = unique id SOAP_TYPE_ns1__MtaAvailabilityHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaAvailabilityHistoryT() : available(NULL), soap(NULL) { }
	virtual ~ns1__MtaAvailabilityHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaProvStatusT
#define SOAP_TYPE_ns1__MtaProvStatusT (58)
/* ns1:MtaProvStatusT */
class SOAP_CMAC ns1__MtaProvStatusT
{
public:
	short provState;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 58; } /* = unique id SOAP_TYPE_ns1__MtaProvStatusT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaProvStatusT() : soap(NULL) { }
	virtual ~ns1__MtaProvStatusT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaProvStatusHistoryT
#define SOAP_TYPE_ns1__MtaProvStatusHistoryT (59)
/* ns1:MtaProvStatusHistoryT */
class SOAP_CMAC ns1__MtaProvStatusHistoryT
{
public:
	ns1__MtaProvStatusT *provStatus;	/* required element of type ns1:MtaProvStatusT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 59; } /* = unique id SOAP_TYPE_ns1__MtaProvStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaProvStatusHistoryT() : provStatus(NULL), soap(NULL) { }
	virtual ~ns1__MtaProvStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaPingStatusT
#define SOAP_TYPE_ns1__MtaPingStatusT (61)
/* ns1:MtaPingStatusT */
class SOAP_CMAC ns1__MtaPingStatusT
{
public:
	short pingState;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 61; } /* = unique id SOAP_TYPE_ns1__MtaPingStatusT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaPingStatusT() : soap(NULL) { }
	virtual ~ns1__MtaPingStatusT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaPingStatusHistoryT
#define SOAP_TYPE_ns1__MtaPingStatusHistoryT (62)
/* ns1:MtaPingStatusHistoryT */
class SOAP_CMAC ns1__MtaPingStatusHistoryT
{
public:
	ns1__MtaPingStatusT *pingStatus;	/* required element of type ns1:MtaPingStatusT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 62; } /* = unique id SOAP_TYPE_ns1__MtaPingStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaPingStatusHistoryT() : pingStatus(NULL), soap(NULL) { }
	virtual ~ns1__MtaPingStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmPerformanceT
#define SOAP_TYPE_ns1__CmPerformanceT (64)
/* ns1:CmPerformanceT */
class SOAP_CMAC ns1__CmPerformanceT
{
public:
	short downstreamSNR;	/* required element of type xsd:short */
	short downstreamPower;	/* required element of type xsd:short */
	short upstreamPower;	/* required element of type xsd:short */
	short t1Timeouts;	/* required element of type xsd:short */
	short t2Timeouts;	/* required element of type xsd:short */
	short t3Timeouts;	/* required element of type xsd:short */
	short t4Timeouts;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 64; } /* = unique id SOAP_TYPE_ns1__CmPerformanceT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmPerformanceT() : soap(NULL) { }
	virtual ~ns1__CmPerformanceT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmPerformanceHistoryT
#define SOAP_TYPE_ns1__CmPerformanceHistoryT (65)
/* ns1:CmPerformanceHistoryT */
class SOAP_CMAC ns1__CmPerformanceHistoryT
{
public:
	ns1__CmPerformanceT *cmPerformance;	/* required element of type ns1:CmPerformanceT */
	std::string timeSec;	/* required element of type xsd:integer */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 65; } /* = unique id SOAP_TYPE_ns1__CmPerformanceHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmPerformanceHistoryT() : cmPerformance(NULL), soap(NULL) { }
	virtual ~ns1__CmPerformanceHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmCurrentPerformanceT
#define SOAP_TYPE_ns1__CmCurrentPerformanceT (66)
/* ns1:CmCurrentPerformanceT */
class SOAP_CMAC ns1__CmCurrentPerformanceT
{
public:
	ns1__CmPerformanceT *cmPerformance;	/* required element of type ns1:CmPerformanceT */
	std::string recordedTime;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 66; } /* = unique id SOAP_TYPE_ns1__CmCurrentPerformanceT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmCurrentPerformanceT() : cmPerformance(NULL), soap(NULL) { }
	virtual ~ns1__CmCurrentPerformanceT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTECustomerT
#define SOAP_TYPE_ns1__CTECustomerT (68)
/* ns1:CTECustomerT */
class SOAP_CMAC ns1__CTECustomerT
{
public:
	std::string *accountNumber;	/* optional element of type xsd:string */
	short *accountActive;	/* optional element of type xsd:short */
	std::string firstName;	/* required element of type xsd:string */
	std::string lastName;	/* required element of type xsd:string */
	std::string street1;	/* required element of type xsd:string */
	std::string *street2;	/* optional element of type xsd:string */
	std::string city;	/* required element of type xsd:string */
	std::string state;	/* required element of type xsd:string */
	std::string zip;	/* required element of type xsd:string */
	std::string phone1;	/* required element of type xsd:string */
	std::string *phone2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 68; } /* = unique id SOAP_TYPE_ns1__CTECustomerT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTECustomerT() : accountNumber(NULL), accountActive(NULL), street2(NULL), phone2(NULL), soap(NULL) { }
	virtual ~ns1__CTECustomerT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEAbstractMacT
#define SOAP_TYPE_ns1__CTEAbstractMacT (70)
/* ns1:CTEAbstractMacT */
class SOAP_CMAC ns1__CTEAbstractMacT
{
public:
	std::string mac;	/* required element of type xsd:string */
	std::string *fqdn;	/* optional element of type xsd:string */
	std::string *host;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 70; } /* = unique id SOAP_TYPE_ns1__CTEAbstractMacT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEAbstractMacT() : fqdn(NULL), host(NULL), soap(NULL) { }
	virtual ~ns1__CTEAbstractMacT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEAbstractNameT
#define SOAP_TYPE_ns1__CTEAbstractNameT (71)
/* ns1:CTEAbstractNameT */
class SOAP_CMAC ns1__CTEAbstractNameT
{
public:
	std::string name;	/* required element of type xsd:string */
	std::string *fqdn;	/* optional element of type xsd:string */
	std::string *host;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 71; } /* = unique id SOAP_TYPE_ns1__CTEAbstractNameT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEAbstractNameT() : fqdn(NULL), host(NULL), soap(NULL) { }
	virtual ~ns1__CTEAbstractNameT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEDataT
#define SOAP_TYPE_ns1__CTEDataT (72)
/* ns1:CTEDataT */
class SOAP_CMAC ns1__CTEDataT
{
public:
	ns1__CTECustomerT *customer;	/* required element of type ns1:CTECustomerT */
	ns1__CTEAbstractMacT *cm;	/* optional element of type ns1:CTEAbstractMacT */
	ns1__CTEAbstractMacT *mta;	/* optional element of type ns1:CTEAbstractMacT */
	ns1__CTEAbstractNameT *cmts;	/* optional element of type ns1:CTEAbstractNameT */
	ns1__CTEAbstractNameT *cms;	/* optional element of type ns1:CTEAbstractNameT */
	std::string *hfcName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 72; } /* = unique id SOAP_TYPE_ns1__CTEDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEDataT() : customer(NULL), cm(NULL), mta(NULL), cmts(NULL), cms(NULL), hfcName(NULL), soap(NULL) { }
	virtual ~ns1__CTEDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CTEQueryInputT
#define SOAP_TYPE_ns1__CTEQueryInputT (74)
/* ns1:CTEQueryInputT */
class SOAP_CMAC ns1__CTEQueryInputT
{
public:
	std::string *accountNumber;	/* optional element of type xsd:string */
	std::string *firstName;	/* optional element of type xsd:string */
	std::string *lastName;	/* optional element of type xsd:string */
	std::string *primaryPhone;	/* optional element of type xsd:string */
	std::string *cmMac;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 74; } /* = unique id SOAP_TYPE_ns1__CTEQueryInputT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CTEQueryInputT() : accountNumber(NULL), firstName(NULL), lastName(NULL), primaryPhone(NULL), cmMac(NULL), soap(NULL) { }
	virtual ~ns1__CTEQueryInputT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CMSLineT
#define SOAP_TYPE_ns1__CMSLineT (76)
/* ns1:CMSLineT */
class SOAP_CMAC ns1__CMSLineT
{
public:
	std::string number;	/* required element of type xsd:string */
	std::string status;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 76; } /* = unique id SOAP_TYPE_ns1__CMSLineT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CMSLineT() : soap(NULL) { }
	virtual ~ns1__CMSLineT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CMSResultT
#define SOAP_TYPE_ns1__CMSResultT (78)
/* ns1:CMSResultT */
class SOAP_CMAC ns1__CMSResultT
{
public:
	ns1__CMSLineT *line1;	/* required element of type ns1:CMSLineT */
	ns1__CMSLineT *line2;	/* optional element of type ns1:CMSLineT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 78; } /* = unique id SOAP_TYPE_ns1__CMSResultT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CMSResultT() : line1(NULL), line2(NULL), soap(NULL) { }
	virtual ~ns1__CMSResultT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UserAccessT
#define SOAP_TYPE_ns1__UserAccessT (79)
/* ns1:UserAccessT */
class SOAP_CMAC ns1__UserAccessT
{
public:
	enum ns1__UserAccessTypeT type;	/* required element of type ns1:UserAccessTypeT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 79; } /* = unique id SOAP_TYPE_ns1__UserAccessT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UserAccessT() : soap(NULL) { }
	virtual ~ns1__UserAccessT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ApplicationDomainT
#define SOAP_TYPE_ns1__ApplicationDomainT (81)
/* ns1:ApplicationDomainT */
class SOAP_CMAC ns1__ApplicationDomainT
{
public:
	enum ns1__ApplicationDomainTypeT type;	/* required element of type ns1:ApplicationDomainTypeT */
	class ArrayOfUserAccessT *accessRights;	/* optional element of type ArrayOfUserAccessT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 81; } /* = unique id SOAP_TYPE_ns1__ApplicationDomainT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ApplicationDomainT() : accessRights(NULL), soap(NULL) { }
	virtual ~ns1__ApplicationDomainT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__RoleT
#define SOAP_TYPE_ns1__RoleT (83)
/* ns1:RoleT */
class SOAP_CMAC ns1__RoleT
{
public:
	std::string roleName;	/* required element of type xsd:string */
	class ArrayOfApplicationDomainT *domains;	/* optional element of type ArrayOfApplicationDomainT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 83; } /* = unique id SOAP_TYPE_ns1__RoleT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__RoleT() : domains(NULL), soap(NULL) { }
	virtual ~ns1__RoleT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__UserT
#define SOAP_TYPE_ns1__UserT (85)
/* ns1:UserT */
class SOAP_CMAC ns1__UserT
{
public:
	std::string userId;	/* required element of type xsd:string */
	std::string firstName;	/* required element of type xsd:string */
	std::string lastName;	/* required element of type xsd:string */
	std::string *middleInitial;	/* optional element of type xsd:string */
	std::string location;	/* required element of type xsd:string */
	std::string loginName;	/* required element of type xsd:string */
	std::string *loginPassword;	/* optional element of type xsd:string */
	short *isActive;	/* optional element of type xsd:short */
	std::string *roleName;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 85; } /* = unique id SOAP_TYPE_ns1__UserT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__UserT() : middleInitial(NULL), loginPassword(NULL), isActive(NULL), roleName(NULL), soap(NULL) { }
	virtual ~ns1__UserT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__PollingIntervalsT
#define SOAP_TYPE_ns1__PollingIntervalsT (87)
/* ns1:PollingIntervalsT */
class SOAP_CMAC ns1__PollingIntervalsT
{
public:
	std::string cmtsPollInterval;	/* required element of type xsd:string */
	std::string cmPollInterval;	/* required element of type xsd:string */
	std::string mtaPollInterval;	/* required element of type xsd:string */
	std::string mtaPingInterval;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 87; } /* = unique id SOAP_TYPE_ns1__PollingIntervalsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__PollingIntervalsT() : soap(NULL) { }
	virtual ~ns1__PollingIntervalsT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AlarmBasedStatusThresholdT
#define SOAP_TYPE_ns1__AlarmBasedStatusThresholdT (88)
/* ns1:AlarmBasedStatusThresholdT */
class SOAP_CMAC ns1__AlarmBasedStatusThresholdT
{
public:
	enum ns1__StatusColorT color;	/* required element of type ns1:StatusColorT */
	std::string alarmType;	/* required element of type xsd:string */
	std::string alarmState;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 88; } /* = unique id SOAP_TYPE_ns1__AlarmBasedStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AlarmBasedStatusThresholdT() : soap(NULL) { }
	virtual ~ns1__AlarmBasedStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AggregateStatusThresholdT
#define SOAP_TYPE_ns1__AggregateStatusThresholdT (90)
/* ns1:AggregateStatusThresholdT */
class SOAP_CMAC ns1__AggregateStatusThresholdT
{
public:
	enum ns1__StatusColorT color;	/* required element of type ns1:StatusColorT */
	enum ns1__StatusColorT childColor;	/* required element of type ns1:StatusColorT */
	std::string thresholdPercent;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 90; } /* = unique id SOAP_TYPE_ns1__AggregateStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AggregateStatusThresholdT() : soap(NULL) { }
	virtual ~ns1__AggregateStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaStatusThresholdT
#define SOAP_TYPE_ns1__MtaStatusThresholdT (92)
/* ns1:MtaStatusThresholdT */
class SOAP_CMAC ns1__MtaStatusThresholdT
{
public:
	class ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 92; } /* = unique id SOAP_TYPE_ns1__MtaStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaStatusThresholdT() : alarmThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__MtaStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcStatusThresholdT
#define SOAP_TYPE_ns1__HfcStatusThresholdT (93)
/* ns1:HfcStatusThresholdT */
class SOAP_CMAC ns1__HfcStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	class ArrayOfAggregateStatusThresholdT *aggThreshArray;	/* required element of type ArrayOfAggregateStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 93; } /* = unique id SOAP_TYPE_ns1__HfcStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcStatusThresholdT() : alarmThreshArray(NULL), aggThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__HfcStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ChannelStatusThresholdT
#define SOAP_TYPE_ns1__ChannelStatusThresholdT (94)
/* ns1:ChannelStatusThresholdT */
class SOAP_CMAC ns1__ChannelStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	ArrayOfAggregateStatusThresholdT *aggThreshArray;	/* required element of type ArrayOfAggregateStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 94; } /* = unique id SOAP_TYPE_ns1__ChannelStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ChannelStatusThresholdT() : alarmThreshArray(NULL), aggThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__ChannelStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsStatusThresholdT
#define SOAP_TYPE_ns1__CmtsStatusThresholdT (95)
/* ns1:CmtsStatusThresholdT */
class SOAP_CMAC ns1__CmtsStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	ArrayOfAggregateStatusThresholdT *aggThreshArray;	/* required element of type ArrayOfAggregateStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 95; } /* = unique id SOAP_TYPE_ns1__CmtsStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsStatusThresholdT() : alarmThreshArray(NULL), aggThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__CmtsStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmsStatusThresholdT
#define SOAP_TYPE_ns1__CmsStatusThresholdT (96)
/* ns1:CmsStatusThresholdT */
class SOAP_CMAC ns1__CmsStatusThresholdT
{
public:
	ArrayOfAlarmStatusThresholdT *alarmThreshArray;	/* required element of type ArrayOfAlarmBasedStatusThresholdT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 96; } /* = unique id SOAP_TYPE_ns1__CmsStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmsStatusThresholdT() : alarmThreshArray(NULL), soap(NULL) { }
	virtual ~ns1__CmsStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__SoakWindowT
#define SOAP_TYPE_ns1__SoakWindowT (97)
/* ns1:SoakWindowT */
class SOAP_CMAC ns1__SoakWindowT
{
public:
	std::string soakWindow_USCORE1_USCOREStartTime;	/* required element of type xsd:string */
	std::string soakWindow_USCORE1_USCOREDuration;	/* required element of type xsd:string */
	std::string soakWindow_USCORE2_USCOREStartTime;	/* required element of type xsd:string */
	std::string soakWindow_USCORE2_USCOREDuration;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 97; } /* = unique id SOAP_TYPE_ns1__SoakWindowT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__SoakWindowT() : soap(NULL) { }
	virtual ~ns1__SoakWindowT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AggregateCmOfflineTresholdT
#define SOAP_TYPE_ns1__AggregateCmOfflineTresholdT (98)
/* ns1:AggregateCmOfflineTresholdT */
class SOAP_CMAC ns1__AggregateCmOfflineTresholdT
{
public:
	std::string percentCmOffline_USCORE1;	/* required element of type xsd:string */
	std::string maxCm_USCORE1;	/* required element of type xsd:string */
	std::string percentCmOffline_USCORE2;	/* required element of type xsd:string */
	std::string maxCm_USCORE2;	/* required element of type xsd:string */
	std::string detectionWindow;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 98; } /* = unique id SOAP_TYPE_ns1__AggregateCmOfflineTresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AggregateCmOfflineTresholdT() : soap(NULL) { }
	virtual ~ns1__AggregateCmOfflineTresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AggregateMtaTresholdT
#define SOAP_TYPE_ns1__AggregateMtaTresholdT (99)
/* ns1:AggregateMtaTresholdT */
class SOAP_CMAC ns1__AggregateMtaTresholdT
{
public:
	std::string mtaThresholdCount;	/* required element of type xsd:string */
	std::string detectionWindow;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 99; } /* = unique id SOAP_TYPE_ns1__AggregateMtaTresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AggregateMtaTresholdT() : soap(NULL) { }
	virtual ~ns1__AggregateMtaTresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcPowerTresholdT
#define SOAP_TYPE_ns1__HfcPowerTresholdT (100)
/* ns1:HfcPowerTresholdT */
class SOAP_CMAC ns1__HfcPowerTresholdT
{
public:
	std::string thresholdCount;	/* required element of type xsd:string */
	std::string detectionWindow;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 100; } /* = unique id SOAP_TYPE_ns1__HfcPowerTresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcPowerTresholdT() : soap(NULL) { }
	virtual ~ns1__HfcPowerTresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcAlarmConfigT
#define SOAP_TYPE_ns1__HfcAlarmConfigT (101)
/* ns1:HfcAlarmConfigT */
class SOAP_CMAC ns1__HfcAlarmConfigT
{
public:
	ns1__AggregateCmOfflineTresholdT *cmThresold;	/* required element of type ns1:AggregateCmOfflineTresholdT */
	ns1__SoakWindowT *cmSoakWindow;	/* required element of type ns1:SoakWindowT */
	ns1__AggregateMtaTresholdT *mtaThresold;	/* required element of type ns1:AggregateMtaTresholdT */
	ns1__SoakWindowT *mtaSoakWindow;	/* required element of type ns1:SoakWindowT */
	ns1__HfcPowerTresholdT *powerThresold;	/* required element of type ns1:HfcPowerTresholdT */
	ns1__SoakWindowT *powerSoakWindow;	/* required element of type ns1:SoakWindowT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 101; } /* = unique id SOAP_TYPE_ns1__HfcAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcAlarmConfigT() : cmThresold(NULL), cmSoakWindow(NULL), mtaThresold(NULL), mtaSoakWindow(NULL), powerThresold(NULL), powerSoakWindow(NULL), soap(NULL) { }
	virtual ~ns1__HfcAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__AlarmTypeConfigT
#define SOAP_TYPE_ns1__AlarmTypeConfigT (102)
/* ns1:AlarmTypeConfigT */
class SOAP_CMAC ns1__AlarmTypeConfigT
{
public:
	std::string alarmType;	/* required element of type xsd:string */
	ns1__SoakWindowT *soakWindow;	/* required element of type ns1:SoakWindowT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 102; } /* = unique id SOAP_TYPE_ns1__AlarmTypeConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__AlarmTypeConfigT() : soakWindow(NULL), soap(NULL) { }
	virtual ~ns1__AlarmTypeConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaAlarmConfigT
#define SOAP_TYPE_ns1__MtaAlarmConfigT (104)
/* ns1:MtaAlarmConfigT */
class SOAP_CMAC ns1__MtaAlarmConfigT
{
public:
	class ArrayOfAlarmTypeConfigT *alarmTypes;	/* required element of type ArrayOfAlarmTypeConfigT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 104; } /* = unique id SOAP_TYPE_ns1__MtaAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaAlarmConfigT() : alarmTypes(NULL), soap(NULL) { }
	virtual ~ns1__MtaAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsAlarmConfigT
#define SOAP_TYPE_ns1__CmtsAlarmConfigT (105)
/* ns1:CmtsAlarmConfigT */
class SOAP_CMAC ns1__CmtsAlarmConfigT
{
public:
	ns1__AlarmTypeConfigT *cmtsDown;	/* required element of type ns1:AlarmTypeConfigT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 105; } /* = unique id SOAP_TYPE_ns1__CmtsAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsAlarmConfigT() : cmtsDown(NULL), soap(NULL) { }
	virtual ~ns1__CmtsAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmsAlarmConfigT
#define SOAP_TYPE_ns1__CmsAlarmConfigT (106)
/* ns1:CmsAlarmConfigT */
class SOAP_CMAC ns1__CmsAlarmConfigT
{
public:
	ns1__AlarmTypeConfigT *cmsLossOfComm;	/* required element of type ns1:AlarmTypeConfigT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 106; } /* = unique id SOAP_TYPE_ns1__CmsAlarmConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmsAlarmConfigT() : cmsLossOfComm(NULL), soap(NULL) { }
	virtual ~ns1__CmsAlarmConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmPerformanceConfigT
#define SOAP_TYPE_ns1__CmPerformanceConfigT (107)
/* ns1:CmPerformanceConfigT */
class SOAP_CMAC ns1__CmPerformanceConfigT
{
public:
	std::string downstreamSnrLower;	/* required element of type xsd:string */
	std::string downstreamPowerLower;	/* required element of type xsd:string */
	std::string downstreamPowerUpper;	/* required element of type xsd:string */
	std::string upstreamPowerLower;	/* required element of type xsd:string */
	std::string upstreamPowerUpper;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 107; } /* = unique id SOAP_TYPE_ns1__CmPerformanceConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmPerformanceConfigT() : soap(NULL) { }
	virtual ~ns1__CmPerformanceConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__ConfigDownloadT
#define SOAP_TYPE_ns1__ConfigDownloadT (108)
/* ns1:ConfigDownloadT */
class SOAP_CMAC ns1__ConfigDownloadT
{
public:
	ns1__CmPerformanceConfigT *cmPerfCfg;	/* optional element of type ns1:CmPerformanceConfigT */
	ns1__CmsAlarmConfigT *cmsAlarmCfg;	/* optional element of type ns1:CmsAlarmConfigT */
	ns1__CmtsAlarmConfigT *cmtsAlarmCfg;	/* optional element of type ns1:CmtsAlarmConfigT */
	ns1__MtaAlarmConfigT *mtaAlarmCfg;	/* optional element of type ns1:MtaAlarmConfigT */
	ns1__HfcAlarmConfigT *hfcAlarmCfg;	/* optional element of type ns1:HfcAlarmConfigT */
	ns1__PollingIntervalsT *pollingIntervals;	/* optional element of type ns1:PollingIntervalsT */
	ArrayOfUserAccessT *userAccessRights;	/* optional element of type ArrayOfUserAccessT */
	ArrayOfApplicationDomainT *applicationDomains;	/* optional element of type ArrayOfApplicationDomainT */
	class ArrayOfRoleT *roles;	/* optional element of type ArrayOfRoleT */
	class ArrayOfUserT *users;	/* optional element of type ArrayOfUserT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 108; } /* = unique id SOAP_TYPE_ns1__ConfigDownloadT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__ConfigDownloadT() : cmPerfCfg(NULL), cmsAlarmCfg(NULL), cmtsAlarmCfg(NULL), mtaAlarmCfg(NULL), hfcAlarmCfg(NULL), pollingIntervals(NULL), userAccessRights(NULL), applicationDomains(NULL), roles(NULL), users(NULL), soap(NULL) { }
	virtual ~ns1__ConfigDownloadT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmtsCmDataT
#define SOAP_TYPE_ns1__CmtsCmDataT (109)
/* ns1:CmtsCmDataT */
class SOAP_CMAC ns1__CmtsCmDataT
{
public:
	std::string cmIpAddress;	/* required element of type xsd:string */
	std::string cmMac;	/* required element of type xsd:string */
	std::string upstreamChannelIndex;	/* required element of type xsd:string */
	std::string downstreamChannelIndex;	/* required element of type xsd:string */
	std::string cmIndex;	/* required element of type xsd:string */
	std::string cmStatus;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 109; } /* = unique id SOAP_TYPE_ns1__CmtsCmDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmtsCmDataT() : soap(NULL) { }
	virtual ~ns1__CmtsCmDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmDataT
#define SOAP_TYPE_ns1__CmDataT (110)
/* ns1:CmDataT */
class SOAP_CMAC ns1__CmDataT
{
public:
	std::string mac;	/* required element of type xsd:string */
	std::string host;	/* required element of type xsd:string */
	std::string cmIndex;	/* required element of type xsd:string */
	std::string downstreamSNR;	/* required element of type xsd:string */
	std::string downstreamPower;	/* required element of type xsd:string */
	std::string upstreamPower;	/* required element of type xsd:string */
	std::string t1Count;	/* required element of type xsd:string */
	std::string t2Count;	/* required element of type xsd:string */
	std::string t3Count;	/* required element of type xsd:string */
	std::string t4Count;	/* required element of type xsd:string */
	std::string *field1;	/* optional element of type xsd:string */
	std::string *field2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 110; } /* = unique id SOAP_TYPE_ns1__CmDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmDataT() : field1(NULL), field2(NULL), soap(NULL) { }
	virtual ~ns1__CmDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaDataT
#define SOAP_TYPE_ns1__MtaDataT (111)
/* ns1:MtaDataT */
class SOAP_CMAC ns1__MtaDataT
{
public:
	std::string provStatus;	/* required element of type xsd:string */
	std::string provCounter;	/* required element of type xsd:string */
	std::string *pingStatus;	/* optional element of type xsd:string */
	std::string *batteryStatus1;	/* optional element of type xsd:string */
	std::string *batteryStatus2;	/* optional element of type xsd:string */
	std::string *field1;	/* optional element of type xsd:string */
	std::string *field2;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 111; } /* = unique id SOAP_TYPE_ns1__MtaDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaDataT() : pingStatus(NULL), batteryStatus1(NULL), batteryStatus2(NULL), field1(NULL), field2(NULL), soap(NULL) { }
	virtual ~ns1__MtaDataT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__StatusSummaryT
#define SOAP_TYPE_ns1__StatusSummaryT (112)
/* ns1:StatusSummaryT */
class SOAP_CMAC ns1__StatusSummaryT
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string resId;	/* required element of type xsd:integer */
	std::string name;	/* required element of type xsd:string */
	std::string sumRedStatusTime;	/* required element of type xsd:integer */
	std::string sumGreenStatusTime;	/* required element of type xsd:integer */
	short sumStateChanges;	/* required element of type xsd:short */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 112; } /* = unique id SOAP_TYPE_ns1__StatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__StatusSummaryT() : topologyKey(NULL), soap(NULL) { }
	virtual ~ns1__StatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcStatusSummaryT
#define SOAP_TYPE_ns1__HfcStatusSummaryT (113)
/* ns1:HfcStatusSummaryT */
class SOAP_CMAC ns1__HfcStatusSummaryT
{
public:
	ns1__StatusSummaryT *statusSummary;	/* required element of type ns1:StatusSummaryT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 113; } /* = unique id SOAP_TYPE_ns1__HfcStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcStatusSummaryT() : statusSummary(NULL), soap(NULL) { }
	virtual ~ns1__HfcStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaStatusSummaryT
#define SOAP_TYPE_ns1__MtaStatusSummaryT (115)
/* ns1:MtaStatusSummaryT */
class SOAP_CMAC ns1__MtaStatusSummaryT
{
public:
	ns1__StatusSummaryT *statusSummary;	/* required element of type ns1:StatusSummaryT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string hfcName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 115; } /* = unique id SOAP_TYPE_ns1__MtaStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaStatusSummaryT() : statusSummary(NULL), soap(NULL) { }
	virtual ~ns1__MtaStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusSummaryT
#define SOAP_TYPE_ns1__CmStatusSummaryT (117)
/* ns1:CmStatusSummaryT */
class SOAP_CMAC ns1__CmStatusSummaryT
{
public:
	ns1__StatusSummaryT *statusSummary;	/* required element of type ns1:StatusSummaryT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmtsName;	/* required element of type xsd:string */
	std::string hfcResId;	/* required element of type xsd:integer */
	std::string hfcName;	/* required element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 117; } /* = unique id SOAP_TYPE_ns1__CmStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusSummaryT() : statusSummary(NULL), soap(NULL) { }
	virtual ~ns1__CmStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__MtaStatusSummaryRespT
#define SOAP_TYPE_ns1__MtaStatusSummaryRespT (119)
/* ns1:MtaStatusSummaryRespT */
class SOAP_CMAC ns1__MtaStatusSummaryRespT
{
public:
	class ArrayOfMtaStatusSummaryT *mtaData;	/* required element of type ArrayOfMtaStatusSummaryT */
	class ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 119; } /* = unique id SOAP_TYPE_ns1__MtaStatusSummaryRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__MtaStatusSummaryRespT() : mtaData(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__MtaStatusSummaryRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HfcStatusSummaryRespT
#define SOAP_TYPE_ns1__HfcStatusSummaryRespT (120)
/* ns1:HfcStatusSummaryRespT */
class SOAP_CMAC ns1__HfcStatusSummaryRespT
{
public:
	class ArrayOfHfcStatusSummaryT *hfcData;	/* required element of type ArrayOfHfcStatusSummaryT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 120; } /* = unique id SOAP_TYPE_ns1__HfcStatusSummaryRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HfcStatusSummaryRespT() : hfcData(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__HfcStatusSummaryRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CmStatusSummaryRespT
#define SOAP_TYPE_ns1__CmStatusSummaryRespT (121)
/* ns1:CmStatusSummaryRespT */
class SOAP_CMAC ns1__CmStatusSummaryRespT
{
public:
	class ArrayOfCmStatusSummaryT *cmData;	/* required element of type ArrayOfCmStatusSummaryT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 121; } /* = unique id SOAP_TYPE_ns1__CmStatusSummaryRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CmStatusSummaryRespT() : cmData(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__CmStatusSummaryRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__CurrentAlarmsRespT
#define SOAP_TYPE_ns1__CurrentAlarmsRespT (122)
/* ns1:CurrentAlarmsRespT */
class SOAP_CMAC ns1__CurrentAlarmsRespT
{
public:
	class ArrayOfCurrentAlarmsT *alarms;	/* required element of type ArrayOfCurrentAlarmT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 122; } /* = unique id SOAP_TYPE_ns1__CurrentAlarmsRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__CurrentAlarmsRespT() : alarms(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__CurrentAlarmsRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__HistoricalAlarmsRespT
#define SOAP_TYPE_ns1__HistoricalAlarmsRespT (123)
/* ns1:HistoricalAlarmsRespT */
class SOAP_CMAC ns1__HistoricalAlarmsRespT
{
public:
	class ArrayOfHistoricalAlarmsT *alarms;	/* required element of type ArrayOfHistoricalAlarmT */
	ArrayOfQueryStateT *queryState;	/* required element of type ArrayOfQueryStateT */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 123; } /* = unique id SOAP_TYPE_ns1__HistoricalAlarmsRespT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__HistoricalAlarmsRespT() : alarms(NULL), queryState(NULL), soap(NULL) { }
	virtual ~ns1__HistoricalAlarmsRespT() { }
};
#endif

#ifndef SOAP_TYPE_ns1__EventMessageT
#define SOAP_TYPE_ns1__EventMessageT (124)
/* ns1:EventMessageT */
class SOAP_CMAC ns1__EventMessageT
{
public:
	enum ns1__EventTypeT eventType;	/* required element of type ns1:EventTypeT */
	enum ns1__EventCategoryT eventCategory;	/* required element of type ns1:EventCategoryT */
	std::string eventSubCategory;	/* required element of type xsd:string */
	std::string *objectId;	/* optional element of type xsd:string */
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 124; } /* = unique id SOAP_TYPE_ns1__EventMessageT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ns1__EventMessageT() : objectId(NULL), soap(NULL) { }
	virtual ~ns1__EventMessageT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfRegionsT
#define SOAP_TYPE_ArrayOfRegionsT (32)
/* SOAP encoded array of ns1:RegionT schema type: */
class SOAP_CMAC ArrayOfRegionsT
{
public:
	ns1__RegionT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 32; } /* = unique id SOAP_TYPE_ArrayOfRegionsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfRegionsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfRegionsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMarketsT
#define SOAP_TYPE_ArrayOfMarketsT (33)
/* SOAP encoded array of ns1:MarketT schema type: */
class SOAP_CMAC ArrayOfMarketsT
{
public:
	ns1__MarketT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 33; } /* = unique id SOAP_TYPE_ArrayOfMarketsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMarketsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMarketsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfBladesT
#define SOAP_TYPE_ArrayOfBladesT (34)
/* SOAP encoded array of ns1:BladeT schema type: */
class SOAP_CMAC ArrayOfBladesT
{
public:
	ns1__BladeT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 34; } /* = unique id SOAP_TYPE_ArrayOfBladesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfBladesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfBladesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmsesT
#define SOAP_TYPE_ArrayOfCmsesT (35)
/* SOAP encoded array of ns1:CmsT schema type: */
class SOAP_CMAC ArrayOfCmsesT
{
public:
	ns1__CmsT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 35; } /* = unique id SOAP_TYPE_ArrayOfCmsesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmsesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmsesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmtsesT
#define SOAP_TYPE_ArrayOfCmtsesT (36)
/* SOAP encoded array of ns1:CmtsT schema type: */
class SOAP_CMAC ArrayOfCmtsesT
{
public:
	ns1__CmtsT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 36; } /* = unique id SOAP_TYPE_ArrayOfCmtsesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmtsesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmtsesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfSnmpV2CAttributesT
#define SOAP_TYPE_ArrayOfSnmpV2CAttributesT (37)
/* SOAP encoded array of ns1:SnmpV2CAttributesT schema type: */
class SOAP_CMAC ArrayOfSnmpV2CAttributesT
{
public:
	ns1__SnmpV2CAttributesT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 37; } /* = unique id SOAP_TYPE_ArrayOfSnmpV2CAttributesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfSnmpV2CAttributesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfSnmpV2CAttributesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfChannelsT
#define SOAP_TYPE_ArrayOfChannelsT (38)
/* SOAP encoded array of ns1:ChannelT schema type: */
class SOAP_CMAC ArrayOfChannelsT
{
public:
	ns1__ChannelT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 38; } /* = unique id SOAP_TYPE_ArrayOfChannelsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfChannelsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfChannelsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfHfcsT
#define SOAP_TYPE_ArrayOfHfcsT (39)
/* SOAP encoded array of ns1:HfcT schema type: */
class SOAP_CMAC ArrayOfHfcsT
{
public:
	ns1__HfcT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 39; } /* = unique id SOAP_TYPE_ArrayOfHfcsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfHfcsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfHfcsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCableModemsT
#define SOAP_TYPE_ArrayOfCableModemsT (40)
/* SOAP encoded array of ns1:CableModemT schema type: */
class SOAP_CMAC ArrayOfCableModemsT
{
public:
	ns1__CableModemT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 40; } /* = unique id SOAP_TYPE_ArrayOfCableModemsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCableModemsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCableModemsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfEmtasT
#define SOAP_TYPE_ArrayOfEmtasT (41)
/* SOAP encoded array of ns1:EmtaT schema type: */
class SOAP_CMAC ArrayOfEmtasT
{
public:
	ns1__EmtaT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 41; } /* = unique id SOAP_TYPE_ArrayOfEmtasT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfEmtasT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfEmtasT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCurrentAlarmsT
#define SOAP_TYPE_ArrayOfCurrentAlarmsT (42)
/* SOAP encoded array of ns1:CurrentAlarmT schema type: */
class SOAP_CMAC ArrayOfCurrentAlarmsT
{
public:
	ns1__CurrentAlarmT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 42; } /* = unique id SOAP_TYPE_ArrayOfCurrentAlarmsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCurrentAlarmsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCurrentAlarmsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfHistoricalAlarmsT
#define SOAP_TYPE_ArrayOfHistoricalAlarmsT (43)
/* SOAP encoded array of ns1:HistoricalAlarmT schema type: */
class SOAP_CMAC ArrayOfHistoricalAlarmsT
{
public:
	ns1__HistoricalAlarmT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 43; } /* = unique id SOAP_TYPE_ArrayOfHistoricalAlarmsT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfHistoricalAlarmsT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfHistoricalAlarmsT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAlarmHistoriesT
#define SOAP_TYPE_ArrayOfAlarmHistoriesT (44)
/* SOAP encoded array of ns1:AlarmHistoryT schema type: */
class SOAP_CMAC ArrayOfAlarmHistoriesT
{
public:
	ns1__AlarmHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 44; } /* = unique id SOAP_TYPE_ArrayOfAlarmHistoriesT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAlarmHistoriesT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAlarmHistoriesT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfScrollPageT
#define SOAP_TYPE_ArrayOfScrollPageT (47)
/* SOAP encoded array of ns1:ScrollPageT schema type: */
class SOAP_CMAC ArrayOfScrollPageT
{
public:
	ns1__ScrollPageT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 47; } /* = unique id SOAP_TYPE_ArrayOfScrollPageT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfScrollPageT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfScrollPageT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfQueryStateT
#define SOAP_TYPE_ArrayOfQueryStateT (49)
/* SOAP encoded array of ns1:QueryStateT schema type: */
class SOAP_CMAC ArrayOfQueryStateT
{
public:
	ns1__QueryStateT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 49; } /* = unique id SOAP_TYPE_ArrayOfQueryStateT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfQueryStateT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfQueryStateT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfGenericCountsHistoryT
#define SOAP_TYPE_ArrayOfGenericCountsHistoryT (51)
/* SOAP encoded array of ns1:GenericCountsHistoryT schema type: */
class SOAP_CMAC ArrayOfGenericCountsHistoryT
{
public:
	ns1__GenericCountsHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 51; } /* = unique id SOAP_TYPE_ArrayOfGenericCountsHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfGenericCountsHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfGenericCountsHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmStatusHistoryT
#define SOAP_TYPE_ArrayOfCmStatusHistoryT (54)
/* SOAP encoded array of ns1:CmStatusHistoryT schema type: */
class SOAP_CMAC ArrayOfCmStatusHistoryT
{
public:
	ns1__CmStatusHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 54; } /* = unique id SOAP_TYPE_ArrayOfCmStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmStatusHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT
#define SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT (57)
/* SOAP encoded array of ns1:MtaAvailabilityHistoryT schema type: */
class SOAP_CMAC ArrayOfMtaAvailabilityHistoryT
{
public:
	ns1__MtaAvailabilityHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 57; } /* = unique id SOAP_TYPE_ArrayOfMtaAvailabilityHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaAvailabilityHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaAvailabilityHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaProvStatusHistoryT
#define SOAP_TYPE_ArrayOfMtaProvStatusHistoryT (60)
/* SOAP encoded array of ns1:MtaProvStatusHistoryT schema type: */
class SOAP_CMAC ArrayOfMtaProvStatusHistoryT
{
public:
	ns1__MtaProvStatusHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 60; } /* = unique id SOAP_TYPE_ArrayOfMtaProvStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaProvStatusHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaProvStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaPingStatusHistoryT
#define SOAP_TYPE_ArrayOfMtaPingStatusHistoryT (63)
/* SOAP encoded array of ns1:MtaPingStatusHistoryT schema type: */
class SOAP_CMAC ArrayOfMtaPingStatusHistoryT
{
public:
	ns1__MtaPingStatusHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 63; } /* = unique id SOAP_TYPE_ArrayOfMtaPingStatusHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaPingStatusHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaPingStatusHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmPerformanceHistoryT
#define SOAP_TYPE_ArrayOfCmPerformanceHistoryT (67)
/* SOAP encoded array of ns1:CmPerformanceHistoryT schema type: */
class SOAP_CMAC ArrayOfCmPerformanceHistoryT
{
public:
	ns1__CmPerformanceHistoryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 67; } /* = unique id SOAP_TYPE_ArrayOfCmPerformanceHistoryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmPerformanceHistoryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmPerformanceHistoryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCTECustomerT
#define SOAP_TYPE_ArrayOfCTECustomerT (69)
/* SOAP encoded array of ns1:CTECustomerT schema type: */
class SOAP_CMAC ArrayOfCTECustomerT
{
public:
	ns1__CTECustomerT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 69; } /* = unique id SOAP_TYPE_ArrayOfCTECustomerT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCTECustomerT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCTECustomerT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCTEDataT
#define SOAP_TYPE_ArrayOfCTEDataT (73)
/* SOAP encoded array of ns1:CTEDataT schema type: */
class SOAP_CMAC ArrayOfCTEDataT
{
public:
	ns1__CTEDataT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 73; } /* = unique id SOAP_TYPE_ArrayOfCTEDataT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCTEDataT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCTEDataT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCTEQueryInputT
#define SOAP_TYPE_ArrayOfCTEQueryInputT (75)
/* SOAP encoded array of ns1:CTEQueryInputT schema type: */
class SOAP_CMAC ArrayOfCTEQueryInputT
{
public:
	ns1__CTEQueryInputT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 75; } /* = unique id SOAP_TYPE_ArrayOfCTEQueryInputT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCTEQueryInputT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCTEQueryInputT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCMSLineT
#define SOAP_TYPE_ArrayOfCMSLineT (77)
/* SOAP encoded array of ns1:CMSLineT schema type: */
class SOAP_CMAC ArrayOfCMSLineT
{
public:
	ns1__CMSLineT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 77; } /* = unique id SOAP_TYPE_ArrayOfCMSLineT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCMSLineT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCMSLineT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfUserAccessT
#define SOAP_TYPE_ArrayOfUserAccessT (80)
/* SOAP encoded array of ns1:UserAccessT schema type: */
class SOAP_CMAC ArrayOfUserAccessT
{
public:
	ns1__UserAccessT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 80; } /* = unique id SOAP_TYPE_ArrayOfUserAccessT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfUserAccessT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfUserAccessT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfApplicationDomainT
#define SOAP_TYPE_ArrayOfApplicationDomainT (82)
/* SOAP encoded array of ns1:ApplicationDomainT schema type: */
class SOAP_CMAC ArrayOfApplicationDomainT
{
public:
	ns1__ApplicationDomainT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 82; } /* = unique id SOAP_TYPE_ArrayOfApplicationDomainT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfApplicationDomainT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfApplicationDomainT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfRoleT
#define SOAP_TYPE_ArrayOfRoleT (84)
/* SOAP encoded array of ns1:RoleT schema type: */
class SOAP_CMAC ArrayOfRoleT
{
public:
	ns1__RoleT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 84; } /* = unique id SOAP_TYPE_ArrayOfRoleT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfRoleT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfRoleT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfUserT
#define SOAP_TYPE_ArrayOfUserT (86)
/* SOAP encoded array of ns1:UserT schema type: */
class SOAP_CMAC ArrayOfUserT
{
public:
	ns1__UserT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 86; } /* = unique id SOAP_TYPE_ArrayOfUserT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfUserT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfUserT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAlarmStatusThresholdT
#define SOAP_TYPE_ArrayOfAlarmStatusThresholdT (89)
/* SOAP encoded array of ns1:AlarmBasedStatusThresholdT schema type: */
class SOAP_CMAC ArrayOfAlarmStatusThresholdT
{
public:
	ns1__AlarmBasedStatusThresholdT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 89; } /* = unique id SOAP_TYPE_ArrayOfAlarmStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAlarmStatusThresholdT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAlarmStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAggregateStatusThresholdT
#define SOAP_TYPE_ArrayOfAggregateStatusThresholdT (91)
/* SOAP encoded array of ns1:AggregateStatusThresholdT schema type: */
class SOAP_CMAC ArrayOfAggregateStatusThresholdT
{
public:
	ns1__AggregateStatusThresholdT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 91; } /* = unique id SOAP_TYPE_ArrayOfAggregateStatusThresholdT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAggregateStatusThresholdT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAggregateStatusThresholdT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfAlarmTypeConfigT
#define SOAP_TYPE_ArrayOfAlarmTypeConfigT (103)
/* SOAP encoded array of ns1:AlarmTypeConfigT schema type: */
class SOAP_CMAC ArrayOfAlarmTypeConfigT
{
public:
	ns1__AlarmTypeConfigT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 103; } /* = unique id SOAP_TYPE_ArrayOfAlarmTypeConfigT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfAlarmTypeConfigT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfAlarmTypeConfigT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfHfcStatusSummaryT
#define SOAP_TYPE_ArrayOfHfcStatusSummaryT (114)
/* SOAP encoded array of ns1:HfcStatusSummaryT schema type: */
class SOAP_CMAC ArrayOfHfcStatusSummaryT
{
public:
	ns1__HfcStatusSummaryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 114; } /* = unique id SOAP_TYPE_ArrayOfHfcStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfHfcStatusSummaryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfHfcStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfMtaStatusSummaryT
#define SOAP_TYPE_ArrayOfMtaStatusSummaryT (116)
/* SOAP encoded array of ns1:MtaStatusSummaryT schema type: */
class SOAP_CMAC ArrayOfMtaStatusSummaryT
{
public:
	ns1__MtaStatusSummaryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 116; } /* = unique id SOAP_TYPE_ArrayOfMtaStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfMtaStatusSummaryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfMtaStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_ArrayOfCmStatusSummaryT
#define SOAP_TYPE_ArrayOfCmStatusSummaryT (118)
/* SOAP encoded array of ns1:CmStatusSummaryT schema type: */
class SOAP_CMAC ArrayOfCmStatusSummaryT
{
public:
	ns1__CmStatusSummaryT **__ptr;
	int __size;
	struct soap *soap;	/* transient */
public:
	virtual int soap_type() const { return 118; } /* = unique id SOAP_TYPE_ArrayOfCmStatusSummaryT */
	virtual void soap_default(struct soap*);
	virtual void soap_serialize(struct soap*) const;
	virtual int soap_put(struct soap*, const char*, const char*) const;
	virtual int soap_out(struct soap*, const char*, int, const char*) const;
	virtual void *soap_get(struct soap*, const char*, const char*);
	virtual void *soap_in(struct soap*, const char*, const char*);
	         ArrayOfCmStatusSummaryT() : __ptr(NULL), soap(NULL) { }
	virtual ~ArrayOfCmStatusSummaryT() { }
};
#endif

#ifndef SOAP_TYPE_adm__updateCmtsResponse
#define SOAP_TYPE_adm__updateCmtsResponse (249)
/* adm:updateCmtsResponse */
struct adm__updateCmtsResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmts
#define SOAP_TYPE_adm__updateCmts (250)
/* adm:updateCmts */
struct adm__updateCmts
{
public:
	ns1__CmtsT *cmts;	/* optional element of type ns1:CmtsT */
};
#endif

#ifndef SOAP_TYPE_adm__addCmtsResponse
#define SOAP_TYPE_adm__addCmtsResponse (252)
/* adm:addCmtsResponse */
struct adm__addCmtsResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__addCmts
#define SOAP_TYPE_adm__addCmts (253)
/* adm:addCmts */
struct adm__addCmts
{
public:
	ns1__CmtsT *cmts;	/* optional element of type ns1:CmtsT */
};
#endif

#ifndef SOAP_TYPE_adm__deleteCmtsResponse
#define SOAP_TYPE_adm__deleteCmtsResponse (255)
/* adm:deleteCmtsResponse */
struct adm__deleteCmtsResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__deleteCmts
#define SOAP_TYPE_adm__deleteCmts (256)
/* adm:deleteCmts */
struct adm__deleteCmts
{
public:
	ns1__CmtsT *cmts;	/* optional element of type ns1:CmtsT */
};
#endif

#ifndef SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse
#define SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributesResponse (259)
/* adm:addCmtsAllSnmpV2CAttributesResponse */
struct adm__addCmtsAllSnmpV2CAttributesResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes
#define SOAP_TYPE_adm__addCmtsAllSnmpV2CAttributes (260)
/* adm:addCmtsAllSnmpV2CAttributes */
struct adm__addCmtsAllSnmpV2CAttributes
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	ArrayOfSnmpV2CAttributesT *attributes;	/* optional element of type ArrayOfSnmpV2CAttributesT */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse
#define SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributesResponse (262)
/* adm:updateCmtsAllSnmpV2CAttributesResponse */
struct adm__updateCmtsAllSnmpV2CAttributesResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes
#define SOAP_TYPE_adm__updateCmtsAllSnmpV2CAttributes (263)
/* adm:updateCmtsAllSnmpV2CAttributes */
struct adm__updateCmtsAllSnmpV2CAttributes
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	ArrayOfSnmpV2CAttributesT *attributes;	/* optional element of type ArrayOfSnmpV2CAttributesT */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmsResponse
#define SOAP_TYPE_adm__updateCmsResponse (265)
/* adm:updateCmsResponse */
struct adm__updateCmsResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCms
#define SOAP_TYPE_adm__updateCms (266)
/* adm:updateCms */
struct adm__updateCms
{
public:
	ns1__CmsT *cms;	/* optional element of type ns1:CmsT */
};
#endif

#ifndef SOAP_TYPE_adm__addCmsResponse
#define SOAP_TYPE_adm__addCmsResponse (268)
/* adm:addCmsResponse */
struct adm__addCmsResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__addCms
#define SOAP_TYPE_adm__addCms (269)
/* adm:addCms */
struct adm__addCms
{
public:
	ns1__CmsT *cms;	/* optional element of type ns1:CmsT */
};
#endif

#ifndef SOAP_TYPE_adm__deleteCmsResponse
#define SOAP_TYPE_adm__deleteCmsResponse (271)
/* adm:deleteCmsResponse */
struct adm__deleteCmsResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__deleteCms
#define SOAP_TYPE_adm__deleteCms (272)
/* adm:deleteCms */
struct adm__deleteCms
{
public:
	ns1__CmsT *cms;	/* optional element of type ns1:CmsT */
};
#endif

#ifndef SOAP_TYPE_adm__getPollingIntervalsResponse
#define SOAP_TYPE_adm__getPollingIntervalsResponse (273)
/* adm:getPollingIntervalsResponse */
struct adm__getPollingIntervalsResponse
{
public:
	ns1__PollingIntervalsT *pollingInterval;	/* RPC return element */	/* optional element of type ns1:PollingIntervalsT */
};
#endif

#ifndef SOAP_TYPE_adm__getPollingIntervals
#define SOAP_TYPE_adm__getPollingIntervals (276)
/* adm:getPollingIntervals */
struct adm__getPollingIntervals
{
};
#endif

#ifndef SOAP_TYPE_adm__updatePollingIntervalsResponse
#define SOAP_TYPE_adm__updatePollingIntervalsResponse (278)
/* adm:updatePollingIntervalsResponse */
struct adm__updatePollingIntervalsResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updatePollingIntervals
#define SOAP_TYPE_adm__updatePollingIntervals (279)
/* adm:updatePollingIntervals */
struct adm__updatePollingIntervals
{
public:
	ns1__PollingIntervalsT *pollintInterval;	/* optional element of type ns1:PollingIntervalsT */
};
#endif

#ifndef SOAP_TYPE_adm__getMtaStatusThresholdResponse
#define SOAP_TYPE_adm__getMtaStatusThresholdResponse (280)
/* adm:getMtaStatusThresholdResponse */
struct adm__getMtaStatusThresholdResponse
{
public:
	ns1__MtaStatusThresholdT *threshold;	/* RPC return element */	/* optional element of type ns1:MtaStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getMtaStatusThreshold
#define SOAP_TYPE_adm__getMtaStatusThreshold (284)
/* adm:getMtaStatusThreshold */
struct adm__getMtaStatusThreshold
{
};
#endif

#ifndef SOAP_TYPE_adm__updateMtaStatusThresholdResponse
#define SOAP_TYPE_adm__updateMtaStatusThresholdResponse (286)
/* adm:updateMtaStatusThresholdResponse */
struct adm__updateMtaStatusThresholdResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateMtaStatusThreshold
#define SOAP_TYPE_adm__updateMtaStatusThreshold (287)
/* adm:updateMtaStatusThreshold */
struct adm__updateMtaStatusThreshold
{
public:
	ns1__MtaStatusThresholdT *pollintInterval;	/* optional element of type ns1:MtaStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getHfcStatusThresholdResponse
#define SOAP_TYPE_adm__getHfcStatusThresholdResponse (288)
/* adm:getHfcStatusThresholdResponse */
struct adm__getHfcStatusThresholdResponse
{
public:
	ns1__HfcStatusThresholdT *threshold;	/* RPC return element */	/* optional element of type ns1:HfcStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getHfcStatusThreshold
#define SOAP_TYPE_adm__getHfcStatusThreshold (292)
/* adm:getHfcStatusThreshold */
struct adm__getHfcStatusThreshold
{
};
#endif

#ifndef SOAP_TYPE_adm__updateHfcStatusThresholdResponse
#define SOAP_TYPE_adm__updateHfcStatusThresholdResponse (294)
/* adm:updateHfcStatusThresholdResponse */
struct adm__updateHfcStatusThresholdResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateHfcStatusThreshold
#define SOAP_TYPE_adm__updateHfcStatusThreshold (295)
/* adm:updateHfcStatusThreshold */
struct adm__updateHfcStatusThreshold
{
public:
	ns1__HfcStatusThresholdT *pollintInterval;	/* optional element of type ns1:HfcStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getChannelStatusThresholdResponse
#define SOAP_TYPE_adm__getChannelStatusThresholdResponse (296)
/* adm:getChannelStatusThresholdResponse */
struct adm__getChannelStatusThresholdResponse
{
public:
	ns1__ChannelStatusThresholdT *threshold;	/* RPC return element */	/* optional element of type ns1:ChannelStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getChannelStatusThreshold
#define SOAP_TYPE_adm__getChannelStatusThreshold (300)
/* adm:getChannelStatusThreshold */
struct adm__getChannelStatusThreshold
{
};
#endif

#ifndef SOAP_TYPE_adm__updateChannelStatusThresholdResponse
#define SOAP_TYPE_adm__updateChannelStatusThresholdResponse (302)
/* adm:updateChannelStatusThresholdResponse */
struct adm__updateChannelStatusThresholdResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateChannelStatusThreshold
#define SOAP_TYPE_adm__updateChannelStatusThreshold (303)
/* adm:updateChannelStatusThreshold */
struct adm__updateChannelStatusThreshold
{
public:
	ns1__ChannelStatusThresholdT *pollintInterval;	/* optional element of type ns1:ChannelStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmtsStatusThresholdResponse
#define SOAP_TYPE_adm__getCmtsStatusThresholdResponse (304)
/* adm:getCmtsStatusThresholdResponse */
struct adm__getCmtsStatusThresholdResponse
{
public:
	ns1__CmtsStatusThresholdT *threshold;	/* RPC return element */	/* optional element of type ns1:CmtsStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmtsStatusThreshold
#define SOAP_TYPE_adm__getCmtsStatusThreshold (308)
/* adm:getCmtsStatusThreshold */
struct adm__getCmtsStatusThreshold
{
};
#endif

#ifndef SOAP_TYPE_adm__updateCmtsStatusThresholdResponse
#define SOAP_TYPE_adm__updateCmtsStatusThresholdResponse (310)
/* adm:updateCmtsStatusThresholdResponse */
struct adm__updateCmtsStatusThresholdResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmtsStatusThreshold
#define SOAP_TYPE_adm__updateCmtsStatusThreshold (311)
/* adm:updateCmtsStatusThreshold */
struct adm__updateCmtsStatusThreshold
{
public:
	ns1__CmtsStatusThresholdT *pollintInterval;	/* optional element of type ns1:CmtsStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmsStatusThresholdResponse
#define SOAP_TYPE_adm__getCmsStatusThresholdResponse (312)
/* adm:getCmsStatusThresholdResponse */
struct adm__getCmsStatusThresholdResponse
{
public:
	ns1__CmsStatusThresholdT *threshold;	/* RPC return element */	/* optional element of type ns1:CmsStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmsStatusThreshold
#define SOAP_TYPE_adm__getCmsStatusThreshold (316)
/* adm:getCmsStatusThreshold */
struct adm__getCmsStatusThreshold
{
};
#endif

#ifndef SOAP_TYPE_adm__updateCmsStatusThresholdResponse
#define SOAP_TYPE_adm__updateCmsStatusThresholdResponse (318)
/* adm:updateCmsStatusThresholdResponse */
struct adm__updateCmsStatusThresholdResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmsStatusThreshold
#define SOAP_TYPE_adm__updateCmsStatusThreshold (319)
/* adm:updateCmsStatusThreshold */
struct adm__updateCmsStatusThreshold
{
public:
	ns1__CmsStatusThresholdT *pollintInterval;	/* optional element of type ns1:CmsStatusThresholdT */
};
#endif

#ifndef SOAP_TYPE_adm__getMtaAlarmConfigResponse
#define SOAP_TYPE_adm__getMtaAlarmConfigResponse (320)
/* adm:getMtaAlarmConfigResponse */
struct adm__getMtaAlarmConfigResponse
{
public:
	ns1__MtaAlarmConfigT *alarmConfig;	/* RPC return element */	/* optional element of type ns1:MtaAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getMtaAlarmConfig
#define SOAP_TYPE_adm__getMtaAlarmConfig (323)
/* adm:getMtaAlarmConfig */
struct adm__getMtaAlarmConfig
{
};
#endif

#ifndef SOAP_TYPE_adm__updateMtaAlarmConfigResponse
#define SOAP_TYPE_adm__updateMtaAlarmConfigResponse (325)
/* adm:updateMtaAlarmConfigResponse */
struct adm__updateMtaAlarmConfigResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateMtaAlarmConfig
#define SOAP_TYPE_adm__updateMtaAlarmConfig (326)
/* adm:updateMtaAlarmConfig */
struct adm__updateMtaAlarmConfig
{
public:
	ns1__MtaAlarmConfigT *alarmConfig;	/* optional element of type ns1:MtaAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getHfcAlarmConfigResponse
#define SOAP_TYPE_adm__getHfcAlarmConfigResponse (327)
/* adm:getHfcAlarmConfigResponse */
struct adm__getHfcAlarmConfigResponse
{
public:
	ns1__HfcAlarmConfigT *alarmConfig;	/* RPC return element */	/* optional element of type ns1:HfcAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getHfcAlarmConfig
#define SOAP_TYPE_adm__getHfcAlarmConfig (330)
/* adm:getHfcAlarmConfig */
struct adm__getHfcAlarmConfig
{
};
#endif

#ifndef SOAP_TYPE_adm__updateHfcAlarmConfigResponse
#define SOAP_TYPE_adm__updateHfcAlarmConfigResponse (332)
/* adm:updateHfcAlarmConfigResponse */
struct adm__updateHfcAlarmConfigResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateHfcAlarmConfig
#define SOAP_TYPE_adm__updateHfcAlarmConfig (333)
/* adm:updateHfcAlarmConfig */
struct adm__updateHfcAlarmConfig
{
public:
	ns1__HfcAlarmConfigT *alarmConfig;	/* optional element of type ns1:HfcAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmtsAlarmConfigResponse
#define SOAP_TYPE_adm__getCmtsAlarmConfigResponse (334)
/* adm:getCmtsAlarmConfigResponse */
struct adm__getCmtsAlarmConfigResponse
{
public:
	ns1__CmtsAlarmConfigT *alarmConfig;	/* RPC return element */	/* optional element of type ns1:CmtsAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmtsAlarmConfig
#define SOAP_TYPE_adm__getCmtsAlarmConfig (337)
/* adm:getCmtsAlarmConfig */
struct adm__getCmtsAlarmConfig
{
};
#endif

#ifndef SOAP_TYPE_adm__updateCmtsAlarmConfigResponse
#define SOAP_TYPE_adm__updateCmtsAlarmConfigResponse (339)
/* adm:updateCmtsAlarmConfigResponse */
struct adm__updateCmtsAlarmConfigResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmtsAlarmConfig
#define SOAP_TYPE_adm__updateCmtsAlarmConfig (340)
/* adm:updateCmtsAlarmConfig */
struct adm__updateCmtsAlarmConfig
{
public:
	ns1__CmtsAlarmConfigT *alarmConfig;	/* optional element of type ns1:CmtsAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmsAlarmConfigResponse
#define SOAP_TYPE_adm__getCmsAlarmConfigResponse (341)
/* adm:getCmsAlarmConfigResponse */
struct adm__getCmsAlarmConfigResponse
{
public:
	ns1__CmsAlarmConfigT *alarmConfig;	/* RPC return element */	/* optional element of type ns1:CmsAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmsAlarmConfig
#define SOAP_TYPE_adm__getCmsAlarmConfig (344)
/* adm:getCmsAlarmConfig */
struct adm__getCmsAlarmConfig
{
};
#endif

#ifndef SOAP_TYPE_adm__updateCmsAlarmConfigResponse
#define SOAP_TYPE_adm__updateCmsAlarmConfigResponse (346)
/* adm:updateCmsAlarmConfigResponse */
struct adm__updateCmsAlarmConfigResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmsAlarmConfig
#define SOAP_TYPE_adm__updateCmsAlarmConfig (347)
/* adm:updateCmsAlarmConfig */
struct adm__updateCmsAlarmConfig
{
public:
	ns1__CmsAlarmConfigT *alarmConfig;	/* optional element of type ns1:CmsAlarmConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__updateLocalSystemResponse
#define SOAP_TYPE_adm__updateLocalSystemResponse (350)
/* adm:updateLocalSystemResponse */
struct adm__updateLocalSystemResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateLocalSystem
#define SOAP_TYPE_adm__updateLocalSystem (351)
/* adm:updateLocalSystem */
struct adm__updateLocalSystem
{
public:
	ns1__LocalSystemT *cmts;	/* optional element of type ns1:LocalSystemT */
};
#endif

#ifndef SOAP_TYPE_adm__updateRegionResponse
#define SOAP_TYPE_adm__updateRegionResponse (353)
/* adm:updateRegionResponse */
struct adm__updateRegionResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateRegion
#define SOAP_TYPE_adm__updateRegion (354)
/* adm:updateRegion */
struct adm__updateRegion
{
public:
	ns1__RegionT *cmts;	/* optional element of type ns1:RegionT */
};
#endif

#ifndef SOAP_TYPE_adm__addRegionResponse
#define SOAP_TYPE_adm__addRegionResponse (356)
/* adm:addRegionResponse */
struct adm__addRegionResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__addRegion
#define SOAP_TYPE_adm__addRegion (357)
/* adm:addRegion */
struct adm__addRegion
{
public:
	ns1__RegionT *cmts;	/* optional element of type ns1:RegionT */
};
#endif

#ifndef SOAP_TYPE_adm__updateMarketResponse
#define SOAP_TYPE_adm__updateMarketResponse (359)
/* adm:updateMarketResponse */
struct adm__updateMarketResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateMarket
#define SOAP_TYPE_adm__updateMarket (360)
/* adm:updateMarket */
struct adm__updateMarket
{
public:
	ns1__MarketT *cmts;	/* optional element of type ns1:MarketT */
};
#endif

#ifndef SOAP_TYPE_adm__addMarketResponse
#define SOAP_TYPE_adm__addMarketResponse (362)
/* adm:addMarketResponse */
struct adm__addMarketResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__addMarket
#define SOAP_TYPE_adm__addMarket (363)
/* adm:addMarket */
struct adm__addMarket
{
public:
	ns1__MarketT *cmts;	/* optional element of type ns1:MarketT */
};
#endif

#ifndef SOAP_TYPE_adm__updateBladeResponse
#define SOAP_TYPE_adm__updateBladeResponse (365)
/* adm:updateBladeResponse */
struct adm__updateBladeResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateBlade
#define SOAP_TYPE_adm__updateBlade (366)
/* adm:updateBlade */
struct adm__updateBlade
{
public:
	ns1__BladeT *cmts;	/* optional element of type ns1:BladeT */
};
#endif

#ifndef SOAP_TYPE_adm__addBladeResponse
#define SOAP_TYPE_adm__addBladeResponse (368)
/* adm:addBladeResponse */
struct adm__addBladeResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__addBlade
#define SOAP_TYPE_adm__addBlade (369)
/* adm:addBlade */
struct adm__addBlade
{
public:
	ns1__BladeT *cmts;	/* optional element of type ns1:BladeT */
};
#endif

#ifndef SOAP_TYPE_adm__deleteBladeResponse
#define SOAP_TYPE_adm__deleteBladeResponse (371)
/* adm:deleteBladeResponse */
struct adm__deleteBladeResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__deleteBlade
#define SOAP_TYPE_adm__deleteBlade (372)
/* adm:deleteBlade */
struct adm__deleteBlade
{
public:
	ns1__BladeT *cmts;	/* optional element of type ns1:BladeT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmPerfConfigResponse
#define SOAP_TYPE_adm__getCmPerfConfigResponse (373)
/* adm:getCmPerfConfigResponse */
struct adm__getCmPerfConfigResponse
{
public:
	ns1__CmPerformanceConfigT *cmPerf;	/* RPC return element */	/* optional element of type ns1:CmPerformanceConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__getCmPerfConfig
#define SOAP_TYPE_adm__getCmPerfConfig (376)
/* adm:getCmPerfConfig */
struct adm__getCmPerfConfig
{
};
#endif

#ifndef SOAP_TYPE_adm__updateCmPerfConfigResponse
#define SOAP_TYPE_adm__updateCmPerfConfigResponse (378)
/* adm:updateCmPerfConfigResponse */
struct adm__updateCmPerfConfigResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateCmPerfConfig
#define SOAP_TYPE_adm__updateCmPerfConfig (379)
/* adm:updateCmPerfConfig */
struct adm__updateCmPerfConfig
{
public:
	ns1__CmPerformanceConfigT *cmPerf;	/* optional element of type ns1:CmPerformanceConfigT */
};
#endif

#ifndef SOAP_TYPE_adm__addUserResponse
#define SOAP_TYPE_adm__addUserResponse (381)
/* adm:addUserResponse */
struct adm__addUserResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__addUser
#define SOAP_TYPE_adm__addUser (382)
/* adm:addUser */
struct adm__addUser
{
public:
	ns1__UserT *user;	/* optional element of type ns1:UserT */
};
#endif

#ifndef SOAP_TYPE_adm__getUsersResponse
#define SOAP_TYPE_adm__getUsersResponse (383)
/* adm:getUsersResponse */
struct adm__getUsersResponse
{
public:
	ArrayOfUserT *name;	/* RPC return element */	/* optional element of type ArrayOfUserT */
};
#endif

#ifndef SOAP_TYPE_adm__getUsers
#define SOAP_TYPE_adm__getUsers (386)
/* adm:getUsers */
struct adm__getUsers
{
};
#endif

#ifndef SOAP_TYPE_adm__getUserResponse
#define SOAP_TYPE_adm__getUserResponse (387)
/* adm:getUserResponse */
struct adm__getUserResponse
{
public:
	ns1__UserT *name;	/* RPC return element */	/* optional element of type ns1:UserT */
};
#endif

#ifndef SOAP_TYPE_adm__getUser
#define SOAP_TYPE_adm__getUser (390)
/* adm:getUser */
struct adm__getUser
{
public:
	std::string loginName;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_adm__updateUserResponse
#define SOAP_TYPE_adm__updateUserResponse (392)
/* adm:updateUserResponse */
struct adm__updateUserResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateUser
#define SOAP_TYPE_adm__updateUser (393)
/* adm:updateUser */
struct adm__updateUser
{
public:
	ns1__UserT *user;	/* optional element of type ns1:UserT */
};
#endif

#ifndef SOAP_TYPE_adm__updateUserPasswordResponse
#define SOAP_TYPE_adm__updateUserPasswordResponse (395)
/* adm:updateUserPasswordResponse */
struct adm__updateUserPasswordResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateUserPassword
#define SOAP_TYPE_adm__updateUserPassword (396)
/* adm:updateUserPassword */
struct adm__updateUserPassword
{
public:
	std::string loginName;	/* required element of type xsd:string */
	std::string newPassword;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_adm__getRolesResponse
#define SOAP_TYPE_adm__getRolesResponse (397)
/* adm:getRolesResponse */
struct adm__getRolesResponse
{
public:
	ArrayOfRoleT *result;	/* RPC return element */	/* optional element of type ArrayOfRoleT */
};
#endif

#ifndef SOAP_TYPE_adm__getRoles
#define SOAP_TYPE_adm__getRoles (400)
/* adm:getRoles */
struct adm__getRoles
{
};
#endif

#ifndef SOAP_TYPE_adm__getRoleResponse
#define SOAP_TYPE_adm__getRoleResponse (401)
/* adm:getRoleResponse */
struct adm__getRoleResponse
{
public:
	ns1__RoleT *result;	/* RPC return element */	/* optional element of type ns1:RoleT */
};
#endif

#ifndef SOAP_TYPE_adm__getRole
#define SOAP_TYPE_adm__getRole (404)
/* adm:getRole */
struct adm__getRole
{
public:
	std::string roleName;	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_adm__updateRoleResponse
#define SOAP_TYPE_adm__updateRoleResponse (406)
/* adm:updateRoleResponse */
struct adm__updateRoleResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__updateRole
#define SOAP_TYPE_adm__updateRole (407)
/* adm:updateRole */
struct adm__updateRole
{
public:
	ns1__RoleT *role;	/* optional element of type ns1:RoleT */
};
#endif

#ifndef SOAP_TYPE_adm__downloadConfigFromParentResponse
#define SOAP_TYPE_adm__downloadConfigFromParentResponse (409)
/* adm:downloadConfigFromParentResponse */
struct adm__downloadConfigFromParentResponse
{
public:
	short rc;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_adm__downloadConfigFromParent
#define SOAP_TYPE_adm__downloadConfigFromParent (410)
/* adm:downloadConfigFromParent */
struct adm__downloadConfigFromParent
{
};
#endif

#ifndef SOAP_TYPE_adm__getConfigResponse
#define SOAP_TYPE_adm__getConfigResponse (411)
/* adm:getConfigResponse */
struct adm__getConfigResponse
{
public:
	ns1__ConfigDownloadT *configData;	/* RPC return element */	/* optional element of type ns1:ConfigDownloadT */
};
#endif

#ifndef SOAP_TYPE_adm__getConfig
#define SOAP_TYPE_adm__getConfig (415)
/* adm:getConfig */
struct adm__getConfig
{
};
#endif

#ifndef SOAP_TYPE_cms__getLineStatusResponse
#define SOAP_TYPE_cms__getLineStatusResponse (416)
/* cms:getLineStatusResponse */
struct cms__getLineStatusResponse
{
public:
	ArrayOfCMSLineT *output;	/* RPC return element */	/* optional element of type ArrayOfCMSLineT */
};
#endif

#ifndef SOAP_TYPE_cms__getLineStatus
#define SOAP_TYPE_cms__getLineStatus (420)
/* cms:getLineStatus */
struct cms__getLineStatus
{
public:
	ArrayOfCMSLineT *input;	/* optional element of type ArrayOfCMSLineT */
};
#endif

#ifndef SOAP_TYPE_cpeer__pingMtaResponse
#define SOAP_TYPE_cpeer__pingMtaResponse (423)
/* cpeer:pingMtaResponse */
struct cpeer__pingMtaResponse
{
public:
	std::string result;	/* RPC return element */	/* required element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_cpeer__pingMta
#define SOAP_TYPE_cpeer__pingMta (424)
/* cpeer:pingMta */
struct cpeer__pingMta
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string mtaResId;	/* required element of type xsd:integer */
};
#endif

#ifndef SOAP_TYPE_cpeer__getMtaDataResponse
#define SOAP_TYPE_cpeer__getMtaDataResponse (425)
/* cpeer:getMtaDataResponse */
struct cpeer__getMtaDataResponse
{
public:
	ns1__MtaDataT *result;	/* RPC return element */	/* optional element of type ns1:MtaDataT */
};
#endif

#ifndef SOAP_TYPE_cpeer__getMtaData
#define SOAP_TYPE_cpeer__getMtaData (429)
/* cpeer:getMtaData */
struct cpeer__getMtaData
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string mtaResId;	/* required element of type xsd:integer */
};
#endif

#ifndef SOAP_TYPE_cpeer__getCmDataResponse
#define SOAP_TYPE_cpeer__getCmDataResponse (430)
/* cpeer:getCmDataResponse */
struct cpeer__getCmDataResponse
{
public:
	ns1__CmDataT *result;	/* RPC return element */	/* optional element of type ns1:CmDataT */
};
#endif

#ifndef SOAP_TYPE_cpeer__getCmData
#define SOAP_TYPE_cpeer__getCmData (434)
/* cpeer:getCmData */
struct cpeer__getCmData
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string cmResId;	/* required element of type xsd:integer */
};
#endif

#ifndef SOAP_TYPE_cpeer__getCmtsCmDataResponse
#define SOAP_TYPE_cpeer__getCmtsCmDataResponse (435)
/* cpeer:getCmtsCmDataResponse */
struct cpeer__getCmtsCmDataResponse
{
public:
	ns1__CmtsCmDataT *result;	/* RPC return element */	/* optional element of type ns1:CmtsCmDataT */
};
#endif

#ifndef SOAP_TYPE_cpeer__getCmtsCmData
#define SOAP_TYPE_cpeer__getCmtsCmData (439)
/* cpeer:getCmtsCmData */
struct cpeer__getCmtsCmData
{
public:
	ns1__TopoHierarchyKeyT *topologyKey;	/* optional element of type ns1:TopoHierarchyKeyT */
	std::string cmtsResId;	/* required element of type xsd:integer */
	std::string cmResId;	/* required element of type xsd:integer */
};
#endif

#ifndef SOAP_TYPE_cpeer__sendEventResponse
#define SOAP_TYPE_cpeer__sendEventResponse (442)
/* cpeer:sendEventResponse */
struct cpeer__sendEventResponse
{
public:
	short result;	/* RPC return element */	/* required element of type xsd:short */
};
#endif

#ifndef SOAP_TYPE_cpeer__sendEvent
#define SOAP_TYPE_cpeer__sendEvent (443)
/* cpeer:sendEvent */
struct cpeer__sendEvent
{
public:
	ns1__EventMessageT *event;	/* optional element of type ns1:EventMessageT */
};
#endif

#ifndef SOAP_TYPE_cte__getCteDataResponse
#define SOAP_TYPE_cte__getCteDataResponse (444)
/* cte:getCteDataResponse */
struct cte__getCteDataResponse
{
public:
	ArrayOfCTEDataT *name;	/* RPC return element */	/* optional element of type ArrayOfCTEDataT */
};
#endif

#ifndef SOAP_TYPE_cte__getCteData
#define SOAP_TYPE_cte__getCteData (449)
/* cte:getCteData */
struct cte__getCteData
{
public:
	ArrayOfCTEQueryInputT *queryInput;	/* optional element of type ArrayOfCTEQueryInputT */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Header
#define SOAP_TYPE_SOAP_ENV__Header (452)
/* SOAP Header: */
struct SOAP_ENV__Header
{
public:
	void *dummy;	/* transient */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Code
#define SOAP_TYPE_SOAP_ENV__Code (453)
/* SOAP Fault Code: */
struct SOAP_ENV__Code
{
public:
	char *SOAP_ENV__Value;	/* optional element of type xsd:QName */
	struct SOAP_ENV__Code *SOAP_ENV__Subcode;	/* optional element of type SOAP-ENV:Code */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Detail
#define SOAP_TYPE_SOAP_ENV__Detail (455)
/* SOAP-ENV:Detail */
struct SOAP_ENV__Detail
{
public:
	int __type;	/* any type of element <fault> (defined below) */
	void *fault;	/* transient */
	char *__any;
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Reason
#define SOAP_TYPE_SOAP_ENV__Reason (456)
/* SOAP-ENV:Reason */
struct SOAP_ENV__Reason
{
public:
	char *SOAP_ENV__Text;	/* optional element of type xsd:string */
};
#endif

#ifndef SOAP_TYPE_SOAP_ENV__Fault
#define SOAP_TYPE_SOAP_ENV__Fault (457)
/* SOAP Fault: */
struct SOAP_ENV__Fault
{
public:
	char *faultcode;	/* optional element of type xsd:QName */
	char *faultstring;	/* optional element of type xsd:string */
	char *faultactor;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *detail;	/* optional element of type SOAP-ENV:Detail */
	struct SOAP_ENV__Code *SOAP_ENV__Code;	/* optional element of type SOAP-ENV:Code */
	struct SOAP_ENV__Reason *SOAP_ENV__Reason;	/* optional element of type SOAP-ENV:Reason */
	char *SOAP_ENV__Node;	/* optional element of type xsd:string */
	char *SOAP_ENV__Role;	/* optional element of type xsd:string */
	struct SOAP_ENV__Detail *SOAP_ENV__Detail;	/* optional element of type SOAP-ENV:Detail */
};
#endif

/******************************************************************************\
 *                                                                            *
 * Types with Custom Serializers                                              *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Typedefs                                                                   *
 *                                                                            *
\******************************************************************************/

#ifndef SOAP_TYPE__XML
#define SOAP_TYPE__XML (4)
typedef char *_XML;
#endif

#ifndef SOAP_TYPE__QName
#define SOAP_TYPE__QName (5)
typedef char *_QName;
#endif

#ifndef SOAP_TYPE_xsd__integer
#define SOAP_TYPE_xsd__integer (8)
typedef std::string xsd__integer;
#endif

#ifndef SOAP_TYPE__SOAP_ENC__arrayType
#define SOAP_TYPE__SOAP_ENC__arrayType (9)
typedef std::string _SOAP_ENC__arrayType;
#endif


/******************************************************************************\
 *                                                                            *
 * Typedef Synonyms                                                           *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Externals                                                                  *
 *                                                                            *
\******************************************************************************/


/******************************************************************************\
 *                                                                            *
 * Service Operations                                                         *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 adm__updateCmts(struct soap*, ns1__CmtsT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__addCmts(struct soap*, ns1__CmtsT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__deleteCmts(struct soap*, ns1__CmtsT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__addCmtsAllSnmpV2CAttributes(struct soap*, ns1__TopoHierarchyKeyT *topologyKey, std::string cmtsResId, ArrayOfSnmpV2CAttributesT *attributes, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateCmtsAllSnmpV2CAttributes(struct soap*, ns1__TopoHierarchyKeyT *topologyKey, std::string cmtsResId, ArrayOfSnmpV2CAttributesT *attributes, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateCms(struct soap*, ns1__CmsT *cms, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__addCms(struct soap*, ns1__CmsT *cms, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__deleteCms(struct soap*, ns1__CmsT *cms, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getPollingIntervals(struct soap*, struct adm__getPollingIntervalsResponse &_param_1);

SOAP_FMAC5 int SOAP_FMAC6 adm__updatePollingIntervals(struct soap*, ns1__PollingIntervalsT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getMtaStatusThreshold(struct soap*, struct adm__getMtaStatusThresholdResponse &_param_2);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateMtaStatusThreshold(struct soap*, ns1__MtaStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getHfcStatusThreshold(struct soap*, struct adm__getHfcStatusThresholdResponse &_param_3);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateHfcStatusThreshold(struct soap*, ns1__HfcStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getChannelStatusThreshold(struct soap*, struct adm__getChannelStatusThresholdResponse &_param_4);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateChannelStatusThreshold(struct soap*, ns1__ChannelStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getCmtsStatusThreshold(struct soap*, struct adm__getCmtsStatusThresholdResponse &_param_5);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateCmtsStatusThreshold(struct soap*, ns1__CmtsStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getCmsStatusThreshold(struct soap*, struct adm__getCmsStatusThresholdResponse &_param_6);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateCmsStatusThreshold(struct soap*, ns1__CmsStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getMtaAlarmConfig(struct soap*, struct adm__getMtaAlarmConfigResponse &_param_7);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateMtaAlarmConfig(struct soap*, ns1__MtaAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getHfcAlarmConfig(struct soap*, struct adm__getHfcAlarmConfigResponse &_param_8);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateHfcAlarmConfig(struct soap*, ns1__HfcAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getCmtsAlarmConfig(struct soap*, struct adm__getCmtsAlarmConfigResponse &_param_9);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateCmtsAlarmConfig(struct soap*, ns1__CmtsAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getCmsAlarmConfig(struct soap*, struct adm__getCmsAlarmConfigResponse &_param_10);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateCmsAlarmConfig(struct soap*, ns1__CmsAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateLocalSystem(struct soap*, ns1__LocalSystemT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateRegion(struct soap*, ns1__RegionT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__addRegion(struct soap*, ns1__RegionT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateMarket(struct soap*, ns1__MarketT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__addMarket(struct soap*, ns1__MarketT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateBlade(struct soap*, ns1__BladeT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__addBlade(struct soap*, ns1__BladeT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__deleteBlade(struct soap*, ns1__BladeT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getCmPerfConfig(struct soap*, struct adm__getCmPerfConfigResponse &_param_11);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateCmPerfConfig(struct soap*, ns1__CmPerformanceConfigT *cmPerf, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__addUser(struct soap*, ns1__UserT *user, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getUsers(struct soap*, struct adm__getUsersResponse &_param_12);

SOAP_FMAC5 int SOAP_FMAC6 adm__getUser(struct soap*, std::string loginName, struct adm__getUserResponse &_param_13);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateUser(struct soap*, ns1__UserT *user, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateUserPassword(struct soap*, std::string loginName, std::string newPassword, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__getRoles(struct soap*, struct adm__getRolesResponse &_param_14);

SOAP_FMAC5 int SOAP_FMAC6 adm__getRole(struct soap*, std::string roleName, struct adm__getRoleResponse &_param_15);

SOAP_FMAC5 int SOAP_FMAC6 adm__updateRole(struct soap*, ns1__RoleT *role, short &result);

SOAP_FMAC5 int SOAP_FMAC6 adm__downloadConfigFromParent(struct soap*, short &rc);

SOAP_FMAC5 int SOAP_FMAC6 adm__getConfig(struct soap*, struct adm__getConfigResponse &_param_16);

SOAP_FMAC5 int SOAP_FMAC6 cms__getLineStatus(struct soap*, ArrayOfCMSLineT *input, struct cms__getLineStatusResponse &_param_17);

SOAP_FMAC5 int SOAP_FMAC6 cpeer__pingMta(struct soap*, ns1__TopoHierarchyKeyT *topologyKey, std::string mtaResId, std::string &result);

SOAP_FMAC5 int SOAP_FMAC6 cpeer__getMtaData(struct soap*, ns1__TopoHierarchyKeyT *topologyKey, std::string mtaResId, struct cpeer__getMtaDataResponse &_param_18);

SOAP_FMAC5 int SOAP_FMAC6 cpeer__getCmData(struct soap*, ns1__TopoHierarchyKeyT *topologyKey, std::string cmResId, struct cpeer__getCmDataResponse &_param_19);

SOAP_FMAC5 int SOAP_FMAC6 cpeer__getCmtsCmData(struct soap*, ns1__TopoHierarchyKeyT *topologyKey, std::string cmtsResId, std::string cmResId, struct cpeer__getCmtsCmDataResponse &_param_20);

SOAP_FMAC5 int SOAP_FMAC6 cpeer__sendEvent(struct soap*, ns1__EventMessageT *event, short &result);

SOAP_FMAC5 int SOAP_FMAC6 cte__getCteData(struct soap*, ArrayOfCTEQueryInputT *queryInput, struct cte__getCteDataResponse &_param_21);

/******************************************************************************\
 *                                                                            *
 * Stubs                                                                      *
 *                                                                            *
\******************************************************************************/


SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCmts(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmtsT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__addCmts(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmtsT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__deleteCmts(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmtsT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__addCmtsAllSnmpV2CAttributes(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TopoHierarchyKeyT *topologyKey, std::string cmtsResId, ArrayOfSnmpV2CAttributesT *attributes, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCmtsAllSnmpV2CAttributes(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TopoHierarchyKeyT *topologyKey, std::string cmtsResId, ArrayOfSnmpV2CAttributesT *attributes, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCms(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmsT *cms, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__addCms(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmsT *cms, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__deleteCms(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmsT *cms, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getPollingIntervals(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getPollingIntervalsResponse &_param_1);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updatePollingIntervals(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__PollingIntervalsT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getMtaStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getMtaStatusThresholdResponse &_param_2);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateMtaStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__MtaStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getHfcStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getHfcStatusThresholdResponse &_param_3);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateHfcStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__HfcStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getChannelStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getChannelStatusThresholdResponse &_param_4);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateChannelStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__ChannelStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getCmtsStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getCmtsStatusThresholdResponse &_param_5);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCmtsStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmtsStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getCmsStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getCmsStatusThresholdResponse &_param_6);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCmsStatusThreshold(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmsStatusThresholdT *pollintInterval, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getMtaAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getMtaAlarmConfigResponse &_param_7);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateMtaAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__MtaAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getHfcAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getHfcAlarmConfigResponse &_param_8);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateHfcAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__HfcAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getCmtsAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getCmtsAlarmConfigResponse &_param_9);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCmtsAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmtsAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getCmsAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getCmsAlarmConfigResponse &_param_10);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCmsAlarmConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmsAlarmConfigT *alarmConfig, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateLocalSystem(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__LocalSystemT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateRegion(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__RegionT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__addRegion(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__RegionT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateMarket(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__MarketT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__addMarket(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__MarketT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateBlade(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__BladeT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__addBlade(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__BladeT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__deleteBlade(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__BladeT *cmts, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getCmPerfConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getCmPerfConfigResponse &_param_11);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateCmPerfConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__CmPerformanceConfigT *cmPerf, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__addUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__UserT *user, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getUsers(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getUsersResponse &_param_12);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string loginName, struct adm__getUserResponse &_param_13);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateUser(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__UserT *user, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateUserPassword(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string loginName, std::string newPassword, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getRoles(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getRolesResponse &_param_14);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getRole(struct soap *soap, const char *soap_endpoint, const char *soap_action, std::string roleName, struct adm__getRoleResponse &_param_15);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__updateRole(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__RoleT *role, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__downloadConfigFromParent(struct soap *soap, const char *soap_endpoint, const char *soap_action, short &rc);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_adm__getConfig(struct soap *soap, const char *soap_endpoint, const char *soap_action, struct adm__getConfigResponse &_param_16);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_cms__getLineStatus(struct soap *soap, const char *soap_endpoint, const char *soap_action, ArrayOfCMSLineT *input, struct cms__getLineStatusResponse &_param_17);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_cpeer__pingMta(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TopoHierarchyKeyT *topologyKey, std::string mtaResId, std::string &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_cpeer__getMtaData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TopoHierarchyKeyT *topologyKey, std::string mtaResId, struct cpeer__getMtaDataResponse &_param_18);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_cpeer__getCmData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TopoHierarchyKeyT *topologyKey, std::string cmResId, struct cpeer__getCmDataResponse &_param_19);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_cpeer__getCmtsCmData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__TopoHierarchyKeyT *topologyKey, std::string cmtsResId, std::string cmResId, struct cpeer__getCmtsCmDataResponse &_param_20);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_cpeer__sendEvent(struct soap *soap, const char *soap_endpoint, const char *soap_action, ns1__EventMessageT *event, short &result);

SOAP_FMAC5 int SOAP_FMAC6 soap_call_cte__getCteData(struct soap *soap, const char *soap_endpoint, const char *soap_action, ArrayOfCTEQueryInputT *queryInput, struct cte__getCteDataResponse &_param_21);

/******************************************************************************\
 *                                                                            *
 * Skeletons                                                                  *
 *                                                                            *
\******************************************************************************/

SOAP_FMAC5 int SOAP_FMAC6 all_serve(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 all_serve_request(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCmts(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__addCmts(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__deleteCmts(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__addCmtsAllSnmpV2CAttributes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCmtsAllSnmpV2CAttributes(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCms(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__addCms(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__deleteCms(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getPollingIntervals(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updatePollingIntervals(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getMtaStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateMtaStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getHfcStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateHfcStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getChannelStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateChannelStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getCmtsStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCmtsStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getCmsStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCmsStatusThreshold(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getMtaAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateMtaAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getHfcAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateHfcAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getCmtsAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCmtsAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getCmsAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCmsAlarmConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateLocalSystem(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateRegion(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__addRegion(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateMarket(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__addMarket(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateBlade(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__addBlade(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__deleteBlade(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getCmPerfConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateCmPerfConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__addUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getUsers(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateUser(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateUserPassword(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getRoles(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getRole(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__updateRole(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__downloadConfigFromParent(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_adm__getConfig(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cms__getLineStatus(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cpeer__pingMta(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cpeer__getMtaData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cpeer__getCmData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cpeer__getCmtsCmData(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cpeer__sendEvent(struct soap*);

SOAP_FMAC5 int SOAP_FMAC6 soap_serve_cte__getCteData(struct soap*);

#endif

/* End of allStub.h */
