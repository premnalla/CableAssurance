package ossj.qos.fmri;

import java.util.Properties;
import java.rmi.RemoteException;
import javax.rmi.PortableRemoteObject;
import java.util.ArrayList;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import javax.ejb.EJBException;

import java.util.Date;
import java.util.Calendar;
import java.util.SimpleTimeZone;
import java.text.SimpleDateFormat;
import java.util.HashMap;
import java.util.Map;

import javax.sql.DataSource;

import javax.ejb.MessageDrivenBean;
import javax.ejb.MessageDrivenContext;
import javax.ejb.CreateException;

import javax.naming.InitialContext;
import javax.naming.Context;
import javax.naming.NamingException;
import javax.naming.NamingEnumeration;
import javax.naming.Binding;

import javax.oss.*;
import javax.oss.util.*;
import javax.oss.fm.monitor.*;
import javax.jms.*;
import ossj.qos.util.Trace;
import ossj.qos.util.Util;

/**
 * BackEndAlarmMessageBean
 * 
 * @author  Audrey Ward
 * @version 1.0
 *
 * ¨ Copyright 2001-2002, MOTOROLA INC. 
 * All Rights Reserved
 */
public class BackEndAlarmMessageBean implements MessageDrivenBean, MessageListener, EnvironmentConstants {

    private MessageDrivenContext ctx = null;
    private InitialContext initCtx = null;

    private AMEventPublisher evPublisher = null;
    private DataSource dataSource = null;
    private Connection connection = null;

    /**
     * Flag that turns on logging.
     */
    private boolean isLoggingEnabled = true;

    /**
     * The logging mechanism.
     */
    private Trace myLog = null;

    /**
     * Environment variable that determines if the application dn
     * will be populated for events generated by this bean and if the
     * application context information will be populated in the alarm keys
     */
    private boolean includeApplicationInfo = true;

    /**
     * Represents the application domain name associated with this bean.
     */
    private String applicationDN = null;

    /**
     * Represents the application context associated with this bean.
     */
    private ApplicationContext applicationContext = null;

    /**
     * BackEndAlarmMessageBean - default constructor.
     */
    public BackEndAlarmMessageBean() {
    }

    //----------------------------
    //
    // Container callbacks/methods
    //
    //----------------------------

    /**
     * EJB required method called when the bean is created.
     */
    public void ejbCreate() {
	System.out.println("BackEndAlarmMessageBean: ejbCreate() called");

        // creates the log
        myLog = Util.createLog("ossj.qos.fmri");

        //System.out.println("wrx--create log is ok in message bean");

        // Removed by Stefan
        //Properties env = System.getProperties();
        try {
            // Changed by Stefan
            //initCtx = new InitialContext( env );
            // to
            initCtx = new InitialContext( );
        }
        catch (NamingException nex) {
            // default is logging enabled to log this error for creating the intialContext
            if ( isLoggingEnabled ) {
                myLog.logException("BackEndAlarmMessageBean:ejbCreate:  Naming exception caught while creating InitialContext", nex);
            }
        }

        Object result;

        // initialize debugLogEnabled from environment property
        // TURN_ON_DEBUG_LOGGING
        try {
            result = initCtx.lookup( TURN_ON_DEBUG_LOGGING );
            Boolean booleanValue = (Boolean) PortableRemoteObject.narrow(result,Boolean.class);
            isLoggingEnabled = booleanValue.booleanValue();
        } catch ( NamingException e ) {
            if ( isLoggingEnabled ) {
                myLog.log("BackEndAlarmMessageBean: ejbCreate(): unable to load " +
                TURN_ON_DEBUG_LOGGING + " property." );
            }
        }

        if ( isLoggingEnabled ) {
            myLog.log ("BackEndAlarmMessageBean:ejbCreate");
        }

        // initialize includeApplicationInfo from environment property
        // INCLUDE_APPLICATION_INFO_PROPERTY_NAME
        try {
            result = initCtx.lookup( INCLUDE_APPLICATION_INFO_PROPERTY_NAME );
            Boolean booleanValue = (Boolean) PortableRemoteObject.narrow(result,Boolean.class);
            includeApplicationInfo = booleanValue.booleanValue();
        } catch ( NamingException e ) {
            if ( isLoggingEnabled ) {
                myLog.log("BackEndAlarmMessageBean: ejbCreate(): unable to load " +
                INCLUDE_APPLICATION_INFO_PROPERTY_NAME + " property." );
            }
        }

        // initializes the application context based on parameters found in the
        // deployment descriptor. This method was modified from the QoS Threshold
        // RI by Henrik Lindstrom.
        initializeApplicationContext();

        try {
            // configure the database data source
			// VP
            //result = initCtx.lookup( SessionResourceConstants.FMDB );
            //dataSource = (javax.sql.DataSource) PortableRemoteObject.narrow(result,DataSource.class);
            dataSource = (javax.sql.DataSource) initCtx.lookup( SessionResourceConstants.FMDB );
        }
        catch ( NamingException nex2 ) {
            if ( isLoggingEnabled ) {
                myLog.logException ("BackEndAlarmMessageBean:ejbCreate: Naming exception while acquiring db pool", nex2 );
            }
        }

        // create the event publisher...
        evPublisher = new AMEventPublisher();

        try {

            // initialize the event publisher to enable the publishing of
            // alarm notifications
            evPublisher.init( initCtx, SessionResourceConstants.AM_TOPIC,
            SessionResourceConstants.AM_CONNECTION_FACTORY );
        }
        catch( Exception x ) {
            if ( isLoggingEnabled ) {
                myLog.logException ("BackEndAlarmMessageBean:ejbCreate:  Unable to create Publisher.", x );
            }
            evPublisher = null;
        }
        return;
    }

    /**
     * EJB required method that sets the context.
     */
    public void setMessageDrivenContext(MessageDrivenContext ctx) {
        this.ctx = ctx;
        return;
    }

    /**
     * EJB required method called when the bean is removed.
     */
    public void ejbRemove() {
        if ( isLoggingEnabled ) {
            myLog.log("BackEndAlarmMessageBean:ejbRemove");
        }
        cleanup();
        return;
    }

    /**
     * Releases any resources held by the bean.
     */
    private void cleanup() {
        try {
            initCtx.close();
        }
        catch (NamingException nex) {
            if ( isLoggingEnabled ) {
                myLog.logException("BackEndAlarmMessageBean:cleanup Problem closing the initialContext.", nex);
            }
        }
        try {
            evPublisher.close();
        }
        catch( Exception e1 ) {
            if ( isLoggingEnabled ) {
                myLog.logException("BackEndAlarmMessageBean:cleanup Problem closing the eventPublisher.", e1);
            }
        }
    }

    /**
     * Get the Event Descriptor associated with an event type
     * @exception javax.oss.IllegalArgumentException -
     * Is raised if the event type is not supported.
     */
    private javax.oss.EventPropertyDescriptor getEventDescriptor(String event_type)
    throws javax.oss.IllegalArgumentException {
        EventPropertyDescriptor evDescriptor = null;
        try {
            evDescriptor = EventFactory.getPropertyDescriptor( event_type );
        }
        catch ( java.lang.IllegalArgumentException iex ) {
            throw new javax.oss.IllegalArgumentException( iex.toString() );
        }
        return evDescriptor;
    }

    /**
     * MessageListener interface that processes NotifyNewAlarmEvents
     * and NotifyClearedAlarmEvents from a backend topic. In this implementation,
     * the NotifyNewAlarmEvents can be used to indicate new alarms,
     * a change of severity, or cleared alarms. It is also used to trigger a
     * NotifyAlarmListRebuiltEvent. NotifyClearedAlarmEvents are
     * used to indicate that an alarm has been cleared. For simplicity, alarm
     * records are retrieved from the database using the following attributes:
     * ManagedObjectInstance, AlarmType, and ProbableCause. The optional alarm
     * attribute, SpecificProblem is not supported in this reference
     * implementation due to this simplistic alarm identification mechanism.
     * The SpecificProblem attribute is not available in the NotifyClearedAlarmEvent.
     *
     * @param msg - incoming alarm event from the backend.
     */
    public void onMessage(Message msg) {

          //System.out.println("wrx:--in BackEndMessageBean");

        if ( isLoggingEnabled ) {
            Object[][] parms = {  { "msg", msg } };
            myLog.logMethodEntry( "onMessage", parms );
        }


        try
        {
            if (msg instanceof ObjectMessage)
            {
                ObjectMessage omsg = (ObjectMessage) msg;

                if ( omsg.getObject() instanceof NotifyNewAlarmEvent )
                {
                    // Process the NotifyNewAlarmEvent
                    NotifyNewAlarmEvent event = (NotifyNewAlarmEvent) omsg.getObject();
                    // Check if we shoudl trigger a rebuilt event. The BackEndAlarmProducer
                    // loads the primarykey with the following text "rebuild" to trigger
                    // the generation of a NotifyAlarmListRebuiltEvent.
                    if ( event.getAlarmKey().getPrimaryKey().equals( "rebuild") == true ) {
                        try {
                            generateEvent( null, NotifyAlarmListRebuiltEventPropertyDescriptor.EVENT_TYPE_VALUE );
                        }
                        catch ( Exception e ) {
                            if ( isLoggingEnabled ) {
                                myLog.logException ("BackEndAlarmMessageBean: onMessage: Problem generating the NotifyAlarmListRebuiltEvent.", e);
                            }
                        }
                    }
                    else {
                        // check to make sure all mandatory fields are set. Note: In this implementation
                        // the SpecificProblem attribute is not supported.
                        if ( validateAlarmEvent( event ) ) {
                            // process the incoming new alarm event.
                            //System.out.println("wrx--before processIncomingNewEvent");
                            String result = processIncomingNewEvent( event );
                            //System.out.println("wrx--after processIncomingNewEvent");
                            if ( isLoggingEnabled ) {
                                // display the status of the operation
                                myLog.log( "AlarmStatus: " + result );
                            }
                        }
                        else {
                            if ( isLoggingEnabled ) {
                                myLog.log( "Unable to process the event. The following attributes " +
                                "must be set: AlarmType, ManagedObjectInstance, ManagedObjectClass, PerceivedSeverity, " +
                                "ProbableCause, EventTime and NotificationId.");
                            }
                        }
                    }
                }
                else if ( omsg.getObject() instanceof NotifyClearedAlarmEvent ) {
                    // process NotifyClearedAlarmEvents.
                    // check to make sure all mandatory fields are set. Note: In this implementation
                    // the SpecificProblem attribute is not supported.
                    NotifyClearedAlarmEvent event = (NotifyClearedAlarmEvent) omsg.getObject();
                    if ( validateAlarmEvent( event ) ) {
                        // process incoming cleared alarm events.
                        String result = processIncomingClearedEvent( event );
                        if ( isLoggingEnabled ) {
                            // display the status of the operation
                            myLog.log( "AlarmStatus: " + result );
                        }
                    }
                    else {
                        if ( isLoggingEnabled ) {
                            myLog.log( "Unable to process the event. The following attributes " +
                            "must be set: AlarmType, ManagedObjectInstance, ManagedObjectClass, PerceivedSeverity, " +
                            "ProbableCause, EventTime and NotificationId.");
                        }
                    }
                }
                else {
                    if ( isLoggingEnabled ) {
                        myLog.log("BackEndAlarmMessageBean:onMessage: invalid message type ");
                    }
                }
            }
        }
        catch ( Exception ex1 )
        {

            //System.out.println("wrx--exception in onmessage in backendmessagebean");
            System.out.println(ex1);
			ex1.printStackTrace();
            if ( isLoggingEnabled ) {
                myLog.logException ("BackEndAlarmMessageBean:onMessage caught processing alarm: ", ex1 );
            }
            // mark to Rollback the transaction
            //ctx.setRollbackOnly();
            closeConnection();
        }
    }

    /**
     * Processes a NotifyNewAlarmEvent. One of the following operations will be
     * performed depending on the existance and severity of the alarm. If no alarm
     * exists and its severity is not cleared, then a new alarm will be created and
     * added to the database. A NotifyNewAlarmEvent is generated to notify interested
     * managers that a new alarm has been added to the db. If the alarm already exists
     * in the db, then its severity is checked to determine if it is different.
     * The event's time stamp is also checked against the stored alarm times to ensure
     * that the information is not stale. If the severity is different and the event's
     * time stamp is later than the stored alarm, then the alarm is updated to
     * reflect the new state represented by the event. For a non-cleared severity,
     * the following alarm attributes will be updated with information taken from the
     * event: NotificationId, PerceivedSeverity, AlarmChangedTime.
     * Also, AckUserId, AckSystemId, and AlarmAckTime are cleared
     * and the AckState is reset to UNACKNOWLEDGED. A NotifyChangedAlarmEvent will
     * be generated following the updates. For a cleared severity,
     * the following attributes are updated with information from the event:
     * NotificationId, PerceivedSeverity, AlarmClearedTime. The alarm is then checked
     * to determine if it has been acknowledged. If it is in an acknowledged state,
     * it is immediately removed from the db. A NotifyClearedAlarmEvent is generated
     * following a cleared alarm update.
     */
    public String processIncomingNewEvent( NotifyNewAlarmEvent event ) throws SQLException {

        //System.out.println("wrx--in processIncomingNewEvent");
        if ( isLoggingEnabled ) {
            Object[][] parms = {  { "event", event } };
            myLog.logMethodEntry( "processIncomingNewEvent", parms );
        }

        String alarmInfoString = null;
        AlarmValue queriedAlarm = QueryByIRPKeyAttributes( event );

        if ( queriedAlarm == null ) {
            if ( event.getPerceivedSeverity() != PerceivedSeverity.CLEARED ) {
                // NEW ALARM
                AlarmValue alarm = createAlarmValue( event );
                populateKey(alarm);
                alarm.setAlarmRaisedTime( event.getEventTime() );
                //System.out.println("wrx--before insertnewalarm");
                insertNewAlarm( alarm );
                //System.out.println("wrx--after insertnewalarm");

                generateEvent( alarm, NotifyNewAlarmEventPropertyDescriptor.EVENT_TYPE_VALUE );
                //System.out.println("wrx--after generateEvent");
                alarmInfoString = new String ( "Alarm created. AlarmKey = " + alarm.getAlarmKey().getAlarmPrimaryKey() );
                //System.out.println("wrx--alarmInfoString" + alarmInfoString);
            }
            else {
                alarmInfoString = new String ( "Cleared Alarm is not in the AlarmList. Alarm ignored." );
            }
        }
        else if ( event.getPerceivedSeverity() != queriedAlarm.getPerceivedSeverity() &&
        isLaterAlarm(event.getEventTime(), queriedAlarm) == true ) {
            // NEWER ALARM WITH A CHANGED SEVERITY
            // set the alarm key (alarm id) from the queried alarm.
            AlarmValue alarm = createAlarmValue( event );
            alarm.setAlarmKey( queriedAlarm.getAlarmKey() );

            if ( alarm.getPerceivedSeverity() == PerceivedSeverity.CLEARED ) {
                // CLEARED SEVERITY
                if ( queriedAlarm.getAlarmAckState() == AlarmAckState.ACKNOWLEDGED ) {
                    // CLEARED AND ACKED ALARM
                    deleteAlarm( alarm.getAlarmKey() );
                }
                else {
                    // ALARM WITH CLEARED SEVERITY
                    // set the alarmCleared time
                    alarm.setAlarmClearedTime( event.getEventTime() );
                    updateClearedAlarm( alarm );
                }
                generateEvent( alarm, NotifyClearedAlarmEventPropertyDescriptor.EVENT_TYPE_VALUE );
                alarmInfoString = new String ( "Alarm cleared. AlarmKey = " + alarm.getAlarmKey().getAlarmPrimaryKey() );
            }
            else {
                alarm.setAlarmChangedTime( event.getEventTime() );
                updateChangedAlarm( alarm );
                generateEvent( alarm, NotifyChangedAlarmEventPropertyDescriptor.EVENT_TYPE_VALUE );
                alarmInfoString = new String ( "Alarm changed severity. AlarmKey = " + alarm.getAlarmKey().getAlarmPrimaryKey() );
            }
        }
        else {
            // DUPLICATE ALARM ( alarm with the SAME SEVERITY ) or EARLIER ALARM
            alarmInfoString = new String ( "Duplicate or Earlier Alarm. Alarm ignored. Ignored AlarmKey = " + queriedAlarm.getAlarmKey().getAlarmPrimaryKey() );
            closeConnection();
        }
        return alarmInfoString;
    }

    /**
     * Processes a NotifyClearedAlarmEvent. If the alarm represented by this event
     * does not exist in the db, then the event is ignored. If the event represents
     * a different severity and the information represents newer information, then the
     * alarm is updated to reflect a cleared state. The following attributes
     * are updated with information taken from the event: NotificationId,
     * PerceivedSeverity, AlarmClearedTime. The alarm is then checked
     * to determine if it has been acknowledged. If it is in an acknowledged state,
     * it is immediately removed from the db. A NotifyClearedAlarmEvent is generated
     * following a cleared alarm update.
     */
    public String processIncomingClearedEvent( NotifyClearedAlarmEvent event ) throws SQLException {

        if ( isLoggingEnabled ) {
            Object[][] parms = {  { "event", event } };
            myLog.logMethodEntry( "processIncomingClearedEvent", parms );
        }

        String alarmInfoString = null;
        AlarmValue queriedAlarm = QueryByIRPKeyAttributes( event );
        if ( queriedAlarm == null ) {
            alarmInfoString = new String ( "Cleared Alarm is not in the AlarmList. Alarm ignored." );
            closeConnection();
        }
        else if ( event.getPerceivedSeverity() != queriedAlarm.getPerceivedSeverity() &&
        isLaterAlarm(event.getEventTime(), queriedAlarm) == true ) {
            // NEWER ALARM WITH A CHANGED SEVERITY
            // set the alarm key (alarm id) from the queried alarm.
            AlarmValue alarm = createAlarmValue( event );
            alarm.setAlarmKey( queriedAlarm.getAlarmKey() );

            if ( queriedAlarm.getAlarmAckState() == AlarmAckState.ACKNOWLEDGED ) {
                // CLEARED AND ACKED ALARM
                deleteAlarm( alarm.getAlarmKey() );
            }
            else {
                // ALARM WITH CLEARED SEVERITY
                // set the alarmCleared time
                alarm.setAlarmClearedTime( event.getEventTime() );
                updateClearedAlarm( alarm );
            }
            generateEvent( alarm, NotifyClearedAlarmEventPropertyDescriptor.EVENT_TYPE_VALUE );
            alarmInfoString = new String ( "Alarm cleared. AlarmKey = " + alarm.getAlarmKey().getAlarmPrimaryKey() );
        }
        else {
            // DUPLICATE ALARM ( alarm with the SAME SEVERITY ) or EARLIER ALARM
            alarmInfoString = new String ( "Duplicate or Earlier Alarm. Alarm ignored. Ignored AlarmKey = " + queriedAlarm.getAlarmKey().getAlarmPrimaryKey() );
            closeConnection();
        }
        return alarmInfoString;
    }

    private boolean isLaterAlarm( Date date, AlarmValue alarm ) {
        boolean isLater = true;
        if ( isLoggingEnabled ) {
            myLog.log ( "alarm event time = " + Util.printObject(date) + "\nqueried alarm changed time = " + Util.printObject(alarm.getAlarmChangedTime() ) +
            "\nqueried alarm raised time = " + Util.printObject(alarm.getAlarmRaisedTime() ) + "\n queried alarm cleared time = "
            + Util.printObject(alarm.getAlarmClearedTime() ) );
        }

        if ( ( alarm.getAlarmChangedTime() != null && date.after( alarm.getAlarmChangedTime() ) == false )  ||
        ( alarm.getAlarmClearedTime() != null && date.after( alarm.getAlarmClearedTime() ) == false )  ||
        ( date.after( alarm.getAlarmRaisedTime() ) == false ) ) {
            isLater = false;
        }

        if ( isLoggingEnabled ) {
            myLog.log( "isLaterAlarm => " + isLater );
        }
        return isLater;
    }

    private AlarmValue createAlarmValue( AlarmEvent event ) {

        AlarmValue alarm = new AlarmValueImpl();

        // Note: In this implementation the AdminDomain is set by the server

        alarm.setManagedObjectInstance( event.getManagedObjectInstance() );
        alarm.setManagedObjectClass( event.getManagedObjectClass() );
        alarm.setProbableCause( event.getProbableCause() );
        alarm.setPerceivedSeverity( event.getPerceivedSeverity() );
        alarm.setAlarmType( event.getAlarmType() );
        alarm.setNotificationId( event.getNotificationId() );
        alarm.setSystemDN( applicationDN );

        if ( event instanceof NotifyNewAlarmEvent ) {
            populateNewAlarmInfo( alarm, (NotifyNewAlarmEvent)event );
        }
        else if ( event instanceof NotifyClearedAlarmEvent ) {
            if (  event.isPopulated( NotifyClearedAlarmEvent.CORRELATED_NOTIFICATIONS ) ) {
                alarm.setCorrelatedNotifications( ((NotifyClearedAlarmEvent)event).getCorrelatedNotifications() );
            }
        }

        return alarm;
    }

    /**
     * Updates the alarm information following a cleared event or cleared severity.
     *
     * @param alarm The AlarmValue template that will contain the updated information
     * @exception SQLException thrown to indicate a problem with the update
     */
    private void updateClearedAlarm( AlarmValue alarm ) throws SQLException {
        // Create the update template for the db command and set the appropriate values
        AlarmValue template = new AlarmValueImpl();

        // set the severity (as specified by 3GPP)
        template.setPerceivedSeverity( alarm.getPerceivedSeverity() );
        // set the notification id (as specified by 3GPP)
        template.setNotificationId( alarm.getNotificationId() );
        // set the alarmCleared time
        template.setAlarmClearedTime( alarm.getAlarmClearedTime() );

        updateAlarmWithChangedSeverity( template, alarm.getAlarmKey() );
        return;
    }

    /**
     * Updates the alarm information following a change in severity ( not cleared ).
     *
     * @param alarm The AlarmValue template that will contain the updated information
     * @exception SQLException thrown to indicate a problem with the update
     */
    private void updateChangedAlarm( AlarmValue alarm ) throws SQLException {
        // Create the update template for the db command and set the appropriate values
        AlarmValue template = new AlarmValueImpl();

        // set the severity (as specified by 3GPP)
        template.setPerceivedSeverity( alarm.getPerceivedSeverity() );
        // set the notification id (as specified by 3GPP)
        template.setNotificationId( alarm.getNotificationId() );
        // update the alarmChangedTime (as specified by 3GPP)

        template.setAlarmChangedTime( alarm.getAlarmChangedTime() );
        // clear out ackTime, ackUserId and ackSystemId attributes (as specified by 3GPP)
        template.setAckTime( null );
        template.setAckUserId( null );
        template.setAckSystemId( null );
        template.setAlarmAckState( AlarmAckState.UNACKNOWLEDGED );
        template.setAlarmClearedTime( null );

        updateAlarmWithChangedSeverity( template, alarm.getAlarmKey() );
        return;
    }

    /**
     * Inserts a new alarm into the database.
     *
     * @param alarm The AlarmValue that contains the alarm information
     * @exception SQLException is thrown indicating a problem with the insert
     */
    private AlarmKey insertNewAlarm( AlarmValue alarm ) throws SQLException {

        // set to fully populated for the database operation
        ((AlarmValueImpl)alarm).setFullyPopulated();

        if ( isLoggingEnabled ) {
            myLog.log( " insertNewAlarm: " + Util.printObject( alarm ) );
        }

        InsertDBCommandImpl dbCmd = (InsertDBCommandImpl) DBCommandFactory.createOperation( DBCommandFactory.INSERT_DBCMD );
        if ( isLoggingEnabled) {
            dbCmd.setLogger(myLog);
        }

        dbCmd.setDBHelper( AlarmValue.VALUE_TYPE );
        dbCmd.setInsertTemplate( alarm );

        try {
            dbCmd.setConnection( getConnection() );
            dbCmd.initializeCmd();
            dbCmd.executeCmd();
        }
        catch  ( SQLException sqe ) {
            throw sqe;
        }
        finally {
            dbCmd.closeCmd();
            // close the connection.
            closeConnection();
        }
        return (AlarmKey)dbCmd.getResult();
    }

    /**
     * Updates an alarm in the database.
     *
     * @param setAlarmTemplate An AlarmValue that serves as a template containing the alarm attributes
     * to update
     * @param key The AlarmKey identifies the alarm to update
     * @exception SQLException is thrown indicating a problem with the update
     */
    private void updateAlarmWithChangedSeverity( AlarmValue setAlarmTemplate, AlarmKey key )
    throws SQLException {

        //debug logging
        if ( isLoggingEnabled ) {
            Object[][] parms = {  { "setAlarmTemplate", setAlarmTemplate },
                                  { "key", key } };
            myLog.logMethodEntry( "BackEndAlarmMessageBean: updateAlarmWithChangedSeverity", parms );
        }

        // Create the set database command
        SetDBCommandImpl dbCmdSet = (SetDBCommandImpl) DBCommandFactory.createOperation( DBCommandFactory.SET_DBCMD );
        if ( isLoggingEnabled) {
            dbCmdSet.setLogger(myLog);
        }

        // build where clause template for the set database command
        AlarmValue setWhereTemplate = new AlarmValueImpl();
        setWhereTemplate.setAlarmKey( key );

        // Configure the db set command with the templates and reuse
        dbCmdSet.setDBHelper( AlarmValue.VALUE_TYPE );
        dbCmdSet.setUpdateTemplate( setAlarmTemplate );
        dbCmdSet.setWhereClauseTemplate( setWhereTemplate );

        try {
            // set the connection and initialize the db commands
            dbCmdSet.setConnection( getConnection() );
            dbCmdSet.initializeCmd();
            dbCmdSet.executeCmd();
        }
        catch ( SQLException sqe ) {
            throw sqe;
        }
        finally {
            dbCmdSet.closeCmd();
            closeConnection();
        }
        return;
    }

    /**
     * Queries the database for an alarm using ManagedObjectInstance, AlarmType,
     * and ProbableCause.
     *
     * @param event The incoming alarm event
     * @exception SQLException is thrown indicating a problem with the query
     */
    private AlarmValue QueryByIRPKeyAttributes( AlarmEvent event ) throws SQLException {

        AlarmValue alarm = null;

        ArrayList resultList = new ArrayList();

        QuerySingleUpdateDBCommandImpl dbCmdQuery = null;

        // Configure a query database command
        dbCmdQuery = (QuerySingleUpdateDBCommandImpl) DBCommandFactory.createOperation( DBCommandFactory.QUERY_SINGLE_UPDATE_DBCMD );
        if ( isLoggingEnabled) {
            dbCmdQuery.setLogger(myLog);
        }

        // Configure the whereClause Template
        AlarmValue queryAlarmTemplate = (AlarmValue) new AlarmValueImpl();
        // set the alarm elements that compose the real key
        queryAlarmTemplate.setProbableCause( event.getProbableCause() );
        queryAlarmTemplate.setAlarmType( event.getAlarmType() );
        queryAlarmTemplate.setManagedObjectInstance( event.getManagedObjectInstance() );

        //debug logging
        if ( isLoggingEnabled ) {
            myLog.log( "BackEndAlarmMessageBean: QueryByIRPKeyAttributes: " + Util.printObject( queryAlarmTemplate ) );
        }

        // SPECIFIC_PROBLEM IS NOT SUPPORTED IN THIS RI
        //queryAlarmTemplate.setSpecificProblem( event.getSpecificProblem() );

        // set the query command attributes
        dbCmdQuery.setDBHelper( AlarmValue.VALUE_TYPE );
        dbCmdQuery.setWhereClauseTemplate( queryAlarmTemplate );

        try {
            // set the connection and initialize the db commands
            dbCmdQuery.setConnection( getConnection() );
            //System.out.println("wrx--before initializeCmd");
            dbCmdQuery.initializeCmd();
            //System.out.println("wrx--after initializeCmd");

            dbCmdQuery.executeCmd();
            //System.out.println("wrx--after executeCmd");

            ManagedEntityValue[] entities = (ManagedEntityValue[]) dbCmdQuery.getResult();
            // should never be more than one returned, otherwise your database is hosed....
            if ( entities.length > 0 ) {
                alarm = (AlarmValue) entities[0];
                // check to fully populate key
                if ( includeApplicationInfo ) {
                    alarm.getManagedEntityKey().setApplicationContext( applicationContext );
                    alarm.getManagedEntityKey().setApplicationDN( applicationDN );
                }
            }

        } // end of try statement
        catch ( SQLException sqe ) {
            //throw new EJBException( sqe );
            throw sqe;
        }
        finally {
            // close the db commands to free resources
            dbCmdQuery.closeCmd();
        }
        return alarm;
    }

    /**
     * Deletes the alarm from the database using the alarm key to identify the alarm.
     *
     * @param key An alarm key used to identify the alarm to delete
     * @exception SQLException is thrown indicating a problem with the delete
     */
    private int deleteAlarm( AlarmKey key ) throws SQLException {

        //debug logging
        if ( isLoggingEnabled ) {
            Object[][] parms = {  { "key", key } };
            myLog.logMethodEntry( "BackEndAlarmMessageBean: deleteAlarm", parms );
        }

        Integer deletedAlarms = new Integer(0);

        DeleteDBCommandImpl dbCmd = ( DeleteDBCommandImpl ) DBCommandFactory.createOperation( DBCommandFactory.DELETE_DBCMD );
        if ( isLoggingEnabled) {
            dbCmd.setLogger(myLog);
        }

        // prepare the where clause template
        AlarmValue alarm = (AlarmValue) new AlarmValueImpl();
        alarm.setAlarmKey( key );
        dbCmd.setWhereClauseTemplate( alarm );
        // load the connection
        dbCmd.setDBHelper( AlarmValue.VALUE_TYPE );
        try {
            dbCmd.setConnection( getConnection() );
            dbCmd.initializeCmd();
            dbCmd.executeCmd();
        }
        catch ( SQLException sqe ) {
            throw sqe;
        }
        finally {
            dbCmd.closeCmd();
            closeConnection();
        }
        deletedAlarms = (Integer) dbCmd.getResult();
        return deletedAlarms.intValue();
    }

    /**
     * Generates one of the following events: NotifyNewAlarmEvent, NotifyChangedAlarmEvent,
     * NotifyChangedAlarmEvent, and NotifyAlarmListRebuiltEvent.
     *
     * @param entity A representation of the stored alarm data
     * @param eventType A string indicating the type of alarm to generate
     */
    private void generateEvent( AlarmValue entity, String eventType ) {

        IRPEvent event = null;

        if ( eventType.equals( NotifyAlarmListRebuiltEventPropertyDescriptor.EVENT_TYPE_VALUE ) ) {
            event = EventFactory.makeEvent( eventType );
            event.setNotificationId( genNotificationId() );
            event.setManagedObjectInstance( "JVTAlarmMonitorSession" );
            event.setManagedObjectClass( "AlarmIRPAgent" );
            ((NotifyAlarmListRebuiltEvent)event).setReason( "Indeterminant" );
        }
        else {
            event = EventFactory.makeEvent( eventType, entity );
        }
        if ( includeApplicationInfo ) {
            // set the application domain
            event.setApplicationDN( applicationDN );
        }

        if ( isLoggingEnabled ) {
            myLog.log("BackEndAlarmMessageBean: generateEvent: event class = " + event.getClass().getName() );
            myLog.log("BackEndAlarmMessageBean: generateEvent: " + Util.printObject( event ) );
        }

        MessageBuilder msgBuilder =
        (MessageBuilder) EventFactory.getPropertyDescriptor( eventType );
        evPublisher.publish( event, null, msgBuilder );

        return;
    }


    /**
     * Generates a notification ID for the NotifyAlarmListRebuiltEvent. This
     * notification generation mechanism should be reworked in order to guarantee
     * uniqueness in a distributed environment.
     *
     * @return String that represents the notificationID
     */
    private String genNotificationId() {
        long timeMillis = java.lang.System.currentTimeMillis();
        return new String( "NotID: " + timeMillis );
    }

    /**
     * Gets a connection to the data source if not already acquired.
     *
     * @return Connection a database connection
     */
    private Connection getConnection() throws SQLException {
        //System.out.println("wrx---before get a connection");
        if ( connection == null ) {
            connection = dataSource.getConnection();
        }
        //System.out.println("wrx--after get a connection");
        return connection;
    }

    /**
     * Closes the data source if not already closed.
     */
    private void closeConnection() {
        try {
            if ( connection != null && connection.isClosed() == false ) {
                connection.close();
                connection = null;
            }
        }
        catch ( SQLException sqe ) {
            if ( isLoggingEnabled ) {
                myLog.logException ("BackEndAlarmMessageBean: closeConnection:  Problem closing the db", sqe );
            }
        }
        return;
    }

    /**
     * Validates the incoming alarm event. The following attributes must be
     * populated: ManagedObjectClass, ManagedObjectInstance, NotificationID,
     * EventTime, AlarmType, PerceivedSeverity, Key, and ProbableCause.
     *
     * @param event The incoming AlarmEvent
     * @return boolean indicating if the alarm event is valid
     */
    private boolean validateAlarmEvent( AlarmEvent event ) {
        boolean validEvent = false;
        if ( event.isPopulated( IRPEvent.MANAGED_OBJECT_CLASS ) &&
        event.isPopulated( IRPEvent.MANAGED_OBJECT_INSTANCE ) &&
        event.isPopulated( IRPEvent.NOTIFICATION_ID ) &&
        event.isPopulated( IRPEvent.EVENT_TIME ) &&
        event.isPopulated( AlarmEvent.ALARM_TYPE ) &&
        event.isPopulated( AlarmEvent.PERCEIVED_SEVERITY ) &&
        event.isPopulated( AlarmEvent.KEY ) &&
        event.isPopulated( AlarmEvent.PROBABLE_CAUSE )  ) {
            validEvent = true;
        }
        if ( isLoggingEnabled ) {
            myLog.log( "BackEndAlarmMessageBean: valid alarm event? " + validEvent );
        }
        return validEvent;
    }

    /**
     * Generates a unique key for an alarm value.
     *
     * @param alarm The AlarmValue for which the key is generated
     */
    private void populateKey( AlarmValue alarm ) {
        // generate the unique key for a new alarm.
        AlarmKey key = alarm.makeAlarmKey();
        key.setAlarmPrimaryKey( Util.makeGUID( alarm ) );
        if ( includeApplicationInfo ) {
            key.setApplicationContext( applicationContext );
            key.setApplicationDN( applicationDN );
        }
        alarm.setAlarmKey(key);
        return;
    }

    /**
     * Populates the alarm with optional attributes if present in the
     * NotifyNewAlarmEvent.
     *
     * @param alarm The alarm to populate
     * @param event The NotifyNewAlarmEvent to populate the alarm from
     */
    private void populateNewAlarmInfo( AlarmValue alarm, NotifyNewAlarmEvent event ) {

        // SPECIFIC_PROBLEM IS NOT SUPPORTED IN THIS RI
        //  if ( event.isPopulated( NotifyNewAlarmEvent.SPECIFIC_PROBLEM ) ) {
        // alarm.setSpecificProblem( event.getSpecificProblem() );
        // }

        if ( event.isPopulated( NotifyNewAlarmEvent.ADDITIONAL_TEXT ) ) {
            alarm.setAdditionalText( event.getAdditionalText() );
        }

        if ( event.isPopulated( NotifyNewAlarmEvent.PROPOSED_REPAIR_ACTIONS ) ) {
            alarm.setProposedRepairActions( event.getProposedRepairActions() );
        }

        if ( event.isPopulated( NotifyNewAlarmEvent.BACKED_UP_STATUS ) ) {
            alarm.setBackedUpStatus( event.getBackedUpStatus() );
        }

        if (  event.isPopulated( NotifyNewAlarmEvent.BACK_UP_OBJECT ) ) {
            alarm.setBackUpObject( event.getBackUpObject() );
        }

        if (  event.isPopulated( NotifyNewAlarmEvent.THRESHOLD_INFO ) ) {
            alarm.setThresholdInfo( event.getThresholdInfo() );
        }

        if (  event.isPopulated( NotifyNewAlarmEvent.TREND_INDICATION ) ) {
            alarm.setTrendIndication( event.getTrendIndication() );
        }

        if (  event.isPopulated( NotifyNewAlarmEvent.ATTRIBUTE_CHANGES ) ) {
            alarm.setAttributeChanges( event.getAttributeChanges() );
        }

        if (  event.isPopulated( NotifyNewAlarmEvent.MONITORED_ATTRIBUTES ) ) {
            alarm.setMonitoredAttributes( event.getMonitoredAttributes() );
        }

        if (  event.isPopulated( NotifyNewAlarmEvent.CORRELATED_NOTIFICATIONS ) ) {
            alarm.setCorrelatedNotifications( event.getCorrelatedNotifications() );
        }
        return;
    }

    /**
     * Initializes the applicationContext and applicationDN. The values are
     * fetched from the bean using JNDI (<code>env-entry</code>).
     * <pre>
     * applicationContextProviderURL
     * applicationContextInitialContextFactory
     * ...
     * applicationDistinguishedName
     * </pre>
     * This method was modified from code in the QoS TM RI by
     * Henrik Lindstrom.
     *
     */
    private void initializeApplicationContext() {

        // initialize ApplicationContext from EJB properties
        applicationContext = new ossj.qos.ApplicationContextImpl();

        try {

            // provider url
            Object ref = initCtx.lookup( APPLICATION_CONTEXT_PROPERTY_PROVIDER_URL );
            String url = (String)PortableRemoteObject.narrow(ref,String.class);
            applicationContext.setURL( url );

            // initial context factory class
            ref = initCtx.lookup( APPLICATION_CONTEXT_PROPERTY_INITIAL_CONTEXT_FACTORY );
            String initialContextFactory = (String) PortableRemoteObject.narrow(ref,String.class);
            applicationContext.setFactoryClass( initialContextFactory );

        } catch ( NamingException e ) {
            if ( isLoggingEnabled ) {
                myLog.logException("BackEndAlarmMessageBean: initializeApplicationContext()", e);
                myLog.log("Unable to initialize Application Context");
            }
        } catch ( ClassCastException e ) {
            myLog.logException("BackEndAlarmMessageBean: initializeApplicationContext()", e);
            myLog.log("Unable to initialize Application Context");
        }

        // initialize applicationDN from properties
        try {
            Object ref = initCtx.lookup( APPLICATION_DN_PROPERTY );
            applicationDN = (String)PortableRemoteObject.narrow(ref,String.class);
        } catch ( NamingException e ) {
            if ( isLoggingEnabled ) {
                myLog.logException("BackEndAlarmMessageBean: initializeApplicationContext() ", e);
                myLog.log("Unable to initialize Application Context");
            }
        }
        return;
    }

}
